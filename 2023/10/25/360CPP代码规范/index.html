<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>360CPP代码规范 | Hoshea的主页</title><meta name="keywords" content="C++,360"><meta name="author" content="Hoshea Zhang,542978210@qq.com"><meta name="copyright" content="Hoshea Zhang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="360CPP代码规范"><meta name="application-name" content="360CPP代码规范"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="360CPP代码规范"><meta property="og:url" content="http://example.com/2023/10/25/360CPP%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/index.html"><meta property="og:site_name" content="Hoshea的主页"><meta property="og:description" content="C&amp;#x2F;C++ 安全规则集合  Bjarne Stroustrup: “C makes it easy to shoot yourself in the foot; C++ makes it harder, but when you do it blows your whole leg off.”  &amp;amp;"><meta property="og:locale" content="en"><meta property="og:image" content="https://hoshea-1318436778.cos.ap-nanjing.myqcloud.com/image360.jpg"><meta property="article:author" content="Hoshea Zhang"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://hoshea-1318436778.cos.ap-nanjing.myqcloud.com/image360.jpg"><meta name="description" content="C&amp;#x2F;C++ 安全规则集合  Bjarne Stroustrup: “C makes it easy to shoot yourself in the foot; C++ makes it harder, but when you do it blows your whole leg off.”  &amp;amp;"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="http://example.com/2023/10/25/360CPP%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"><link rel="preconnect" href="//cdn.cbd.int"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/swiper/swiper.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2023/09/03/125766904/ee23df8517f3c3e3efc4145658269c06_5714860933110284659.png"},
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: {"enable":true,"default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 宝贝","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: 'hoshea-env-2gxt402g10c22211',
  commentBarrageConfig:undefined,
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: {"skills":null},
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: 'days',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"Author: Hoshea Zhang","link":"Link: ","source":"Source: Hoshea的主页","info":"Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source.","copySuccess":"Copy success, copy and reprint please mark the address of this article"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"Traditional Chinese Activated Manually","cht_to_chs":"Simplified Chinese Activated Manually","day_to_night":"Dark Mode Activated Manually","night_to_day":"Light Mode Activated Manually","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'Hoshea的主页',
  title: '360CPP代码规范',
  postAI: '',
  pageFillDescription: 'C/C++ 安全规则集合 , 规则说明, 规则选取, 规则列表, 1. Security, ▌R1.1 敏感数据不可写入代码, 相关, 参考, ▌R1.2 敏感数据不可被系统外界感知, 相关, 参考, ▌R1.3 敏感数据在使用后应被有效清理, 相关, 依据, 参考, ▌R1.4 公共成员或全局对象不应记录敏感数据, 参考, ▌R1.5 预判用户输入造成的不良后果, 参考, ▌R1.6 对资源设定合理的访问权限, 依据, 参考, ▌R1.7 对用户落实有效的权限管理, 参考, ▌R1.8 避免引用危险符号名称, 参考, ▌R1.9 避免使用危险接口, 参考, ▌R1.10 避免使用已过时的接口, 相关, 参考, ▌R1.11 禁用不安全的字符串函数, 相关, 依据, 参考, ▌R1.12 确保字符串以空字符结尾, 相关, 依据, 参考, ▌R1.13 避免除 0 等计算异常, 相关, 依据, 参考, ▌R1.14 格式化字符串应为常量, 相关, 参考, ▌R1.15 与内存空间布局相关的信息不可被外界感知, 相关, 参考, ▌R1.16 与网络地址相关的信息不应写入代码, 相关, ▌R1.17 选择安全的异常处理方式, 参考, ▌R1.18 启用平台和编译器提供的防御机制, 2. Resource, ▌R2.1 不可失去对已分配资源的控制, 相关, 参考, ▌R2.2 不可失去对已分配内存的控制, 相关, 依据, 参考, ▌R2.3 不可访问未初始化或已释放的资源, 相关, 依据, 参考, ▌R2.4 资源应接受对象化管理, 参考, ▌R2.5 资源的分配与回收方法应成对提供, 相关, 参考, ▌R2.6 资源的分配与回收方法应配套使用, 相关, 依据, 参考, ▌R2.7 不应在模块之间传递容器类对象, 相关, ▌R2.8 不应在模块之间传递非标准布局类型的对象, 依据, 参考, ▌R2.9 对象申请的资源应在析构函数中释放, 相关, 参考, ▌R2.10 对象被移动后应重置状态再使用, 相关, 依据, 参考, ▌R2.11 构造函数抛出异常需避免相关资源泄漏, 相关, 依据, ▌R2.12 资源不可被重复释放, 依据, 参考, ▌R2.13 用 delete 释放对象需保证其类型完整, 依据, ▌R2.14 用 delete 释放对象不可多写中括号, 相关, 依据, 参考, ▌R2.15 用 delete 释放数组不可漏写中括号, 相关, 依据, 参考, ▌R2.16 非动态申请的资源不可被释放, 依据, 参考, ▌R2.17 在一个表达式语句中最多使用一次 new, 相关, 参考, ▌R2.18 流式资源对象不应被复制, 依据, 参考, ▌R2.19 避免使用变长数组, 相关, 依据, 参考, ▌R2.20 避免使用在栈上分配内存的函数, 相关, 参考, ▌R2.21 局部数组不应过大, 配置, 参考, ▌R2.22 避免不必要的内存分配, 相关, ▌R2.23 避免动态内存分配, 依据, 参考, ▌R2.24 判断资源分配函数的返回值是否有效, 依据, 参考, ▌R2.25 C++ 代码中禁用 C 内存管理函数, 相关, 参考, 3. Precompile, 3.1 Include, ▌R3.1.1 include 指令应符合标准格式, 相关, 依据, 参考, ▌R3.1.2 include 指令中禁用不合规的字符, 依据, 参考, ▌R3.1.3 include 指令中不应使用反斜杠, 依据, 参考, ▌R3.1.4 include 指令中不应使用绝对路径, ▌R3.1.5 include 指令应位于文件的起始部分, 依据, 参考, ▌R3.1.6 禁用不合规的头文件, 配置, 依据, 参考, ▌R3.1.7 C++ 代码不应引用 C 头文件, 相关, 依据, 参考, 3.2 Macro-definition, ▌R3.2.1 宏应遵循合理的命名方式, 相关, 参考, ▌R3.2.2 不可定义具有保留意义的宏名称, 配置, 相关, 依据, 参考, ▌R3.2.3 不可取消定义具有保留意义的宏名称, 配置, 相关, 依据, 参考, ▌R3.2.4 可作为子表达式的宏定义应该用括号括起来, 依据, 参考, ▌R3.2.5 表达式中的宏参数应该用括号括起来, 依据, 参考, ▌R3.2.6 由多个语句组成的宏定义应该用 do-while(0) 括起来, 相关, 依据, 参考, ▌R3.2.7 宏定义中的  和  运算符不应嵌套使用, 依据, 参考, ▌R3.2.8 不应使用宏定义常量, 相关, 参考, ▌R3.2.9 不应使用宏定义类型, 相关, 参考, ▌R3.2.10 可由函数实现的功能不应使用宏实现, 相关, 参考, ▌R3.2.11 宏不应被重定义, 依据, ▌R3.2.12 只应在全局作用域中定义宏, 配置, 相关, 依据, 参考, ▌R3.2.13 避免宏被取消定义, 配置, 相关, 参考, 3.3 Macro-usage, ▌R3.3.1 宏的实参不应有副作用, 相关, 参考, ▌R3.3.2 宏的实参个数不可小于形参个数, 相关, 依据, 参考, ▌R3.3.3 宏的实参个数不可大于形参个数, 相关, 依据, 参考, ▌R3.3.4 va_start 或 va_copy 应配合 va_end 使用, 相关, 依据, ▌R3.3.5 va_arg 的类型参数应符合要求, 相关, 依据, 参考, ▌R3.3.6 在 C++ 代码中不应使用宏 offsetof, 依据, 参考, 3.4 Directive, ▌R3.4.1 头文件不应缺少守卫, 配置, 参考, ▌R3.4.2 不应出现非标准格式的预编译指令, 依据, 参考, ▌R3.4.3 不应使用非标准预编译指令, 依据, 参考, ▌R3.4.4 避免使用 pragma 指令, 依据, 参考, ▌R3.4.5 非自动生成的代码中不应出现 line 指令, 依据, ▌R3.4.6 宏的参数列表中不应出现预编译指令, 依据, 参考, ▌R3.4.7 条件编译代码块应在同一文件中, 参考, ▌R3.4.8 对编译警告的屏蔽应慎重, 相关, ▌R3.4.9 在高级别的警告设置下编译, 相关, 参考, 3.5 Comment, ▌R3.5.1 关注 TODO、FIXME、XXX、BUG 等特殊注释, 配置, 参考, ▌R3.5.2 注释不可嵌套, 依据, 参考, ▌R3.5.3 注释应出现在合理的位置, 依据, 3.6 Other, ▌R3.6.1 非空源文件应以换行符结尾, 配置, 依据, ▌R3.6.2 除转义字符、宏定义之外不应使用反斜杠, 依据, 参考, 4. Global, ▌R4.1 全局名称应遵循合理的命名方式, 配置, 相关, 参考, ▌R4.2 为代码设定合理的命名空间, 相关, 参考, ▌R4.3 main 函数只应处于全局作用域中, 依据, 参考, ▌R4.4 头文件中不应使用 using directive, 相关, 参考, ▌R4.5 头文件中不应使用静态声明, 相关, 依据, ▌R4.6 头文件中不应定义匿名命名空间, 相关, 依据, 参考, ▌R4.7 匿名命名空间中不应使用静态声明, 依据, ▌R4.8 全局对象的初始化不可依赖未初始化的对象, 依据, 参考, ▌R4.9 全局对象只应为常量或静态对象, 相关, 参考, ▌R4.10 全局对象只应为常量, 配置, 相关, 参考, ▌R4.11 全局对象不应同时被 static 和 const 等关键字限定, 相关, 依据, ▌R4.12 全局及命名空间作用域中禁用 using directive, 相关, 参考, ▌R4.13 避免无效的 using directive, ▌R4.14 不应定义全局 inline 命名空间, ▌R4.15 不可修改 std 命名空间, 依据, 参考, 5. Type, 5.1 Class, ▌R5.1.1 类的非常量数据成员均应为 private, 相关, 参考, ▌R5.1.2 类的非常量数据成员不应定义为 protected, 相关, 参考, ▌R5.1.3 类不应既有 public 数据成员又有 private 数据成员, 相关, 参考, ▌R5.1.4 有虚函数的基类应具有虚析构函数, 依据, 参考, ▌R5.1.5 避免多重继承自同一非虚基类, 相关, 依据, 参考, ▌R5.1.6 存在析构函数或拷贝赋值运算符时不应缺少拷贝构造函数, 相关, 参考, ▌R5.1.7 存在拷贝构造函数或析构函数时不应缺少拷贝赋值运算符, 相关, 参考, ▌R5.1.8 存在拷贝构造函数或拷贝赋值运算符时不应缺少析构函数, 相关, 参考, ▌R5.1.9 存在任一拷贝、移动、析构相关的函数时应定义所有相关函数, 相关, 参考, ▌R5.1.10 避免重复实现由默认拷贝、移动、析构函数完成的功能, 相关, 参考, ▌R5.1.11 可接受一个参数的构造函数需用 explicit 关键字限定, 相关, 参考, ▌R5.1.12 重载的类型转换运算符需用 explicit 关键字限定, 相关, 参考, ▌R5.1.13 不应过度使用 explicit 关键字, 参考, ▌R5.1.14 带模板的赋值运算符不应与拷贝或移动赋值运算符混淆, 相关, 依据, 参考, ▌R5.1.15 带模板的构造函数不应与拷贝或移动构造函数混淆, 相关, 依据, 参考, ▌R5.1.16 抽象类禁用拷贝和移动赋值运算符, 参考, ▌R5.1.17 数据成员的数量应在规定范围之内, 配置, ▌R5.1.18 数据成员之间的填充数据不应被忽视, 相关, 依据, 参考, ▌R5.1.19 常量成员函数不应返回数据成员的非常量指针或引用, 相关, 参考, ▌R5.1.20 类成员应按 public、protected、private 的顺序声明, ▌R5.1.21 存在构造、析构或虚函数的类不应采用 struct 关键字, 参考, 5.2 Enum, ▌R5.2.1 同类枚举项的值不应相同, 参考, ▌R5.2.2 合理初始化各枚举项, 相关, 参考, ▌R5.2.3 不应使用匿名枚举声明, 参考, ▌R5.2.4 用 enum class 取代 enum, 依据, 参考, 5.3 Union, ▌R5.3.1 联合体内禁用非基本类型的对象, 依据, ▌R5.3.2 禁用在类之外定义的联合体, 相关, 参考, ▌R5.3.3 禁用联合体, 相关, 参考, 6. Declaration, 6.1 Naming, ▌R6.1.1 遵循合理的命名方式, 配置, 依据, 参考, ▌R6.1.2 不应定义具有保留意义的名称, 相关, 依据, 参考, ▌R6.1.3 局部名称不应被覆盖, 参考, ▌R6.1.4 成员名称不应被覆盖, 参考, ▌R6.1.5 全局名称不应被覆盖, 参考, ▌R6.1.6 类型名称不应重复定义, 参考, ▌R6.1.7 类型名称不应与对象或函数名称相同, 参考, ▌R6.1.8 不应存在拼写错误, 6.2 Qualifier, ▌R6.2.1 const、volatile 不应重复, 相关, ▌R6.2.2 const、volatile 限定指针类型的别名是可疑的, 相关, 参考, ▌R6.2.3 const、volatile 不可限定引用, 依据, ▌R6.2.4 const、volatile 限定类型时的位置应统一, 配置, 相关, 依据, 参考, ▌R6.2.5 const、volatile 等关键字不应出现在基本类型名称的中间, 相关, 依据, 参考, ▌R6.2.6 指向常量字符串的指针应使用 const 声明, 相关, 依据, 参考, ▌R6.2.7 枚举类型的底层类型不应为 const 或 volatile, 依据, ▌R6.2.8 对常量的定义不应为引用, ▌R6.2.9 禁用 restrict 指针, 依据, 参考, ▌R6.2.10 非适当场景禁用 volatile, 依据, 参考, ▌R6.2.11 相关对象未被修改时应使用 const 声明, 相关, 参考, 6.3 Specifier, ▌R6.3.1 合理使用 auto 关键字, 相关, 参考, ▌R6.3.2 不应使用已过时的关键字, 依据, ▌R6.3.3 不应使用多余的 inline 关键字, 依据, ▌R6.3.4 extern 关键字不应作用于类成员的声明或定义, 依据, ▌R6.3.5 重写的虚函数应声明为 override 或 final, 依据, 参考, ▌R6.3.6 override 和 final 关键字不应同时出现在声明中, 参考, ▌R6.3.7 override 或 final 关键字不应与 virtual 关键字同时出现在声明中, 参考, ▌R6.3.8 不应将 union 设为 final, 依据, ▌R6.3.9 未访问 this 指针的成员函数应使用 static 声明, 参考, ▌R6.3.10 声明和定义内部链接的对象和函数时均应使用 static 关键字, 参考, ▌R6.3.11 inline、virtual、static、typedef 等关键字的位置应统一, 相关, 依据, 6.4 Declarator, ▌R6.4.1 用 auto 声明指针或引用时应显式标明 *、amp 等符号, 依据, ▌R6.4.2 禁用可变参数列表, 相关, 依据, 参考, ▌R6.4.3 禁用柔性数组, 依据, 参考, ▌R6.4.4 接口的参数类型和返回类型不应为 void*, 相关, 参考, ▌R6.4.5 类成员的类型不应为 void*, 相关, 参考, ▌R6.4.6 数组大小应被显式声明, 配置, 参考, ▌R6.4.7 不应将类型定义和对象声明写在一个语句中, 参考, ▌R6.4.8 不应将不同类别的声明写在一个语句中, 相关, 参考, 6.5 Object, ▌R6.5.1 不应产生无效的临时对象, 参考, ▌R6.5.2 不应存在没有被用到的局部声明, 参考, ▌R6.5.3 对象初始化不可依赖自身的值, ▌R6.5.4 参与数值运算的 char 对象应显式声明 signed 或 unsigned, 依据, 参考, ▌R6.5.5 字节的类型应为 stdbyte 或 unsigned char, 相关, 依据, 6.6 Parameter, ▌R6.6.1 函数原型声明中的参数应具有合理的名称, 参考, ▌R6.6.2 不应将数组作为函数的形式参数, 依据, 参考, ▌R6.6.3 parmN 的声明应符合要求, 相关, 依据, 参考, ▌R6.6.4 虚函数参数的默认值应与基类中声明的一致, 相关, 依据, 参考, ▌R6.6.5 不建议虚函数的参数有默认值, 相关, 依据, 参考, ▌R6.6.6 C 代码中参数列表如果为空应声明为(void), 相关, 依据, 参考, ▌R6.6.7 C++ 代码中参数列表如果为空不应声明为(void), 相关, 依据, 参考, ▌R6.6.8 声明数组参数的大小时禁用 static 关键字, 依据, 参考, 6.7 Function, ▌R6.7.1 派生类不应重新定义与基类相同的非虚函数, 参考, ▌R6.7.2 重载运算符的返回类型应与内置运算符相符, 相关, ▌R6.7.3 赋值运算符应返回所属类的非 const 左值引用, 相关, 依据, 参考, ▌R6.7.4 拷贝构造函数的参数应为同类对象的 const 左值引用, 相关, ▌R6.7.5 拷贝赋值运算符的参数应为同类对象的 const 左值引用, 相关, 依据, 参考, ▌R6.7.6 移动构造函数的参数应为同类对象的非 const 右值引用, 相关, ▌R6.7.7 移动赋值运算符的参数应为同类对象的非 const 右值引用, 依据, 参考, ▌R6.7.8 不应重载取地址运算符, 依据, 参考, ▌R6.7.9 不应重载逗号运算符, 相关, 依据, 参考, ▌R6.7.10 不应重载逻辑与和逻辑或运算符, 相关, 依据, 参考, ▌R6.7.11 拷贝和移动赋值运算符不应为虚函数, 相关, 依据, 参考, ▌R6.7.12 比较运算符不应为虚函数, 参考, ▌R6.7.13 final 类中不应声明虚函数, 依据, 6.8 Bitfield, ▌R6.8.1 对位域声明合理的类型, 配置, 依据, 参考, ▌R6.8.2 位域长度不应超过类型长度, 依据, ▌R6.8.3 有符号整型对象的位域长度不应为 1, 参考, ▌R6.8.4 不应对枚举对象声明位域, 相关, 依据, 参考, ▌R6.8.5 禁用位域, 相关, 依据, 6.9 Complexity, ▌R6.9.1 不应采用复杂的声明, ▌R6.9.2 声明中不应包含过多的指针嵌套, 配置, 相关, 参考, ▌R6.9.3 在一个语句中不应声明多个对象或函数, 配置, 相关, 参考, 6.10 Other, ▌R6.10.1 遵循 One Definition Rule, 依据, 参考, ▌R6.10.2 声明与实现应一致, 相关, 依据, 参考, ▌R6.10.3 在合理的位置声明, 相关, 依据, 参考, ▌R6.10.4 不应存在没有被用到的标签, 参考, ▌R6.10.5 不应存在没有被用到的静态声明, 相关, 参考, ▌R6.10.6 不应存在没有被用到的 private 成员, 相关, 参考, ▌R6.10.7 不应省略声明对象或函数的类型, 参考, ▌R6.10.8 用 stdint.h 中的类型代替 short、int、long 等类型, 依据, 参考, ▌R6.10.9 避免使用已过时的标准库组件, 相关, 依据, 7. Exception, ▌R7.1 保证异常安全, 相关, 参考, ▌R7.2 处理所有异常, 相关, 依据, 参考, ▌R7.3 不应抛出过于宽泛的异常, 相关, 参考, ▌R7.4 不应捕获过于宽泛的异常, 相关, 参考, ▌R7.5 不应抛出非异常类型的对象, 配置, 相关, 参考, ▌R7.6 不应捕获非异常类型的对象, 相关, 参考, ▌R7.7 全局对象的初始化过程不可抛出异常, 相关, 依据, 参考, ▌R7.8 析构函数不可抛出异常, 相关, 依据, 参考, ▌R7.9 内存回收函数不可抛出异常, 相关, 依据, 参考, ▌R7.10 对象交换过程不可抛出异常, 相关, 参考, ▌R7.11 移动构造函数和移动赋值运算符不可抛出异常, 相关, 参考, ▌R7.12 异常类的拷贝构造函数不可抛出异常, 相关, 依据, 参考, ▌R7.13 异常类的构造函数和异常信息相关的函数不应抛出异常, 相关, 依据, 参考, ▌R7.14 与标准库相关的 hash 过程不应抛出异常, 参考, ▌R7.15 由 noexcept 标记的函数不可产生未处理的异常, 相关, 依据, 参考, ▌R7.16 避免异常类多重继承自同一非虚基类, 相关, 依据, ▌R7.17 通过引用捕获异常, 相关, 参考, ▌R7.18 捕获异常时不应产生对象切片问题, 相关, 参考, ▌R7.19 捕获异常后不应直接再次抛出异常, ▌R7.20 重新抛出异常时应使用空 throw 表达式（throw）, 依据, ▌R7.21 不应在 catch 子句外使用空 throw 表达式（throw）, 依据, 参考, ▌R7.22 不应抛出指针, 参考, ▌R7.23 不应抛出 NULL, 相关, 依据, 参考, ▌R7.24 不应抛出 nullptr, 相关, 参考, ▌R7.25 不应在模块之间传播异常, 相关, 参考, ▌R7.26 禁用动态异常说明, 配置, 依据, 参考, ▌R7.27 禁用 C++ 异常, 相关, 参考, 8. Function, ▌R8.1 main 函数的返回类型只应为 int, 依据, 参考, ▌R8.2 main 函数不应被调用、重载或被 inline、static 等关键字限定, 依据, ▌R8.3 在头文件中不应实现函数或定义对象, 参考, ▌R8.4 函数的参数名称在声明处和实现处应保持一致, 相关, 参考, ▌R8.5 多态类的对象作为参数时不应采用值传递的方式, 相关, 参考, ▌R8.6 不应存在未被使用的具名形式参数, 参考, ▌R8.7 非基本类型的常量参数不应按值传递, 参考, ▌R8.8 转发引用只应作为 stdforward 的参数, 相关, 依据, 参考, ▌R8.9 局部对象在使用前应被初始化, 相关, 依据, 参考, ▌R8.10 成员须在声明处或构造时初始化, 参考, ▌R8.11 基类对象构造完毕之前不可调用成员函数, 依据, ▌R8.12 在面向构造或析构函数体的 catch 子句中不可访问非静态成员, 依据, 参考, ▌R8.13 成员初始化应遵循声明的顺序, 依据, 参考, ▌R8.14 在构造函数中不应使用动态类型, 依据, 参考, ▌R8.15 在析构函数中不应使用动态类型, 依据, 参考, ▌R8.16 在析构函数中避免调用 exit 函数, 依据, ▌R8.17 拷贝构造函数应避免实现复制之外的功能, 相关, 依据, 参考, ▌R8.18 移动构造函数应避免实现数据移动之外的功能, 相关, 依据, ▌R8.19 拷贝赋值运算符应处理参数是自身对象时的情况, 参考, ▌R8.20 不应存在无效的写入操作, ▌R8.21 不应存在没有副作用的语句, 依据, 参考, ▌R8.22 不应存在得不到执行机会的代码, 相关, 参考, ▌R8.23 有返回值的函数其所有分枝都应显式返回, 依据, 参考, ▌R8.24 不可返回局部对象的地址或引用, 相关, 依据, 参考, ▌R8.25 不可返回临时对象的地址或引用, 相关, 依据, 参考, ▌R8.26 合理设置 lambda 表达式的捕获方式, 相关, 依据, 参考, ▌R8.27 函数返回值不应为右值引用, 相关, 参考, ▌R8.28 函数返回值不应为常量对象, 相关, 参考, ▌R8.29 函数返回值不应为基本类型的常量, 相关, 依据, ▌R8.30 被返回的表达式应与函数的返回类型一致, 参考, ▌R8.31 被返回的表达式不应为相同的常量, ▌R8.32 具有 noreturn 属性的函数不应返回, 相关, 依据, ▌R8.33 具有 noreturn 属性的函数返回类型只应为 void, 相关, 依据, ▌R8.34 由 atexit、at_quick_exit 指定的处理函数应正常返回, 依据, 参考, ▌R8.35 函数模板不应被特化, 参考, ▌R8.36 函数的退出点数量应在规定范围之内, 配置, 相关, 参考, ▌R8.37 函数的标签数量应在规定范围之内, 配置, ▌R8.38 函数的行数应在规定范围之内, 配置, 参考, ▌R8.39 lambda 表达式的行数应在规定范围之内, 配置, ▌R8.40 函数参数的数量应在规定范围之内, 配置, 参考, ▌R8.41 不应定义过于复杂的内联函数, 配置, 依据, 参考, ▌R8.42 避免函数调用自身, 参考, ▌R8.43 作用域及类型嵌套不应过深, 配置, ▌R8.44 汇编代码不应与普通代码混合, 依据, 参考, ▌R8.45 避免重复的函数实现, 配置, 参考, 9. Control, 9.1 If, ▌R9.1.1 if 语句不应被分号隔断, 参考, ▌R9.1.2 在 if…else-if 分枝中不应有重复的条件, 相关, 参考, ▌R9.1.3 在 if…else-if 分枝中不应有被遮盖的条件, 相关, 参考, ▌R9.1.4 if 分枝和 else 分枝的代码不应完全相同, 相关, 参考, ▌R9.1.5 if…else-if 各分枝的代码不应完全相同, 配置, 相关, 参考, ▌R9.1.6 if 分枝和隐含的 else 分枝代码不应完全相同, 相关, 参考, ▌R9.1.7 没有 else 子句的 if 语句与其后续代码相同是可疑的, 相关, 参考, ▌R9.1.8 if 分枝和 else 分枝的起止语句不应相同, 相关, 参考, ▌R9.1.9 if 语句作用域的范围不应有误, 相关, 参考, ▌R9.1.10 如果 if 关键字前面是右大括号if 关键字应另起一行, ▌R9.1.11 if 语句的条件不应为赋值表达式, 配置, 相关, 参考, ▌R9.1.12 if 语句不应为空, 参考, ▌R9.1.13 if…else-if 分枝数量应在规定范围之内, 配置, ▌R9.1.14 if 分枝中的语句应该用大括号括起来, 相关, 参考, ▌R9.1.15 所有 if…else-if 分枝都应以 else 子句结束, 相关, 参考, 9.2 For, ▌R9.2.1 for 语句不应被分号隔断, 相关, 参考, ▌R9.2.2 for 语句中不应存在无条件的跳转语句, 相关, 参考, ▌R9.2.3 for 语句作用域的范围不应有误, 相关, 参考, ▌R9.2.4 for 语句没有明确的循环变量时应改用 while 语句, 参考, ▌R9.2.5 for 循环体不应为空, 参考, ▌R9.2.6 for 循环变量不应为浮点型, 相关, 参考, ▌R9.2.7 for 循环变量不应在循环体内被改变, 参考, ▌R9.2.8 嵌套的 for 语句不应使用相同的循环变量, 相关, ▌R9.2.9 for 循环体应该用大括号括起来, 参考, 9.3 While, ▌R9.3.1 while 语句不应被分号隔断, 参考, ▌R9.3.2 while 语句中不应存在无条件的跳转语句, 相关, 参考, ▌R9.3.3 while 语句的条件不应为赋值表达式, 相关, 参考, ▌R9.3.4 while 语句作用域的范围不应有误, 相关, 参考, ▌R9.3.5 while 循环体不应为空, 参考, ▌R9.3.6 while 循环体应该用大括号括起来, 相关, 参考, 9.4 Do, ▌R9.4.1 注意 do-while(0) 中可疑的 continue 语句, 参考, ▌R9.4.2 do-while 循环体不应为空, 相关, 参考, ▌R9.4.3 do-while 循环体应该用大括号括起来, 相关, 参考, ▌R9.4.4 不建议使用 do 语句, 参考, 9.5 Switch, ▌R9.5.1 switch 语句不应被分号隔断, 参考, ▌R9.5.2 switch 语句不应为空, 参考, ▌R9.5.3 case 标签的值不可超出 switch 条件的范围, 相关, 参考, ▌R9.5.4 switch 语句中任何子句都应从属于某个 case 或 default 分枝, 参考, ▌R9.5.5 case 和 default 标签应直接从属于 switch 语句, 相关, 参考, ▌R9.5.6 不应存在紧邻 default 标签的空 case 标签, ▌R9.5.7 不应存在内容完全相同的 case 分枝, 配置, 相关, 参考, ▌R9.5.8 switch 语句的条件不应为 bool 型, 参考, ▌R9.5.9 switch 语句不应只包含 default 标签, 参考, ▌R9.5.10 switch 语句不应只包含一个 case 标签, 参考, ▌R9.5.11 switch 语句分枝数量应在规定范围之内, 配置, ▌R9.5.12 switch 语句应配有 default 分枝, 相关, 参考, ▌R9.5.13 switch 语句的每个非空分枝都应该用无条件的 break 或 return 语句终止, 依据, 参考, ▌R9.5.14 switch 语句应该用大括号括起来, 相关, 参考, ▌R9.5.15 switch 语句不应嵌套, 9.6 Try-catch, ▌R9.6.1 try 关键字的作用域不应为空, 参考, ▌R9.6.2 catch 子句不应为空, 参考, ▌R9.6.3 不应嵌套 try-catch 语句, 参考, ▌R9.6.4 捕获所有异常的 catch(…) 子句应位于最后, 相关, 依据, 参考, ▌R9.6.5 面向派生类的 catch 子句应排在面向基类的 catch 子句之前, 相关, 依据, 参考, 9.7 Jump, ▌R9.7.1 禁止 goto 语句向嵌套的或无包含关系的作用域跳转, 相关, 参考, ▌R9.7.2 禁止 goto 语句向前跳转, 相关, 参考, ▌R9.7.3 禁用 goto 语句, 相关, 参考, ▌R9.7.4 禁用 setjmp、longjmp, 依据, 参考, ▌R9.7.5 不应存在不受条件控制的跳转语句, 相关, ▌R9.7.6 不应存在不改变程序流程的跳转语句, ▌R9.7.7 避免使用跳转语句退出循环, 相关, 参考, 10. Expression, 10.1 Logic, ▌R10.1.1 不应存在无意义的重复子表达式, 参考, ▌R10.1.2 逻辑子表达式之间不应存在矛盾, 相关, 参考, ▌R10.1.3 作为条件的逻辑表达式不应恒为真或恒为假, 相关, 参考, ▌R10.1.4 不应存在多余的逻辑子表达式, 相关, ▌R10.1.5 逻辑表达式及逻辑子表达式不应为常量, 参考, ▌R10.1.6 逻辑表达式的右子表达式不应有副作用, 依据, 参考, ▌R10.1.7 化简可被合并的逻辑子表达式, 相关, ▌R10.1.8 化简可转换为逻辑表达式的三元表达式, 10.2 Evaluation, ▌R10.2.1 不可依赖不会生效的副作用, 相关, 依据, 参考, ▌R10.2.2 避免依赖特定的子表达式求值顺序, 相关, 依据, 参考, ▌R10.2.3 在表达式中不应多次读写同一对象, 相关, 依据, 参考, ▌R10.2.4 注意运算符优先级避免非预期的结果, 参考, ▌R10.2.5 不在同一数组或对象中的地址不可相减或比较大小, 相关, 依据, 参考, ▌R10.2.6 bool 值不应参与位运算、大小比较、数值增减, 依据, 参考, ▌R10.2.7 不应出现复合赋值的错误形式, 参考, ▌R10.2.8 避免出现复合赋值的可疑形式, 参考, ▌R10.2.9 amp=、|=、-=、/=、%= 左右子表达式不应相同, 参考, ▌R10.2.10 不应将 NULL 当作整数使用, 依据, 参考, ▌R10.2.11 注意赋值运算符与一元运算符的空格方式, 参考, ▌R10.2.12 不可将对象的值赋给具有部分重叠区域的对象, 依据, 参考, ▌R10.2.13 赋值运算符左右子表达式不应相同, 参考, ▌R10.2.14 除法和求余运算符左右子表达式不应相同, 参考, ▌R10.2.15 减法运算符左右子表达式不应相同, 参考, ▌R10.2.16 异或运算符左右子表达式不应相同, 参考, ▌R10.2.17 负号不应作用于无符号整数, 配置, 依据, 参考, ▌R10.2.18 不应重复使用一元运算符, ▌R10.2.19 运算结果不应溢出, 依据, 参考, ▌R10.2.20 位运算符不应作用于有符号整数, 依据, 参考, ▌R10.2.21 移位数量不应超过相关类型比特位的数量, 依据, 参考, ▌R10.2.22 按位取反需避免由类型提升产生的多余数据, 参考, ▌R10.2.23 逗号表达式的子表达式应具有必要的副作用, 相关, 10.3 Comparison, ▌R10.3.1 参与比较的对象之间应具备合理的大小关系, 相关, 参考, ▌R10.3.2 不应使用 == 或 != 判断浮点数是否相等, 参考, ▌R10.3.3 指针不应与字符串常量直接比较, 依据, 参考, ▌R10.3.4 不应比较非同类枚举值, ▌R10.3.5 比较运算符左右子表达式不应相同, 参考, ▌R10.3.6 比较运算不可作为另一个比较运算的直接子表达式, 相关, 参考, 10.4 Call, ▌R10.4.1 不应忽略重要的返回值, 配置, 依据, 参考, ▌R10.4.2 不可臆断返回值的意义, 依据, 参考, ▌R10.4.3 避免对象切片, 相关, 参考, ▌R10.4.4 避免显式调用析构函数, 相关, 依据, ▌R10.4.5 不应将非 POD 对象传入可变参数列表, 相关, 依据, 参考, ▌R10.4.6 C 格式化字符串需要的参数个数与实际传入的参数个数应一致, 相关, 依据, 参考, ▌R10.4.7 C 格式化占位符与其对应参数的类型应一致, 相关, 依据, 参考, ▌R10.4.8 在 C++ 代码中禁用 C 字符串格式化方法, 相关, 依据, 参考, ▌R10.4.9 禁用 atof、atoi、atol 以及 atoll 等函数, 依据, 参考, ▌R10.4.10 避免使用由实现定义的库函数, 依据, 参考, ▌R10.4.11 合理使用 stdmove, 依据, 参考, ▌R10.4.12 合理使用 stdforward, 相关, 依据, 参考, 10.5 Sizeof, ▌R10.5.1 sizeof 不应作用于数组参数, 依据, 参考, ▌R10.5.2 sizeof 不应作用于逻辑表达式, ▌R10.5.3 sizeof 作用于指针是可疑的, 相关, 参考, ▌R10.5.4 被除数不应是作用于指针的 sizeof 表达式, 相关, 参考, ▌R10.5.5 指针加减偏移量时计入 sizeof 是可疑的, 依据, 参考, ▌R10.5.6 sizeof 表达式的结果不应与 0 或负数比较, 依据, 参考, ▌R10.5.7 sizeof 不应再作用于 sizeof 表达式, 依据, 参考, ▌R10.5.8 C++ 代码中 sizeof 不应作用于 NULL, 相关, 依据, 参考, ▌R10.5.9 sizeof 不可作用于 void, 依据, 10.6 Assertion, ▌R10.6.1 断言中的表达式不应恒为真, 依据, ▌R10.6.2 断言中的表达式不应有副作用, 相关, 依据, 参考, ▌R10.6.3 断言中的表达式不应过于复杂, 配置, 10.7 Complexity, ▌R10.7.1 表达式不应过于复杂, 配置, 参考, 10.8 Other, ▌R10.8.1 不应访问填充数据, 相关, 依据, ▌R10.8.2 new 表达式只可用于赋值或当作参数, 相关, ▌R10.8.3 数组下标应为整型表达式, 依据, ▌R10.8.4 禁用逗号表达式, 配置, 参考, 11. Literal, ▌R11.1 转义字符的反斜杠不可误写成斜杠, 相关, 依据, ▌R11.2 在字符常量中用转义字符表示制表符和控制字符, 相关, ▌R11.3 在字符串常量中用转义字符表示制表符和控制字符, 相关, ▌R11.4 不应使用非标准转义字符, 依据, 参考, ▌R11.5 不应连接不同前缀的字符串常量, 配置, 依据, 参考, ▌R11.6 字符串常量中不应存在拼写错误, 相关, ▌R11.7 常量后缀由应由大写字母组成, 配置, 参考, ▌R11.8 禁用 8 进制常量, 参考, ▌R11.9 不应使用非标准常量后缀, 相关, 依据, ▌R11.10 小心遗漏逗号导致的非预期字符串连接, ▌R11.11 不应存在 magic number, 相关, 参考, ▌R11.12 不应存在 magic string, 相关, 参考, ▌R11.13 不应使用多字符常量, 相关, 依据, 12. Cast, ▌R12.1 避免类型转换造成数据丢失, 依据, 参考, ▌R12.2 避免数据丢失造成类型转换失效, 相关, 参考, ▌R12.3 避免有符号整型与无符号整型相互转换, 依据, 参考, ▌R12.4 避免与 void* 相互转换, 相关, 依据, 参考, ▌R12.5 避免向下类型转换, 相关, 参考, ▌R12.6 指针与整数不应相互转换, 配置, 相关, 依据, 参考, ▌R12.7 类型转换不应去掉 const、volatile 等属性, 依据, 参考, ▌R12.8 不应转换无继承关系的指针或引用, 配置, 相关, 依据, 参考, ▌R12.9 不应转换无 public 继承关系的指针或引用, 相关, 依据, ▌R12.10 非 POD 类的指针与基本类型的指针不应相互转换, 相关, 参考, ▌R12.11 不同的字符串类型之间不可直接转换, 相关, 参考, ▌R12.12 避免向对齐要求更严格的指针转换, 相关, 依据, 参考, ▌R12.13 避免转换指向数组的指针, 依据, 参考, ▌R12.14 避免转换函数指针, 依据, 参考, ▌R12.15 向下动态类型转换应使用 dynamic_cast, 相关, 依据, 参考, ▌R12.16 对 new 表达式不应进行类型转换, 相关, ▌R12.17 不应存在多余的类型转换, 参考, ▌R12.18 可用其他方式完成的转换不应使用 reinterpret_cast, 相关, 依据, 参考, ▌R12.19 合理使用 reinterpret_cast, 相关, 参考, ▌R12.20 在 C++ 代码中禁用 C 风格类型转换, 参考, 13. Buffer, ▌R13.1 避免缓冲区溢出, 相关, 参考, ▌R13.2 数组下标不可越界, 相关, 依据, 参考, ▌R13.3 为缓冲区分配足够的空间, 相关, 参考, ▌R13.4 memset 等函数不应作用于非 POD 对象, 相关, 参考, ▌R13.5 memset 等函数长度相关的参数不应有误, 参考, ▌R13.6 memset 等函数填充值相关的参数不应有误, 依据, 参考, 14. Pointer, ▌R14.1 避免空指针解引用, 依据, 参考, ▌R14.2 注意逻辑表达式内的空指针解引用, 依据, 参考, ▌R14.3 不可解引用未初始化的指针, 相关, 依据, 参考, ▌R14.4 不可解引用已被释放的指针, 相关, 依据, 参考, ▌R14.5 避免无效的空指针检查, 相关, 依据, ▌R14.6 不应重复检查指针是否为空, 相关, ▌R14.7 不应将非零常量值赋值给指针, 配置, 相关, 参考, ▌R14.8 不应使用常量 0 表示空指针, 相关, 依据, 参考, ▌R14.9 不应使用 false 对指针赋值, 相关, 参考, ▌R14.10 不应使用 ‘\0’ 等字符常量对指针赋值, 相关, 参考, ▌R14.11 指针不应与 false 比较大小, 相关, 参考, ▌R14.12 指针不应与 ‘\0’ 等字符常量比较大小, 相关, 参考, ▌R14.13 指针与空指针不应比较大小, 相关, 依据, 参考, ▌R14.14 不应判断 this 指针是否为空, 参考, ▌R14.15 析构函数中不可使用 delete this, 参考, ▌R14.16 禁用 delete this, ▌R14.17 判断 dynamic_cast 转换是否成功, 相关, 依据, 参考, ▌R14.18 指针在释放后应置空, 相关, 参考, 15. Interruption, ▌R15.1 避免由信号处理产生的数据竞争, 相关, 依据, 参考, ▌R15.2 处理信号时避免使用非异步信号安全函数, 相关, 依据, 参考, ▌R15.3 SIGFPE、SIGILL、SIGSEGV 等信号的处理函数不可返回, 依据, 参考, ▌R15.4 禁用 signal 函数, 相关, 依据, 参考, 16. Concurrency, ▌R16.1 访问共享数据应遵循合理的同步机制, 相关, 依据, 参考, ▌R16.2 避免在事务中通过路径多次访问同一文件, 依据, 参考, ▌R16.3 避免在事务中多次非同步地访问原子对象, 相关, 参考, ▌R16.4 避免死锁, 依据, 参考, ▌R16.5 避免异步终止线程, 相关, 参考, ▌R16.6 避免异步终止共享对象的生命周期, 相关, 依据, 参考, ▌R16.7 避免虚假唤醒造成同步错误, 参考, ▌R16.8 避免并发访问位域造成的数据竞争, 相关, 依据, 参考, ▌R16.9 多线程环境中不可使用 signal 函数, 相关, 依据, 参考, 17. Style, ▌R17.1 空格应遵循统一风格, 相关, ▌R17.2 大括号应遵循统一风格, 相关, ▌R17.3 赋值表达式不应作为子表达式, 配置, 相关, 参考, ▌R17.4 自增、自减表达式不应作为子表达式, 相关, 参考, ▌R17.5 控制条件应为 bool 型表达式, 相关, 参考, ▌R17.6 !、ampamp、|| 的子表达式应为 bool 型表达式, 相关, 参考, ▌R17.7 ampamp、|| 的子表达式应为后缀表达式, 依据, 参考, ▌R17.8 在 C++ 代码中 NULL 和 nullptr 不应混用, 相关, 参考, ▌R17.9 在 C++ 代码中用 nullptr 代替 NULL, 依据, 参考, ▌R17.10 避免多余的括号, 参考, ▌R17.11 避免多余的分号, 附录, 结语安全规则集合针对语言本文收录了种需要重点关注的问题可为制定编程规范提供依据也可为代码审计以及相关培训提供指导意见适用于桌面服务端以及嵌入式等软件系统每个问题对应一条规则每条规则可直接作为规范条款或审计检查点本文是适用于不同应用场景的规则集合读者可根据自身需求从中选取某个子集作为规范或审计依据从而提高软件产品的安全性规则说明规则按如下主题分为个类别敏感信息防护资源管理预处理宏注释全局及命名空间作用域类型设计与实现声明异常函数实现流程控制表达式常量类型转换缓冲区指针中断与信号处理异步与并发样式与风格每条规则包括编号规则在本文中的章节编号以开头称为名称用简练的短语描述违反规则的状况以开头称为标题规则的定义说明规则设立的原因违反规则的后果示例改进建议参照依据参考资料等内容如果违反规则后果的严重程度分为直接导致错误或形成安全漏洞可导致错误或形成安全隐患可疑的代码需进一步排查代码质量降低应依照建议改进规则的说明包含示例规则相关的示例代码指明符合规则的和违反规则的情况相关与当前规则有相关性的规则可作为扩展阅读的线索依据规则依照的标准条目规则以为主规则以为主配置某些规则的细节可灵活设置审计工具可以此为参照实现定制化功能参考规则参考的其他规范条目如等也可作为扩展阅读的线索规则的相关性分为特化设规则的特殊情况需要由规则阐明称规则是规则的特化泛化与特化相反称规则是规则的泛化相交设两个规则针对不同的问题但在内容上有一定的交集称这两个规则相交规则以标准名称版本章节编号段落编号性质的格式引用标准如表示引用标准的第章第节第段说明的具有性质的问题其中性质分为可使程序产生未定义的行为这种行为造成的后果是不可预期的可使程序产生未声明的行为这种行为由编译器或环境定义具有随意性可使程序产生由实现定义的行为这种行为由编译器或环境定义有明确的文档支持已被废弃的或不建议继续使用的编程方式本文以为主要依据兼顾以及历史标准没有特殊说明的规则同时适用于语言和语言只适用于某一种语言的规则会另有说明规则选取本文是适用于不同应用场景的规则集合读者可选取适合自己需求的规则指出某种错误的规则如有不可不应等字样的规则应尽量被选取有禁用等字样的规则可能只适用于某一场景可酌情选取如果将本文作为培训内容为了全面理解各种场景下存在的问题应选取全部规则规则列表敏感数据不可写入代码敏感数据不可被系统外界感知敏感数据在使用后应被有效清理公共成员或全局对象不应记录敏感数据预判用户输入造成的不良后果对资源设定合理的访问权限对用户落实有效的权限管理避免引用危险符号名称避免使用危险接口避免使用已过时的接口禁用不安全的字符串函数确保字符串以空字符结尾避免除等计算异常格式化字符串应为常量与内存空间布局相关的信息不可被外界感知与网络地址相关的信息不应写入代码选择安全的异常处理方式启用平台和编译器提供的防御机制不可失去对已分配资源的控制不可失去对已分配内存的控制不可访问未初始化或已释放的资源资源应接受对象化管理资源的分配与回收方法应成对提供资源的分配与回收方法应配套使用不应在模块之间传递容器类对象不应在模块之间传递非标准布局类型的对象对象申请的资源应在析构函数中释放对象被移动后应重置状态再使用构造函数抛出异常需避免相关资源泄漏资源不可被重复释放用释放对象需保证其类型完整用释放对象不可多写中括号用释放数组不可漏写中括号非动态申请的资源不可被释放在一个表达式语句中最多使用一次流式资源对象不应被复制避免使用变长数组避免使用在栈上分配内存的函数局部数组不应过大避免不必要的内存分配避免动态内存分配判断资源分配函数的返回值是否有效代码中禁用内存管理函数指令应符合标准格式指令中禁用不合规的字符指令中不应使用反斜杠指令中不应使用绝对路径指令应位于文件的起始部分禁用不合规的头文件代码不应引用头文件宏应遵循合理的命名方式不可定义具有保留意义的宏名称不可取消定义具有保留意义的宏名称可作为子表达式的宏定义应该用括号括起来表达式中的宏参数应该用括号括起来由多个语句组成的宏定义应该用括起来宏定义中的和运算符不应嵌套使用不应使用宏定义常量不应使用宏定义类型可由函数实现的功能不应使用宏实现宏不应被重定义只应在全局作用域中定义宏避免宏被取消定义宏的实参不应有副作用宏的实参个数不可小于形参个数宏的实参个数不可大于形参个数或应配合使用的类型参数应符合要求在代码中不应使用宏头文件不应缺少守卫不应出现非标准格式的预编译指令不应使用非标准预编译指令避免使用指令非自动生成的代码中不应出现指令宏的参数列表中不应出现预编译指令条件编译代码块应在同一文件中对编译警告的屏蔽应慎重在高级别的警告设置下编译关注等特殊注释注释不可嵌套注释应出现在合理的位置非空源文件应以换行符结尾除转义字符宏定义之外不应使用反斜杠全局名称应遵循合理的命名方式为代码设定合理的命名空间函数只应处于全局作用域中头文件中不应使用头文件中不应使用静态声明头文件中不应定义匿名命名空间匿名命名空间中不应使用静态声明全局对象的初始化不可依赖未初始化的对象全局对象只应为常量或静态对象全局对象只应为常量全局对象不应同时被和等关键字限定全局及命名空间作用域中禁用避免无效的不应定义全局命名空间不可修改命名空间类的非常量数据成员均应为类的非常量数据成员不应定义为类不应既有数据成员又有数据成员有虚函数的基类应具有虚析构函数避免多重继承自同一非虚基类存在析构函数或拷贝赋值运算符时不应缺少拷贝构造函数存在拷贝构造函数或析构函数时不应缺少拷贝赋值运算符存在拷贝构造函数或拷贝赋值运算符时不应缺少析构函数存在任一拷贝移动析构相关的函数时应定义所有相关函数避免重复实现由默认拷贝移动析构函数完成的功能可接受一个参数的构造函数需用关键字限定重载的类型转换运算符需用关键字限定不应过度使用关键字带模板的赋值运算符不应与拷贝或移动赋值运算符混淆带模板的构造函数不应与拷贝或移动构造函数混淆抽象类禁用拷贝和移动赋值运算符数据成员的数量应在规定范围之内数据成员之间的填充数据不应被忽视常量成员函数不应返回数据成员的非常量指针或引用类成员应按的顺序声明存在构造析构或虚函数的类不应采用关键字同类枚举项的值不应相同合理初始化各枚举项不应使用匿名枚举声明用取代联合体内禁用非基本类型的对象禁用在类之外定义的联合体禁用联合体遵循合理的命名方式不应定义具有保留意义的名称局部名称不应被覆盖成员名称不应被覆盖全局名称不应被覆盖类型名称不应重复定义类型名称不应与对象或函数名称相同不应存在拼写错误不应重复限定指针类型的别名是可疑的不可限定引用限定类型时的位置应统一等关键字不应出现在基本类型名称的中间指向常量字符串的指针应使用声明枚举类型的底层类型不应为或对常量的定义不应为引用禁用指针非适当场景禁用相关对象未被修改时应使用声明合理使用关键字不应使用已过时的关键字不应使用多余的关键字关键字不应作用于类成员的声明或定义重写的虚函数应声明为或和关键字不应同时出现在声明中或关键字不应与关键字同时出现在声明中不应将设为未访问指针的成员函数应使用声明声明和定义内部链接的对象和函数时均应使用关键字等关键字的位置应统一用声明指针或引用时应显式标明等符号禁用可变参数列表禁用柔性数组接口的参数类型和返回类型不应为类成员的类型不应为数组大小应被显式声明不应将类型定义和对象声明写在一个语句中不应将不同类别的声明写在一个语句中不应产生无效的临时对象不应存在没有被用到的局部声明对象初始化不可依赖自身的值参与数值运算的对象应显式声明或字节的类型应为或函数原型声明中的参数应具有合理的名称不应将数组作为函数的形式参数的声明应符合要求虚函数参数的默认值应与基类中声明的一致不建议虚函数的参数有默认值代码中参数列表如果为空应声明为代码中参数列表如果为空不应声明为声明数组参数的大小时禁用关键字派生类不应重新定义与基类相同的非虚函数重载运算符的返回类型应与内置运算符相符赋值运算符应返回所属类的非左值引用拷贝构造函数的参数应为同类对象的左值引用拷贝赋值运算符的参数应为同类对象的左值引用移动构造函数的参数应为同类对象的非右值引用移动赋值运算符的参数应为同类对象的非右值引用不应重载取地址运算符不应重载逗号运算符不应重载逻辑与和逻辑或运算符拷贝和移动赋值运算符不应为虚函数比较运算符不应为虚函数类中不应声明虚函数对位域声明合理的类型位域长度不应超过类型长度有符号整型对象的位域长度不应为不应对枚举对象声明位域禁用位域不应采用复杂的声明声明中不应包含过多的指针嵌套在一个语句中不应声明多个对象或函数遵循声明与实现应一致在合理的位置声明不应存在没有被用到的标签不应存在没有被用到的静态声明不应存在没有被用到的成员不应省略声明对象或函数的类型用中的类型代替等类型避免使用已过时的标准库组件保证异常安全处理所有异常不应抛出过于宽泛的异常不应捕获过于宽泛的异常不应抛出非异常类型的对象不应捕获非异常类型的对象全局对象的初始化过程不可抛出异常析构函数不可抛出异常内存回收函数不可抛出异常对象交换过程不可抛出异常移动构造函数和移动赋值运算符不可抛出异常异常类的拷贝构造函数不可抛出异常异常类的构造函数和异常信息相关的函数不应抛出异常与标准库相关的过程不应抛出异常由标记的函数不可产生未处理的异常避免异常类多重继承自同一非虚基类通过引用捕获异常捕获异常时不应产生对象切片问题捕获异常后不应直接再次抛出异常重新抛出异常时应使用空表达式不应在子句外使用空表达式不应抛出指针不应抛出不应抛出不应在模块之间传播异常禁用动态异常说明禁用异常函数的返回类型只应为函数不应被调用重载或被等关键字限定在头文件中不应实现函数或定义对象函数的参数名称在声明处和实现处应保持一致多态类的对象作为参数时不应采用值传递的方式不应存在未被使用的具名形式参数非基本类型的常量参数不应按值传递转发引用只应作为的参数局部对象在使用前应被初始化成员须在声明处或构造时初始化基类对象构造完毕之前不可调用成员函数在面向构造或析构函数体的子句中不可访问非静态成员成员初始化应遵循声明的顺序在构造函数中不应使用动态类型在析构函数中不应使用动态类型在析构函数中避免调用函数拷贝构造函数应避免实现复制之外的功能移动构造函数应避免实现数据移动之外的功能拷贝赋值运算符应处理参数是自身对象时的情况不应存在无效的写入操作不应存在没有副作用的语句不应存在得不到执行机会的代码有返回值的函数其所有分枝都应显式返回不可返回局部对象的地址或引用不可返回临时对象的地址或引用合理设置表达式的捕获方式函数返回值不应为右值引用函数返回值不应为常量对象函数返回值不应为基本类型的常量被返回的表达式应与函数的返回类型一致被返回的表达式不应为相同的常量具有属性的函数不应返回具有属性的函数返回类型只应为由指定的处理函数应正常返回函数模板不应被特化函数的退出点数量应在规定范围之内函数的标签数量应在规定范围之内函数的行数应在规定范围之内表达式的行数应在规定范围之内函数参数的数量应在规定范围之内不应定义过于复杂的内联函数避免函数调用自身作用域及类型嵌套不应过深汇编代码不应与普通代码混合避免重复的函数实现语句不应被分号隔断在分枝中不应有重复的条件在分枝中不应有被遮盖的条件分枝和分枝的代码不应完全相同各分枝的代码不应完全相同分枝和隐含的分枝代码不应完全相同没有子句的语句与其后续代码相同是可疑的分枝和分枝的起止语句不应相同语句作用域的范围不应有误如果关键字前面是右大括号关键字应另起一行语句的条件不应为赋值表达式语句不应为空分枝数量应在规定范围之内分枝中的语句应该用大括号括起来所有分枝都应以子句结束语句不应被分号隔断语句中不应存在无条件的跳转语句语句作用域的范围不应有误语句没有明确的循环变量时应改用语句循环体不应为空循环变量不应为浮点型循环变量不应在循环体内被改变嵌套的语句不应使用相同的循环变量循环体应该用大括号括起来语句不应被分号隔断语句中不应存在无条件的跳转语句语句的条件不应为赋值表达式语句作用域的范围不应有误循环体不应为空循环体应该用大括号括起来注意中可疑的语句循环体不应为空循环体应该用大括号括起来不建议使用语句语句不应被分号隔断语句不应为空标签的值不可超出条件的范围语句中任何子句都应从属于某个或分枝和标签应直接从属于语句不应存在紧邻标签的空标签不应存在内容完全相同的分枝语句的条件不应为型语句不应只包含标签语句不应只包含一个标签语句分枝数量应在规定范围之内语句应配有分枝语句的每个非空分枝都应该用无条件的或语句终止语句应该用大括号括起来语句不应嵌套关键字的作用域不应为空子句不应为空不应嵌套语句捕获所有异常的子句应位于最后面向派生类的子句应排在面向基类的子句之前禁止语句向嵌套的或无包含关系的作用域跳转禁止语句向前跳转禁用语句禁用不应存在不受条件控制的跳转语句不应存在不改变程序流程的跳转语句避免使用跳转语句退出循环不应存在无意义的重复子表达式逻辑子表达式之间不应存在矛盾作为条件的逻辑表达式不应恒为真或恒为假不应存在多余的逻辑子表达式逻辑表达式及逻辑子表达式不应为常量逻辑表达式的右子表达式不应有副作用化简可被合并的逻辑子表达式化简可转换为逻辑表达式的三元表达式不可依赖不会生效的副作用避免依赖特定的子表达式求值顺序在表达式中不应多次读写同一对象注意运算符优先级避免非预期的结果不在同一数组或对象中的地址不可相减或比较大小值不应参与位运算大小比较数值增减不应出现复合赋值的错误形式避免出现复合赋值的可疑形式左右子表达式不应相同不应将当作整数使用注意赋值运算符与一元运算符的空格方式不可将对象的值赋给具有部分重叠区域的对象赋值运算符左右子表达式不应相同除法和求余运算符左右子表达式不应相同减法运算符左右子表达式不应相同异或运算符左右子表达式不应相同负号不应作用于无符号整数不应重复使用一元运算符运算结果不应溢出位运算符不应作用于有符号整数移位数量不应超过相关类型比特位的数量按位取反需避免由类型提升产生的多余数据逗号表达式的子表达式应具有必要的副作用参与比较的对象之间应具备合理的大小关系不应使用或判断浮点数是否相等指针不应与字符串常量直接比较不应比较非同类枚举值比较运算符左右子表达式不应相同比较运算不可作为另一个比较运算的直接子表达式不应忽略重要的返回值不可臆断返回值的意义避免对象切片避免显式调用析构函数不应将非对象传入可变参数列表格式化字符串需要的参数个数与实际传入的参数个数应一致格式化占位符与其对应参数的类型应一致在代码中禁用字符串格式化方法禁用以及等函数避免使用由实现定义的库函数合理使用合理使用不应作用于数组参数不应作用于逻辑表达式作用于指针是可疑的被除数不应是作用于指针的表达式指针加减偏移量时计入是可疑的表达式的结果不应与或负数比较不应再作用于表达式代码中不应作用于不可作用于断言中的表达式不应恒为真断言中的表达式不应有副作用断言中的表达式不应过于复杂表达式不应过于复杂不应访问填充数据表达式只可用于赋值或当作参数数组下标应为整型表达式禁用逗号表达式转义字符的反斜杠不可误写成斜杠在字符常量中用转义字符表示制表符和控制字符在字符串常量中用转义字符表示制表符和控制字符不应使用非标准转义字符不应连接不同前缀的字符串常量字符串常量中不应存在拼写错误常量后缀由应由大写字母组成禁用进制常量不应使用非标准常量后缀小心遗漏逗号导致的非预期字符串连接不应存在不应存在不应使用多字符常量避免类型转换造成数据丢失避免数据丢失造成类型转换失效避免有符号整型与无符号整型相互转换避免与相互转换避免向下类型转换指针与整数不应相互转换类型转换不应去掉等属性不应转换无继承关系的指针或引用不应转换无继承关系的指针或引用非类的指针与基本类型的指针不应相互转换不同的字符串类型之间不可直接转换避免向对齐要求更严格的指针转换避免转换指向数组的指针避免转换函数指针向下动态类型转换应使用对表达式不应进行类型转换不应存在多余的类型转换可用其他方式完成的转换不应使用合理使用在代码中禁用风格类型转换避免缓冲区溢出数组下标不可越界为缓冲区分配足够的空间等函数不应作用于非对象等函数长度相关的参数不应有误等函数填充值相关的参数不应有误避免空指针解引用注意逻辑表达式内的空指针解引用不可解引用未初始化的指针不可解引用已被释放的指针避免无效的空指针检查不应重复检查指针是否为空不应将非零常量值赋值给指针不应使用常量表示空指针不应使用对指针赋值不应使用等字符常量对指针赋值指针不应与比较大小指针不应与等字符常量比较大小指针与空指针不应比较大小不应判断指针是否为空析构函数中不可使用禁用判断转换是否成功指针在释放后应置空避免由信号处理产生的数据竞争处理信号时避免使用非异步信号安全函数等信号的处理函数不可返回禁用函数访问共享数据应遵循合理的同步机制避免在事务中通过路径多次访问同一文件避免在事务中多次非同步地访问原子对象避免死锁避免异步终止线程避免异步终止共享对象的生命周期避免虚假唤醒造成同步错误避免并发访问位域造成的数据竞争多线程环境中不可使用函数空格应遵循统一风格大括号应遵循统一风格赋值表达式不应作为子表达式自增自减表达式不应作为子表达式控制条件应为型表达式的子表达式应为型表达式的子表达式应为后缀表达式在代码中和不应混用在代码中用代替避免多余的括号避免多余的分号敏感数据不可写入代码代码中的敏感数据极易泄露产品及相关运维测试工具的代码均不可记录任何敏感数据示例将密码等敏感数据写入代码是非常不安全的即使例中是实际密码的某种变换聪明的读者也会很快将其破解敏感数据的界定是产品设计的重要环节对具有高可靠性要求的客户端软件不建议保存任何敏感数据对于必须保存敏感数据的软件系统则需要落实安全的存储机制以及相关的评审与测试相关参考敏感数据不可被系统外界感知敏感数据出入软件系统时需采用有效的保护措施示例显然将敏感数据直接输出到界面日志或其他外界可感知的介质中是不安全的需避免敏感数据的有意外传除此之外还需要落实具体的保护措施保护措施包括但不限于避免用明文或弱加密方式传输敏感数据避免敏感数据从内存交换到外存避免避免敏感数据写入内存转储文件应具备反调试机制使外界无法获得程序的内部数据应具备反注入机制使外界无法篡改程序的行为下面以平台为例给出阻止敏感数据从内存交换到外存的示例例中是一个缓冲区类其申请的内存会被锁定在物理内存中不会与外存交换可在一定程度上防止其他进程的恶意嗅探保障缓冲区内数据的安全在构造函数中通过锁定物理内存在析构函数中通过解除锁定解锁之前有必要清除数据否则解锁之后残留数据仍有可能被交换到外存进一步可参见的使用方法如下在等系统中可参见如下有相似功能的接口相关参考敏感数据在使用后应被有效清理及时清理不再使用的敏感数据是重要的安全措施且应保证清理过程不会因为编译器的优化而失效程序会反复利用内存敏感数据可能会残留在未初始化的对象或对象之间的填充数据中如果被存储到磁盘或传输到网络就会造成敏感信息的泄露可参见和的进一步讨论示例示例代码调用覆盖敏感数据以达到清理目的然而保存敏感信息的为局部数组且之后没有再被引用根据相关标准编译器可将过程去掉使敏感数据没有得到有效清理提供了函数以避免这种问题某些平台和库也提供了相关支持如等不会被优化掉的函数在代码中可用限定相关数据以避免编译器的优化再用等方法清理如相关依据参考公共成员或全局对象不应记录敏感数据公共成员全局对象可被外部代码引用如果存有敏感数据则可能会被误用或窃取示例至少应将相关成员改为敏感数据最好对引用者完全隐藏避免被恶意分析复制或序列化使数据与接口进一步分离可参见等模式参考预判用户输入造成的不良后果须对用户输入的脚本路径资源请求等信息进行预判对产生不良后果的输入予以拒绝示例设返回用户输入的字符串将用户输入替换格式化占位符后执行语句如果用户输入一类的字符串则相当于执行的是一个恒为真的条件使限制失效造成所有数据被返回这是一种常见的攻击方式称为注入对于等脚本均需考虑这种问题应在执行前判断用户输入的安全性又如这段代码意在将用户输入的路径限制在目录下然而这么做是不安全的如果用户输入带有这种相对路径则仍可绕过限制这也是一种常见的攻击方式称为路径遍历应在读取文件之前判断路径的安全性注意用户输入不单指人的手工输入源自环境变量配置文件以及其他软硬件的输入均在此范围内参考对资源设定合理的访问权限对资源设定合理的访问权限避免为攻击者提供不应拥有的权限或能力权限的分类包括但不限于文件数据库等资源的读写权限计算过程的执行权限软硬件资源的占用权限权限设定是产品设计与实现的重要环节需落实相关的评审与测试示例例中函数开放了所有用户对文件的读写权限这是很不安全的进程之间不应直接通过文件通信应实现安全的接口和交互机制由于历史原因语言的和语言的都不能确保文件只能被当前用户访问提供了提供了以填补这方面的需求简例与不同可以不受等函数的影响直接将文件的权限设为当前用户私有其他用户不可访问降低了文件被窃取或篡改的风险是一种更安全的方法除此之外如果需要对资源进行更精细的权限管理可参见依据参考对用户落实有效的权限管理需落实有效的权限管理相关措施包括但不限于落实授权与认证机制提供多因素认证遵循最小特权原则对资源和相关算法设置合理的访问或执行权限避免仅在客户端认证而非服务端认证检查请求是否符合用户的权限设定拒绝无权限的请求用户放弃某项权限后应确保相关权限不再生效遵循合理的认证执行顺序避免复杂度攻击或早期放大攻击保证信道完整性对相关用户进行充分的身份认证避免中间人攻击验证通信通道的源和目的地拒绝非预期的请求和应答避免攻击者使用重放攻击等手段绕过身份认证或干扰正常运营避免不恰当地信任反向关注避免过于严格且易触发的账户锁定机制使攻击者通过锁定账户干扰正常运营权限管理与安全直接相关应落实严格的评审测试以及攻防演练示例设例中对应用户请求将请求中的字段替换格式化占位符后执行查询这个模式存在多种问题应先判断用户是否具有读取数据库相关字段的权限而且还应判断的值是否安全详见又如设例中读取大型文件进行身份认证在身份认证之前访问资源使得攻击者不必获取有效账号即可消耗系统资源从而对系统造成干扰所以应该在访问资源之前进行身份认证参考避免引用危险符号名称弱加密弱哈希弱随机不安全的协议等相关库函数类宏常量等名称不应出现在代码中这种危险符号名称主要来自低质量随机数生成算法如等不再适用的哈希算法如以及等非加密协议如等低版本的传输层安全协议如之前的版本弱加密算法如等示例参考避免使用危险接口由于历史原因有些系统接口甚至标准库函数存在缺陷无法安全使用也有一些接口的使用条件很苛刻难以安全使用示例例中函数不检查缓冲区边界无法安全使用等强制终止线程线程持有的资源难以正确释放极易导致泄漏或死锁等问题应避免使用这类函数参考避免使用已过时的接口避免使用在相关标准中已过时的接口应改用更完善的替代方法以规避风险提高可移植性对于过时的标准库接口本规则特化为示例例中引入的等函数在标准中已过时应改用函数等位在和位平台中不应再被使用相关参考禁用不安全的字符串函数由于历史原因标准库中的某些字符串函数不执行边界检查易造成运行时错误和安全漏洞这类函数包括与这类函数相似的函数同样受本规则约束如下列在代码中应采用更安全的库函数如用代替代替在代码中应采用标准库提供的相关功能示例例中函数无法检查缓冲区的大小一旦输入超过了数组的边界程序的数据或流程就会遭到破坏这种情况会被攻击者利用可参见的进一步说明如果代码中存在等函数可以直接判定程序是有漏洞的应改为与不同当输入超过缓冲区大小时会被截断保证缓冲区之外的数据不会被破坏又如例中函数与函数有相同的问题可改为等函数无视缓冲区大小需要在外部另行实现防止缓冲区溢出的代码完全依赖于开发者的小心谨慎历史表明对人的单方面依赖是不可靠的改用更安全的方法才是明智的选择相关依据参考确保字符串以空字符结尾语言要求字符串以空字符结尾程序应保证有足够的内存空间安置空字符否则会破坏程序基本的执行机制造成严重问题空字符指分别对应等字符串类型示例例示代码将字符串复制到数组中转为大写并打印然而如果所指字符串的长度超过不会在数组的结尾安置空字符导致内存访问越界程序可能会崩溃也可能打印出本该隐藏的敏感数据应改为将所有数组元素初始化为调用后如果数组最后一个元素是说明输入字符串的长度符合要求否则可作出相应的异常处理相关依据参考避免除等计算异常除等在数学上没有定义的运算浮点异常非法指令段错误等问题称为计算异常意味着严重的底层运行时错误而且这种异常无法用语言层面的常规方法捕获示例整数除往往会使程序崩溃浮点数除可以产生或等无效结果在某些环境中也可以设置浮点异常使程序收到特定信号崩溃会使程序异常终止无法或难以执行必要的善后工作如果崩溃可由外部输入引起会被攻击者利用从而迫使程序无法正常工作具有高可靠性要求的服务类程序更应该注意这一点可参见拒绝服务攻击对于客户端程序也要防止攻击者对崩溃产生的进行恶意调试避免泄露敏感数据总之程序的健壮性与安全性是紧密相关的相关依据参考格式化字符串应为常量出于可读性和安全性的考量格式化字符串最好直接写成常量字符串的形式本规则是的特化示例例中格式化字符串是变量这种方式可读性较差而且要注意如果可受外界影响则可能被攻击者利用造成不良后果应将改为常量相关参考与内存空间布局相关的信息不可被外界感知函数对象缓冲区的地址以及相关内存区域的长度等信息不可被外界感知否则会成为攻击者的线索示例示例代码将缓冲区的地址和长度输出到日志是不安全的这种代码多以调试为目的不应将其编译到产品的正式版本中相关参考与网络地址相关的信息不应写入代码在代码中记录网络地址不利于维护和移植也容易暴露产品的网络结构属于安全隐患示例应从配置文件中获取地址并配以加密措施特殊的地址可不受本规则限制如相关选择安全的异常处理方式避免使用和与其相同的模式应根据实际需求选择通过函数返回值或异常机制来处理异常情况被设定的位置和被读取的位置相距较远不遵循固定的静态结构极易误用是不安全的异常处理方式对异常情况的错误处理往往会成为业务漏洞使攻击者轻易地实现其目的示例例中执行异常通过获取异常信息但的值会被修改相应的异常处理也失去了意义又如并不能反映所有异常情况等函数与无关例中的值来自函数外部难以预料的位置相应的异常处理也将是错误的参考启用平台和编译器提供的防御机制针对一些常见攻击平台和编译器会提供防御机制如数据执行保护栈溢出防护地址空间布局随机化程序应利用这种机制加强自身的安全性进一步可参见示例如果在等平台上按如下方式编译各函数的地址在虚拟内存中是固定的易被攻击者猜中进而施展攻击手段当平台启用了机制再按如下方式编译可使程序各结构的地址随机化函数的地址在每次运行时均不相同有效提高了攻击难度如无特殊原因在编译程序时不应屏蔽这种防御机制如如果必须屏蔽应落实相关的评审与测试不可失去对已分配资源的控制对于动态分配的资源其地址句柄或描述符等标志性信息不可被遗失否则资源无法被访问也无法被回收这种问题称为资源泄漏会导致资源耗尽或死锁等问题使程序无法正常运行在资源被回收之前记录其标志性信息的变量如果均被重新赋值生命周期均已结束所在线程均被终止相关资源便失去了控制无法再通过正常手段访问相关资源示例例中变量记录文件资源描述符在回收资源之前对其重新赋值会导致资源泄漏相关参考不可失去对已分配内存的控制动态分配的内存地址不可被遗失否则相关内存无法被访问也无法被回收这种问题称为内存泄漏会导致可用内存被耗尽使程序无法正常运行程序需要保证内存分配与回收之间的流程可达且不可被异常中断相关线程也不可在中途停止本规则是的特化示例例中局部变量记录已分配的内存地址释放前在某种情况下函数返回之后便再也无法访问到这块内存了导致内存泄露又如例中函数分配失败会返回未经释放而被重新赋值导致内存泄露相关依据参考不可访问未初始化或已释放的资源访问未初始化或已释放的资源属于逻辑错误会导致标准未定义的行为对于访问未初始化的局部对象本规则特化为对于解引用未初始化或已被释放的指针本规则特化为示例相关依据参考资源应接受对象化管理使资源接受对象化管理免去繁琐易错的手工分配回收过程是程序设计的重要方法将资源分配的结果直接在程序中传递是非常不安全的极易产生泄漏或死锁等问题动态申请的资源如果只用普通变量引用不受对象的构造或析构机制控制则称为无主资源在程序设计中应当避免应尽量使用标准库提供的容器或智能指针避免显式使用资源管理接口本规则集合示例中的意在代指一般的资源操作仅作示例在实际代码中应尽量避免示例例中和函数的资源管理方式是不符合理念的函数中的对象负责资源的分配与回收称对象具有资源的所有权相关资源的生命周期与的生命周期一致有效避免了资源泄漏或错误回收等问题资源的所有权可以发生转移但应保证转移前后均有对象负责管理资源并且在转移过程中不会产生异常进一步理解对象化管理方法可参见等机制与资源相关的系统接口不应直接被业务代码引用如例中返回资源句柄是无主资源很可能被后续代码误用或遗忘应进行合理封装本例将及其相关数据封装成一个类由对象保存的结果是资源的回收方法将其作为对象的组成部分使资源可以被自动回收参考资源的分配与回收方法应成对提供资源的分配和回收方法应在同一库或主程序等可执行模块类等逻辑模块中提供如果一个模块分配的资源需要另一个模块回收会打破模块之间的独立性增加维护成本而且等可执行模块一般都有独立的堆栈跨模块的分配与回收往往会造成严重错误示例例中分配的内存由释放相当于混淆了不同堆栈中的数据程序一般会崩溃应改为修正后成对提供分配回收函数配套使用这些函数避免了冲突类等逻辑模块提供了分配方法也应提供回收方法如重载了运算符也应重载相应的运算符与也应成对提供相关参考资源的分配与回收方法应配套使用使用了某种分配方法就应使用与其配套的回收方法否则会引发严重错误示例不同的分配回收方法属于不同的资源管理体系用分配的资源应使用回收分配的应使用回收相关依据参考不应在模块之间传递容器类对象在库或主程序等可执行模块之间传递容器类对象会造成分配回收方面的冲突与资源管理相关的对象如流字符串智能指针以及自定义对象均不应在模块间传递不同的可执行模块往往具有独立的资源管理机制跨模块的分配与回收会造成严重错误而且不同的模块可能由不同的编译器生成对同一对象的实现也可能存在冲突示例例中容器的初始内存由分配与具有独立的堆栈由于模板库的内联实现函数会调用的内存管理函数重新分配中的内存造成严重错误相关不应在模块之间传递非标准布局类型的对象非标准布局类型的运行时特性依赖编译器的具体实现在不同编译器生成的模块间传递这种类型的对象会导致运行时错误标准布局类型的主要特点没有虚函数也没有虚基类所有非静态数据成员均具有相同的访问权限所有非静态数据成员和位域都在同一个类中声明不存在相同类型的基类对象没有非标准布局的基类没有非标准布局和引用类型的非静态数据成员除非模块均由同一编译器的同一版本生成否则不具备上述特点的对象不应在模块之间传递示例设例中和由不同的编译器生成中定义的对象被传递给了中定义的接口由于存在虚函数不同的编译器对对象的内存布局会有不同的解读从而造成冲突依据参考对象申请的资源应在析构函数中释放对象在析构函数中释放自己申请的资源是程序设计的重要原则不可被遗忘也不应要求用户释放示例例中成员与内存分配有关但析构函数为空不符合本规则要求相关参考对象被移动后应重置状态再使用对象被移动后在逻辑上不再有效如果没有通过清空数据或重新初始化等方法更新对象的状态不应再使用该对象示例例中容器的数据被移动到容器可能是通过交换的方法实现的也可能是通过其他方法实现的标准容器被移动后的状态在标准中是未声明的程序不应依赖未声明的状态应改为相关依据参考构造函数抛出异常需避免相关资源泄漏构造函数抛出异常表示对象构造失败不会再执行相关析构函数需要保证已分配的资源被有效回收示例例中内存分配可能会失败抛出异常在某种条件下还会抛出自定义的异常任何一种异常被抛出析构函数就不会被执行已分配的资源就无法被回收但已构造完毕的对象还是会正常析构的所以应采用对象化资源管理方法使资源可以被自动回收可改为先用对象持有资源完成可能抛出异常的事务之后再将资源转移给相关成员转移的过程不可抛出异常这种模式可以保证异常安全如果有异常抛出资源均可被正常回收对遵循及之后标准的代码建议用函数代替运算符示例代码意在讨论一种通用模式实际代码可采用更直接的方式保证已分配的资源时刻有对象负责回收是重要的设计原则可参见的进一步讨论注意未成功初始化的对象在语言中是不存在的应避免相关逻辑错误如例中类型的对象在构造时抛出异常而实际上并不会指向一个未能成功初始化的对象赋值被异常中断中的仍然是一个空指针表达式中抛出异常会自动回收已分配的内存相关依据资源不可被重复释放重复释放资源属于逻辑错误导致标准未定义的行为示例依据参考用释放对象需保证其类型完整如果用释放不完整类型的对象而对象完整类型声明中有析构函数会导致标准未定义的行为示例例中作用于不完整类型的指针析构函数不会正确执行应保证在之前定义依据用释放对象不可多写中括号用分配的对象应该用释放不可用释放否则导致标准未定义的行为示例相关依据参考用释放数组不可漏写中括号用分配的数组应该用释放不可漏写中括号否则导致标准未定义的行为示例在某些环境中可能只有第一个对象的析构函数被执行其他对象的析构函数都没有被执行如果对象与资源分配有关就会导致资源泄漏相关依据参考非动态申请的资源不可被释放释放非动态申请的资源会导致标准未定义的行为示例释放在栈上分配的空间或者局部对象的地址会造成严重的运行时错误依据参考在一个表达式语句中最多使用一次如果表达式语句多次使用一旦某个构造函数抛出异常就会造成内存泄漏示例例中的两个参数均为表达式实际执行时可以先为两个对象分配内存再分别执行对象的构造函数如果某个构造函数抛出异常已分配的内存就得不到回收了保证一次内存分配对应一个构造函数可解决这种问题这样即使构造函数抛出异常也会自动回收已分配的内存更好的方法是避免显式资源分配用等函数代替运算符可有效规避这种问题相关参考流式资源对象不应被复制等流式对象不应被复制如果存在多个副本会造成数据不一致的问题示例依据参考避免使用变长数组使用变长数组可以在栈上动态分配内存但分配失败时的行为不受程序控制变长数组由标准提出不在标准之内在代码中不应使用示例例中数组的长度为变量其内存空间在运行时动态分配如果长度参数不是合理的正整数会导致未定义的行为另外对于本应兼容的数组类型如果长度不同也会导致未定义的行为如相关依据参考避免使用在栈上分配内存的函数等函数可以在栈上动态分配内存但分配失败时的行为不受程序控制示例例中函数在失败时往往会使程序崩溃对其返回值的检查是无效的这种后果不可控的函数应避免使用尤其在循环和递归调用过程中更不应使用这种函数相关参考局部数组不应过大局部数组在栈上分配空间如果占用空间过大会导致栈溢出错误应关注具有较大数组的函数评估其在运行时的最大资源消耗是否符合执行环境的要求示例在栈上分配空间难以控制失败情况如果条件允许可改在堆上分配配置函数内局部数组空间之和的上限超过则报出参考避免不必要的内存分配对单独的基本变量或只包含少量基本变量的对象不应使用动态内存分配示例内存分配的开销远大于变量的直接使用而且还涉及到回收问题是得不偿失的应改为用分配数组时方括号被误写成小括号或使用等智能指针时遗漏了数组括号也是常见笔误如应改为有时可能需要区分变量是否存在用空指针表示不存在并通过资源分配创建变量的方式属于低效实现不妨改用变量的特殊值表示变量的状态在代码中也可使用实现相关功能相关避免动态内存分配标准库提供的动态内存分配方法其算法或策略不在使用者的控制之内很多细节是标准没有规定的而且也是内存耗尽等问题的根源有高可靠性要求的嵌入式系统应避免动态内存分配在内存资源有限的环境中由于难以控制具体的分配策略很可能会导致已分配的空间用不上未分配的空间不够用的情况而在资源充足的环境中也应尽量避免动态分配如果能在栈上创建对象就不应采用动态分配的方式以提高效率并降低资源管理的复杂性示例例中容器使用了动态内存分配方法容量的增长策略可能会导致内存空间的浪费甚至使程序难以稳定运行依据参考判断资源分配函数的返回值是否有效等函数在分配失败时返回空指针如果不加判断直接使用会导致标准未定义的行为在有虚拟内存支持的平台中正常的内存分配一般不会失败但申请内存过多或有误时如参数为负数也会导致分配失败而对于没有虚拟内存支持的或可用内存有限的嵌入式系统检查分配资源是否成功是十分重要的所以本规则应该作为代码编写的一般性要求库的实现更需要注意这一点如果库由于分配失败而使程序直接崩溃相当于干扰了主程序的决策权很可能会造成难以排查的问题对于有高可靠性要求的软件在极端环境中的行为是需要明确设定的示例示例代码未检查的有效性便直接使用是不符合要求的依据参考代码中禁用内存管理函数在代码中不应使用等内存管理函数应使用内存管理方法示例应改为相关参考指令应符合标准格式后只应为头文件路径或头文件路径否则会导致标准未定义的行为示例例中对的引用符合标准而对的引用会导致标准未定义的行为注意由引号标识的头文件路径并非字符串常量不应对其使用字符串常量的特性如是否会将引号中的内容连接成一个路径是由实现定义的这种代码是不可移植的另外如下形式的代码也是不符合标准的相关依据参考指令中禁用不合规的字符字母数字下划线点号之外的字符可能与文件系统存在冲突也可能导致标准未定义的行为不应出现在头文件和相关目录名称中示例可以用作为路径分隔符但不应出现或如另外某些平台的文件路径不区分大小写建议在头文件名称中只使用小写字母以提高可移植性依据参考指令中不应使用反斜杠如果在指令中使用反斜杠程序的行为在和标准中是未定义的在标准中是由实现定义的示例在有可移植性要求的代码中应避免使用反斜杠依据参考指令中不应使用绝对路径绝对路径使代码过分依赖编译环境意味着项目的编译设置不完善应使用相对路径示例指令应位于文件的起始部分指令之前的代码只应为预编译指令或注释否则不利于阅读和维护用于包含模板实现文件的指令可不受本规则限制但相关文件的命名应与普通头文件有所区别示例如果声明的一部分在头文件内另一部分在头文件外会导致标准未定义的行为依据参考禁用不合规的头文件已过时的无意义的或有不良副作用的头文件应禁用示例和会使用语言标准之外的技术实现某种重载效果而且其中的部分函数名称会干扰其他标准库中的名称和则包含危险的过程间跳转函数以及等头文件对语言没有意义等头文件在标准中已过时在代码中不应使用这些头文件等头文件含有较多标准未声明或由实现定义的内容对有高可靠性要求的软件系统也不建议使用审计工具不妨通过配置设定不合规头文件的名称如表示对代码将设为不合规对代码将设为不合规配置代码中不合规头文件名称代码中不合规头文件名称依据参考代码不应引用头文件为了与语言兼容标准库也会提供头文件但在这种头文件在标准中是已过时的标准头文件均有对应的版本版本提供了更适合代码的命名空间模板以及函数重载等功能标准不在标准之内在代码中不建议使用标准库的功能如果确有必要应使用版本的头文件本规则是的特化示例相关依据参考宏应遵循合理的命名方式宏的名称应采用全大写字母的形式非宏名称则应包含小写字母宏用于文本处理不受语言规则限制易被误用在命名方式上将其与普通代码分开可引起使用者或维护者的注意有助于规避错误本规则是的特化宏名称同样受的约束示例相关参考不可定义具有保留意义的宏名称重新定义已有特殊用途的名称会导致标准未定义的行为也会使代码陷入难以维护的境地标准库编译环境中的名称以及关键字不应重新定义标准指明不可重新定义的宏有以下划线开头的名称用于表示标准库或编译环境的保留名称自定义名称不应以下划线开头示例标识平台或编译环境的宏不可在代码中写死不可重定义关键字编译优化相关的宏不可在代码中写死标准库中的名称不应被重新定义配置是否将关键字作为保留名称是否将标准库中的名称作为保留名称是否将下划线开头的名称作为保留名称用户指定的保留名称相关依据参考不可取消定义具有保留意义的宏名称取消定义已有特殊用途的宏会导致标准未定义的行为也会使代码陷入难以维护的境地标准库编译环境中的宏不可被取消定义示例配置是否将关键字作为保留名称是否将标准库中的名称作为保留名称是否将下划线开头的名称作为保留名称用户指定的保留名称相关依据参考可作为子表达式的宏定义应该用括号括起来由于宏只做文本处理不考虑运算符优先级等问题可作为子表达式的宏定义应该用括号括起来否则易产生意料之外的错误示例设为变量如果按如下使用方式则相当于这显然会造成意料之外的结果所以的定义应改为依据参考表达式中的宏参数应该用括号括起来由于宏只做文本处理不考虑运算符优先级等问题故应将宏参数用括号括起来否则易产生意料之外的错误示例应改为依据参考由多个语句组成的宏定义应该用括起来可以作为一条语句使用的宏且宏包含多个并列子句时应该用和括起来否则易造成作用域的混乱示例如果按如下使用方式展开后不在语句的范围内应改为更进一步地建议使用结构这样在使用宏时必须以分号结尾否则无法通过编译使宏在使用风格上与函数相同易于阅读相关依据参考宏定义中的和运算符不应嵌套使用和运算符的求值顺序在标准中是未声明的不应嵌套使用示例依据参考不应使用宏定义常量宏用于文本处理不受作用域等语言规则限制不应使用宏实现常量等语言层面的概念示例例中宏不受命名空间的限制第二个宏定义会覆盖第一个宏定义而且会干扰其他作用域中相同的名称应改为为了避免混乱建议宏只作为等指令的条件不参与具体的功能实现相关参考不应使用宏定义类型宏用于文本处理不受作用域等语言规则限制不应使用宏实现类型等语言层面的概念示例例中的最终定义是第二个宏定义会覆盖第一个宏定义这显然是不可靠的相关参考可由函数实现的功能不应使用宏实现宏用于文本处理不受作用域参数传递重载等语言规则限制且难以调试可由函数实现的功能不应使用宏实现示例例中宏意在获取参数的和但宏无法被重载最终只有一个宏被定义函数中的宏展开会造成错误相关参考宏不应被重定义宏不受作用域限制重定义宏会使同一个全局名称产生多种不同的意义易导致错误并降低可维护性示例例中宏在函数中被重定义其影响范围是难以控制的即使在重定义前用取消定义也是不可取的复用宏名称会使代码难以维护依据只应在全局作用域中定义宏宏不受作用域限制在非全局作用域中定义宏易引起误解示例例中宏在函数中定义但其作用范围却是全局的如果宏与某作用域密切相关在该作用域内定义宏使用后再取消定义是一种惯用方式如审计工具不妨通过配置决定是否放过这种情况配置是否允许在同一非全局作用域内定义并取消定义宏相关依据参考避免宏被取消定义宏不受作用域限制不应被取消定义否则会失去确定性使代码难以维护示例在一个文件中定义了宏在另一个文件取消并重定义了使同一个全局名称产生两种不同的意义严重降低了可维护性有时取消定义已使用完毕的内部宏可避免对外部产生不良影响具有一定积极作用但宏的定义和取消应在同一文件的同一作用域中完成相关示例可参见配置是否允许取消在同一作用域内定义的宏相关参考宏的实参不应有副作用当宏参数有副作用时如果宏定义中没有或多次引用到该参数会导致意料之外的错误示例例中和看起来像是函数调用而展开后的结果却在意料之外相关参考宏的实参个数不可小于形参个数宏的实参个数小于形参个数是不符合标准的参数个数不一致必然意味着某种错误然而在某些编译环境下却可以通过编译示例早期标准对这种情况没有明确定义后续标准对其进行了约束但等编译器至今仍不把这种问题视作编译错误需要特别注意相关依据参考宏的实参个数不可大于形参个数宏的实参个数大于形参个数是不符合标准的多余的宏参数是没有意义的然而在某些编译环境下却可以通过编译示例例外可变宏参数列表可不受本规则约束相关依据参考或应配合使用可变参数列表相关的或和应在同一函数中使用否则会导致标准未定义的行为示例应在函数返回前使用相关依据的类型参数应符合要求对于中的宏其类型参数在对于宏的类型参数下列情况会导致标准未定义的行为后加号不能表示指针类型与默认参数提升后的类型不兼容与可变参数列表中对应的实参类型不兼容或没有对应的实参以下类型不可作为的参数这些类型的参数在传入可变参数列表时会被提升为等类型如果再按提升前的类型解析参数的值就会产生错误参见默认参数提升机制另外代码中非类型也不可作为的参数参见示例例中的类型参数为是不符合要求的应改为相关依据参考在代码中不应使用宏宏很难适用于具有特性的类在代码中不应使用如果用于非类型计算静态成员或成员函数的偏移量会导致标准未定义的行为示例依据参考头文件不应缺少守卫以或为扩展名的头文件应包含头文件守卫示例例中是模块中的头文件宏即可作为它的守卫保证头文件被重复引入也不会出现问题守卫名称不可有重复建议守卫名称遵循模块名文件名的形式指令也可作为头文件守卫但并不是的标准方式只是多数编译器均有支持这种方式由编译器维护一个列表引入头文件时如果发现文件中有指令就将文件路径加入列表当这个文件再次被时便不会加载而宏守卫的方式仍然要对文件进行预编译所以方式在编译效率上会更高一些宏守卫用宏名区分头文件所以不能有重复宏的引入可以使相关设定更灵活比如声明头文件之间的依赖或排斥关系如果依赖在之前必须可在中设置这样如果不满足条件无法通过编译本规则建议使用宏守卫的方式但方法也是惯用写法不妨通过配置项决定其是否合规配置是否允许作为头文件守卫参考不应出现非标准格式的预编译指令非标准格式的预编译指令往往意味着错误也会导致标准未定义的行为需注意只应作用于宏名称或括号括起来的宏名称不应出现在宏定义中之后应为正确的常量表达式之后只应为宏名称之后应直接换行之后应接整数常量或整数常量和文件名称指定的行号应在有效范围内不应出现在非自动生成的代码中示例例中作用于比较表达式的和条件中由宏展开产生的均会导致未定义的行为由指定的行号应大于且小于按标准则应小于否则也会导致未定义的行为又如这种代码是不符合标准的但可被某些编译器接受应避免依据参考不应使用非标准预编译指令非标准预编译指令往往属于某种编译器独有在有可移植性要求的代码中应避免使用示例依据参考避免使用指令应避免使用由实现定义的指令以提高可移植性示例应使用标准方法代替指令如果难以代替相关指令应备以文档说明依据参考非自动生成的代码中不应出现指令在非自动生成的代码中没有必要使用指令否则会干扰编译器的输出使问题难以定位示例依据宏的参数列表中不应出现预编译指令如果预编译指令出现在宏的参数列表中会导致标准未定义的行为示例可能会打印出也可能是这种怪异的结果依据参考条件编译代码块应在同一文件中与对应的应在同一文件中否则会增加代码的维护成本示例示例代码将分成了三个文件使这些文件的依赖关系变得复杂也使单个文件失去了可读性参考对编译警告的屏蔽应慎重编译器一般允许使用预编译指令屏蔽某些编译警告但对于反映风险或安全问题的警告不应屏蔽示例示例代码屏蔽了和对应的警告当局部变量的地址被返回时编译器不会给出警告但这种警告是不应该被屏蔽的详见本规则集合提到的部分问题编译器也可以给出警告这种警告均不应被屏蔽相关在高级别的警告设置下编译编译器一般允许设定编译警告的级别级别越高关注的问题就越多也可以将警告设为错误当有警告产生时停止编译建议代码在高级别的警告设置下编译应避免代码中出现等指令这种指令将警告级别设为默认可能与整个项目的设置不一致如果一定要使用应改用方式示例示例代码在导入某些代码之前将代号为的警告屏蔽之后又将其设为默认级别首先要关注是否应该被屏蔽还要关注如果将其设为默认是否与整个项目的设置有冲突应改为改用这种方式之后不必再关注是否与整个项目的设置有冲突了相关参考关注等特殊注释等特殊注释表示代码中存在问题这种问题不应被遗忘应有计划地予以解决及时记录问题是一种好习惯而且最好有署名和日期示例审计工具不妨定期搜索这些关键词对应的注释以供相关人员核对问题解决情况配置特殊注释的模式字符串如正则表达式等供审计工具查找参考注释不可嵌套嵌套的注释不符合标准与之间不应出现某些编译器可以接受嵌套但不具备可移植性示例根据标准处的与处的匹配而处的处于失配状态依据参考注释应出现在合理的位置注释应出现在段落的前后或行尾不应出现在行首或中间否则干扰阅读甚至会导致标准未定义的行为示例应改为例外如果参数有默认值在函数实现中参数声明的结尾可用注释说明不受本规则限制依据非空源文件应以换行符结尾如果非空源文件未以换行符结尾或以换行符结尾但换行符之前是反斜杠在和标准中会导致未定义的行为一般情况下或编辑器会保证源文件以空行结尾而且规定编译器应补全所需的空行但为了提高兼容性并便于各种相关工具的使用所有与代码相关的文本文件均应以有效的换行符结尾配置是否要求所有文本文件均以换行符结尾依据除转义字符宏定义之外不应使用反斜杠反斜杠可用于标识转义字符也可用于实现伪换行即代码换行显示但在语法上并没有换行一般用于宏定义除此之外不应再使用反斜杠否则没有实际意义也会造成混乱示例如果被反斜杠截断会导致标准未定义的行为如应去掉反斜杠依据参考全局名称应遵循合理的命名方式全局名称应具有标识性长度不应过短否则易与局部名称产生冲突本规则是的特化示例名称适用的作用域范围越广其长度也应该越长建议全局名称长度不小于个字符配置全局对象名称长度下限小于则报出全局函数名称长度下限小于则报出全局命名空间名称长度下限小于则报出全局类型名称长度下限小于则报出相关参考为代码设定合理的命名空间命名空间是项目的必要组成结构可有效规避名称冲突等问题代码的顶层作用域应为具名非内联命名空间命名空间名称应与项目名称相符且具有标识性示例对于函数和声明的代码可不受本规则限制如相关参考函数只应处于全局作用域中函数作为程序的入口链接器需对其特殊处理不应受命名空间等作用域的限制示例依据参考头文件中不应使用在头文件的全局作用域中使用极易造成命名冲突且影响范围难以控制如果代码涉及多个命名空间而这些命名空间中又有名称相同且功能相似的代码元素时将造成难以排查的混乱对于库的头文件更应该严禁使用全局的否则造成对用户命名空间的干扰示例下例展示的问题是头文件不同的包含顺序竟导致同一函数产生了不同的行为头文件和以不同的顺序被包含使函数调用了不同的函数导致这种混乱的正是中的相关参考头文件中不应使用静态声明头文件中由关键字声明的对象数组或函数会在每个包含该头文件的翻译单元或模块中生成副本造成数据冗余如果将静态数据误用作全局数据也会造成逻辑错误类的静态成员不受本规则限制示例在编译每个包含该头文件的源文件时变量和函数都会生成不必要的副本在头文件中实现的内联或模板函数中也不应使用静态声明如如果该头文件被不同的模块包含对象会生成不同的副本很可能造成逻辑错误另外由或关键字限定的常量也具有静态数据的特性在头文件中定义常量也面对这种问题基本类型的常量经过编译优化可以不占用存储空间有取地址操作的除外而对于非基本类型的常量对象或数组也不应在头文件中定义建议采用单件模式将其数据定义在等源文件中在头文件中定义访问这些数据的接口如在需要用到常量数组的地方调用函数即可获取该数组的引用没有任何重复的数据产生并可保证数组在使用之前被有效初始化相关依据头文件中不应定义匿名命名空间在头文件中定义匿名命名空间相当于在头文件中定义静态数据头文件被多个源文件包含时会造成数据冗余可参见的进一步讨论示例相关依据参考匿名命名空间中不应使用静态声明匿名命名空间中的元素已具有内部链接性不应再用关键字限定示例例中关键字是多余的应改为依据全局对象的初始化不可依赖未初始化的对象全局对象的初始化或构造过程不可依赖在其他源文件中定义的全局对象也不可依赖在其后面定义的对象在不同源文件中定义的全局对象以及类的静态成员对象其初始化顺序是不确定的在同一源文件中定义的对象排在前面的会先于后面的初始化为避免产生问题建议只使用基本类型的常量作为全局对象且尽量不要使用关键字示例例中是在其他源文件中定义的对象初始化时无法保证已被正确初始化又如例中在的后面定义会先于初始化的值是还是函数的返回值在标准中是未声明的依据参考全局对象只应为常量或静态对象非常量全局对象破坏了面向对象的封装理念如果必须使用全局对象应将其限定在文件范围之内本规则放宽了的要求对于代码不建议选取本规则对于代码可酌情选取示例相关参考全局对象只应为常量非常量全局对象对外部的读写没有限制破坏了面向对象的封装理念不利于维护全局对象的初始化顺序和依赖关系也是开发与维护的难点建议只允许基本类型的常量作为全局对象进一步讨论可参见示例应将全局对象和相关函数封装成类如果变量确有全局意义多个模块都需要访问不妨将其单件化用函数获取对象再由其成员函数对数据进行读写有效实现封装理念而且可以保证对象在使用之前已被初始化配置是否只允许基本类型的常量作为全局对象相关参考全局对象不应同时被和等关键字限定在语言中由或关键字限定的全局对象已具有内部链接性不应再被关键字限定示例应改为相关依据全局及命名空间作用域中禁用通过将其他命名空间中的名称一并引入当前命名空间是对命名空间机制的破坏会造成难以预料的冲突与混乱示例在函数作用域内可适当放宽要求如建议用代替相关参考避免无效的用引用当前命名空间属于无效代码可能意味着某种错误示例不应定义全局命名空间定义全局命名空间相当于没有命名空间应在普通命名空间之内使用命令空间示例应该用普通命名空间加以限定不可修改命名空间可以为用户定义的类型特化某些标准模板类除此之外对命名空间添加修改甚至删除任何代码所导致的后果都是标准未定义的示例例中对标准模板类的特化是可被允许的但在命名空间中添加的函数是不被允许的应去掉命名空间作用域声明改为依据参考类的非常量数据成员均应为类的数据成员均应设为对外统一由成员函数提供访问方法且应避免返回成员的非常量引用或指针将类的所有接口都实现为成员函数由成员函数按指定逻辑读写数据以便保证有效地改变对象状态良好的接口设计会对代码的职责进行合理划分显著提升可维护性理想状态下当有错误需要修正或有功能需要调整时只改动相关接口的实现即可调用接口的代码不需要改动从而将改动降到最低这种设计的基础便是将数据设为只能由本类的成员函数访问否则数据可被各个模块随意读写当有一处需要改动时很难控制其影响范围常量数据成员不可被改变所以可不受本规则约束示例例中类的数据成员指向动态分配的内存区域记录区域大小和之间存在紧密的逻辑关系这种内在关系应由成员函数统一维护不暴露给类的使用者这便是面向对象的封装理念也是语言的核心理念之一应改为这样数据成员不能被外界直接访问成员之间的关系也不会被随意打破显著提升可维护性相关参考类的非常量数据成员不应定义为数据成员在派生类中仍可被随意读写破坏了封装理念本规则是的特化关于封装的进一步讨论可参见常量数据成员不可被改变所以可不受本规则约束示例应改为由接口访问相关参考类不应既有数据成员又有数据成员类的设计应遵循成员之间没有依赖关系且都可以随意被读写时则都应声明为成员之间有依赖关系或成员的状态会影响到整个对象的状态时则都应声明为否则应对类进行改造或拆分面向对象的封装理念更倾向于将所有数据成员都设为由成员函数按指定逻辑控制每个成员的读写方法以供外部访问对代码的职责进行有效地划分从而提高可维护性并降低风险关于封装的进一步讨论可参见常量数据成员不可被改变所以可不受本规则约束示例应改为相关参考有虚函数的基类应具有虚析构函数为了避免意料之外的资源泄漏有虚函数的基类都应该具有虚析构函数通过基类指针析构派生类对象时如果基类没有虚析构函数会导致标准未定义的行为无法正确执行派生类的析构函数示例由于基类的析构函数不是虚函数只调用了基类析构函数派生类对象的资源没有得到释放例外如果有意阻止外界通过基类指针析构对象如析构函数是可不受本规则限制依据参考避免多重继承自同一非虚基类当派生类有多个基类这些基类又派生自同一非虚基类时派生类对象会持有该非虚基类的多个实例造成逻辑和存储上的冗余示例在类对象中基类的成员有两个不同的实例不能直接访问只能通过或这种怪异的方式访问将共同的基类设为虚基类可以解决这种问题注意直接将虚基类指针转为派生类指针会导致标准未定义的行为如这种转换一般不会通过编译但标准并未要求编译器必须阻止这种转换改用可解决这些问题相关依据参考存在析构函数或拷贝赋值运算符时不应缺少拷贝构造函数三个紧密相关的函数拷贝构造函数拷贝赋值运算符析构函数当这三个函数中的任何一个函数被定义时说明对象在资源管理等方面有特定的需求其他两个函数也需要被定义否则难以适应各种应用场景易产生意料之外的错误这种规则称为如果缺少某个函数编译器会生成相关默认函数但其特定需求不会被实现示例例中的类有析构函数但没有拷贝构造函数和拷贝赋值运算符只能进行变量值的复制使多个对象的资源指针指向同一块内存区域导致重复释放和内存泄漏所以应定义拷贝构造函数和拷贝赋值运算符重新分配内存并复制数据同理在遵循及之后标准的代码中拷贝构造函数拷贝赋值运算符析构函数移动构造函数移动赋值运算符当定义了这五个函数中的任何一个函数时其他四个函数也需要定义详见相关参考存在拷贝构造函数或析构函数时不应缺少拷贝赋值运算符三个紧密相关的函数拷贝构造函数拷贝赋值运算符析构函数当这三个函数中的任何一个函数被定义时其他两个函数也需要被定义详见示例应明确定义赋值运算符相关参考存在拷贝构造函数或拷贝赋值运算符时不应缺少析构函数三个紧密相关的函数拷贝构造函数拷贝赋值运算符析构函数当这三个函数中的任何一个函数被定义时其他两个函数也需要被定义详见示例应明确定义析构函数相关参考存在任一拷贝移动析构相关的函数时应定义所有相关函数五个紧密相关的函数拷贝构造函数拷贝赋值运算符析构函数移动构造函数移动赋值运算符当这五个函数中的任何一个函数被定义时说明对象在资源管理等方面有特定的需求其他四个函数也需要被定义否则难以适应各种应用场景易产生意料之外的错误这种规则称为如果缺少某个函数编译器会生成相关默认函数但其特定需求不会被实现如果确实不需要某个函数也应将其明确地设定为或如果确实只需要默认处理应将其声明为这样可明确对象的行为规避意料之外的错误本规则适用于遵循及之后标准的代码对于遵循及之前标准的代码本规则特化为另外如果类只负责成员对象的包装或组合而没有特殊的复制移动析构需求时这些函数就都不要定义参见相关参考避免重复实现由默认拷贝移动析构函数完成的功能当类只负责成员对象的包装或组合而没有特殊的复制移动析构需求时不应定义下列函数拷贝构造函数拷贝赋值运算符析构函数移动构造函数移动赋值运算符应由编译器生成相关默认函数否则会产生多余的代码增加维护成本这种规则称为示例例中的类只涉及字符串对象的组合复制移动和析构可交由成员对象完成其拷贝构造函数赋值运算符以及析构函数是多余的应该去掉编译器会进行更好地处理相关参考可接受一个参数的构造函数需用关键字限定为了避免意料之外的类型转换可接受一个参数的构造函数应该用关键字限定示例由于类的构造函数接受一个型参数相当于将隐式转为类的对象这种隐式转换是怪异的也往往意味着意料之外的错误应改为这样这种写法便不会通过编译例外拷贝移动构造函数可不受本规则约束如果将拷贝移动构造函数声明为则无法再按值传递参数或按值返回对象在类的接口设计中应尽量减少隐式转换以避免不易察觉的问题相关参考重载的类型转换运算符需用关键字限定为了避免意料之外的类型转换重载的类型转换运算符需用关键字限定示例例中返回临时对象类型转换运算符被隐式调用然而当返回后临时对象被销毁返回的指针是无效的将类型转换运算符用关键字限定有问题的代码便不会通过编译在类的接口设计中应尽量减少隐式转换以避免不易察觉的问题相关参考不应过度使用关键字对类的拷贝移动以及不接受个参数的构造函数一般不用限定否则有损代码的易用性和可扩展性示例当类的拷贝移动构造函数被限定时无法再按值传递参数或按值返回对象当不接受个参数的构造函数被限定时无法再用初始化列表定义临时对象如下代码将无法通过编译参考带模板的赋值运算符不应与拷贝或移动赋值运算符混淆带模板的赋值运算符不应与拷贝或移动赋值运算符混淆存在带模板的赋值运算符时应明确声明拷贝和移动赋值运算符示例设例中的类需要深拷贝标准规定即使带模板的赋值运算符在功能上可以满足拷贝或移动赋值运算符的需求也不能作为拷贝或移动赋值运算符故其拷贝和移动赋值运算符仍然是默认的无法完成深拷贝以及正确的数据移动应明确声明拷贝和移动赋值运算符相关依据参考带模板的构造函数不应与拷贝或移动构造函数混淆带模板的构造函数不应与拷贝或移动构造函数混淆存在带模板的构造函数时应明确声明拷贝和移动构造函数示例设例中的类需要深拷贝标准规定即使带模板的构造函数在功能上可以满足拷贝或移动构造函数的需求也不能作为拷贝或移动构造函数故其拷贝和移动构造函数仍然是默认的无法完成深拷贝以及正确的数据移动应明确声明拷贝和移动构造函数相关依据参考抽象类禁用拷贝和移动赋值运算符抽象类只能作为基类没有独立的对象调用拷贝或移动赋值运算符会造成数据不完整示例例中函数的参数只能是的派生类对象派生类对象调用基类的拷贝赋值运算符会得到不完整的复制结果应改为将抽象类的拷贝和移动赋值运算符设为或可在编译期阻止不完整的复制和移动参考数据成员的数量应在规定范围之内类或联合体的数据成员过多意味着一个逻辑或功能单位承担了过多的职责违反了模块化设计理念是难以维护的示例配置类数据成员的数量上限超过则报出联合体数据成员的数量上限超过则报出数据成员之间的填充数据不应被忽视成员之间存在填充数据且没有声明对齐方式时填充数据的长度是由实现定义的这种数据不应在不同的环境之间传输而且应注意成员的声明顺序避免由填充数据造成的空间浪费关于填充数据的具体组织方式详见内存对齐示例例中成员和之间存在填充数据但没有声明对齐方式直接在网络上传输这种类型的对象是不符合要求的如果发送端的对齐方式与接收端不一致就会造成混乱应在发送端和接收端统一声明对齐方式注意敏感数据可能会残留在填充数据中所以当存储或传输对象前有必要清理填充数据的值如相关依据参考常量成员函数不应返回数据成员的非常量指针或引用如果常量成员函数返回数据成员的非常量指针或引用既打破了常量限定又违反了封装理念属于不良实现方式本规则是的特化示例相关参考类成员应按的顺序声明类成员统一按的顺序声明有利于提高可读性示例供外部使用的成员应作为重点写在前面其次是成员成员应写在最后存在构造析构或虚函数的类不应采用关键字简单结构体应采用关键字具有封装或多态等特性的类应采用关键字以便提高可读性示例参考同类枚举项的值不应相同枚举项用于标记不同的事物名称不同但值相同的枚举项往往意味着错误示例例中三个枚举项应分别表示三种颜色但与的值相同会造成逻辑错误又如例中定义了三种水果而表示最喜欢的水果与其他枚举项不是同一层面的概念不应聚为一类应采用更结构化的方式参考合理初始化各枚举项合理初始化各枚举项只应从下列方式中选择一种全不初始化只初始化第一个全部初始化为不同的值示例应改为相关参考不应使用匿名枚举声明匿名枚举声明相当于在当前作用域定义常量但类型不够明确示例如果无法确定枚举类型的名称也意味着各枚举项不应聚为一类应改为参考用取代传统枚举没有有效的类型和作用域控制极易造成类型混淆和名称冲突在代码中建议改用示例传统枚举值与等类型可以随意转换如果和表示某种错误情况表示正确情况那么函数中对返回值的判断就是错误的这也是一种常见问题提出了的概念加强了类型检查提倡在新项目中尽量使用应改为依据参考联合体内禁用非基本类型的对象因为联合体成员之间共享内存地址所以成员具有构造或析构函数时会导致混乱禁止具有拷贝构造函数或析构函数的对象出现在联合体中解除了这条禁令但在语言层面上不保障正确性相当于把问题抛给了用户示例示例代码在某些环境中会崩溃原因是没能正确区分对象当前持有的类型执行了错误的构造或析构过程正确的做法是在类中用一个成员变量记录当前持有的类型再将匿名联合体与类的构造函数以及析构函数相关联从而根据当前持有的类型正确地初始化或销毁对象依据禁用在类之外定义的联合体联合体各成员共享存储地址易引发意料之外的错误如果一定要使用联合体需对其进行一定的封装避免对成员的错误访问不应出现在命名空间作用域内定义的联合体在类中定义的具有访问权限的联合体示例类的数据成员本来就违反了封装原则如果这种数据成员又处于联合体中会进一步增加风险相关参考禁用联合体联合体的问题主要有无法只通过对象获取当前有效的成员访问不同的成员相当于不安全的类型转换对非基本类型的成员造成构造和析构的混乱不能作为基类这些问题在本质上是对类型理念的破坏面向对象的程序设计应避免使用联合体示例例中对的访问也相当于一种没有任何限制的类型转换在代码中建议用或取代联合体可以有效记录对象当前持有的类型如果以不正确的类型访问对象会及时抛出异常本规则比更严格针对所有联合体相关参考遵循合理的命名方式应遵循易于读写并可准确表达代码意图的命名方式不应出现下列情况超长的名称易造成混淆或冲突的名称无意义或意义过于空泛的名称不易于读写的名称有违公序良俗的名称示例例中这种无意义或意义过于空泛的名称以及这种易与数字或其他单词混淆的名称均是不符合要求的转义名称只应出现在字符串中否则没有可读性名称中各单词间应有下划线或大小写变化否则不便于读写本规则集合示例中出现的等名称意在代指一般的代码元素仅作示例实际代码中不应出现不良命名方式甚至会导致标准未定义的行为如注意如果两个名称有相同的前缀而且相同前缀超过一定长度时是危险的有可能会导致编译器无法有效区分相关名称标准指明保证名称前位不同即可避免这种问题可参见的相关规定不建议采用相同长前缀不同短后缀的命名方式这种名称非常容易形成笔误或由复制粘贴造成错误如设是二元表达式类为左右子表达式这种命名方式应改进配置对象名称长度上限超过则报出函数名称长度上限超过则报出类型名称长度上限超过则报出连续无大小写变化的字符数量上限超过则报出依据参考不应定义具有保留意义的名称自定义的名称不应与标准库或编译环境中的名称相同否则会导致标准未定义的行为也不利于阅读和维护下列名称具有保留意义自定义名称不应与之相同标准库或编译环境中的宏名称标准库中具有外部链接性的对象或函数名称标准库中的类型名称自定义字面常量后缀应以下划线开头否则为保留名称除此之外以两个下划线开头的名称以一个下划线和一个大写字母开头的名称以下划线开头的全局名称均具有保留意义自定义名称应避免这种命名方式对于宏本规则特化为示例例中成员变量与标准库中的名称相同不便于区分是自定义的还是系统定义的又如例中函数名以一个下划线和一个大写字母开头自定义字面常量后缀未以下划线开头均不符合要求为避免冲突和误解以下命名方式可供参考除自定义字面常量后缀之外避免名称以下划线开头无命名空间限制的全局名称以模块名称开头从名称上体现作用域如全局对象名以开头成员对象名以开头或以结尾从名称上体现类别如宏名采用全大写字母类型名以大写字母开头函数或对象名以小写字母开头本规则集合对具体的命名方式暂不作量化要求但读者应具备相关意识相关依据参考局部名称不应被覆盖不应在嵌套的作用域中声明相同的名称否则干扰阅读极易引起误解示例在一个函数中出现了多个名为的变量当实际代码较为复杂时很容易出现意图与实现不符的问题参考成员名称不应被覆盖成员函数内的局部名称与成员名称相同会干扰阅读易引起误解示例建议成员对象遵循统一的命名约定如以结尾或以开头可有效规避这类问题参考全局名称不应被覆盖局部成员名称不应与全局或命名空间内的名称相同否则干扰阅读易引起误解示例建议全局对象遵循统一的命名约定如以开头且名称长度不宜过短可有效规避这类问题例外无成员函数的结构体或联合体成员可不受本规则限制参考类型名称不应重复定义如果类型相关的名称有重复极易引起误解不利于阅读和维护对于类联合体枚举类型的名称结构体联合体枚举类型的标签名称用或定义的类型别名均不应重复定义示例例外如果类型定义处于不同的命名空间可不受本规则约束参考类型名称不应与对象或函数名称相同不同的代码元素使用相同的名称不利于阅读和维护示例例中结构体名称与枚举项重名的意义是非常令人困惑的参考不应存在拼写错误代码中不应存在拼写错误尤其是供他人调用的代码如命名空间名称公共接口名称等更不应存在拼写错误拼写错误会使用户对代码的质量产生疑虑而且相关代码被大量引用后也不便于改正示例例中函数的名称有拼写错误应改为不应重复重复的或限定符是没意义的很可能意味着某种错误示例对于和重复限定其中一个很可能是为了限定号但形成了笔误应改为对于重复限定号其中一个很可能是为了限定应改为相关限定指针类型的别名是可疑的如果用限定指针类型的别名很可能会造成意料之外的错误示例例中是的别名很容易引起误解好像对象是不可被改变的但实际上的类型是限定的是指针而不是指针指向的对象对象仍可被修改其调用的函数也可能与预期不符应避免为指针类型定义别名否则应提供常量和非常量两种别名如注意如果用限定引用的别名则是错误的详见相关参考不可限定引用在语言中或可以限定指针但不可限定引用否则起不到任何作用示例限定号的和是无效的可被随意修改也可能被优化应去掉限定符或使限定符作用于类型名称注意如果限定符作用于引用类型的别名会引起很大误解如例中像是一个常量对象而像是常量对象的引用但展开后相当于不是常量也不是常量的引用依据限定类型时的位置应统一语言允许等关键字出现在类型名称的左侧也可以出现在其右侧甚至可以出现在基本类型名称的中间应对其位置进行统一规范以提高可读性可从下列方案中选择一种作为规范即统一要求出现在类型名称的左侧出现在类型名称的右侧出现在指针类型名称的右侧非指针类型名称的左侧示例例中的位置不统一是不符合要求的出现在类型名称右侧时和号一起易被误用如出现在类型名称左侧时如果类型为指针类型则易引起误解如可参见的进一步讨论如果约定出现左侧表示类型为对象类型右侧表示类型为指针类型有助于提高可读性审计工具不妨通过配置决定具体检查方案配置的位置方案对应说明中的号方案是否应写在的前面如果值为则应写在后面不设此项则不考虑相关顺序相关依据参考等关键字不应出现在基本类型名称的中间某些基本类型名称可由多个符号组成等关键字不应出现在类型名称的中间否则可读性较差本规则对下列或关键字有同样的要求即使对这些关键字的位置不作统一要求也不应使其出现在类型名称的中间否则很容易引起误解示例应改为相关依据参考指向常量字符串的指针应使用声明常量字符串与非常量字符串指针的隐式转换是不安全的一旦相关内存被修改会导致标准未定义的行为这种转换在标准中是过时的在代码中也不应出现指向常量字符串的指针应声明为为常量字符串中的字符类型如示例例中非常量指针指向常量字符串通过修改常量数据一般会引发段错误而导致崩溃应改为改为常量字符串指针后错误的操作无法通过编译又如应将的参数类型改为或将常量字符串复制后传给函数相关依据参考枚举类型的底层类型不应为或将或的底层类型设为或是没有意义的会被编译器忽略属于语言运用错误示例应改为依据对常量的定义不应为引用虽然语言十分灵活可以通过多种方式达到同一种目的但应该选择最简洁且通俗易懂的方式实现示例应改为禁用指针语言中的指针要求其他指针不能再指向相同区域有助于编译器优化但不符合这种限制时会导致标准未定义的行为相当于增加了误用风险也增加了测试成本示例指针虽然有助于编译器优化但应在效率的提高和存在的风险之间进行取舍非系统库中的代码改动频繁的代码不建议使用指针而且这种优化大部分情况下也难以真正解决效率的瓶颈问题依据参考非适当场景禁用应在适当的场景中合理使用否则会导致优化或同步相关的多种问题下列场景可使用对象读写对应外设与信号等中断处理过程共享对象局部对象在之间被修改出于安全目的清理内存中的数据在之外通过与编译优化不兼容的方式访问对象在这些场景中如果相关对象没有用限定会导致程序和预期不符关键字可以保证对象具有稳定的内存地址任何读取或写入都可以来源于或作用于内存中的实际数据除此之外不应使用不参与过程间跳转的局部对象往往意味着的滥用审计工具不妨重点关注这种对象而且要注意和的并发或同步机制没有直接关系也无法保证相关操作的原子性示例例中是不涉及外设的共享对象是线程函数是某种锁在已落实同步机制的情况下不应再使用依据参考相关对象未被修改时应使用声明用显式区分数据是只读的还是可写的细化数据的访问方式可显著提高可读性并保护数据不被错误修改有助于编译器优化下列情况应使用声明不需要被修改的非参数对象应声明为常量对象通过指针或引用访问对象但不修改对象时应声明为常量指针或引用成员函数访问非静态成员对象但不修改相关对象时应声明为常量成员函数示例例中未被修改应作为常量拷贝构造函数的参数未被修改应声明为常量引用成员函数未修改成员对象应声明为常量成员函数相关参考合理使用关键字关键字隐藏了类型名称在使用时需注意不应降低可读性非局部对象不宜用声明如接口的返回类型参数全局对象等如果局部对象的类型对程序的行为有显著影响也不宜用声明示例如果想确定对象的类型必须通读所有与之相关的代码可读性很差将代码中所有可以替换成的标识符全部替换成其结果是不可想象的与等语言不同语言存在重载模板等多种严格依赖于类型的特性如果类型名称不明确必然会造成阅读和维护等方面的障碍下面给出关键字的合理用法重复的类型名称使代码变得繁琐这种情况使用是更好的方法又如函数返回迭代器是一种常识且迭代器类型名称往往较长这种情况应使用又如重复的类作用域声明十分繁琐可用关键字配合后置返回类型改善总之使用关键字的目的应是提高可读性而不是单纯地简化代码相关参考不应使用已过时的关键字在标准中关键字已过时关键字也不可再作为存储类说明符本规则对代码适用代码可不受限制示例依据不应使用多余的关键字由关键字限定的函数已经相当于被声明为不应再重复声明示例应改为另外在类声明中实现的函数也相当于被声明为不应重复声明依据关键字不应作用于类成员的声明或定义关键字作用于类成员的声明或定义是没有意义的属于语言运用错误示例依据重写的虚函数应声明为或将重写的虚函数都声明为或有利于提高可读性并可确保虚函数被有效重写示例例中重写的和这两个虚函数如果不看的声明则看不出是虚函数也看不出是重写的虚函数改为如下方式会清晰很多而且当重写的函数名参数返回类型与基类声明不符时不能通过编译可及时修正问题依据参考和关键字不应同时出现在声明中表示不可重写的重写表示可再次重写的重写这两个关键字不应同时出现在声明中示例参考或关键字不应与关键字同时出现在声明中只应在定义新的虚函数时使用关键字重写虚函数应使用或关键字不应再出现关键字示例去掉多余的关键字使代码更简洁参考不应将设为在语言中不可作为基类将声明为是没有意义的属于语言运用错误示例依据未访问指针的成员函数应使用声明如果未访问指针的成员函数没有被设计为静态成员函数很可能意味着错误或功能不完整示例例中函数只访问了静态数据成员但在调用时仍会将指针作为参数这在逻辑上是矛盾的所以应使用关键字明确声明参考声明和定义内部链接的对象和函数时均应使用关键字声明和定义内部链接的对象和函数时均应使用关键字不可使用关键字否则极易引起误解示例例中是内部链接的静态对象在定义的前后不可再用声明否则极易与全域对象混淆又如在声明和定义内部链接的函数时均应使用关键字否则也易引起误解参考等关键字的位置应统一语言允许等关键字出现在类型名称的左侧也可以出现在其右侧甚至可以出现在基本类型名称的中间应对其位置进行统一规范以提高可读性本规则对下列或关键字有同样的要求这些关键字应统一出现在声明的起始类型名称的左侧对于和也需面对类似的问题参见示例例中各种声明均有一定的特殊性如果声明其特殊性的关键字在类型名称之后不便于阅读甚至会引起误解应改为相关依据用声明指针或引用时应显式标明等符号用声明指针时显式标明号有利于提高可读性否则会使人误以为是某种非指针的对象在声明引用时必须显式标明或号否则成为对象声明导致逻辑错误或造成不必要的复制开销示例例中为指针但看起来像是个对象返回引用但并不是引用是容器元素的复本这些问题可能与预期不符需谨慎对待依据禁用可变参数列表可变参数列表对参数的类型和数量缺乏有效的限定和控制是公认的不安全因素示例假设函数与函数功能相似由参数设定格式将其他参数转为字符串后依次替换中的占位符并返回结果设和为占位符分别对应字符串和整数如调用则返回字符串如果用可变参数列表实现例中是可变参数列表的标准支持这种方法只能在运行时以为依据获取后续参数当实际参数与不符时会造成严重问题单纯地要求开发者小心谨慎是不可靠的改用更安全的方法才是明智的选择在代码中可采用模板参数包来实现这种功能示例代码用函数递归地将参数都转为对象存入容器再将中的和依次替换成容器中的字符串实际上这种实现是可以不区分和的这个过程中参数的个数和类型是可以由代码主动判断的如果参数不能转为字符串则不会通过编译如果参数个数与占位符不符也容易作出处理模板参数包等特性是语言在编译理论上的重大突破合理运用这些特性可以有效提升代码的安全性和可维护性相关依据参考禁用柔性数组柔性数组一般是指结构体最后不完整定义的数组成员表示不占用空间的指针这种数组在中有所定义但不在标准之中在代码中不应使用示例例中这种拷贝赋值运算会漏掉数组的内容而且数组不会计入的结果易引起意料之外的错误所以在代码中也不建议使用柔性数组依据参考接口的参数类型和返回类型不应为与接口相关的数据类型应保持精确不应将参数类型或返回类型设为在代码中如果参数或返回值需要面对多种不同类型的数据应合理使用重载或模板机制示例例中和函数的返回值以及参数是不符合要求的语言中存在大量的库函数不符合本规则要求在代码中应避免使用如例中函数的第一个形式参数就是型只能通过更底层的二进制方式访问对象序列是一种对类型设计的破坏应改用标准库提供的方法改用类型明确的方法可以使很多问题在编译期得到控制例外语言规定运算符的返回类型为运算符的参数类型为这些情况可不受本规则约束相关参考类成员的类型不应为与接口相关的数据类型应保持精确不应将成员类型设为尤其是非成员的类型更不应设为在代码中如果成员需要面对多种不同类型的数据应合理使用模板机制示例应改为相关参考数组大小应被显式声明显式声明数组大小有利于提高可读性示例由初始化列表定义数组大小是一种惯用方式但列表较为复杂时不便于读出数组大小如审计工具不妨通过配置决定这种方式是否合规例外数组参数可不受本规则限制配置是否放过带有初始化列表的数组参考不应将类型定义和对象声明写在一个语句中将类型定义和对象声明写在一个语句中可读性较差应分开书写示例应改为参考不应将不同类别的声明写在一个语句中将对象指针引用数组函数等不同类别的声明写入一个语句可读性较差易引起误解本规则是的特化示例混在一起的声明易引起误解例中和是不同的类型只有被初始化为函数应分开声明相关参考不应产生无效的临时对象无名且不受控制的临时对象在构造之后会立即析构在逻辑上没有意义往往意味着错误示例示例代码意在调用重载的构造函数但只生成了一个无效的临时对象成员并没有被正确初始化应改用等形式在遵循标准的代码中也可将移入初始化列表又如设是某种锁只生成了一个临时对象该对象会立即析构起不到作用这也是一种常见的错误应改为参考不应存在没有被用到的局部声明没有被用到的局部声明是没有意义的往往意味着代码冗余或功能不完整也可能导致严重的逻辑错误示例在作用域中声明的对象没有被使用与其相关的计算过程是无效的应改为具有特定构造或析构函数的对象可以做到声明即使用但要注意如下情况例中意在实现某种锁但声明的是函数而不是对象构造和析构函数不会按预期执行这也是一种常见笔误应改为参考对象初始化不可依赖自身的值对象初始化依赖自身的值属于逻辑错误也是常见的笔误示例例中局部变量的初始化依赖自身的值这种问题往往是错误地定义了与外层作用域中名称相同的对象应改为参与数值运算的对象应显式声明或类型是否有符号由实现定义为了提高可移植性并规避意料之外的错误参与数值运算的对象应显式声明符号属性示例例中函数的型参数只与字符有关可不必声明符号属性而函数的参数被当作整数参与了数值运算应显式声明为否则在为无符号整型的环境中会得到错误的结果应改为依据参考字节的类型应为或字节等二进制概念不应受对齐方式或符号位的干扰字节的类型应为或是的标准字节类型对字节相关的运算和操作提供了更安全的限定在代码或不便于遵循新标准的代码中应将字节类型声明为示例类型的符号由实现定义有符号的变量在数值计算位运算等方面很容易产生意料之外的结果应改为这样做也可有效区分二进制数据与字符串提高可读性相关依据函数原型声明中的参数应具有合理的名称参数的名称是其用途的直接说明合理的名称可显著提高可读性示例这是标准库函数的原型声明利用形象的比喻表示在中查找如果将声明改为如下形式就令人费解了例中无名称或名称无实际意义的参数是不符合要求的参考不应将数组作为函数的形式参数数组作为形式参数时其大小声明起不到实际的限制作用示例建议在代码中采用数组引用或模板的方式例外用空的方括号声明数组并用另一个参数表示数组大小的情况可不受本规则限制依据参考的声明应符合要求可变参数列表中省略号的前一个参数称为如果在代码中为数组函数或具有寄存器存储期以及与默认参数提升后不兼容的类型在代码中为引用数组函数或具有与默认参数提升后不兼容的类型会导致标准未定义的行为示例例中参数为型与默认参数提升后的类型不兼容参数为引用参数被限定具有寄存器存储期这种代码均会导致标准未定义的行为相关依据参考虚函数参数的默认值应与基类中声明的一致虚函数参数的默认值不受多态规则控制通过基类指针或引用调用派生类重写的虚函数时默认值仍采用基类中的定义示例输出这种虚函数的非多态行为是非常令人困惑的相关依据参考不建议虚函数的参数有默认值虚函数参数的默认值不受多态规则控制通过基类指针或引用调用派生类重写的虚函数时默认值仍采用基类中的定义易造成混淆故不建议虚函数的参数有默认值示例应尽量去掉默认参数值或改用重载函数的方式相关依据参考代码中参数列表如果为空应声明为在语言中如果函数的参数列表声明为空括号表示函数的参数还没有声明而不是表示没有参数这很容易使人误解所以在代码中没有参数的参数列表应声明为示例例中和两种调用都可以通过编译然而声明与实现不一致的问题总是令人困惑的如果明确将参数声明为或则可以解决这种问题应改为或者相关依据参考代码中参数列表如果为空不应声明为与语言不同在语言中空括号和均表示没有参数所以应采用更简洁的方式示例相关依据参考声明数组参数的大小时禁用关键字语言规定数组作为形式参数时可用关键字限定大小要求传入数组的大小不能小于由关键字限定的值有助于编译器优化但不符合这种限制时会导致标准未定义的行为相当于增加了误用风险也增加了测试成本示例这种机制虽然有助于编译器优化但应在效率的提高和存在的风险之间进行取舍非系统库中的代码改动频繁的代码不建议使用这种机制而且这种优化大部分情况下也难以真正解决效率的瓶颈问题依据参考派生类不应重新定义与基类相同的非虚函数派生类不应重新定义与基类相同的非虚函数否则与多态机制相矛盾易造成意料之外的问题示例如果将类型的指针传入函数将执行然而参数实际指向的是类型的对象但不会被执行这就形成了逻辑上的矛盾极易造成意料之外的问题参考重载运算符的返回类型应与内置运算符相符为了便于调用者使用并满足泛型编程的要求重载运算符的返回类型应与内置运算符相符比较和逻辑运算符应返回型对象算术和位运算符应返回相关类的对象符号运算符应返回相关类的对象后置运算符应返回相关类的对象前置运算符应返回相关类的引用下标运算符应返回相关类的引用赋值及复合赋值运算符应返回相关类的引用示例例中重载的比较运算符返回型对象而内置比较运算符的结果为型重载运算符的行为和内置运算符不一致会导致意料之外的错误相关对象也可能无法被通用泛型算法接受应改为相关赋值运算符应返回所属类的非左值引用赋值运算符应返回所属类不受关键字限定的左值引用以便调用者使用并满足泛型编程的要求重载赋值运算符的行为应与内置赋值运算符一致使类对象的赋值表达式可以灵活地作为各种语句的子表达式这也是泛型程序设计的必要条件使同一套代码既可以适应普通变量也可以适应类对象本规则是的特化对复合赋值运算符也有相同的要求示例应改为相关依据参考拷贝构造函数的参数应为同类对象的左值引用如果构造函数的参数不是同类对象的左值引用则不构成拷贝构造函数拷贝构造函数不应具备复制之外的功能故其参数不应被修改应受关键字限制拷贝构造函数可能会被优化而导致复制之外的功能不生效可参见的进一步讨论示例拷贝构造函数不可按值传递参数否则会再次调用拷贝构造函数从而陷入无限递归应改为相关拷贝赋值运算符的参数应为同类对象的左值引用拷贝赋值运算符应专注于复制参数的数据且参数不应按值传递否则会产生不必要的复制开销以及对象切片等问题示例应改为相关依据参考移动构造函数的参数应为同类对象的非右值引用移动构造意在将参数的数据转移到当前对象中故参数应为右值引用且不应受关键字限制示例相关移动赋值运算符的参数应为同类对象的非右值引用移动赋值意在将参数的数据转移到当前对象中故参数应为右值引用且不应受关键字限制示例例中赋值运算符先释放持有的资源再复制的资源不是真正的移动赋值仍是一种低效实现应将与交换省去复制过程并使原有资源由的析构函数释放才是真正意义上的移动赋值依据参考不应重载取地址运算符取地址运算符一元运算符重载之后可以返回任意地址极易误用获取不完整类型的对象地址时如果其完整类型重载了取地址运算符会导致标准未定义的行为示例例中会导致未定义的行为可能会返回对象的实际地址而会调用重载了的取地址运算符这是一种混乱的局面依据参考不应重载逗号运算符逗号表达式意在从左至右依次执行各子表达式但重载逗号运算符会打破这一规则易造成意料之外的结果示例例中逗号运算符被重载后变成了一个函数和变成了函数参数函数参数的求值顺序在标准中是未声明的很有可能会先被求值则失去了意义另外也不应重载逻辑运算符参见相关依据参考不应重载逻辑与和逻辑或运算符对逻辑与逻辑或等运算符的重载会影响效率甚至造成不符合预期的结果标准明确规定了内置逗号逻辑与逻辑或等运算符的子表达式求值顺序对于逻辑表达式从左到右计算子表达式的值当可以确定整个表达式的值时立即结束计算如果还有其他子表达式未求值也不再计算了这种规则称为短路规则意在提高效率然而运算符的重载却打破了这一规则示例注意表达式设和为类对象按常理此表达式的意思应该是如果在某种意义上有效就将赋给所以的值应先被求出但由于被重载成了一个函数其左右子表达式成了函数的参数短路规则不再有效而且参数的求值顺序在标准中是未声明的所以常规逻辑子表达式的求值顺序无法得到保证目前等主流编译器默认都是从右到左计算参数的值例中会先被执行造成完全不符合预期的结果解决方法去掉对的重载在中定义类型转换运算符既可保证短路规则又可保证求值顺序相关依据参考拷贝和移动赋值运算符不应为虚函数拷贝和移动赋值运算符的参数应分别为所属类的左值和右值引用这类运算符即使是虚函数也不便于被重写示例相关依据参考比较运算符不应为虚函数重载的比较运算符很难正确触发的多态机制将其设为虚函数很可能引发意料之外的错误运算符均受本规则限制示例参考类中不应声明虚函数类不再产生派生类其中的虚函数也不会再被重写故不应声明虚函数示例依据对位域声明合理的类型为了提高可移植性和可维护性应对位域声明合理的类型如显式声明或的整数类型语言的或语言的类型各种实现中取值范围均一致的整数类型标准只允许或作为位域类型在之后的标准以及之前的标准中用于位域的或等整数类型是否有符号由实现定义为了避免意料之外的符号扩展溢出等问题建议统一使用无符号整型作为位域类型示例是否有符号由实现定义位域的取值范围可能是也可能是故应明确声明位域的符号属性又如例中结构体只涉及个比特位但由于的取值范围是由实现定义的结构体的内存布局在不同的平台上会有较大差异可能会产生意料之外的填充数据造成对接口或协议的解析错误应改为配置位域类型是否必须为无符号整型位域类型是否必须为或中定义的类型依据参考位域长度不应超过类型长度位域长度超过类型长度易误导维护者而且也可能是笔误标准不允许位域长度超过类型长度但标准允许超过的部分作为不参与数据的存储示例例中的位域长度超过了类型长度但有效位域长度仍为有效位域和声明位域不一致易误导维护者造成截断或溢出等错误如果是为了特殊的对齐可改用成员占位的方式成员特殊的名称表明它是用于占位的特殊成员这种方式比位域更有利于维护依据有符号整型对象的位域长度不应为有符号整型对象的位域长度如果为表示只有一个比特位而该比特位是符号位极易造成意料之外的错误匿名成员的位域长度不受本规则限制示例输出和为与预期相符预期是但实际是参考不应对枚举对象声明位域枚举类型是否有符号由实现定义而且符号位与位域结合易导致意料之外的错误示例可能输出例中枚举项的取值范围是位域长度为即可满足这个范围但如果位域有符号位会导致意料之外的问题如用对赋值但的结果却是因为的值为而的值为例外在遵循及之后标准的代码中如果显式指定了枚举类型的的底层类型可不受本规则限制相关依据参考禁用位域位域改变了类型约定俗成的取值范围和存储方式易造成理解上的偏差增加维护成本在不受特定协议限制的代码中不应使用位域位域与引用等概念有冲突而且标准在位域的内存布局等方面定义的不够充分存在很多由实现定义的内容要特别注意的是多线程访问位域还会造成数据竞争参见示例相关依据不应采用复杂的声明复杂的声明可读性较差容易造成理解上的偏差对于函数指针的数组返回函数指针数组指针的函数以函数指针数组指针为参数的函数应先将各子类型取别名再用简单声明的方式书写示例例中声明的是两个函数但看起来像是函数指针而且参数列表也显得混乱应改为声明中不应包含过多的指针嵌套指针嵌套层级过多意味着指针的解引用逻辑过于复杂相关代码将难以理解指针嵌套不宜超过级示例例中为任意类型如果发现这种指针意味着需要改进对相关数据的访问方式出于灵活性的考虑非连续的指针嵌套可不受本规则约束如例中是指向数组的指针数组元素为级指针是函数指针函数返回级指针这种情况是可接受的配置指针嵌套的最大层数超过则报出相关参考在一个语句中不应声明多个对象或函数在一个语句中声明多个对象或函数不利于阅读和维护建议在一个语句中只声明一个对象或函数函数数组以及相关指针引用的声明相对复杂不应和其他声明混在一起为了便于查阅对于类及结构体成员全局对象具有外部链接性或静态存储期的对象也不应将多项声明混在一个语句中对于简单的局部对象声明可适当放宽要求但仍以一个语句一项声明为宜不应将指针引用数组函数等不同类别的声明混在一个语句中对此本规则特化为示例例中一个语句声明多个函数成员或全局对象是不符合要求的又如对于局部对象审计工具不妨统计声明项及其初始化表达式的字符个数如果超过指定限制则判其应在单独的语句中声明配置局部作用域中一个语句能声明的对象个数上限超过则报出类或结构体中一个语句能声明的对象个数上限超过则报出全局及命名空间作用域中一个语句能声明的对象个数上限超过则报出声明字符数量阈值超过此值则判其应在单独的语句中声明相关参考遵循即任何翻译单元不得包含对象函数类型或模板的多个定义否则会导致标准未定义的行为示例例中类型在两个翻译单元中有不同的定义违反了易造成难以排查的错误应在头文件中统一定义类型依据参考声明与实现应一致声明与实现在书写上应完全一致否则极易引起误解而且对同一对象或函数进行类型不兼容的声明也会导致标准未定义的行为示例例中变量有多处声明但类型不一致会导致标准未定义的行为又如例中在实现处为参数类型定义别名是不符合要求的在允许重载的代码中会引起更大的误解应改为相关依据参考在合理的位置声明如果声明的位置不合理会降低代码的可维护性甚至会导致标准未定义的行为应遵循如下原则外部链接的对象或函数应在头文件中声明并避免重复声明内部链接的对象或函数应在源文件中声明不应在头文件中声明避免在头文件外手工书写外部声明避免在局部作用域内声明函数或全局对象示例外部链接的对象或函数应通过头文件引入如果分散在函数中声明是不便于统一管理和维护的另外在局部作用域中使用除之外的存储类说明符声明函数会导致标准未定义的行为相关依据参考不应存在没有被用到的标签没有被用到的标签意味着语句的缺失也可能是残留代码应当去除示例标签只应与语句对应不可有其他用途如例中标签被当作注释这是一种怪异的用法也可能会干扰编译器的优化参考不应存在没有被用到的静态声明没有被用到的静态声明往往是没有意义的应删除或修正引用关系类的静态成员可不受本规则限制示例相关参考不应存在没有被用到的成员没有被用到的成员是没有意义的应删除或修正引用关系示例相关参考不应省略声明对象或函数的类型允许省略对象或函数的类型声明但实践表明这并不是一种良好的编程方式可读性较差本规则仅针对语言语言不存在这种问题示例例中的类型被省略默认为应改为参考用中的类型代替等类型等类型的取值范围由执行环境的架构决定可移植性较差示例例中成员变量在不同的平台会有不同的取值范围引入解决了这一问题应改为另外等基本类型均有此问题在有高可移植性要求的代码中应避免直接使用基本类型依据参考避免使用已过时的标准库组件已过时的标准库组件会被语言标准弃用应改用更完善的替代方法下列标准库组件已过时类型类型和函数类型类型的成员类型和函数类型和函数函数类型类型类型和函数示例对象的赋值或传参都会引起资源所有权的转移如会使的资源被转移到中会使的资源转移到参数中这种方式很容易使人误解故被标准判为已过时并从标准中移出可使用代替禁止资源所有权隐式转移语义更为明确相关依据保证异常安全当产生异常时保证相关资源不会泄漏相关对象处于正确状态是异常机制可以正确工作的重要基础示例设是某种获取资源的操作是释放资源的操作是可能抛出异常的过程那么函数就不是异常安全的一旦有异常抛出会导致死锁或泄露等问题应保证资源从分配到回收的过程不被异常中断采用对象化管理方法使分配和回收得以自动完成将和分别由的构造和析构函数完成即使抛出异常相关资源也可被自动回收实现了异常安全资源的对象化管理方法可参见异常安全的另一个重要方面是抛出异常时应保证相关对象的状态是正确的事务或算法在处理对象时可能要分多个步骤处理对象的多个成员要注意中途抛出异常会造成数据不一致等问题设和是两个密切相关的成员如账号和金额等是一个处理事务的函数如果在中途抛出异常就会使对象处于错误的状态解决方法可以考虑复制交换模式如事务先处理对象的副本处理成功后交换副本与对象的数据交换过程需要保证不抛出异常这样从对象副本的生成到事务处理完毕的过程中即使抛出异常也不影响对象的状态过程不可抛出异常也是一个规则参见相关参考处理所有异常如果被抛出的异常没有被相应的子句处理会引发函数的执行使程序异常终止应避免函数被执行函数执行前相关调用栈中的对象是否会被析构由实现定义函数会调用由指定的回调函数在默认情况下会执行函数终止进程但打开的流是否会被关闭缓冲区内的数据是否会写入文件临时文件是否会被清理等问题仍由实现定义示例相关依据参考不应抛出过于宽泛的异常抛出过于宽泛的异常如等类型的异常会使异常处理失去针对性而且处理这种异常时很可能会将本不应处理的异常一并捕获示例函数在参数不符合要求时抛出类的异常过于宽泛如果函数抛出从派生的其他异常也会被当作参数不符合要求处理应为异常定义具体的类相关参考不应捕获过于宽泛的异常捕获过于宽泛的异常如捕获等类型的异常或使用子句捕获所有异常会使异常处理失去针对性而且很可能会将本不应处理的异常一并捕获示例例中函数在参数不符合要求时抛出异常函数会抛出其他异常用子句将所有异常都当作参数不符合要求是不合理的例外当不受控制的外部代码会抛出未知的异常时可酌情捕获宽泛类型的异常但应配以文档说明问题相关参考不应抛出非异常类型的对象不应将整数字符串等非异常类的对象当作异常抛出否则意味着异常相关的设计是不健全的完善的异常类型应满足如下需求可以将异常合理分类提供对异常情况的准确描述使异常便于处理和调试非异常类型难以满足这种需求示例整数或字符串无法区分异常的种类如果不同的功能模块均将简单变量作为异常很容易产生冲突如果条件允许应选择适当的标准异常类作为基类并实现相关接口这样可使异常类形成继承体系便于分类管理另外要注意等关键字应专注于异常处理不应使用这些关键字控制程序的业务流程业务代码与异常处理代码应有明显区别否则会使代码含混不明效率也会降低如例中函数抛出字符串在容器中的位置用异常机制实现与异常无关的功能是不符合要求的配置是否要求异常类必须派生自相关参考不应捕获非异常类型的对象整数字符串等非异常类的对象不应被当作异常捕获否则意味着异常相关的设计是不健全的可参见的进一步讨论示例相关参考全局对象的初始化过程不可抛出异常在全局对象初始化过程中抛出的异常没有被处理的机会导致程序异常终止本规则是的特化示例如果例中全局对象的构造函数抛出异常会引发函数的执行使程序异常终止应改为相关依据参考析构函数不可抛出异常析构函数抛出异常会违反异常处理机制当抛出异常时从异常被抛出到异常被处理之间的对象也就是从到各层调用栈中的对象会被自动析构如果这个过程中某个对象的析构函数又抛出异常便违反了异常处理机制这种情况将直接引发函数的执行所以从析构函数抛出的异常可能无法被捕获和处理也可能导致程序异常终止示例设和是不相关的异常类建议将析构函数声明为与析构相关的过程也不应抛出异常资源回收运算符具有等语义的函数另外具有等语义以及移动构造或赋值相关的过程也不应抛出异常详见相关规则相关依据参考内存回收函数不可抛出异常内存回收函数抛出异常会导致标准未定义的行为示例相关依据参考对象交换过程不可抛出异常两个对象在交换过程中每个对象的状态都是不完整的如果在交换中途抛出异常对象将处于错误的状态注意交换是保证异常安全的重要手段不抛出异常是基本要求详见标准库中存在大量与交换相关的接口和算法如果抛出异常也会使标准库无法按约定工作所有交换相关的函数均应标记为示例相关参考移动构造函数和移动赋值运算符不可抛出异常在移动过程中对象的状态是不完整的如果在中途抛出异常对象将处于错误的状态示例例中函数会抛出异常意味着移动构造函数和移动赋值运算符也会抛出异常是不符合要求的相关参考异常类的拷贝构造函数不可抛出异常异常类的拷贝构造函数抛出异常违反异常处理机制导致程序异常终止当抛出异常时表达式指定的异常对象会被复制用以初始化对应的子句的参数如果在复制过程中又抛出异常便违反了异常处理机制这种情况将直接引发函数的执行使程序异常终止示例例中子句的参数引用由复制而成的临时对象在复制过程中抛出的异常无法被捕获会直接导致程序异常终止相关依据参考异常类的构造函数和异常信息相关的函数不应抛出异常创建复制异常对象以及获取异常信息时不应再抛出异常否则不利于异常的定位与处理示例例中在异常类的构造函数和函数中抛出异常是不符合要求的而且要注意的构造及拷贝构造函数需要动态内存分配当分配失败时也会抛出异常有高可靠性要求的软件系统需要规避自定义的异常类可从标准异常类派生成员也应尽量简单如其中是标准异常类在实际代码中也可以选择等其他标准异常类作为基类相关依据参考与标准库相关的过程不应抛出异常对象的过程中不应抛出异常否则相关的容器和算法无法正常工作示例标准库规定容器的等方法应通过返回值表示对象存在与否然而如果过程抛出异常这些方法也会抛出异常相当于打破了这种约定易造成意料之外的结果参考由标记的函数不可产生未处理的异常由标记的函数产生未被处理的异常属于逻辑错误会引发函数的执行使程序异常终止程序异常终止所产生的问题可参见的进一步讨论示例应处理相关异常或修正异常说明相关依据参考避免异常类多重继承自同一非虚基类当异常类有多个基类这些基类又派生自同一非虚基类时无法通过该非虚基类捕获异常本规则是的特化示例例中基类在派生类中会有多个实例在这种情况下无法通过基类捕获派生类的对象应将设为虚基类相关依据通过引用捕获异常通过值捕获异常可能会导致对象切片通过指针捕获异常会增加内存管理成本通过引用捕获异常才是最合理的方式示例例中是异常类用传值的方式捕获异常是不符合要求的应改为通过指针捕获异常也是不符合要求的参见相关参考捕获异常时不应产生对象切片问题通过值捕获多态类的异常对象会使其多态性失效使异常被错误处理本规则是与的特化示例例中抛出的是派生类对象但函数只能返回相关参考捕获异常后不应直接再次抛出异常捕获异常后将其直接再次抛出是没有意义的还会造成不必要的开销示例例中的子句是没有意义的应将其去掉或对异常进行有效处理重新抛出异常时应使用空表达式重新抛出异常时应使用空表达式避免异常对象的精度损失和不必要的复制开销示例注意例中函数虽然捕获的是对象但抛出的是对象这也是一种对象切片问题造成了对象类型的精度损失将改为可解决这种问题依据不应在子句外使用空表达式空表达式用于重新抛出当前捕获的异常用在子句外是危险的增大了流程控制的复杂性如果当前没有异常被捕获空表达式会引发函数的执行导致程序异常终止示例依据参考不应抛出指针抛出指针会增加不必要的内存管理成本也容易造成意料之外的错误示例例中对捕获的异常指针不论释放还是不释放都有问题改为抛出对象的方式可有效避免这种问题参考不应抛出虽然表示空指针但在相当一部分实现中相当于无法区分指针与整数示例例中意在抛出空指针然而会被子句捕获相关依据参考不应抛出可被所有接受指针的子句捕获使异常处理失去针对性示例相关参考不应在模块之间传播异常异常的传播机制依赖编译器的具体实现在不同编译器产生的模块间传播异常会造成运行时错误除非模块均由同一编译器的同一版本生成否则模块供外部使用的接口不应抛出异常示例设例中和由不同的编译器生成异常的抛出机制和捕获机制可能并不匹配进而导致冲突相关参考禁用动态异常说明用关键字声明的动态异常说明已过时应使用关键字完成异常说明动态异常说明将所有可能抛出的异常详细列出尤其是牵扯到外部不可控代码时会大幅增加异常管理成本而且各编译器相关实现并未统一现已从标准中移出示例应改为例外与等价保留了但不建议继续使用审计工具不妨通过配置决定是否放过这种方式配置是否放过空异常说明依据参考禁用异常本规则适用如下场景可酌情选取对时空性能有严格要求的项目代码所属框架不支持异常处理与或其他语言兼容的接口实现项目没有依照异常安全的理念实施利用返回值或错误码的错误处理方式要求检查可能产生错误的每一个步骤有些出错情况可能被遗漏的异常机制可大幅简化这种繁琐的方式使代码更专注于事务或算法的实现而且异常是不可被忽略的然而的异常机制是需要一定开销的对代码的设计与实现也有更严格的要求如果异常情况频繁出现其成本是不可被忽视的不适用于具有高性能要求的实时软件系统如果代码所属项目没有依照异常安全的理念实施使用异常反而会造成更多问题可参见的进一步讨论相关参考函数的返回类型只应为函数的返回值可作为整个进程执行情况的总结按惯例返回或表示执行成功非或表示执行失败函数的返回值会作为标准函数的参数应采用标准明确支持的方式如果将返回值设为或其他非类型会导致未定义未声明或由实现定义的行为依据参考函数不应被调用重载或被等关键字限定函数作为程序的入口是一种特殊的函数其链接性由实现定义不应被调用重载或被任何函数限定符修饰示例依据在头文件中不应实现函数或定义对象头文件中的函数或对象会被引入不同的翻译单元造成编译冲突常量对象和内联模板函数可不受本规则约束静态对象和静态函数也不受本规则约束但受规则限制头文件是项目文档的重要组成部分有必要保持头文件简洁清晰头文件的主要内容应是类型或接口的声明除非函数很简短否则不建议在头文件中内联实现大段的函数实现会影响头文件的可读性示例对于较为复杂的模板函数应将其实现与声明分离如将模板函数的实现移入文件中再由主头文件包含即可文件称为模板实现文件参考函数的参数名称在声明处和实现处应保持一致参数名称在声明处和实现处不一致会误导函数的使用者而且很可能是实现错误示例例中参数和在声明处和实现处的顺序是颠倒的令人非常困惑相关参考多态类的对象作为参数时不应采用值传递的方式将派生类对象通过传值的方式转换为基类对象后不再遵循多态机制易产生意料之外的错误应采用指针或引用的方式传递多态类对象示例相关参考不应存在未被使用的具名形式参数如果函数的某个参数在函数内没有被用到意味着函数的功能与设计之间存在差距如果某个参数确实不需要被用到应尽量从参数列表中将其删除如果需要遵循某种约定而必须保留参数如虚函数或回调函数在代码中不妨将参数的名称删掉在代码中可用转换指明未使用的参数在预期之内并用注释说明参数未被使用的原因示例应改为参考非基本类型的常量参数不应按值传递常量参数不可被改变按值传递产生的复制开销是没有意义的应使用常量引用传递参数基本类型的参数复制开销可被忽略故不受本规则限制示例例中为按值传递的常量参数每当函数被调用时传入的参数会被复制成一个新的对象但其值又不能被改变所以这种复制是没有意义的利用常量引用可解决这个问题改为常量引用后不会产生额外的复制开销参考转发引用只应作为的参数不应混淆转发引用与右值引用除作为的参数之外不应对转发引用再有任何操作转发引用是类型为的参数为函数模板类型无论左值还是右值均可被这种参数接受而且等属性也会被忽略由于含有不确定的状态所以直接操作转发引用是不妥的只应通过交由合适的接口处理示例例中和为转发引用及相关参数包不经的转换直接作为接口的参数无法正确选择重载的接口应改为相关依据参考局部对象在使用前应被初始化未初始化的局部对象具有不确定的值读取未初始化的对象会导致标准未定义的行为示例例中局部对象的初始化依赖某种条件在条件范围之外读取的值会得到不确定的结果建议对象在声明处初始化即使不方便在声明处初始化也应该在声明的附近进行无条件初始化不建议的模式例中的初始化依赖条件并在满足条件时被使用即使条件和条件有一定相关性可以保证对的使用是正确的也会造成潜在的维护困难当条件比较复杂或有变化时极易出错相关依据参考成员须在声明处或构造时初始化成员的声明和使用相距较远更容易造成未初始化先使用的问题所以应在声明处或构造函数中初始化所有成员示例例中构造函数没有对初始化是不符合要求的尤其是成员出现这种问题时会造成更大的风险建议所有成员都在声明处初始化参考基类对象构造完毕之前不可调用成员函数基类对象未构造完毕时调用成员函数会导致标准未定义的行为示例例中成员函数的返回值作为基类构造函数的参数而这时基类对象尚未构造相当于成员函数的调用者没有被初始化这是一种逻辑错误依据在面向构造或析构函数体的子句中不可访问非静态成员当流程进入面向构造或析构函数体的子句时非静态成员的生命周期已结束如果继续访问会导致标准未定义的行为示例例中子句均面向函数体从属于函数块当流程进入子句时成员的生命周期已结束不应被访问应调整实现或将语句移入函数内依据参考成员初始化应遵循声明的顺序类成员的初始化顺序是按声明的顺序进行的初始化前面的成员时不可使用后面成员的值示例虽然在初始化列表中在的前面但先于声明仍然在之后被初始化会造成严重错误应改为调整了和的声明顺序使先于初始化即可如果使用后面成员的地址初始化前面的成员则不受本规则约束如例中为引用的地址在初始化之前就确定了所以没问题为数组也是一个地址所以没有问题依据参考在构造函数中不应使用动态类型对象的动态类型在其构造过程中不生效执行基类构造函数时派生类对象尚未构造完毕基类构造函数不能使用派生类动态类型对于正在构造的对象不应调用派生类重写的虚函数通过判断对象的动态类型通过转换对象的动态类型注意如果在构造函数中调用未实现的纯虚函数会导致标准未定义的行为示例在基类的构造函数中判断动态类型是无效的依据参考在析构函数中不应使用动态类型对象的动态类型在其析构过程中不生效执行基类析构函数时属于派生类的成员已被析构基类析构函数不能使用派生类动态类型对于正在析构的对象不应调用派生类重写的虚函数通过判断对象的动态类型通过转换对象的动态类型注意如果在析构函数中调用未实现的纯虚函数会导致标准未定义的行为示例虽然派生类重写了函数但在基类的析构函数中不生效相关内存没有被正确释放应将基类的析构函数设为虚函数在派生类的析构函数中释放资源依据参考在析构函数中避免调用函数程序调用后具有静态或线程存储期的对象开始析构如果这种对象的析构函数再调用会导致标准未定义的行为为规避意料之外的错误应统一要求在析构函数中避免直接或间接地调用示例依据拷贝构造函数应避免实现复制之外的功能拷贝构造函数的执行在某些情况下可被省略其执行次数可能与预期不符复制之外的功能也可能无法生效示例例中拷贝构造函数对静态成员有所读写这种复制之外的功能是不符合要求的如果按下列方式使用相关类用函数返回的临时对象构造对象理论上应执行拷贝构造函数但标准允许编译器将临时对象直接作为对象省略拷贝构造函数的执行以提高效率这种优化称为复制之外的功能会因此无法生效在之前是否执行这种优化由实现定义从开始在某些情况下必须执行这种优化具体可参见相关依据参考移动构造函数应避免实现数据移动之外的功能移动构造函数的执行在某些情况下可被省略其执行次数可能与预期不符数据移动之外的功能也可能无法生效示例例中移动构造函数对静态成员有所读写这种数据移动之外的功能是不符合要求的如果按下列方式使用相关类用函数返回的临时对象构造对象理论上应执行移动构造函数但标准允许编译器将临时对象直接作为对象移动和拷贝构造函数均可省略以提高效率这种优化称为移动或复制之外的功能会因此无法生效在之前是否执行这种优化由实现定义从开始在某些情况下必须执行这种优化具体可参见相关依据拷贝赋值运算符应处理参数是自身对象时的情况如果拷贝赋值运算符的参数是自身对象需防止资源分配和回收方面的冲突示例设例中是需要深拷贝的类其赋值运算符往往需要先释放自身的资源再复制参数的资源如果参数就是自身则需要避免资源被释放可在赋值运算符中判断与参数地址是否相同如果的拷贝构造函数和交换方法齐备也可按复制交换模式实现利用创建临时对象并与之交换的方法也有效规避了冲突这种方法使各函数更专注于自己的职责不必重复编写分配和回收相关的代码建议采用这种方法参考不应存在无效的写入操作内存中的数据写入之后应被读取如果出现写入后未经读取便再次被无条件写入写入后未经读取而相关对象的生命周期已结束这种写入是无效的出现这种问题往往意味着逻辑错误或功能不完整下列情况可不受本规则约束对象初始化时的写入有特殊副作用的写入如对型数据的写入等示例例中参数被赋值为之后又被无条件地赋值为显然第一次赋值是没有意义的很有可能是漏掉了什么又如例中函数返回局部变量自增前的值自增运算是没有意义的对象的初始化可不受本规则限制如例中局部变量初始化后经由分枝在其两个分枝中都被赋值也相当于被无条件写入但在声明处初始化是值得提倡的故这种情况不受本规则限制不应存在没有副作用的语句不能对程序状态产生影响的语句称为无副作用的语句往往属于笔误或调试痕迹应当修正或去除示例设为变量或指针单纯的判等是没有副作用的很可能是赋值语句的笔误单纯从某个地址进行读取是没有副作用的这是一种对运算符优先级理解不当造成的常见错误应改为由变量名或无实参列表的函数名作为一个语句是没有副作用的此语句应改为正确的函数调用正号是没有副作用的此句很可能应为如果语句为逻辑与表达式左子表达式可以作为右子表达式的条件故左子表达式可以无副作用而右子表达式一定要有副作用如如果语句为逻辑或表达式则要求其左右子表达式均有副作用如依据参考不应存在得不到执行机会的代码得不到执行机会的代码是没有意义的往往意味着逻辑错误这种代码的主要成因如下括号内为特化规则所在函数无法被调用之前的所有分枝都提前结束了程序的执行之前的必经分枝中存在不会结束执行的代码所在分枝的条件恒为假所在分枝被其他分枝遮盖流程被不受条件控制的跳转语句跨过示例例中之前的所有分枝都会结束函数的执行所以不会被执行另外在正式代码中不应存在如下形式的代码也不应该在语句之后存在其他语句这种代码如果不是被人恶意篡改就是出于某种目的将本已无效的代码遗留了下来可参见的进一步讨论建议时刻保持代码的整洁并将维护过程中的变动及时地保存在版本管理系统中这样可以清晰地查看各版本之间的变动而如果将无效代码与有效代码混在一起势必造成维护的负担相关参考有返回值的函数其所有分枝都应显式返回如果有返回值的函数在某个分枝没有使用语句显式返回会导致标准未定义的行为示例当条件符合时函数的调用者将得到一个错误的返回值例外标准规定未显式返回的函数会返回故函数不受本规则约束依据参考不可返回局部对象的地址或引用局部对象的生命周期结束后其地址或引用也会失效如果继续访问会导致标准未定义的行为示例局部对象的生命周期在函数返回后结束返回与局部对象相关的指针或引用是不符合要求的注意除了语句赋值等表达式也受本规则限制禁止将内层作用域中的地址向外层作用域传递如例中是局部数组函数返回后全局指针会指向无效的内存区域另外将对象地址传入异步过程时也需要注意对象的生命周期参见相关依据参考不可返回临时对象的地址或引用临时对象可以通过常量引用或右值引用等方式作为函数的参数但生命周期结束后其地址或引用就会失效如果继续访问会导致标准未定义的行为对引用型参数取地址应谨慎示例例中函数的参数是由字符串常量生成的型临时对象所在语句执行完毕后生命周期即结束会成为野指针继续访问会导致标准未定义的行为同理也应避免对于右值引用型的参数取地址如相关依据参考合理设置表达式的捕获方式如果表达式只在函数内部使用可采用捕获引用的方式如果表达式可以超出函数作用域应采用捕获值的方式示例例中的表达式引用了局部变量但返回后的地址不再有效会导致标准未定义的行为另外要注意解引用指针造成的间接引用例中的表达式通过值捕获变量指针也被捕获成员变量是通过指针的隐式解引用获取到的如果表达式在指针的生命周期之外执行就会造成错误应改为如果需要捕获指针则应显式捕获所有相关变量避免使用相关依据参考函数返回值不应为右值引用函数返回右值引用的实际价值有限且易产生错误示例例中函数返回类型为右值引用这种情况下返回临时对象一定是错误的临时对象在返回前析构返回的是无效引用也不应返回局部对象的右值引用如和返回临时对象一样对象在函数返回前析构返回的也是无效引用应直接返回对象而不是对象的右值引用对于函数引用的参数或函数作用域之外的对象如果通过返回右值引用如这种情况在运行机制上可能没有问题但满足的实际需求较为有限而且相当于将和两种事务合在一个函数中在某种程度上违反了单一职责原则综上所述应统一要求函数不应返回右值引用相关参考函数返回值不应为常量对象函数返回常量对象不利于移动构造或移动赋值等机制也可能本意是返回引用但遗漏了引用符号示例返回对象构造对象时只能进行深拷贝无法利用移动构造等特性应改为这样可以利用移动构造函数提高效率对于遵循之前标准的代码也不应返回常量对象函数返回的对象本来就需要通过常量引用或传值的方式被后续代码使用将返回值设为常量的意义不大相关参考函数返回值不应为基本类型的常量基本类型的函数返回值本来就是不可被修改的右值不应再受关键字限制本规则是的特化示例出现这种问题说明设计与使用存在一定的偏差也可能本意是返回引用或指针而书写时漏掉了相关符号相关依据被返回的表达式应与函数的返回类型一致为了提高可读性并规避意料之外的错误应避免隐式转换被返回的表达式不应出现下列情况返回类型为却返回了非非非非的常量返回类型为指针却返回了非非非的常量返回类型为整数却返回了等常量示例这种问题可能是在维护过程中产生的也可能意味着逻辑错误需谨慎对待参考被返回的表达式不应为相同的常量被返回的表达式均为相同的常量是没有意义的示例具有属性的函数不应返回具有属性的函数返回会导致标准未定义的行为示例表示不会返回编译器可能不会为函数生成跳转回调用处的指令一旦函数返回就会造成严重错误相关依据具有属性的函数返回类型只应为返回类型不是说明函数有返回值与属性矛盾示例例中函数的返回类型为与属性矛盾也会对函数的使用者造成困扰应改为相关依据由指定的处理函数应正常返回如果指定的处理函数未正常返回会导致标准未定义的行为示例例中程序在调用时会执行而又调用在逻辑上形成无限递归其后果在标准中是未定义的又如例中返回后会调用而又调用跳回函数在逻辑上形成死循环依据参考函数模板不应被特化特化的函数模板不参与重载函数的选取易导致意类之外的错误如果某些特殊情况确实需要特化模板不妨将函数委托给模板类实现通过特化模板类实现特殊的需求参见示例输出特化的函数模板不参与重载函数的选取所以只会在和中选取与更贴近而是的特化所以不会选取这种情况下是无效的应去除对函数模板的特化改为普通重载函数这样例中函数会输出参考函数的退出点数量应在规定范围之内理想情况下应在函数的结尾设置统一的退出点使代码具有清晰的静态结构否则可读性较差尤其在多个嵌套的作用域中使用等语句会使代码难以理解示例例中函数的主体逻辑被语句割裂这显然是不利于阅读和维护的然而严格地要求每个函数只能有一个退出点是不够灵活的对于等并列的分枝结构其末尾的退出点可以算作一个退出点如配置退出点数量上限超过则报出相关参考函数的标签数量应在规定范围之内标签过多意味着函数内部的跳转逻辑过于复杂违反结构化设计理念应适当重构对于代码建议一个函数只用一个标签作为函数统一出口对于代码不建议使用标签示例配置标签数量上限超过则报出函数的行数应在规定范围之内函数体过大违反模块化编程理念使人难以阅读更不便于维护应适当重构示例建议函数体不超过行以不需要拖拽滚动条就可以在屏幕上完整显示为宜配置函数行数上限超过则报出参考表达式的行数应在规定范围之内复杂的表达式与调用者的代码混在一起是难以阅读的引入表达式的目的应该是化简否则应使用普通函数示例建议表达式不超过行一个函数中不应有多个复杂的表达式配置表达式行数上限超过则报出函数参数的数量应在规定范围之内函数参数过多意味着缺少合理的抽象机制应将多而零散的参数按其内在联系封装成对象从而方便地处理其逻辑关系而不是简单地线性罗列违反单一职责原则参数越多函数处理的事务自然越多代码的可维护性自然越差建议可供外部使用的全局函数或成员函数的参数不超过个内部使用的函数成员函数的参数不超过个示例当函数参数过多时应按参数的逻辑职责进行封装假设和有直接逻辑关系有直接逻辑关系不妨将和封装成一个类封装成一个类在类的成员函数中实现相关功能可更为清晰直观地保证逻辑关系的正确性配置函数参数数量上限超过则报出函数或成员函数参数数量上限超过则报出参考不应定义过于复杂的内联函数是否对函数进行内联优化由实现定义当函数执行的开销远大于调用的开销时将函数定义为内联函数是没有意义的不适合将函数定义为内联函数的情况语句数量超过指定限制存在循环或异常处理语句存在分枝语句函数存在递归实现建议内联函数的实现不要超过个语句配置内联函数语句数量上限超过则报出依据参考避免函数调用自身函数直接或间接调用自身可实现递归算法但调用栈的消耗情况不够直观易导致栈溢出等错误应使用复杂度更易控制的方法代替函数调用自身这种实现方式对于难以代替的特殊算法应做到资源消耗可控示例例中函数无条件地调用自身是一种逻辑错误导致无限的递归调用又如例中函数设置了递归条件但仍是不可取的当参数较大时仍然可以造成栈溢出错误参考作用域及类型嵌套不应过深作用域及类型嵌套过深会造成阅读和维护困难建议函数作用域嵌套不超过层内联函数作用域嵌套不超过层表达式内作用域嵌套不超过层类结构体嵌套不超过层命名空间嵌套不超过层示例审计工具不妨通过配置决定嵌套层数是否合规配置函数作用域最大嵌套层数超过则报出内联函数作用域最大嵌套层数超过则报出函数作用域最大嵌套层数超过则报出类型最大嵌套层数超过则报出命名空间最大嵌套层数超过则报出汇编代码不应与普通代码混合汇编代码的格式由实现定义不具备可移植性且可读性较差故不应与普通代码混合如果条件允许应使用汇编语言实现独立的库再由代码调用示例例中函数同时含有汇编代码和代码是不符合要求的至少应将汇编代码单独隔离成一个函数如依据参考避免重复的函数实现重复的或过于相似的代码不利于维护示例例中返回数组中最大元素的地址代码与几乎完全相同当需求有变化时需要同时修改两个函数极易造成意料之外的差异显然是不利于维护的本例可通过模板和自动类型推理将公有代码抽取出来这样与的代码便得到了简化虽然简化后仍然是相同的但仅为接口调用可以接受配置符号数量阈值小于此阈值的函数不参与比较函数相似度阈值超过则报出参考语句不应被分号隔断语句不应被分号隔断示例一个分号使整个语句失效这可能是笔误也可能是需求变化不再需要条件判断了在维护过程中加入了分号形成了令人费解的残留代码也不能排除是有人恶意篡改了代码应立即修正参考在分枝中不应有重复的条件分枝的条件不应有重复否则相同条件排在前面的分枝会得以执行而排在后面的分枝得不到执行机会示例例中和的条件是相同的所以不会被执行此问题为常见笔误多数由复制粘贴造成也可能是维护代码时对之前的逻辑不够了解造成的错误相关参考在分枝中不应有被遮盖的条件分枝中如果前面的条件被满足后面的分枝就不会被执行所以如果前面的条件是后面条件的一部分或者前面的条件包含后面的条件即使后面的条件可以被满足其分枝也得不到执行机会示例如果为将得以执行不会被执行如果为还是不会被执行称被遮盖了永远不会得到执行机会如果前面的条件包含后面的条件同样也会遮盖后面的条件如同理永远也不会被执行相关参考分枝和分枝的代码不应完全相同分枝和分枝完全相同会使条件判断失去意义往往是由复制粘贴造成的错误示例例中表示完全相同的代码需修正本应存在的差异或去掉结构相关参考各分枝的代码不应完全相同内容完全相同的分枝是没有意义的也可能是由复制粘贴造成的错误示例例中对应分枝和分枝的内容完全相同应该合并成一个分枝或修正本应存在的差异例外如果分枝内容较少为了使代码更清晰可以接受适当的重复但如果分枝内容很多就不应重复了审计工具不妨指定一个数量限制当重复分枝的符号数量超过这个限制时算作违规否则放过配置分枝符号数量阈值不检查符号数量小于该值的分枝相关参考分枝和隐含的分枝代码不应完全相同带有或等子句的语句其同一作用域的后续代码相当于它的分枝显然这种隐含的分枝与分枝完全相同是没有意义的很可能是由复制粘贴造成的错误示例例中语句之内的以及语句和语句之外的语句完全相同这种情况下语句的条件判断是没有意义的需修正本应存在的差异或去掉语句相关参考没有子句的语句与其后续代码相同是可疑的语句与其同一作用域的后续代码完全相同是可疑的可能是由复制粘贴造成的错误示例例中对变量的赋值是没有意义的相关参考分枝和分枝的起止语句不应相同如果分枝和分枝的起止语句相同应将其从分枝结构中提取出来否则重复的代码不利于阅读和维护示例与分枝的开头和结尾相同应提取出来当条件分枝中的所有语句都相同时本规则特化为这种情况往往意味着错误相关参考语句作用域的范围不应有误语句作用域的范围不应有误示例例中不在语句的作用域中但看起来又和语句相关这种问题多数是由错误的宏展开或无效的缩进造成的为了避免这种问题语句应使用大括号括起来相关参考如果关键字前面是右大括号关键字应另起一行当关键字前面是右大括号且关键字与该大括号在同一行时属于不良换行方式易造成等关键字的遗漏示例这种情况很可能是漏掉了关键字即使没有被漏掉也应该让关键字另起一行否则这种换行习惯会增加遗漏关键字的风险而且可读性较差语句的条件不应为赋值表达式虽然语言允许在语句的条件中赋值但和极易混淆建议所有产生型结果的表达式都不要包含赋值运算符本规则是的特化示例例中为常量在条件中用常量对变量赋值是没有逻辑意义的如果条件中等号右侧为常量基本可以判定是被误写成了又如例中为函数这也是一种公认的不良风格应将赋值表达式拆分出来或者在代码中改为将赋值表达式加上括号表示有意为之是一种惯用写法但并不值得提倡如审计工具不妨通过配置决定是否放过这种情况配置是否放过括号括起来的赋值表达式相关参考语句不应为空空的语句或子句无实际意义往往是残留代码或功能未实现示例如果语句没有分枝且其分枝内容为空这样的语句无任何意义即使其条件有副作用也不应继续保留该结构又如应改为或者添加注释说明为何为空参考分枝数量应在规定范围之内分枝过多不利于阅读和维护而且执行时需逐一判断各分枝的条件效率较低建议改为遵循某种算法的索引结构示例建议分枝数量不超过个配置分枝数量上限超过则报出分枝中的语句应该用大括号括起来组成分枝的语句应为大括号括起来的复合语句即使该复合语句只包含一条语句示例根据缩进这段代码想表达的逻辑应是但规定子句与最近的子句配对所以实际逻辑是这显然是与预期不符的又如例中看起来应该是分枝的一部分但它实际上并不在的作用范围之内所以用大括号括起来可避免此类问题例外直接与语句相连的子句不受本规则约束相关参考所有分枝都应以子句结束所有分枝都以子句结束是防御性编程思想的良好体现单独的一个分枝不要求接有子句存在多个分枝时要求接有子句相关参考语句不应被分号隔断语句不应被分号隔断示例分号使循环失效这可能是笔误也可能是有人恶意篡改了代码应立即修正相关参考语句中不应存在无条件的跳转语句无条件的或语句会使循环失效无条件的语句会使其后面的代码失效如果其后没有代码时该语句是没有意义的示例这种问题多数由错误的缩进或混乱的逻辑造成相关参考语句作用域的范围不应有误语句作用域的范围不应有误示例例中不在循环的作用域中但看起来又和循环相关这种问题多数是由宏展开或无效的缩进造成的为了避免这种问题语句应使用大括号括起来相关参考语句没有明确的循环变量时应改用语句语句一般用于实现具有明确循环次数和循环变量的迭代算法循环变量即控制循环次数的变量语句小括号内的三个表达式应分别专注于循环变量的初始化循环条件的判断循环变量的增减这样可以使循环具有清晰的静态结构便于阅读利于维护如果没有明确的循环变量则应改用循环避免误导维护者示例例中不是循环变量它可以记录循环次数但与循环条件无关应改为循环如果语句的第个和第个表达式为空则更应改为循环使代码更简洁如应改为参考循环体不应为空空的循环结构不清晰可读性较差示例语句小括号内的三个表达式应分别专注于循环变量的初始化循环条件的判断循环变量的增减循环体应专注于迭代算法的实现使程序具有清晰的静态结构便于阅读利于维护应改为另外在代码中如果只通过语句遍历容器而不对元素进行操作是没有意义的如这种代码多为残留代码或功能未实现应当及时去除或补全功能参考循环变量不应为浮点型用于控制循环次数的变量称为循环变量这种变量不应采用浮点类型否则循环的次数难以控制由于浮点型变量的不精确性使浮点型变量不适用于控制循环次数参见示例本例按常识应循环次然而由于无法精确表示导致实际循环次数与预期产生偏差可变通地建立整型循环变量与浮点数的关系这样循环的次数便与预期相符相关参考循环变量不应在循环体内被改变用于控制循环次数的变量称为循环变量为了使代码具有清晰的静态结构循环变量只应在语句的第个表达式中被改变示例例中循环变量在多处被改变循环的执行次数和结束条件变得难以理解易错且不利于维护参考嵌套的语句不应使用相同的循环变量同一个循环变量在内外层循环中均被修改使循环次数难以控制是过于复杂的循环逻辑也可能是某种错误示例相关循环体应该用大括号括起来循环体应为大括号括起来的复合语句即使该复合语句只包含一条语句示例应改为参考语句不应被分号隔断语句不应被分号隔断示例分号使循环失效有造成死循环的危险参考语句中不应存在无条件的跳转语句不受条件限制的或语句会使循环失效不受条件限制的语句会使其后面的代码失效如果其后没有代码该语句是没有意义的示例这种问题多数由错误的缩进或混乱的逻辑造成相关参考语句的条件不应为赋值表达式虽然语言允许在语句的条件中赋值但和极易混淆建议所有产生型结果的表达式都不要包含赋值运算符示例相关参考语句作用域的范围不应有误语句作用域的范围不应有误示例例中不在循环的作用域中但看起来又和循环相关这种问题多数是由宏展开或无效的缩进造成的为了避免这种问题语句应使用大括号括起来相关参考循环体不应为空空的循环将功能全部压缩到了条件表达式中各子句的职责划分不明确可读性较差示例示例代码循环检测并设置某标志位这些功能被压缩到了循环条件中而且容易使人误以为下一行代码也与循环有关应改为循环体的内容才是循环主体功能的体现不应为空参考循环体应该用大括号括起来循环体应为大括号括起来的复合语句即使该复合语句只包含一条语句示例应改为相关参考注意中可疑的语句语句和语句在语义上是不同的但在中的功效是一样的在的循环体中如果既有语句又有语句语句被误用的可能性较大示例建议在中只使用语句不使用语句参考循环体不应为空空的循环将功能全部压缩到了条件表达式中各子句的职责划分不明确可读性较差示例示例代码将循环的条件和循环产生的副作用叠加在了一起易使人误解相关参考循环体应该用大括号括起来循环体应为大括号括起来的复合语句即使该复合语句只包含一条语句示例例中关键字与关键字产生了错误的对应关系导致最后一个形成了死循环应改为相关参考不建议使用语句语句的终止条件在末尾且第一次执行时不检查终止条件易被误用语句可用于循环也可用于定义由等语句跳出的作用域糅合了循环和流程跳转使代码变得复杂不利于阅读和维护建议将复杂的语句抽取成函数使代码的静态结构更加清晰宏定义中的可不受本规则限制示例参考语句不应被分号隔断语句不应被分号隔断示例这种无意义的语句应及时去除或补全代码参考语句不应为空空的语句无实际意义往往是残留代码或功能未实现示例这种无意义的语句应及时去除或补全代码参考标签的值不可超出条件的范围如果标签的值超出了条件的范围会导致相应分枝永远不会被执行示例例中变量的值不可能为所以对应的分枝永远不会被执行相关参考语句中任何子句都应从属于某个或分枝语句中任何子句都应从属于某个或分枝否则不会被执行示例例中对变量的声明和赋值不从属于任何或分枝是无效语句参考和标签应直接从属于语句不直接从属于语句的或标签用于非结构性跳转是公认的不良实现关于非结构性跳转的进一步讨论可参见示例例中直接从属于语句而和直接从属于语句当的值不是时会绕过语句的条件判断产生非结构性跳转与语句的问题一样很容易导致逻辑混乱且不利于维护虽然有些编程技巧会将置于循环中如等但当今主流的编程语言均已不再提倡非结构性跳转相关参考不应存在紧邻标签的空标签紧邻标签的空标签是没有意义的应当去除示例应改为不应存在内容完全相同的分枝内容完全相同的分枝应合并为一个分枝也可能是由复制粘贴造成的错误示例例中对应的分枝和对应的分枝内容完全相同应将其合并为一个分枝或修正本应存在的差异例外如果分枝内容较少为了使代码更清晰可以接受适当的重复但如果分枝内容很多就不应重复了审计工具不妨指定一个数量限制当重复分枝的符号数量超过这个限制时算作违规否则放过配置分枝符号数量阈值不检查符号数量小于该值的分枝相关参考语句的条件不应为型如果条件为型应改用语句使代码的结构更清晰示例应改为参考语句不应只包含标签只有标签的语句是没有意义的起不到分枝选择的作用往往是残留代码或功能未实现示例这种空的可以到标签的空标签也是没有意义的参考语句不应只包含一个标签只有一个标签的语句与语句语义相同但形式上更为复杂应改为语句示例应改为参考语句分枝数量应在规定范围之内语句分枝过多不利于阅读和维护这种情况下建议将分枝抽取成函数再按遵循某种算法的索引结构组织在一起示例建议数量不超过个配置分枝数量上限超过则报出语句应配有分枝所有语句都配有分枝是防御性编程思想的良好体现示例例外当条件为枚举类型且标签已对应所有枚举项时不再要求有分枝相关参考语句的每个非空分枝都应该用无条件的或语句终止在语句的分枝中或语句的缺失是导致错误的常见原因示例相连的标签不受本规则约束但最好配有注释少数情况下如果确实不能有或语句应添加注释说明情况或在代码中用注明依据参考语句应该用大括号括起来语句应为包含多条语句的复合语句且用大括号括起来否则不应选用语句示例应改为语句相关参考语句不应嵌套嵌套的语句使代码显得复杂不利于阅读和维护不同语句的分枝交织在一起较难看出分枝的从属关系尤其是相关代码行数较多时这种问题会更为明显应将内嵌的语句抽取成一个函数使代码具有更清晰的静态结构示例关键字的作用域不应为空关键字的作用域即关键字后的复合语句不应为空否则无实际意义往往是残留代码或功能未实现示例参考子句不应为空空的子句仅捕获异常而未作任何处理相当于掩盖了异常示例掩盖异常也可能会影响到程序其他方面的正常运行至少应添加日志记录等操作参考不应嵌套语句嵌套的语句使代码显得复杂不利于阅读和维护在嵌套的语句中较难看出各子句的从属关系尤其是相关代码行数较多时这种问题会更为明显应将内嵌的语句抽取成函数使代码具有更清晰的静态结构示例参考捕获所有异常的子句应位于最后如果子句排在前面其后面的子句会失去作用示例应改为相关依据参考面向派生类的子句应排在面向基类的子句之前以派生类对象为参数的子句应排在以基类对象为参数的子句之前否则后面的子句会失去作用示例例中为基类为派生类类异常会被第一个子句捕获第二个子句失去了作用应改为相关依据参考禁止语句向嵌套的或无包含关系的作用域跳转不同的作用域对应不同的条件约束在不同的作用域间跳转是对约束的破坏很容易导致逻辑混乱向嵌套的或无包含关系的作用域跳转是不应被允许的如果是为了结束当前流程而在同层或向外层作用域跳转则可被本规则允许示例例中从语句跳入循环语句是应当被禁止的而用于结束循环流程可以保留相关参考禁止语句向前跳转向先于当前语句定义的标签跳转可读性较差是公认的不良实现示例例中向后跳转符合本规则要求而向前跳转不符合要求应改用循环等结构性语句相关参考禁用语句历史表明语句会破坏程序的结构性规划很容易导致逻辑混乱且不利于阅读和维护在非自动生成的对可读性有要求的代码中建议禁用语句示例语句的排列和作用域的嵌套描述了程序的静态结构清晰的静态结构使人易于理解程序的行为而语句会打破这种结构无规律的跳转会严重地降低代码可读性例中会绕过第二个语句的条件约束可读性很差应被禁止语言的流程管理较为简单语句可提供一定的灵活性但不应作为常规实现手段也应受一定的限制在代码中使用语句应遵循和等规则语言提供了更丰富的流程管理功能在代码中不应再使用语句下面给出语句的一种常用模式在多次资源分配过程中如果某次分配失败则需要释放已分配的资源利用语句可实现资源的统一释放在代码中如果不用语句反而会很繁琐所以这种模式在代码中可以复用由于提供容器智能指针等更丰富的资源管理手段所以不建议在代码中再使用这种模式即使标准库没有和相关资源对应的功能也应该利用等机制对其先封装再使用相关参考禁用可以在函数间跳转进一步破坏了结构化编程理念非框架代码不应使用与由类型为的参数关联只能在同一线程中使用如果调用时没有对应的或所在函数已经结束执行会导致标准未定义的行为而且要注意无法与对象自动析构等机制兼容极易造成意料之外的错误示例返回表示设置跳转位置成功之后如果调用会跳回的位置这时返回非值这种机制在语言中可以用作异常处理也可以实现协程等概念但会严重地降低代码可读性在普通的业务逻辑或算法实现中不应使用另外函数间跳转与编译器的优化机制有冲突如在启用优化时和关闭优化时可能会有不同的输出启用优化时局部变量可能直接存于寄存器当通过跳转回函数时的结果会丢失将局部变量用限定可解决这种问题但很容易遗漏或产生无必要的限定依据参考不应存在不受条件控制的跳转语句不受条件控制的跳转语句会剥夺其后续代码的执行机会往往意味着逻辑错误也可能是调试或维护痕迹示例例中语句相对其同一作用域中的后续代码是不受条件控制的函数得不到执行机会相关不应存在不改变程序流程的跳转语句不改变程序流程的跳转语句是多余的往往意味着逻辑错误也可能是调试或维护痕迹等跳转语句均受本规则约束示例避免使用跳转语句退出循环循环的退出条件应与其控制表达式一致使代码具有清晰的静态结构否则可读性较差尤其在多个嵌套的作用域中使用或等跳转语句会使代码难以理解示例例中循环条件散落在循环体内而且循环的主体逻辑被各种跳转语句割裂是不利于阅读和维护的相关参考不应存在无意义的重复子表达式逻辑与逻辑或按位与按位或的子表达式以及三元表达式的两个分枝不应重复否则相关运算会失去意义示例例中重复的子表达式都是有问题的这是很常见的错误多由复制粘贴引起修正时不应只删去重复项还要考虑是否漏掉了某些项例外具有副作用的逻辑子表达式可不受本规则约束例中重复的子表达式可以改变文件流的状态但第二个子表达式可能不会被执行这种代码即使没有逻辑错误也是不便于维护的参见参考逻辑子表达式之间不应存在矛盾相互矛盾的逻辑子表达式会使整个表达式的结果恒为真或恒为假导致逻辑错误示例同一变量不可能同时等于不同的值这种表达式是无效的又如这种表达式均为常见笔误应及时修正相关参考作为条件的逻辑表达式不应恒为真或恒为假以恒为真或恒为假的表达式作为条件是没有意义的属于逻辑错误示例例中变量初始化为后在没有被修改过的情况下仍对其进行判断是没有意义的分枝的代码得不到执行机会相关参考不应存在多余的逻辑子表达式逻辑或逻辑与的子表达式有包含关系时其中的一个表达式是多余的示例多余的子表达式很可能意味着某种错误需认真对待相关逻辑表达式及逻辑子表达式不应为常量不改变程序流程的常量逻辑表达式是没有意义的而常量逻辑子表达式则是多余的示例这种代码往往是调试或维护过程中产生的残留代码应及时去除例外或等常量可作为或循环的条件或等常量可作为循环的条件由宏定义的常量也不应作为控制语句的条件如应采用条件编译的方式避免占用运行时资源或参考逻辑表达式的右子表达式不应有副作用逻辑表达式的右子表达式有副作用会使代码变得复杂易错不利于阅读和维护对于逻辑表达式的求值标准规定从左至右计算各子表达式的值当可以确定整个表达式的值时即使还有未计算的子表达式也会立即结束求值这种方法可提高效率称为短路规则逻辑表达式的右子表达式受左子表达式影响可能不会被执行如果有副作用也可能不会生效示例如果为真不论是否等于整个条件表达式的值一定为真所以不一定会被执行需要同时考虑执行与未执行的两种状态很容易产生错误也不利于阅读和维护依据参考化简可被合并的逻辑子表达式逻辑或逻辑与的子表达式可以合并成一个表达式时应尽量合并示例不合理的繁琐写法也可能意味着某种错误需认真对待相关化简可转换为逻辑表达式的三元表达式当三元表达式的分枝是常量或时应化简为逻辑表达式示例应改为不可依赖不会生效的副作用有些运算符只关注类型其子表达式不会被求值子表达式的副作用也不会有实际效果这类运算在语言中有在语言中有这类运算符不宜作用于逻辑算术位运算函数调用等子表达式特殊情况在语言中如果作用于变长数组类型数组长度表达式会被求值在语言中如果作用于返回多态类型的函数调用该函数也会被执行虽然在某些特殊情况下相关子表达式会被求值但为了避免意料之外的错误本规则要求这类运算符的子表达式在任何情况下均不可含有任何副作用示例输出的副作用不生效而的副作用会生效这往往会使人困惑相关依据参考避免依赖特定的子表达式求值顺序不同的求值顺序不应产生不同的结果否则极易导致意料之外的错误也会降低代码的可移植性标准用序列点定义求值顺序序列点前面的表达式先于后面的表达式求值并落实相关副作用逻辑与逻辑或三元逗号等运算符以及函数调用的左括号与序列点相关其左子表达式先于右子表达式求值并落实副作用赋值算术位运算等运算符与序列点无关其左右子表达式的求值顺序是未声明的函数各参数的求值顺序也是未声明的标准与标准大致相同明确了赋值移位等运算符的求值顺序要注意子表达式的副作用在不同求值顺序下的正确性可参见的进一步说明示例设函数弹出并返回栈顶元素减号左右的两个函数哪个先执行呢这是标准未声明的的值可以是也可以是由编译器决定应改为这样便确定是栈项的第一个元素减第二个元素又如设是函数名称或获取函数指针的表达式标准规定会先于参数求值但参数之间的求值顺序是未声明的逻辑与逻辑或三元逗号等表达式可不受本规则限制但其子表达式需受本规则限制相关依据参考在表达式中不应多次读写同一对象在表达式中多次引用并修改同一对象很可能会因为非预期的求值顺序而产生错误的结果关于对象的副作用在求值过程中何时生效这一问题相关标准既复杂又有大量未声明和未定义的情况故需注意写入对象的次数不应超过次对象不应既被读取又被写入除非是为了计算对象的新状态并写入对象注意对对象的读取相当于更新对象的值也是一种副作用故对象在表达式中只应出现次对象不应既被读取又被写入本规则是的特化示例例中泛指写入操作设是值为的整型变量如下表达式对变量有两次写入分别是增和赋值为子表达式的值为这两次写入的次序在和之前的标准中是未声明的如果先增再赋的值最终为如果先赋再增的值最终为这种不确定的结果应当避免规定了右子表达式的副作用先于赋值生效所以在之后例中表达式是无效的虽然新的标准强化了求值顺序但这种代码使人费解很容易造成理解上的偏差故不应使用如果不是变量应改为如果是变量应改为对于逻辑与逻辑或三元以及逗号表达式标准明确规定了子表达式从左至右求值左子表达式的副作用也会在右子表达式求值前生效故可不受本规则限制但其子表达式仍需受本规则限制进一步可参见序列点以及求值顺序等概念相关依据参考注意运算符优先级避免非预期的结果对运算符优先级的错误理解是产生逻辑错误的主要原因之一示例加号的优先级大于三元运算符但是型变量所以这种情况十分可疑很可能应改为参考不在同一数组或对象中的地址不可相减或比较大小不在同一数组或对象中的地址之间没有逻辑关系这种地址相减或比较大小属于逻辑错误也会导致标准未定义或未声明的行为对于语言即使在同一对象中静态成员之间静态成员与非静态成员之间由分隔的成员之间也不应对地址求差值或比较大小示例另外指针与空指针之间也不应相减或比较大小指针与空指针比较大小是一种常见笔误对此本规则特化为相关依据参考值不应参与位运算大小比较数值增减值只能为真或假不具有大小等数值意义值参与位运算大小比较数值增减是不合理的示例由于的优先级高于所以例中的语句相当于先判断是否为再将这个型的结果与按位与这是没有意义的应改为依据参考不应出现复合赋值的错误形式如下形式的复合赋值表达式设和为变量或表达式均为常见笔误应将复合赋值改为普通赋值或去掉重复的子表达式参考避免出现复合赋值的可疑形式如下形式的复合赋值表达式设和为变量或表达式均为常见笔误但在特定需求下也有其逻辑意义故对这种表达式应给出可疑提醒即使这类表达式没有逻辑错误也应该换成普通赋值表达式以便提高可读性示例应改为参考左右子表达式不应相同左右子表达式如果相同则没有任何效果左右子表达式相同则结果总为或这种表达式往往意味着笔误或逻辑错误示例设为变量或表达式如果目的是清零或置也不建议使用下列表达式对于高级语言来说应该直接将变量赋值为或而不是采用更繁琐甚至低效的方式参考不应将当作整数使用标识符由实现定义在语言中往往等同于常量但只应该用来表示空指针否则不利于阅读和维护被当作整数使用的也很可能意味着某种错误示例应改为依据参考注意赋值运算符与一元运算符的空格方式如果与等一元运算符之间没有空格而一元运算符与其子表达式之间有空格是一种非常怪异的格式也可能是等复合赋值运算符的笔误示例参考不可将对象的值赋给具有部分重叠区域的对象如果两个对象的存储区域有部分重叠将其中一个对象的值赋给另一个对象会导致标准未定义的行为示例例中和的存储区域完全重叠且类型相同可以相互赋值和有部分重叠不可相互赋值依据参考赋值运算符左右子表达式不应相同赋值运算符左右子表达式相同是没有逻辑意义的往往是笔误或残留代码示例也可能是对语言特性不了解所致如例中构造函数对成员的赋值是无效的应改为有时这种代码被用来消除编译警告编译器可能会报出没有被用到的参数将参数赋值给自身可去除警告但这并不是一种好方法引入了没有实际意义的代码改进方法可参见有时为了设置调试断点但又找不到合适的位置可以增加这种代码作为断点但这种非正式的代码是不应被保留的参考除法和求余运算符左右子表达式不应相同除法或求余运算符左右子表达式相同结果总为或以及产生除零异常往往是某种笔误示例参考减法运算符左右子表达式不应相同与自身做减法结果总为往往是某种笔误示例例中减法表达式是没有意义的很可能是被误写成了参考异或运算符左右子表达式不应相同与自身异或的结果总为而且也可能意味着某种错误示例这种代码可能是为了对变量清零也可能是笔误即使没有逻辑错误也应将变量直接赋值为以提高可读性参考负号不应作用于无符号整数负号作用于等无符号整型表达式的结果仍为无符号整数易产生意料之外的错误当类型的取值范围可以包含等较小无符号整型的取值范围时较小的无符号整型可以被提升为类型负号作用于这种类型的表达式可以得到有符号的结果但会降低可移植性示例例中的值预期为但实际值是无符号整数的最大值这种常量是令人困惑的应使用代替配置是否允许负号作用于等无符号整型表达式依据参考不应重复使用一元运算符重复的一元运算符没有意义为常见笔误示例例外两个连续的是转换的惯用方法可不受本规则约束运算结果不应溢出溢出即运算结果超出了对应类型的取值范围使相关数据无法被完整存储造成数据丢失有符号整型和浮点型溢出会导致标准未定义的行为无符号整数的运算结果是数学上的结果与无符号整型最大值求模的结果标准认为这是一种算法特性规定无符号整型不存在溢出然而实践表明运算结果超出取值范围往往意味着错误示例例中位整数相乘可能产生溢出使函数返回错误结果应对溢出作出判断其中和分别为位整数的最大值与最小值依据参考位运算符不应作用于有符号整数符号位在位运算方面没有逻辑意义对负数进行位运算往往意味着逻辑错误示例例中为有符号整数其符号位对位运算没有意义对负数左移会导致标准未定义的行为对负数右移则由实现定义依据参考移位数量不应超过相关类型比特位的数量如果移位数量为负数大于或等于相关类型比特位的数量会导致标准未定义的行为示例例中变量为位整数是否会被提升为位整型由实现定义参见类型提升变量为位整数将其左移位并不能得到位整数反而会导致标准未定义的行为应改为依据参考按位取反需避免由类型提升产生的多余数据位或位整数按位取反时会被提升为等类型可能会产生非预期的多余数据示例经类型提升例中在位环境中为在位环境中为高位的数据很可能是多余的应在取反后立即转为目标类型参考逗号表达式的子表达式应具有必要的副作用缺少必要副作用的逗号子表达式没有意义往往意味着逻辑错误设逗号表达式中逗号运算符的子表达式个数为如果最后一个子表达式的值可影响程序状态前个子表达式应具备副作用否则所有子表达式都应具备副作用示例例中逗号表达式有个子表达式只有第个子表达式有效第和第个没有意义应改为本规则集合不建议使用逗号表达式将逗号表达式拆分成合理的语句是更好的选择如相关参与比较的对象之间应具备合理的大小关系对象与超出其类型取值范围的值比较或与取值范围的边界进行无意义的比较属于逻辑错误示例例中为无符号变量一定大于或等于是无意义的比较也是一种常见笔误又如例中为位无符号变量其取值范围为恒为假由于类型提升可以被转为型再与比较恒为正数而为负数故不可能相等对于有符号字符型变量与其比较的数值不在范围内时也是无效的即使例中的二进制绝对值确实为但由于类型提升转为型后为负数为正数比较的结果恒为假型变量是否有符号由实现定义可参见的进一步说明将等变量设为可解决这个问题相关参考不应使用或判断浮点数是否相等一般来说除了可以记作为整数的浮点数值可以被精确存储之外其他均为近似值用或判断浮点数是否相等往往得不到预期的结果如可以被精确存储而除此之外绝大部分数值如只能存储其近似值示例输出这是因为在运算时将变量和常量转为型而转换过程中生成了两个不同的对的近似值如和其结果自然为这非常容易造成意料之外的混乱所以判断浮点数是否相等不应直接使用或运算符即使浮点数可以被精确存储解决方法利用函数判断浮点数是否相等如果两个浮点数的差值非常小则可以认为相等其中为计算浮点数差值绝对值的函数如果差值绝对值小于则认为相等否则不等参考指针不应与字符串常量直接比较直接比较指针和字符串常量的结果往往总是应改用字符串比较函数示例如果例中函数只接受常量字符串作为参数该函数在某些环境中也可能正常工作如然而相同的字符串常量是否一定拥有相同的地址呢对这个问题不同的编译器有不同的实现有可移植性要求的代码要规避这种问题而且这种问题极易导致错误一般的程序都应该避免这种问题应改为依据参考不应比较非同类枚举值比较非同类枚举值相当于比较不同类别的事物没有逻辑意义往往是设计缺陷或逻辑错误示例比较运算符左右子表达式不应相同与自身的比较是没意义的往往是某种笔误示例设为变量或表达式例外当为真时表示为无效值这是判断浮点数是否有效的惯用方法可不受本规则约束参考比较运算不可作为另一个比较运算的直接子表达式在语言中连续的比较运算是没有意义的本规则是的特化示例例中的结果为型型数据是没有大小概念的这个结果再与比较大小是没有意义的例外如果是判断两个表达式是否相等可不受本规则约束但这种复杂的形式并不值得提倡相关参考不应忽略重要的返回值与状态判断信息获取资源分配有关的返回值不应被忽略示例例中函数返回字符串是否为空如果忽略返回值会使函数调用失去意义属性表示返回值具有重要意义标准库中以及由用户标注的具有属性的返回值不应被忽略如经转换的函数调用可以认为是有意放弃返回值审计工具不妨通过配置决定是否放过这种情况配置是否允许通过转换忽略返回值依据参考不可臆断返回值的意义应遵循接口文档使用接口不可臆断返回值的意义否则造成逻辑错误示例例中函数返回在中的位置当中不存在时返回将函数的返回值转为型是没有逻辑意义的应改为想当然地认为返回表示失败或不存在非表示成功或存在是造成错误的常见原因又如函数的返回值可以是等于大于或小于的任意整数分别对应字符串的等于大于或小于关系认为其只能返回或是一种常见的误解应改为以及等函数不应与之外的任何值比较下列函数的返回值不应与比较也不应转为型等系统调用失败时返回负数成功时返回非负数等失败时返回而不是型返回值负数表示失败非负数表示成功另外有相当一部分函数成功时返回失败时返回非如等系统调用不可将其返回值当作型使用依据参考避免对象切片将派生类对象复制为基类对象的行为称为对象切片基类对象不再持有派生类的属性不再遵循多态机制意味着某种精度上的损失往往会造成意料之外的错误示例尤其是函数传参或容器收纳对象时发生切片会引起相当大的困惑明明传入的是派生类对象但虚函数都不生效了所以要求多态性的接口或容器均应使用指针或引用在少数情况下对象切片可能也有其逻辑意义但不建议隐式切片应定义特定名称的函数标明这是一种特殊处理如其中是一个返回基类对象的函数表示有意为之相关参考避免显式调用析构函数显式调用析构函数会提前结束对象的生命周期之后对该对象的任何访问都会导致标准未定义的行为对于在栈上定义的对象流程离开相关作用域时会再次自动调用其析构函数对于动态创建的对象用回收时也会调用其析构函数使对象在生命周期之外被访问导致标准未定义的行为示例例中对象的析构函数被显式调用返回前会再次调用析构函数造成内存被重复释放应去掉显式调用由类提供提前释放资源的方法并保证资源不会被重复释放例外与配合的显式析构是实现容器或内存池的常规手段可不受本规则约束相关依据不应将非对象传入可变参数列表如果将非对象传入可变参数列表程序的行为在中是未定义的在中是部分由实现定义的示例例中类对象不是对象其拷贝构造和析构过程难以与可变参数列表机制兼容通过难以获取正确的对象又如即使对象有转为的方法在可变参数列表中也是无效的无法正确获取字符串地址造成内存访问错误应改为相关依据参考格式化字符串需要的参数个数与实际传入的参数个数应一致如果格式化占位符的数量大于参数的数量会导致标准未定义的行为反之多余的参数会失去意义往往意味着逻辑错误示例例中格式化字符串需要两个参数但只传入了一个往往会引发运行时堆栈错误由于可变参数列表自身的局限很难在编译时发现这种问题有些编译器会检查等标准函数但无法检查自定义函数建议在代码中禁用可变参数列表和风格的格式化函数相关依据参考格式化占位符与其对应参数的类型应一致格式化占位符与其对应参数的类型应一致否则导致标准未定义的行为示例等类型是由实现定义的标准没有规定其是否一定对应或等类型而只对应等类型所以示例代码都是不合理的应使对应对应对于中定义的类型应使用中定义的占位符并不一定对应不应将等占位符在代码中写死和是中定义的宏可解决移植相关的问题又如例中要求对应型指针但是型对象造成栈读取错误应改为由于可变参数列表自身的局限很难在编译时发现这种问题有些编译器会检查等标准函数但无法检查自定义函数建议在代码中禁用可变参数列表和风格的格式化函数相关依据参考在代码中禁用字符串格式化方法字符串格式化方法的主要问题有需要手工维护参数与格式化占位符的对应关系在编译期难以保证安全性增加测试成本与的强类型理念不符不在标准之内只接受基本类型的参数不利于数据的对象化管理故在代码中禁用下列函数示例在字符串格式化方法中不同类型的参数依赖不同的格式化占位符参数的类型与个数必须和占位符严格对应否则就会导致未定义的行为当参数较多时极易出错单纯地要求开发者小心谨慎是不可靠的改用更安全的方法才是明智的选择在代码中利用标准流可避免这些问题而且标准流具备可扩展性符合面向对象的编程理念当参数较多时标准流的方式在形态上可能较为松散在可读性上可能不如函数而且重载运算符的方式也会产生同步问题和额外的性能开销对此的提供了更多的格式化方法也可参见的示例用模板参数包等更安全的方法实现函数的功能相关依据参考禁用以及等函数当字符串无法被正确转为数值时或中的以及等函数会导致标准未定义的行为对于语言应改用等函数对于语言应改用标准流转换的方式示例例中字符串不表示数字字符串超出了正常型变量的范围这些情况会导致标准未定义的行为更严重的问题是无法通过这种函数判断转换是否成功这种不确定性也意味着代码在实现上存在缺陷标准流转换示例本例通过判断字符串前面的字符是否可以转为型变量也可通过判断字符串整体是否可以转为型变量依据参考避免使用由实现定义的库函数由实现定义的库函数会增加移植或兼容等方面的成本如中的等函数中的等函数中的等函数这些函数的行为取决于编译器库或环境的生产厂家同一个函数不同的厂家会有不同的实现故称这种函数的行为是由实现定义的有高可靠性要求的软件系统应避免使用这种函数否则需明确各种实现上的具体差异增加了移植发布以及兼容性等多方面的成本示例调用函数会终止进程但打开的流是否会被关闭缓冲区内的数据是否会写入文件临时文件是否会被清理则由实现定义依据参考合理使用的参数应为左值返回值应直接作为接口的参数除此之外的使用方式价值有限且易产生错误将左值转为右值意在宣告对象的数据将被转移到其他对象应由合适的接口完成数据转移示例例中函数返回的是右值如果再调用是多余的应将去掉又如例中是具有名称的右值引用其实是左值仍是拷贝构造应改为这样构造时会自动选取移动构造函数避免了复制又如例中函数返回对象编译器会进行优化显式调用是多余的而且会干扰优化不应出现这种代码应改为依据参考合理使用的参数应为转发引用返回值应直接作为接口的参数除此之外的使用方式价值有限且易产生错误转发引用是类型为的参数为函数模板类型无论左值还是右值均可被这种参数接受而且等属性也会被忽略这种参数应通过交由合适的接口处理关于转发引用可参见的进一步说明示例例中接口的参数为转发引用在函数中接口将左值常量引用和临时对象分别转发给对应的接口这种模式称为完美转发应在这种模式内使用下面给出几种错误示例注意转发引用的类型只能是函数模板类型非模板和类模板不构成转发引用的返回值应直接作为接口的参数且只应使用相关依据参考不应作用于数组参数当函数的形式参数为数组时实际上是一个指针对这种参数使用无法获取到数组大小往往意味着错误示例例中参数是一个指针而不是一个真实的数组在代码中如果有必要将参数设为数组建议使用引用的方式如这样的结果就会和预期一致依据参考不应作用于逻辑表达式作用于等逻辑表达式为常见笔误逻辑运算符往往应该移出表达式示例作用于指针是可疑的作用于指针的结果是指针的大小而不是指针指向内容的大小作用于指针很容易造成错误示例应改为其中参数是数组元素的个数相关参考被除数不应是作用于指针的表达式形如的表达式往往意在获取数组元素的个数如果是指针是指针大小而不是数组大小结果很可能是错误的示例例中并不能获取所指数组中元素的个数本规则是的特化作用于指针是可疑的再作为被除数就更加可疑了相关参考指针加减偏移量时计入是可疑的指针加减偏移量时会自动计入指针指向类型的大小如果再计入的值很可能是某种错误示例如果函数是为了获取指针之后第个整数的值那么这种实现是错误的应改为依据参考表达式的结果不应与或负数比较将表达式的结果与或负数比较往往意味着逻辑错误标准规定如果作用于完整类型结果一定大于如果作用于不完整的类型则无法通过编译示例注意在某些环境中作用于空结构体或联合体结果可能是但这属于未定义的行为如空结构体或联合体在标准中属于非法类型示例代码可能会输出也可能不会通过编译依据参考不应再作用于表达式等价于在实际应用中没有任何必要写成连续的形式往往意味着逻辑错误多数由复制粘贴或错误的宏展开导致示例依据参考代码中不应作用于标识符由实现定义在语言中往往等同于常量的结果很可能与预期不符示例不同的编译器对示例代码有不同的处理有些会把当作指针有些会当作常量应改为相关依据参考不可作用于表示不存在的类型也是不完整的类型作用于是没意义的属于语言运用错误也可能是的笔误示例依据断言中的表达式不应恒为真恒为真的断言是没有意义的示例也不建议使用恒为假的断言表示异常在代码中应改用异常处理的方式依据断言中的表达式不应有副作用断言中的表达式如果有副作用不能保证在所有编译设置下都有效如标准断言会受宏的影响当该宏被定义时中的表达式不会被执行示例表达式的副作用均应在之前完成相关依据参考断言中的表达式不应过于复杂断言中的表达式不应过于复杂否则不易定位具体是哪一项不符合断言不利于调试对于逻辑与表达式应将各子表达式分成多个断言示例应改为本着使代码便于调试的理念展开工作可有效降低测试及维护成本配置断言表达式中逻辑与运算符的最大数量超过则报出表达式不应过于复杂复杂的表达式不利于阅读与调试易包含潜在的错误应适当拆分下列情况可判定为复杂表达式运算符过多有副作用的子表达式过多优先级括号嵌套层次过深函数调用或数组索引嵌套层次过深三元表达式嵌套层次过深审计工具不妨通过配置判断表达式是否合规示例配置运算符最大数量超过则报出具有副作用的子表达式最大数量超过则报出优先级括号嵌套最大层数超过则报出函数调用数组索引嵌套最大层数超过则报出三元表达式嵌套最大层数超过则报出参考不应访问填充数据内存中各对象之间可能存在填充数据这种数据只为实现内存对齐而无数值意义而且填充数据的值是标准未声明的示例如果按常见的或字节对齐的成员和之间会存在填充数据填充数据参与比较将得到错误的结果应改为即使成员之间没有填充数据也不应使用等函数比较应实现类型明确的比较接口以供调用否则很容易产生错误相关依据表达式只可用于赋值或当作参数表达式只应作为的直接右子表达式或直接作为参数其他形式均有问题本规则对不作要求示例这种问题多数是由笔误或错误的宏展开造成的相关数组下标应为整型表达式语言规定数组下标可以在中括号的右侧也可以在左侧然而这只是一种理论上的设计在实际代码中应采用约定俗成的方式即数组的名称在中括号的左侧下标在中括号的右侧示例由于相当于所以与其等价的也应该可以解释为但下标在左侧的写法容易造成运算符优先级相关的问题将下标写在右侧才是符合惯例的方式依据禁用逗号表达式逗号表达式将多个语句合成一个表达式不利于阅读且易形成笔误示例逗号表达式会使代码的静态结构含混不明总有更合理的方法替代逗号表达式逗号表达式也易被误用如又如在语句的第个和第个表达式中使用逗号表达式为惯用方式但这种方式并不值得提倡审计工具不妨通过配置决定是否放过这种方式配置是否放过语句中的逗号表达式参考转义字符的反斜杠不可误写成斜杠将转义字符的反斜杠误写成斜杠是常见笔误但仍可通过编译造成不易察觉的问题本规则是的特化示例例中是错误的但可以作为多字符常量通过编译值由实现定义又如在某些环境中执行结果和下列代码一样字符将被忽略造成逻辑错误应改为相关依据在字符常量中用转义字符表示制表符和控制字符未经转义的制表符和控制字符不利于阅读和维护示例例中字符常量为制表符易被误解为空格在终端上复制粘贴后也可能变成数目不确定的空格成为常量导致意料之外的错误故应使用转义字符相关在字符串常量中用转义字符表示制表符和控制字符未经转义的制表符和控制字符不利于阅读和维护原始字符串不受本规则限制但不建议在原始字符串中使用制表符和换行符之外的控制字符示例例中字符串包含制表符易被误解为空格在终端上复制粘贴后也可能变成数目不确定的空格导致与预期不符的结果故应使用转义字符相关不应使用非标准转义字符非标准转义字符没有可移植性也可能是忘了将反斜杠转义示例例中不是标准转义字符也不符合进制转义字符的格式这显然是路径中的反斜杠忘了转义附标准转义字符依据参考不应连接不同前缀的字符串常量连接不同前缀的字符串常量会导致标准未定义或由实现定义的行为示例规定宽字符串与窄字符串连接会导致未定义的行为规定如果一个字符串有前缀另一个没有结果以有前缀的为准其他情况由实现定义或无法通过编译如规定宽字符串与窄字符串连接的结果为宽字符串规定不同前缀的宽字符串连接结果由实现定义如为了提高可读性和可移植性字符串前缀应保持一致对于有前缀和无前缀的字符串连接在新的语言标准中均已有定义审计工具不妨通过配置决定是否放过这种连接配置是否允许有前缀和无前缀的字符串连接依据参考字符串常量中不应存在拼写错误如果含有拼写错误的常量字符串对用户可见也可以认为是产品的一种会对用户造成困扰故应认真对待示例例中存在拼写错误应改为相关常量后缀由应由大写字母组成小写字母极易与数字混淆为了提高可读性常量后缀均应由大写字母组成示例应改为后缀大小写混用的情况会使人更加困惑其中小写的和大写的混在了一起应改为配置要求后缀中所有字符均为大写或只要求小写字符不得用于后缀参考禁用进制常量进制不像进制那样符合人们的常规思维也不像进制或进制那样便于展示数据的存储格式而且语言中进制表示法只是在数字前置与十进制过于相似易被误用示例为了格式上的对齐错误地在进制数前写是常见笔误例中的实际值为参考不应使用非标准常量后缀整数常量后缀应为浮点数常量的后缀应为或非标准后缀不具备可移植性在代码中用户自定义后缀不受本规则限制示例例中为编译器特有的后缀应改为相关依据小心遗漏逗号导致的非预期字符串连接注意可能导致非预期结果的字符串连接尤其在初始化列表中小心逗号被遗漏字符串连接的适用场景字符串过长不便于显示时可将字符串拆成多个子串分行书写宏和字符串连接在一起完成一些更灵活的操作除此之外不应将一个字符串拆成多个子串示例例中初始化列表第行的与第行的中间没有逗号会连接成显然是不符合预期的这种问题属于常见笔误又如不应存在直接出现在代码中的字面数值称为使人难以理解其含义不利于阅读和维护应改用具有适当名称的常量或枚举项示例例中不能表示其含义而且当这种散落在代码的各个角落时不便于统一管理造成维护上的困难应改为具有名称的常量常量初始化表达式中的字面数值以及表示序号起始或简单状态的等小字面数值可不受本规则约束相关参考不应存在直接出现在代码中的字面常量字符串称为不利于阅读和维护应改用具有适当名称的常量示例当这种常量字符串散落在代码的各个角落时不便于统一管理造成维护上的困难应改为常量初始化表达式中的常量字符串可不受本规则约束相关参考不应使用多字符常量多字符常量指单引号之间有多个字符或非基本字符的常量如中文这种常量的值是由实现定义的而且在形式上与字符或字符串常量非常相似易被误用故建议禁用示例例中为多字符常量在代码中应改用在代码中应改用实现相关依据避免类型转换造成数据丢失应避免取值范围大的类型向取值范围小的类型隐式转换相关显式转换也应在合理的条件下完成如果对象的值在新类型取值范围内但无法用新类型精确表示转换由实现定义如果对象的值超出了新类型的取值范围会导致数据丢失以及由实现定义或未定义的行为示例将整数类型转为取值范围更小的整数类型会造成数据丢失将浮点类型转为整数类型或取值范围更小的浮点类型则可导致由实现定义或未定义的行为所以应在转换前判断是否可以安全转换或实现特定的转换逻辑下面给出判断转换是否安全的示例函数委托类将源类型转为目标类型再将目标类型转回源类型如果经两次转换得到的值与转换前的值不符说明转换存在数据丢失抛出异常浮点型转换可能导致未定义的行为所以应在转换之前判断取值范围可通过特化实现这样当对象的值超出或对象的取值范围时会抛出异常另外浮点类型转整数类型时小数部分如何取舍负数是否可以转为无符号数等问题均可以根据实际需求通过特化来实现函数的用法依据参考避免数据丢失造成类型转换失效下列表达式的类型不应被隐式或显式地转为取值范围更大的类型二元算术表达式以二元算术表达式为分枝的三元表达式这种表达式的溢出或精度损失会发生在类型转换之前使类型转换失效示例例中表达式的类型为位整型如果溢出则无法正确转为位整型的结果仍是整数小数部分将丢失应将操作数转为目标类型使算术表达式与被赋值的对象具有相同的类型这样便可避免类型转换失效相关参考避免有符号整型与无符号整型相互转换有符号整型与无符号整型相互转换易导致意料之外的错误整型转换规则如果向布尔型以外的其他整数类型转换且值在新类型取值范围内值不变否则如果新类型为无符号整型将值不断加减直至进入新类型取值范围为新类型最大值否则如果新类型为有符号整型相关转换由实现定义负数转为无符号整数往往会得到意料之外的结果无符号整数转为有符号整数也可能导致移植相关的问题所以应避免有符号整型与无符号整型之间的隐式转换相关显式转换也应在合理的条件下完成示例例中有符号整数的值为无符号整数的值为理应小于但由于类型提升会被转为无符号整数值为无符号整数的最大值的实际结果为依据参考避免与相互转换与相互转换会打破类型限制是不安全的类型转换语言的某些传统接口会使用可不受本规则限制但在代码中应避与相互转换示例例中参数可以随意接受非对象的指针进而导致标准未定义的行为代码的正确性单方面依赖开发者是不可靠的相关依据参考避免向下类型转换从基类到派生类的向下类型转换往往意味着现有接口已经不能满足需求故应避免这种转换示例例中接口对基类参数进行向下类型转换是不利于维护的当这种特殊处理较多时应利用多态方法合理重构相关参考指针与整数不应相互转换指针与整数相互转换容易造成地址不完整寻址错误降低可移植性等多种问题指针与整数的转换由实现定义整数的符号和取值范围可能与指针有冲突错误的值转为指针也会导致标准未定义的行为在某些平台上指针与可以安全转换但不具备可移植性审计工具不妨通过配置决定是否放过这种转换标准规定指针可以转为或但也声明了这些类型不是编译器必须实现的类型示例例中将指针转为是不符合要求的指针的值可能会超过的范围配置是否放过指针与的转换相关依据参考类型转换不应去掉等属性去掉等属性会使相关机制失去意义往往意味着设计上的缺陷也会导致标准未定义的行为示例通过去掉或的转换修改相关对象会导致标准未定义的行为又如例中为常量成员函数用去掉指针的限定是不符合要求的如果成员的改变只起辅助作用而不影响对象状态可将成员设为否则应重新设计类如依据参考不应转换无继承关系的指针或引用无继承关系的指针或引用之间没有逻辑关系转换意味着设计缺陷或逻辑错误示例基本类型之间没有继承关系转为属于逻辑错误导致标准未定义的行为有时为了考察对象内部结构需要将对象指针转为等类型但这种转换脱离了类型的保护也会降低代码的可移植性审计工具不妨通过配置决定是否放过这种转换又如例中与没有继承关系从和继承指针为类型但实际指向的实例这种情况下将直接强制转为类型的指针将得到错误的结果这种问题在实际代码中也很常见本规则限制无继承关系的风格类型转换以及转换不限制和转换示例中的转换将得到编译错误从而锁定问题如果和是多态类型用会得到正确的结果例外例中和是无继承关系的类但实现了向的转换运算符和之间存在逻辑关系这时的风格类型转换可不受本规则限制但不符合规则这种情况仍然不能使用参见配置是否放过与的转换相关依据参考不应转换无继承关系的指针或引用继承表示派生类是基类的某种扩展而非继承往往表示派生类是基类的某种例外基类的方法不再适用于派生类的对象示例例中派生类是对基类的改造再用类方法处理类对象是有问题的相关依据非类的指针与基本类型的指针不应相互转换非对象相关数据之间存在特殊的内在关系尤其是虚函数表指针虚基类表指针这种由实现定义的运行时数据不应当作普通二进制数据处理非对象的指针也不应与等基本类型的指针相互转换示例例中是多态类型函数将对象写入文件的第一个参数被隐式转为不符合本规则要求对象的虚表指针等数据一并被写入文件但虚表指针是运行时数据不应被保存函数从文件中读取对象便破坏了运行时数据相关参考不同的字符串类型之间不可直接转换和直接转换并不进行字符集转换属于语言运用错误以及之间均不可直接转换本规则是的特化示例示例代码显然是错误的应改用等字符集编码转换函数由于一般针对二进制数据与其他字符串类型之间的转换可不受本规则约束但不应作为二进制数据的类型参见相关参考避免向对齐要求更严格的指针转换访问不符合对齐要求的数据会导致标准未定义的行为对象的存储地址与其占用空间的长度相关如变量的地址往往是其长度的整数倍这种机制称为内存对齐可提高处理器访问数据的效率如果对象的地址不符合这种要求访问对象的效率就会降低在某些平台上甚至会崩溃详见每种对象类型都有一个对齐要求一般来说占用空间越大的类型对齐要求越严格如对象可以存储在任意地址而对象的地址只应是的整数倍所以解引用由指针转换成的指针很可能会造成示例二进制数据转向结构化数据时这种问题较为常见例中与型变量的对齐要求不同不应直接转换应改为用等函数将低对齐要求的数据复制到高对齐要求的对象中是避免相关问题的通用模式相关依据参考避免转换指向数组的指针指针的逻辑大小与类型相关转换指向数组的指针极易造成元素定位空间计算等方面的错误示例例中派生类对象的数组被转换成了基类指针函数中对数组元素的定位将是错误的另外在回收动态分配的数组时如果指针的类型与实际元素的类型不一致会导致标准未定义的行为这是一个危险的问题本规则针对所有数组相关的隐式和显式类型转换依据参考避免转换函数指针函数指针和不兼容的类型转换会导致标准未定义的行为示例例外对函数指针进行转换或等动态导入函数的系统接口可不受本规则约束依据参考向下动态类型转换应使用向下动态类型转换应使用以保证安全性示例如果实际指向的不是类对象使用会得到一个空值便于进一步处理其他方式的转换会得到无法判断对错的结果注意虚基类指针只能通过转换为派生类指针否则导致标准未定义的行为应尽量减少向下类型转换参见相关依据参考对表达式不应进行类型转换表达式本身是类型明确的转换表达式的类型也容易造成分配访问或回收相关的错误示例例中数组被转为数组由于元素个数不兼容也会导致内存访问与回收的错误相关不应存在多余的类型转换多余的类型转换是没有意义的往往意味着某种错误不应出现下列情况原类型与转换后的类型完全相同非转换的结果没有被读取示例例中参数转换后的类型与转换前完全相同参数转换后没有被读取均不符合要求应改为可用转换表示有意放弃读取但对无返回值的函数不应再使用转换如参考可用其他方式完成的转换不应使用将地址强行按另一种类型解释不考虑转换需要的逻辑可用完成的转换不应使用示例输出如果想将派生类对象的地址转为基类指针应使用进行正确的偏移转换使用不会进行偏移转换得到的成员不是真实的成员相关依据参考合理使用是一种不安全的类型转换如果必须使用需提供合理的注释说明示例设例中读取并返回文件的二进制数据用将二进制数据直接转为对象是不安全的妥善的做法是根据文件数据将对象的成员逐一构造出来可参见介绍的方法这样也可以及时发现并处理问题又如例中是不受控制的外部接口它的返回类型不完整或不可用甚至返回的地址也不遵循内存模型需要将其重解释为另一种类型才能探究其内部结构和数据是为了解决这个问题而自定义的类型这种情况可以使用完成这种非常规转换但需注明这种情况产生的原因相关参考在代码中禁用风格类型转换风格类型转换易造成数据丢失或逻辑错误在代码中应使用等方法代替风格类型转换示例例中和是两种不相关的类型用语言的转换方式是可以转换成功的但并没有逻辑意义在代码中应使用或等方法在编译时或运行时保障转换的有效性参考避免缓冲区溢出缓冲区的本意是指内存等高速设备上的区域程序在这种区域内接收或处理数据之后再一并输出到网络或磁盘等低速环境起到提高效率的作用故称缓冲区连续的内存区域均可称为缓冲区在语言中对应数组等结构缓冲区之外可能是程序的其他数据也可能是函数返回地址资源分配信息等重要数据对缓冲区的越界读写往往意味着逻辑错误而且会使程序遭到破坏示例例中函数返回用户输入的字符串其长度不确定而缓冲区的长度为字节如果用户输入超过这个长度就会使程序遭到破坏这种问题称为缓冲区溢出也是程序遭受攻击的常见原因缓冲区溢出可造成严重危害如破坏堆栈或段结构扰乱程序执行改写关键信息篡改程序行为注入并运行恶意代码攻击高权限进程获取非法权限所以将读写限定在缓冲区边界之内是十分重要的示例代码应改为与不同当源字符串长度超过指定限制时会结束复制但要注意对空字符的处理相关参考数组下标不可越界数组下标超过数组大小范围会导致标准未定义的行为设数组元素个数为为指向数组第一个元素的指针为整数标准规定当且时的结果不会溢出当等于时的结果不会溢出但不可对其解引用当或时的结果可能会溢出使数组下标超出的运算可能会使指针值溢出导致未定义的行为示例相关依据参考为缓冲区分配足够的空间为缓冲区分配足够的空间避免溢出等问题示例字符串以空字符结尾在分配字符串空间时不可漏掉空字符的空间又如例中函数为型数组分配了个字节的空间而不能被整除最后一个元素会越界虽然函数返回已对齐的地址但这种代码往往意味着因子的缺失应改为相关参考等函数不应作用于非对象等具有填充功能的函数不应作用于非对象否则会破坏其数据的内在关系本规则是的特化示例例中填充非对象其虚函数表指针会被破坏造成严重的运行时错误相关参考等函数长度相关的参数不应有误对于及同类函数表示长度的参数不应存在常见笔误示例长度和填充值参数被写反是常见笔误应改为又如等函数的长度单位为字节不应遗漏因子应改为又如设为对象指针应改为作用于指针并不能获取到对象的大小可参见的进一步讨论又如设是对象应改为这是常见的复制粘贴错误又如长度参数不应为比较表达式应改为括号的错误嵌套也是常见的笔误参考等函数填充值相关的参数不应有误等函数的填充值参数会被转为型所以填充值不应超出的取值范围示例例中填充值为超出了的范围在实际代码中也可能是长度参数与填充值参数被写反了依据参考避免空指针解引用通过指针的值访问相应地址中的数据称为解引用空指针是没有指向任何数据的指针空指针解引用是一种逻辑错误会导致标准未定义的行为示例例中指针为空的状态可以到达解引用处往往会引发段错误而导致崩溃例外在代码中通过指针访问静态成员不算作解引用可不受本规则约束但这种风格易引起维护者的疑虑而增加维护成本注意非静态成员函数是对象数据的访问方法即使非静态成员函数没有实际地访问对象数据也不应通过空指针调用非静态成员函数否则仍属于逻辑错误而且如果调用的是虚函数或虚基类的成员函数也会造成崩溃依据参考注意逻辑表达式内的空指针解引用在逻辑表达式中需注意逻辑关系以及运算符优先级不可出现空指针解引用等问题示例设是指针所指对象的非静态成员函数当为空时执行的右子表达式恰好使空指针被解引用的优先级高于由的左子表达式可知可能为空而右子表达式却没有限制导致空指针被解引用这是颠倒了对指针的判断和解引用次序属于语言运用错误依据参考不可解引用未初始化的指针未初始化的指针具有不确定的值对其解引用会导致标准未定义的行为往往会造成严重错误示例例中指针定义后未被初始化可能指向不可访问的空间也可能指向已分配的空间对其读写可能会导致崩溃也可能会扰乱程序的行为造成难以排查的错误相关依据参考不可解引用已被释放的指针已被释放的指针指向失效的内存空间对其解引用会导致标准未定义的行为往往会造成严重错误示例本来指针指向有效的内存空间但由于某种原因相关内存被释放的值不变但已无效这种情况被形象地称为指针悬挂未经初始化的指针和这种被悬挂的指针统称野指针均指向无效地址不可被解引用应关注对象的生命周期避免内层作用域中的地址向外层传递如例中局部变量的地址被传给了外层作域中的指针的生命周期结束后会成为野指针另外在代码中应避免持有可被自动销毁的对象地址如容器中对象的地址智能指针所指对象的地址等例中指针记录了容器中对象的地址根据容器持有对象的策略随着元素的增加原有对象的地址可能不再有效又如例中指针记录了所指对象的地址当指向新的对象时原对象的地址不再有效相关依据参考避免无效的空指针检查当指针的值一定不为空时再对其进行检查是没有意义的往往意味着逻辑错误示例标准规定默认运算符的返回值不会为空如果分配失败则抛出异常所以这种检查和相关错误处理是无效的应改为又如对于可接受空指针的接口不必总在调用前判断指针是否为空否则会使代码变得繁琐关键字或函数可以作用于空指针调用之前的检查是没有意义的相关依据不应重复检查指针是否为空重复的空指针检查是不必要的使代码显得繁琐且干扰编译器优化示例相关不应将非零常量值赋值给指针固定地址是不可移植的且存在安全隐患示例示例代码的本意是声明一个表示无效地址的值但在位系统中这个地址可能是有效的又如示例代码假设在特定地址可以找到特定的函数将该地址赋给一个指针并调用这种假设是不可移植的也可能本身就是错误的会导致崩溃而且函数地址往往也属于敏感信息不应被写入代码否则一旦泄露攻击者可以更改预期地址上的数据导致恶意代码被执行某些框架或系统会以表示无效地址但不具备通用性审计工具不妨通过配置决定是否放过例外如果固定地址受环境支持如固定的设备地址可不受本规则约束但应通过接口获取地址避免将常量地址写死在代码中配置是否允许作为指针的值相关参考不应使用常量表示空指针在代码中应使用表示空指针在代码中应使用表示空指针标准允许等值为的常量表达式作为空指针常量但易与非指针混淆不利于阅读和维护示例应改为相关依据参考不应使用对指针赋值用对指针赋值是非常怪异的会误导维护者而且也很可能是逻辑错误本规则是的特化示例应改为相关参考不应使用等字符常量对指针赋值用等字符常量对指针赋值是非常怪异的往往意味着逻辑错误本规则是的特化示例应改为相关参考指针不应与比较大小指针与比较大小是非常怪异的往往是某种笔误本规则是的特化示例设为指针如果判断指针是否为空只应将指针与或比较其他常量均不符合要求相关参考指针不应与等字符常量比较大小指针与等字符常量比较大小是非常怪异的往往是某种笔误本规则是的特化示例设为指针这种情况很有可能是漏写了号否则只应将指针与或比较相关参考指针与空指针不应比较大小指针与空指针比较大小往往意味着逻辑错误而且只有指向同一数组或对象的指针才能比较大小否则会导致标准未定义的行为空指针不指向任何数组或对象故不应比较指针与空指针的大小指针与空指针之间只应使用或比较其他比较运算符均不符合要求本规则是的特化示例设为指针相关依据参考不应判断指针是否为空正常情况下指针不会为空而且判断指针是否为空会影响编译器对指针的优化造成难以预料的后果在某些环境中通过空指针调用非静态成员函数时指针可能为空但这并不符合标准值得强调的是任何情况下都不应逃避解引用空指针造成的问题示例假设函数不应返回空指针而某个错误导致其返回了空指针程序本应崩溃而函数却逃避了崩溃这非但不能真正地解决问题反而使问题难以定位使程序难以调试大大降低了可维护性参考析构函数中不可使用析构函数中不可使用否则造成无限递归示例参考禁用使用须保证对象是用创建的但不能用或使用之后不能再访问相关非静态成员不能在析构函数中使用由于限制条件易被打破对框架以及语言工具之外的业务类或算法类代码建议禁用示例如果有必要使用应将类的析构函数设为非使对象只能通过创建并确保执行后指针再也不会被访问而且不能用创建数组否则仍然存在内存泄漏等问题判断转换是否成功转换指针失败会返回空指针转换引用失败会抛出异常如果不作判断则失去了使用的意义示例应改为使用会产生一定的开销如果不对其结果作判断还不如使用等转换但本规则集合不建议采用非的动态类型转换参见相关依据参考指针在释放后应置空内存空间被回收后相关指针不再有效这时应将指针设为空指针可避免重复释放等问题如果后续对指针有错误访问也可使问题立即显现出来便于修正示例例中函数释放指针后将其置为空指针如果函数被外界反复调用也没有问题本规则是对指针悬挂等问题的有效措施参见相关参考避免由信号处理产生的数据竞争异步信号处理函数的调用会随时打断主程序的流程当处理函数返回后主程序在被打断的位置继续执行这种方式称为中断与执行非并发的线程相似但没有锁等同步机制而且信号处理函数本身也可能被中断所以在信号处理函数中访问共享数据应格外小心异步信号处理函数的安全模式调用异步信号安全函数执行清理或结束进程如等对等类型的共享对象赋值主程序周期性地检查共享对象并执行相应动作利用等函数使流程跳转到主程序中的预定位置通过管道等方式与主程序通信向管道写入一个字节主程序监控该管道并执行相应动作只应选择其中一种方式且尽量避免访问共享数据否则对共享数据的错误处理会使程序产生未定义的行为示例例中信号处理函数和主程序均访问了共享数据中的可以在中的执行之前或中途执行造成非预期的结果应改为用和之间的值对类型的对象赋值可以保证原子性超出范围的赋值或赋值之外的操作不能保证原子性需要避免相关依据参考处理信号时避免使用非异步信号安全函数不处理共享数据也不会影响程序状态的函数以及不会被信号中断的函数称为异步信号安全函数处理信号时只应使用这种函数示例不是异步信号安全函数例中两个的输出结果可能会交织在一起甚至会产生运行时错误相关依据参考等信号的处理函数不可返回与计算异常相关的信号由不可恢复的错误引起相关信号处理函数应终止程序的执行否则导致标准未定义的行为示例当发生除等计算异常时程序会收到信号这种信号对应的处理函数应使用等函数终止程序的执行不可正常返回否则可能会造成更严重的损失应改为或使用和使流程跳转到主程序中的预定位置在这种模式下实现程序的功能如果收到了信号流程就会跳转到依据参考禁用函数函数具有一定的局限性且各平台实现差异较大可用函数代替示例设例中是某种信号的处理函数在某些平台上指定的函数只能被执行一次所以需要在中再次调用指定处理函数但如果程序在运行到和之间时收到同样的信号会执行不符合预期的默认处理函数这是一种竞态条件而在另一些平台上指定的函数会一直有效再次调用是多余的函数不存在这些问题也可提供更多的功能但要注意该函数尚未在语言标准中定义相关依据参考访问共享数据应遵循合理的同步机制如果一份数据同时被多个线程进程或中断处理过程读写会产生不确定的结果这种情况称为数据竞争会导致标准未定义的行为应落实合理的同步机制来控制访问共享数据的先后顺序示例这个函数意在每次被调用都可以返回不同的整数但如果多个线程同时执行会使读取计算写入等步骤交织在一起得到错误的结果这是一种典型的数据竞争应改为其中是标准原子类将对象持有的整数增并返回之前的值这个过程不会被多个线程同时执行只能依次执行从而保证了返回值的唯一性和正确性对共享数据访问次序的控制称为同步可使用锁条件变量原子操作等方法实现对线程的同步与共享数据相关但未落实同步机制的函数不应在多线程环境中使用如与线程同步不同中断处理过程的同步较为特殊可参见的进一步讨论考虑比数据竞争更高层面的问题如果程序的正确性依赖进线程处理数据的特定时序一旦这种特定时序被打破便会产生错误或漏洞攻击者可以抢在某关键过程前后通过修改共享数据达到攻击目的这种情况称为竞态条件如如果指向共享数据那么攻击者可以通过修改共享数据实现对程序流程的劫持比如在处的值本为攻击者在之前改变的值迫使流程向或处跳转关于竞态条件的进一步讨论可参见等规则相关依据参考避免在事务中通过路径多次访问同一文件攻击者可以在两次通过路径访问文件的中途对文件做手脚从而造成不良后果这种问题称为有时需要先检查文件的某种状态如果状态满足条件的话再使用该文件如果检查和使用都是通过路径完成的攻击者可以在中途将文件替换成不满足条件的文件如将文件替换成指向另一个文件的链接从而对系统造成破坏这是一种典型的竞态条件示例示例代码先通过路径判断文件是否存在如果存在则不作处理如果不存在则再次通过路径创建文件并写入数据如果攻击者把握住时机在程序执行到和之间时按创建指向其他文件的链接那么被指向的文件会遭到破坏尤其是当被攻击的进程权限比较高时破坏力是难以控制的应只通过路径打开文件对象一次只通过文件对象操作文件利用模式即可保证在文件不存在时创建文件文件存在时返回空注意目前的尚无法完成与模式相同的功能相同功能的代码要用实现依据参考避免在事务中多次非同步地访问原子对象原子对象可以保证某些特定操作的原子性但特定操作的组合并不具备原子性非同步地访问原子对象仍然存在数据竞争示例设为线程函数原子对象在表达式中出现了多次其读取计算写入等过程在多线程中仍然是交织在一起的造成数据竞争应改为对于一些复杂的原子运算如可采用方法同步首先读取原子对象的值经过运算得到新值再通过更新原子对象的值具有原子性将和原子对象当前值比较相等则说明在运算过程中原子对象没有被其他线程更新将原子对象的值设为不相等则说明原子对象已被其他线程更新将设为原子对象当前值再重复这个过程直到原子对象可用更新是重要的原子对象同步手段在实际代码中可与等函数对应相关参考避免死锁对于锁等资源错误的请求时序或管理方式会使程序永远陷入等待状态这种问题称为死锁示例设是非递归互斥量锁定互斥量后调用而也会锁定互斥量导致等待解锁而返回之前不可能解锁这是一种导致死锁的逻辑错误也明确规定在同一线程中不可重复锁定非递归互斥量另外线程之间相互等待对方解锁也是死锁的主要原因如设和是两个可以并发执行的函数如果被锁定被锁定等待解锁而等待解锁这种相互等待导致了死锁的局面例中和是具名全局对象在各线程中按统一的顺序加锁可避免死锁在更普遍的情况下为不同对象加锁前可使对象按某种内在的标准排序再依次加锁如为每个对象分配一个以标识不同的对象每次小的先加锁可有效避免相互等待造成的死锁示例代码忽略了相等的情况在实际代码中应补全否则也会造成第一个例子中的问题依据参考避免异步终止线程资源的使用情况在异步过程中是难以掌控的异步终止线程往往会导致泄漏或死锁等严重问题示例以线程库为例和是两个相关的异步过程通过指定其线程可以随时被终止调用终止线程在一个过程中暴力终止另一个过程是非常危险的会使锁信号量或动态分配的资源无法释放等选项等以及具有相同功能的选项或均不应使用应使线程主动执行清理并正常结束执行相关参考避免异步终止共享对象的生命周期共享对象的使用情况在异步过程中是难以掌控的贸然终止共享对象的生命周期往往会导致标准未定义的行为示例设例中创建执行函数的线程与是异步过程共享对象在返回后失效如果继续访问共享对象就会出错应等待线程执行完毕或调整共享对象的生命周期相关依据参考避免虚假唤醒造成同步错误条件不满足时条件变量也可以被唤醒这种情况称为虚假唤醒条件变量被唤醒后应检查相关条件是否满足否则会造成同步相关的错误示例设例中是条件变量代表相关条件等待条件被其他异步过程满足条件的判断与更改应是互斥的会解锁并进入等待状态当得到或的通知后会退出等待状态并再次加锁但在条件不满足时也可能退出等待原因主要有一个条件变量对应多个条件与当前条件无关的条件被满足并通知了条件变量在退出等待并加锁的过程中其他线程使条件不被满足等待过程被信号打断这些问题取决于程序和系统的具体实现在循环中等待并判断条件可一并解决这些问题参考避免并发访问位域造成的数据竞争相邻的位域成员可能在一个存储单元中所以并发访问位域也可能造成数据竞争示例设例中和是可以并发执行的函数位域成员和在一个存储单元中对或的更新相当于用新数据更新存储单元的值再将存储单元的值整体写入内存这个过程如果是异步并发执行的就会产生错误所以对不同位域成员的并发访问也应保证合理的同步措施相关依据参考多线程环境中不可使用函数在多线程环境中使用函数会导致标准未定义的行为示例例中是线程函数标准指明在多线程环境中使用函数会导致未定义的行为相关依据参考空格应遵循统一风格与运算符标点符关键字相关的空格应遵循统一风格过于随意的空格会干扰阅读甚至形成笔误本规则暂不限定具体风格但强调一致性同类运算符标点符关键字的空格方式应保持一致等变长空白符不应用作空格示例例中运算符和关键字相关的空格风格不一致代码显得很混乱本规则是的泛化该规则描述了一种由空格造成的错误相关大括号应遵循统一风格大括号应遵循统一的换行和缩进风格否则不利于阅读和维护甚至形成笔误命名空间类函数体复合语句等不同类别的大括号换行方式可以不同但同类大括号的换行方式应该是一致的本规则暂不限定具体风格但强调一致性示例例中大括号换行的方式不一致代码显得很混乱本规则是的泛化该规则描述了一种由换行造成的错误相关赋值表达式不应作为子表达式赋值及复合赋值表达式作为子表达式可读性较差易产生求值顺序或运算符优先级相关的问题示例设为变量连续赋值是一种惯用方式但不值得提倡如审计工具不妨通过配置决定是否放过这种方式配置是否允许连续赋值相关参考自增自减表达式不应作为子表达式自增自减表达式作为子表达式易使人费解也易产生求值顺序相关的问题示例应改为相关参考控制条件应为型表达式如果控制条件均为型表达式可使逻辑结构更清晰有效避免隐式类型转换造成的问题示例例中和不应直接作为条件为型可直接作为条件应改为循环条件三元表达式的条件等所有可作为控制条件的表达式均受本规则限制例外允许将声明作为条件这种情况可不受本规则限制相关参考的子表达式应为型表达式如果的子表达式均为型表达式可使逻辑结构更清晰有效避免隐式类型转换或运算符误用造成的问题示例设为指针为整型变量应改为相关参考的子表达式应为后缀表达式如果的子表达式均为后缀表达式可使逻辑结构更清晰有效避免各种优先级问题后缀表达式是语言的文法概念也是一类表达式的总称只包含标识符或常量的表达式用小括号括起来的表达式用于数组元素求值的表达式函数调用函数式类型转换表达式表达式后置表达式等表达式本规则意在强调子表达式应适当地用括号括起来以便提高可读性并确保程序的行为符合开发者的意图示例设为型变量为整型变量例中不是后缀表达式应使用括号括起来又如即使知道的优先级高于也应使用括号将的子表达式括起来如例外当的子表达式运算符与其相同时可不受本规则约束依据参考在代码中和不应混用在代码中和不应混用应统一使用示例相关参考在代码中用代替标识符由实现定义在语言中往往等同于常量无法有效区分整数与指针用可避免这种问题示例表示空指针所以应该调用参数为指针的重载函数但不同的编译器对这段代码有不同的处理有的无法通过编译有的编译执行后会输出用代替可解决这种问题依据参考避免多余的括号重复的或与优先级无关的括号使代码显得繁琐应去掉宏定义中的括号不受本规则限制示例例中括号均作用于后缀表达式与优先级无关可参见对后缀表达式的说明应去掉多余的括号注意设立本规则并不是为了提倡省略括号如果可以更好地表达逻辑意义或不确定运算符优先级时应及时使用括号参考避免多余的分号多余的分号使代码显得繁琐也可能意味着某种错误应去掉示例附录未定义行为成因列表未定义行为成因列表与标准解读结语保障软件安全提升产品质量是宏大的主题需要不断地学习探索与实践也难以在一篇文章中涵盖所有要点这条规则就暂且讨论至此了欢迎提供修订意见和扩展建议由于本文档是自动生成的请不要直接编辑本文档可在区发表高见管理员修正数据库后会在致谢列表中存档此致祝编程愉快',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-10-25 21:21:49',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://npm.elemecdn.com/anzhiyu-blog-static@1.0.4/img/avatar.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://hosheazhang.github.io/" title="博客"><img class="back-menu-item-icon" src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://github.com/HosheaZhang/cmu15445" title="cmu15445"><img class="back-menu-item-icon" src="https://image.anheyu.com/favicon.ico" alt="cmu15445"/><span class="back-menu-item-text">cmu15445</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">Hoshea的主页</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button only-home" id="travellings_button" title="随机前往一个开往项目网站"><a class="site-page" onclick="anzhiyu.totraveling()" title="随机前往一个开往项目网站" href="javascript:void(0);" rel="external nofollow" data-pjax-state="external"><i class="anzhiyufont anzhiyu-icon-train"></i></a></div><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> Newest Comments</span></div><div class="aside-list"><span>loading...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/360/" style="font-size: 1.05rem;">360<sup>1</sup></a><a href="/tags/C/" style="font-size: 1.05rem;">C++<sup>5</sup></a><a href="/tags/CMU15445/" style="font-size: 1.05rem;">CMU15445<sup>2</sup></a><a href="/tags/CMake/" style="font-size: 1.05rem;">CMake<sup>1</sup></a><a href="/tags/CSAPP/" style="font-size: 1.05rem;">CSAPP<sup>9</sup></a><a href="/tags/MYSQL/" style="font-size: 1.05rem;">MYSQL<sup>6</sup></a><a href="/tags/VSCODE/" style="font-size: 1.05rem;">VSCODE<sup>1</sup></a><a href="/tags/dfs/" style="font-size: 1.05rem;">dfs<sup>1</sup></a><a href="/tags/gdb/" style="font-size: 1.05rem;">gdb<sup>1</sup></a><a href="/tags/git/" style="font-size: 1.05rem;">git<sup>1</sup></a><a href="/tags/github/" style="font-size: 1.05rem;">github<sup>1</sup></a><a href="/tags/linux/" style="font-size: 1.05rem;">linux<sup>6</sup></a><a href="/tags/markdown/" style="font-size: 1.05rem;">markdown<sup>1</sup></a><a href="/tags/ssh/" style="font-size: 1.05rem;">ssh<sup>1</sup></a><a href="/tags/workflow/" style="font-size: 1.05rem;">workflow<sup>3</sup></a><a href="/tags/%E4%B8%AD%E7%AD%89/" style="font-size: 1.05rem;">中等<sup>9</sup></a><a href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" style="font-size: 1.05rem;">动态规划<sup>2</sup></a><a href="/tags/%E5%91%A8%E8%B5%9B/" style="font-size: 1.05rem;">周赛<sup>9</sup></a><a href="/tags/%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/" style="font-size: 1.05rem;">学习计划<sup>1</sup></a><a href="/tags/%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3/" style="font-size: 1.05rem;">报错解决<sup>4</sup></a><a href="/tags/%E6%A0%A1%E6%8B%9B/" style="font-size: 1.05rem;">校招<sup>1</sup></a><a href="/tags/%E6%A8%A1%E6%8B%9F/" style="font-size: 1.05rem;">模拟<sup>6</sup></a><a href="/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/" style="font-size: 1.05rem;">每日一题<sup>3</sup></a><a href="/tags/%E6%B1%87%E7%BC%96/" style="font-size: 1.05rem;">汇编<sup>1</sup></a><a href="/tags/%E6%BA%90%E7%A0%81/" style="font-size: 1.05rem;">源码<sup>2</sup></a><a href="/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/" style="font-size: 1.05rem;">滑动窗口<sup>1</sup></a><a href="/tags/%E7%AE%80%E5%8D%95/" style="font-size: 1.05rem;">简单<sup>3</sup></a><a href="/tags/%E7%BC%96%E8%AF%91/" style="font-size: 1.05rem;">编译<sup>1</sup></a><a href="/tags/%E8%84%91%E7%AD%8B%E6%80%A5%E8%BD%AC%E5%BC%AF/" style="font-size: 1.05rem;">脑筋急转弯<sup>1</sup></a><a href="/tags/%E8%B4%AA%E5%BF%83/" style="font-size: 1.05rem;">贪心<sup>2</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>Archives</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/10/"><span class="card-archive-list-date">October 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">42</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2022/10/"><span class="card-archive-list-date">October 2022</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2022/07/"><span class="card-archive-list-date">July 2022</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">4</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2022/04/"><span class="card-archive-list-date">April 2022</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">7</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item on" id="consoleCommentBarrage" onclick="anzhiyu.switchCommentBarrage()" title="热评开关"><a class="commentBarrage"><i class="anzhiyufont anzhiyu-icon-message"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/" itemprop="url">开发笔记</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/C/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>C++</span></a><a class="article-meta__tags" href="/tags/360/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>360</span></a></span></div></div><h1 class="post-title" itemprop="name headline">360CPP代码规范</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2023-10-25T13:19:49.000Z" title="Created 2023-10-25 21:19:49">2023-10-25</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2023-10-25T13:21:49.790Z" title="Updated 2023-10-25 21:21:49">2023-10-25</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-wordcount"><i class="anzhiyufont anzhiyu-icon-file-word post-meta-icon" title="文章字数"></i><span class="post-meta-label" title="文章字数">Word count:</span><span class="word-count" title="文章字数">120k</span><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-clock post-meta-icon" title="阅读时长"></i><span class="post-meta-label" title="阅读时长">Reading time:</span><span>482min</span></span><span class="post-meta-separator"></span><span class="post-meta-pv-cv" id="" data-flag-title="360CPP代码规范"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">Post View:</span><span id="busuanzi_value_page_pv"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为南京"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>南京</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://hoshea-1318436778.cos.ap-nanjing.myqcloud.com/image360.jpg"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="http://example.com/2023/10/25/360CPP%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"><header><a class="post-meta-categories" href="/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/" itemprop="url">开发笔记</a><a href="/tags/C/" tabindex="-1" itemprop="url">C++</a><a href="/tags/360/" tabindex="-1" itemprop="url">360</a><h1 id="CrawlerTitle" itemprop="name headline">360CPP代码规范</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">Hoshea Zhang</span><time itemprop="dateCreated datePublished" datetime="2023-10-25T13:19:49.000Z" title="Created 2023-10-25 21:19:49">2023-10-25</time><time itemprop="dateCreated datePublished" datetime="2023-10-25T13:21:49.790Z" title="Updated 2023-10-25 21:21:49">2023-10-25</time></header><h1 id="C-C-安全规则集合"><a href="#C-C-安全规则集合" class="headerlink" title="C/C++ 安全规则集合 "></a>C/C++ 安全规则集合 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shields.io/badge/version-1.3.2-brightgreen" alt="Version"></h1><blockquote>
<p>Bjarne Stroustrup: “<em>C makes it easy to shoot yourself in the foot; C++ makes it harder, but when you do it blows your whole leg off.</em>”</p>
</blockquote>
<p>&emsp;&emsp;针对 C、C++ 语言，本文收录了 487 种需要重点关注的问题，可为制定编程规范提供依据，也可为代码审计以及相关培训提供指导意见，适用于桌面、服务端以及嵌入式等软件系统。<br>&emsp;&emsp;每个问题对应一条规则，每条规则可直接作为规范条款或审计检查点，本文是适用于不同应用场景的规则集合，读者可根据自身需求从中选取某个子集作为规范或审计依据，从而提高软件产品的安全性。<br><br/></p>
<h2 id="规则说明"><a href="#规则说明" class="headerlink" title="规则说明"></a>规则说明</h2><p>规则按如下主题分为 17 个类别：</p>
<ol>
<li><a href="#__security">Security</a>：敏感信息防护</li>
<li><a href="#__resource">Resource</a>：资源管理</li>
<li><a href="#__precompile">Precompile</a>：预处理、宏、注释</li>
<li><a href="#__global">Global</a>：全局及命名空间作用域</li>
<li><a href="#__type">Type</a>：类型设计与实现</li>
<li><a href="#__declaration">Declaration</a>：声明</li>
<li><a href="#__exception">Exception</a>：异常</li>
<li><a href="#__function">Function</a>：函数实现</li>
<li><a href="#__control">Control</a>：流程控制</li>
<li><a href="#__expression">Expression</a>：表达式</li>
<li><a href="#__literal">Literal</a>：常量</li>
<li><a href="#__cast">Cast</a>：类型转换</li>
<li><a href="#__buffer">Buffer</a>：缓冲区</li>
<li><a href="#__pointer">Pointer</a>：指针</li>
<li><a href="#__interruption">Interruption</a>：中断与信号处理</li>
<li><a href="#__concurrency">Concurrency</a>：异步与并发</li>
<li><a href="#__style">Style</a>：样式与风格</li>
</ol>
<p>每条规则包括：</p>
<ul>
<li>编号：规则在本文中的章节编号，以“R”开头，称为 Section-ID</li>
<li>名称：用简练的短语描述违反规则的状况，以“ID_”开头，称为 Fault-ID</li>
<li>标题：规则的定义</li>
<li>说明：规则设立的原因、违反规则的后果、示例、改进建议、参照依据、参考资料等内容</li>
</ul>
<p>如果违反规则，后果的严重程度分为：</p>
<ul>
<li>Error：直接导致错误或形成安全漏洞</li>
<li>Warning：可导致错误或形成安全隐患</li>
<li>Suspicious：可疑的代码，需进一步排查</li>
<li>Suggestion：代码质量降低，应依照建议改进</li>
</ul>
<p>规则的说明包含：</p>
<ul>
<li>示例：规则相关的示例代码，指明符合规则（Compliant）的和违反规则（Non-compliant）的情况</li>
<li>相关：与当前规则有相关性的规则，可作为扩展阅读的线索</li>
<li>依据：规则依照的 ISO/IEC 标准条目，C 规则以 ISO/IEC 9899:2011 为主，C++ 规则以 ISO/IEC 14882:2011 为主</li>
<li>配置：某些规则的细节可灵活设置，审计工具可以此为参照实现定制化功能</li>
<li>参考：规则参考的其他规范条目，如 C++ Core Guidelines、MISRA、SEI CERT Coding Standards 等，也可作为扩展阅读的线索</li>
</ul>
<p>规则的相关性分为：</p>
<ul>
<li>特化：设规则 A 的特殊情况需要由规则 B 阐明，称规则 B 是规则 A 的特化</li>
<li>泛化：与特化相反，称规则 A 是规则 B 的泛化</li>
<li>相交：设两个规则针对不同的问题，但在内容上有一定的交集，称这两个规则相交</li>
</ul>
<p>规则以“<code>标准名称:版本 章节编号(段落编号)-性质</code>”的格式引用标准，如“<code>ISO/IEC 14882:2011 5.6(4)-undefined</code>”，表示引用 C++11 标准的第 5 章第 6 节第 4 段说明的具有 undefined 性质的问题。  </p>
<p>其中“性质”分为：</p>
<ul>
<li>undefined：可使程序产生未定义的行为，这种行为造成的后果是不可预期的</li>
<li>unspecified：可使程序产生未声明的行为，这种行为由编译器或环境定义，具有随意性</li>
<li>implementation：可使程序产生由实现定义的行为，这种行为由编译器或环境定义，有明确的文档支持</li>
<li>deprecated：已被废弃的或不建议继续使用的编程方式</li>
</ul>
<p>本文以 ISO/IEC 9899:2011、ISO/IEC 14882:2011 为主要依据，兼顾 C18、C++17 以及历史标准，没有特殊说明的规则同时适用于 C 语言和 C++ 语言，只适用于某一种语言的规则会另有说明。</p>
<h2 id="规则选取"><a href="#规则选取" class="headerlink" title="规则选取"></a>规则选取</h2><p>本文是适用于不同应用场景的规则集合，读者可选取适合自己需求的规则。</p>
<p>指出某种错误的规则，如有“不可”、“不应”等字样的规则应尽量被选取，有“禁用”等字样的规则可能只适用于某一场景，可酌情选取。</p>
<p>如果将本文作为培训内容，为了全面理解各种场景下存在的问题，应选取全部规则。</p>
<h2 id="规则列表"><a href="#规则列表" class="headerlink" title="规则列表"></a>规则列表</h2><p><span id="__security"><strong><a href="#security">1. Security</a></strong></span></p>
<ul>
<li><a href="#plainsensitiveinfo">R1.1 敏感数据不可写入代码</a></li>
<li><a href="#secretleak">R1.2 敏感数据不可被系统外界感知</a></li>
<li><a href="#unsafecleanup">R1.3 敏感数据在使用后应被有效清理</a></li>
<li><a href="#sensitivename">R1.4 公共成员或全局对象不应记录敏感数据</a></li>
<li><a href="#hijack">R1.5 预判用户输入造成的不良后果</a></li>
<li><a href="#unlimitedauthority">R1.6 对资源设定合理的访问权限</a></li>
<li><a href="#improperauthorization">R1.7 对用户落实有效的权限管理</a></li>
<li><a href="#dangerousname">R1.8 避免引用危险符号名称</a></li>
<li><a href="#dangerousfunction">R1.9 避免使用危险接口</a></li>
<li><a href="#obsoletefunction">R1.10 避免使用已过时的接口</a></li>
<li><a href="#unsafestringfunction">R1.11 禁用不安全的字符串函数</a></li>
<li><a href="#impropernulltermination">R1.12 确保字符串以空字符结尾</a></li>
<li><a href="#dividebyzero">R1.13 避免除 0 等计算异常</a></li>
<li><a href="#variableformatstring">R1.14 格式化字符串应为常量</a></li>
<li><a href="#addressexposure">R1.15 与内存空间布局相关的信息不可被外界感知</a></li>
<li><a href="#hardcodedip">R1.16 与网络地址相关的信息不应写入代码</a></li>
<li><a href="#deprecatederrno">R1.17 选择安全的异常处理方式</a></li>
<li><a href="#missinghardening">R1.18 启用平台和编译器提供的防御机制</a><br><br/></li>
</ul>
<p><span id="__resource"><strong><a href="#resource">2. Resource</a></strong></span></p>
<ul>
<li><a href="#resourceleak">R2.1 不可失去对已分配资源的控制</a></li>
<li><a href="#memoryleak">R2.2 不可失去对已分配内存的控制</a></li>
<li><a href="#illaccess">R2.3 不可访问未初始化或已释放的资源</a></li>
<li><a href="#ownerlessresource">R2.4 资源应接受对象化管理</a></li>
<li><a href="#incompletenewdeletepair">R2.5 资源的分配与回收方法应成对提供</a></li>
<li><a href="#incompatibledealloc">R2.6 资源的分配与回收方法应配套使用</a></li>
<li><a href="#crossmoduletransfer">R2.7 不应在模块之间传递容器类对象</a></li>
<li><a href="#abiconflict">R2.8 不应在模块之间传递非标准布局类型的对象</a></li>
<li><a href="#memberdeallocation">R2.9 对象申请的资源应在析构函数中释放</a></li>
<li><a href="#useaftermove">R2.10 对象被移动后应重置状态再使用</a></li>
<li><a href="#throwinconstructor">R2.11 构造函数抛出异常需避免相关资源泄漏</a></li>
<li><a href="#doublefree">R2.12 资源不可被重复释放</a></li>
<li><a href="#deleteincompletetype">R2.13 用 delete 释放对象需保证其类型完整</a></li>
<li><a href="#excessivedelete">R2.14 用 delete 释放对象不可多写中括号</a></li>
<li><a href="#insufficientdelete">R2.15 用 delete 释放数组不可漏写中括号</a></li>
<li><a href="#illdealloc">R2.16 非动态申请的资源不可被释放</a></li>
<li><a href="#multiallocation">R2.17 在一个表达式语句中最多使用一次 new</a></li>
<li><a href="#copiedstream">R2.18 流式资源对象不应被复制</a></li>
<li><a href="#variablelengtharray">R2.19 避免使用变长数组</a></li>
<li><a href="#stackallocation">R2.20 避免使用在栈上分配内存的函数</a></li>
<li><a href="#unsuitablearraysize">R2.21 局部数组不应过大</a></li>
<li><a href="#unnecessaryallocation">R2.22 避免不必要的内存分配</a></li>
<li><a href="#dynamicallocation">R2.23 避免动态内存分配</a></li>
<li><a href="#nullderefallocret">R2.24 判断资源分配函数的返回值是否有效</a></li>
<li><a href="#forbidmallocandfree">R2.25 C++ 代码中禁用 C 内存管理函数</a><br><br/></li>
</ul>
<p><span id="__precompile"><strong><a href="#precompile">3. Precompile</a></strong></span></p>
<ul>
<li><a href="#precompile.include">3.1 Include</a><ul>
<li><a href="#illformedinclude">R3.1.1 include 指令应符合标准格式</a></li>
<li><a href="#nonstandardcharinheadername">R3.1.2 include 指令中禁用不合规的字符</a></li>
<li><a href="#forbidbackslashinheadername">R3.1.3 include 指令中不应使用反斜杠</a></li>
<li><a href="#forbidabspathinheadername">R3.1.4 include 指令中不应使用绝对路径</a></li>
<li><a href="#badincludeposition">R3.1.5 include 指令应位于文件的起始部分</a></li>
<li><a href="#forbiddenheader">R3.1.6 禁用不合规的头文件</a></li>
<li><a href="#forbidcheaderincpp">R3.1.7 C++ 代码不应引用 C 头文件</a></li>
</ul>
</li>
<li><a href="#precompile.macro-definition">3.2 Macro-definition</a><ul>
<li><a href="#macro_badname">R3.2.1 宏应遵循合理的命名方式</a></li>
<li><a href="#macro_definereserved">R3.2.2 不可定义具有保留意义的宏名称</a></li>
<li><a href="#macro_undefreserved">R3.2.3 不可取消定义具有保留意义的宏名称</a></li>
<li><a href="#macro_expnotenclosed">R3.2.4 可作为子表达式的宏定义应该用括号括起来</a></li>
<li><a href="#macro_paramnotenclosed">R3.2.5 表达式中的宏参数应该用括号括起来</a></li>
<li><a href="#macro_stmtnotenclosed">R3.2.6 由多个语句组成的宏定义应该用 do-while(0) 括起来</a></li>
<li><a href="#macro_complexconcat">R3.2.7 宏定义中的 # 和 ## 运算符不应嵌套使用</a></li>
<li><a href="#macro_const">R3.2.8 不应使用宏定义常量</a></li>
<li><a href="#macro_typeid">R3.2.9 不应使用宏定义类型</a></li>
<li><a href="#macro_function">R3.2.10 可由函数实现的功能不应使用宏实现</a></li>
<li><a href="#macro_redefined">R3.2.11 宏不应被重定义</a></li>
<li><a href="#macro_inblock">R3.2.12 只应在全局作用域中定义宏</a></li>
<li><a href="#macro_undef">R3.2.13 避免宏被取消定义</a></li>
</ul>
</li>
<li><a href="#precompile.macro-usage">3.3 Macro-usage</a><ul>
<li><a href="#macro_sideeffectargs">R3.3.1 宏的实参不应有副作用</a></li>
<li><a href="#macro_insufficientargs">R3.3.2 宏的实参个数不可小于形参个数</a></li>
<li><a href="#macro_redundantargs">R3.3.3 宏的实参个数不可大于形参个数</a></li>
<li><a href="#incompletevamacros">R3.3.4 va_start 或 va_copy 应配合 va_end 使用</a></li>
<li><a href="#badvaargtype">R3.3.5 va_arg 的类型参数应符合要求</a></li>
<li><a href="#deprecatedoffsetof">R3.3.6 在 C++ 代码中不应使用宏 offsetof</a></li>
</ul>
</li>
<li><a href="#precompile.directive">3.4 Directive</a><ul>
<li><a href="#missingheaderguard">R3.4.1 头文件不应缺少守卫</a></li>
<li><a href="#illformeddirective">R3.4.2 不应出现非标准格式的预编译指令</a></li>
<li><a href="#nonstddirective">R3.4.3 不应使用非标准预编译指令</a></li>
<li><a href="#forbidpragmadirective">R3.4.4 避免使用 pragma 指令</a></li>
<li><a href="#explicitlinedirective">R3.4.5 非自动生成的代码中不应出现 line 指令</a></li>
<li><a href="#directiveinmacroargument">R3.4.6 宏的参数列表中不应出现预编译指令</a></li>
<li><a href="#incompletedirective">R3.4.7 条件编译代码块应在同一文件中</a></li>
<li><a href="#warningdisabled">R3.4.8 对编译警告的屏蔽应慎重</a></li>
<li><a href="#warningdefault">R3.4.9 在高级别的警告设置下编译</a></li>
</ul>
</li>
<li><a href="#precompile.comment">3.5 Comment</a><ul>
<li><a href="#specialcomment">R3.5.1 关注 TODO、FIXME、XXX、BUG 等特殊注释</a></li>
<li><a href="#nestedcomment">R3.5.2 注释不可嵌套</a></li>
<li><a href="#badcommentposition">R3.5.3 注释应出现在合理的位置</a></li>
</ul>
</li>
<li><a href="#precompile.other">3.6 Other</a><ul>
<li><a href="#missingnewlinefileend">R3.6.1 非空源文件应以换行符结尾</a></li>
<li><a href="#badbackslash">R3.6.2 除转义字符、宏定义之外不应使用反斜杠</a><br><br/></li>
</ul>
</li>
</ul>
<p><span id="__global"><strong><a href="#global">4. Global</a></strong></span></p>
<ul>
<li><a href="#nametooshort">R4.1 全局名称应遵循合理的命名方式</a></li>
<li><a href="#missingnamespace">R4.2 为代码设定合理的命名空间</a></li>
<li><a href="#nonglobalmain">R4.3 main 函数只应处于全局作用域中</a></li>
<li><a href="#usingnamespaceinheader">R4.4 头文件中不应使用 using directive</a></li>
<li><a href="#staticinheader">R4.5 头文件中不应使用静态声明</a></li>
<li><a href="#anonymousnamespaceinheader">R4.6 头文件中不应定义匿名命名空间</a></li>
<li><a href="#staticinanonymousnamespace">R4.7 匿名命名空间中不应使用静态声明</a></li>
<li><a href="#relyonexternalobject">R4.8 全局对象的初始化不可依赖未初始化的对象</a></li>
<li><a href="#nonconstnonstaticglobalobject">R4.9 全局对象只应为常量或静态对象</a></li>
<li><a href="#nonconstglobalobject">R4.10 全局对象只应为常量</a></li>
<li><a href="#staticandconst">R4.11 全局对象不应同时被 static 和 const 等关键字限定</a></li>
<li><a href="#forbidusingdirectives">R4.12 全局及命名空间作用域中禁用 using directive</a></li>
<li><a href="#usingself">R4.13 避免无效的 using directive</a></li>
<li><a href="#topinlinenamespace">R4.14 不应定义全局 inline 命名空间</a></li>
<li><a href="#stdnamespacemodified">R4.15 不可修改 std 命名空间</a><br><br/></li>
</ul>
<p><span id="__type"><strong><a href="#type">5. Type</a></strong></span></p>
<ul>
<li><a href="#type.class">5.1 Class</a><ul>
<li><a href="#nonprivatedata">R5.1.1 类的非常量数据成员均应为 private</a></li>
<li><a href="#protecteddata">R5.1.2 类的非常量数据成员不应定义为 protected</a></li>
<li><a href="#mixpublicprivatedata">R5.1.3 类不应既有 public 数据成员又有 private 数据成员</a></li>
<li><a href="#missingvirtualdestructor">R5.1.4 有虚函数的基类应具有虚析构函数</a></li>
<li><a href="#diamondinheritance">R5.1.5 避免多重继承自同一非虚基类</a></li>
<li><a href="#missingcopyconstructor">R5.1.6 存在析构函数或拷贝赋值运算符时，不应缺少拷贝构造函数</a></li>
<li><a href="#missingcopyassignoperator">R5.1.7 存在拷贝构造函数或析构函数时，不应缺少拷贝赋值运算符</a></li>
<li><a href="#missingdestructor">R5.1.8 存在拷贝构造函数或拷贝赋值运算符时，不应缺少析构函数</a></li>
<li><a href="#violateruleoffive">R5.1.9 存在任一拷贝、移动、析构相关的函数时，应定义所有相关函数</a></li>
<li><a href="#violateruleofzero">R5.1.10 避免重复实现由默认拷贝、移动、析构函数完成的功能</a></li>
<li><a href="#missingexplicitconstructor">R5.1.11 可接受一个参数的构造函数需用 explicit 关键字限定</a></li>
<li><a href="#missingexplicitconvertor">R5.1.12 重载的类型转换运算符需用 explicit 关键字限定</a></li>
<li><a href="#excessiveexplicit">R5.1.13 不应过度使用 explicit 关键字</a></li>
<li><a href="#roughtemplateassignoperator">R5.1.14 带模板的赋值运算符不应与拷贝或移动赋值运算符混淆</a></li>
<li><a href="#roughtemplateconstructor">R5.1.15 带模板的构造函数不应与拷贝或移动构造函数混淆</a></li>
<li><a href="#unsuitableassignoperator">R5.1.16 抽象类禁用拷贝和移动赋值运算符</a></li>
<li><a href="#toomanyfields">R5.1.17 数据成员的数量应在规定范围之内</a></li>
<li><a href="#ignorepaddingdata">R5.1.18 数据成员之间的填充数据不应被忽视</a></li>
<li><a href="#returnnonconstdata">R5.1.19 常量成员函数不应返回数据成员的非常量指针或引用</a></li>
<li><a href="#accessspecifierdisorder">R5.1.20 类成员应按 public、protected、private 的顺序声明</a></li>
<li><a href="#unsuitablestructtag">R5.1.21 存在构造、析构或虚函数的类不应采用 struct 关键字</a></li>
</ul>
</li>
<li><a href="#type.enum">5.2 Enum</a><ul>
<li><a href="#duplicateenumerator">R5.2.1 同类枚举项的值不应相同</a></li>
<li><a href="#casualinitialization">R5.2.2 合理初始化各枚举项</a></li>
<li><a href="#forbidunnamedenum">R5.2.3 不应使用匿名枚举声明</a></li>
<li><a href="#forbidunscopedenum">R5.2.4 用 enum class 取代 enum</a></li>
</ul>
</li>
<li><a href="#type.union">5.3 Union</a><ul>
<li><a href="#forbidnonbasicfield">R5.3.1 联合体内禁用非基本类型的对象</a></li>
<li><a href="#forbidnakedunion">R5.3.2 禁用在类之外定义的联合体</a></li>
<li><a href="#forbidunion">R5.3.3 禁用联合体</a><br><br/></li>
</ul>
</li>
</ul>
<p><span id="__declaration"><strong><a href="#declaration">6. Declaration</a></strong></span></p>
<ul>
<li><a href="#declaration.naming">6.1 Naming</a><ul>
<li><a href="#badname">R6.1.1 遵循合理的命名方式</a></li>
<li><a href="#reservedname">R6.1.2 不应定义具有保留意义的名称</a></li>
<li><a href="#hidelocal">R6.1.3 局部名称不应被覆盖</a></li>
<li><a href="#hidemember">R6.1.4 成员名称不应被覆盖</a></li>
<li><a href="#hideglobal">R6.1.5 全局名称不应被覆盖</a></li>
<li><a href="#duplicatedtypename">R6.1.6 类型名称不应重复定义</a></li>
<li><a href="#duplicatedname">R6.1.7 类型名称不应与对象或函数名称相同</a></li>
<li><a href="#misspelling">R6.1.8 不应存在拼写错误</a></li>
</ul>
</li>
<li><a href="#declaration.qualifier">6.2 Qualifier</a><ul>
<li><a href="#qualifierrepeated">R6.2.1 const、volatile 不应重复</a></li>
<li><a href="#qualifierforptralias">R6.2.2 const、volatile 限定指针类型的别名是可疑的</a></li>
<li><a href="#qualifierinvalid">R6.2.3 const、volatile 不可限定引用</a></li>
<li><a href="#badqualifierposition">R6.2.4 const、volatile 限定类型时的位置应统一</a></li>
<li><a href="#sandwichedmodifier">R6.2.5 const、volatile 等关键字不应出现在基本类型名称的中间</a></li>
<li><a href="#conststrtononconstptr">R6.2.6 指向常量字符串的指针应使用 const 声明</a></li>
<li><a href="#uselessqualifier">R6.2.7 枚举类型的底层类型不应为 const 或 volatile</a></li>
<li><a href="#constliteralreference">R6.2.8 对常量的定义不应为引用</a></li>
<li><a href="#forbidrestrictptr">R6.2.9 禁用 restrict 指针</a></li>
<li><a href="#forbidvolatile">R6.2.10 非适当场景禁用 volatile</a></li>
<li><a href="#nonconstunmodified">R6.2.11 相关对象未被修改时应使用 const 声明</a></li>
</ul>
</li>
<li><a href="#declaration.specifier">6.3 Specifier</a><ul>
<li><a href="#abusedauto">R6.3.1 合理使用 auto 关键字</a></li>
<li><a href="#deprecatedspecifier">R6.3.2 不应使用已过时的关键字</a></li>
<li><a href="#inlineredundant">R6.3.3 不应使用多余的 inline 关键字</a></li>
<li><a href="#invalidexternspecifier">R6.3.4 extern 关键字不应作用于类成员的声明或定义</a></li>
<li><a href="#missingexplicitoverride">R6.3.5 重写的虚函数应声明为 override 或 final</a></li>
<li><a href="#redundantoverride">R6.3.6 override 和 final 关键字不应同时出现在声明中</a></li>
<li><a href="#redundantvirtual">R6.3.7 override 或 final 关键字不应与 virtual 关键字同时出现在声明中</a></li>
<li><a href="#invalidfinal">R6.3.8 不应将 union 设为 final</a></li>
<li><a href="#this_notused">R6.3.9 未访问 this 指针的成员函数应使用 static 声明</a></li>
<li><a href="#missingstatic">R6.3.10 声明和定义内部链接的对象和函数时均应使用 static 关键字</a></li>
<li><a href="#badspecifierposition">R6.3.11 inline、virtual、static、typedef 等关键字的位置应统一</a></li>
</ul>
</li>
<li><a href="#declaration.declarator">6.4 Declarator</a><ul>
<li><a href="#roughauto">R6.4.1 用 auto 声明指针或引用时应显式标明 *、&amp; 等符号</a></li>
<li><a href="#forbidvariadicfunction">R6.4.2 禁用可变参数列表</a></li>
<li><a href="#forbidflexiblearray">R6.4.3 禁用柔性数组</a></li>
<li><a href="#forbidfunctionvoidptr">R6.4.4 接口的参数类型和返回类型不应为 void*</a></li>
<li><a href="#forbidmembervoidptr">R6.4.5 类成员的类型不应为 void*</a></li>
<li><a href="#missingarraysize">R6.4.6 数组大小应被显式声明</a></li>
<li><a href="#mixedtypeobjdefinition">R6.4.7 不应将类型定义和对象声明写在一个语句中</a></li>
<li><a href="#mixeddeclarations">R6.4.8 不应将不同类别的声明写在一个语句中</a></li>
</ul>
</li>
<li><a href="#declaration.object">6.5 Object</a><ul>
<li><a href="#inaccessibletmpobject">R6.5.1 不应产生无效的临时对象</a></li>
<li><a href="#invalidlocaldeclaration">R6.5.2 不应存在没有被用到的局部声明</a></li>
<li><a href="#selfdependentinitialization">R6.5.3 对象初始化不可依赖自身的值</a></li>
<li><a href="#plainnumericchar">R6.5.4 参与数值运算的 char 对象应显式声明 signed 或 unsigned</a></li>
<li><a href="#plainbinarychar">R6.5.5 字节的类型应为 std::byte 或 unsigned char</a></li>
</ul>
</li>
<li><a href="#declaration.parameter">6.6 Parameter</a><ul>
<li><a href="#missingparamname">R6.6.1 函数原型声明中的参数应具有合理的名称</a></li>
<li><a href="#invalidparamarraysize">R6.6.2 不应将数组作为函数的形式参数</a></li>
<li><a href="#badparmn">R6.6.3 parmN 的声明应符合要求</a></li>
<li><a href="#inconsistentdefaultargument">R6.6.4 虚函数参数的默认值应与基类中声明的一致</a></li>
<li><a href="#deprecateddefaultargument">R6.6.5 不建议虚函数的参数有默认值</a></li>
<li><a href="#missingvoid">R6.6.6 C 代码中参数列表如果为空应声明为“(void)”</a></li>
<li><a href="#superfluousvoid">R6.6.7 C++ 代码中参数列表如果为空不应声明为“(void)”</a></li>
<li><a href="#forbidstaticarrsize">R6.6.8 声明数组参数的大小时禁用 static 关键字</a></li>
</ul>
</li>
<li><a href="#declaration.function">6.7 Function</a><ul>
<li><a href="#nonvirtualoverride">R6.7.1 派生类不应重新定义与基类相同的非虚函数</a></li>
<li><a href="#illoperatorrettype">R6.7.2 重载运算符的返回类型应与内置运算符相符</a></li>
<li><a href="#nonstdassignmentrettype">R6.7.3 赋值运算符应返回所属类的非 const 左值引用</a></li>
<li><a href="#illcopyconstructorparam">R6.7.4 拷贝构造函数的参数应为同类对象的 const 左值引用</a></li>
<li><a href="#nonstdcopyassignmentparam">R6.7.5 拷贝赋值运算符的参数应为同类对象的 const 左值引用</a></li>
<li><a href="#illmoveconstructorparam">R6.7.6 移动构造函数的参数应为同类对象的非 const 右值引用</a></li>
<li><a href="#nonstdmoveassignmentparam">R6.7.7 移动赋值运算符的参数应为同类对象的非 const 右值引用</a></li>
<li><a href="#overloadaddressoperator">R6.7.8 不应重载取地址运算符</a></li>
<li><a href="#overloadcomma">R6.7.9 不应重载逗号运算符</a></li>
<li><a href="#overloadlogicoperator">R6.7.10 不应重载“逻辑与”和“逻辑或”运算符</a></li>
<li><a href="#virtualassignment">R6.7.11 拷贝和移动赋值运算符不应为虚函数</a></li>
<li><a href="#virtualcomparison">R6.7.12 比较运算符不应为虚函数</a></li>
<li><a href="#virtualinfinal">R6.7.13 final 类中不应声明虚函数</a></li>
</ul>
</li>
<li><a href="#declaration.bitfield">6.8 Bitfield</a><ul>
<li><a href="#improperbitfieldtype">R6.8.1 对位域声明合理的类型</a></li>
<li><a href="#exceededbitfield">R6.8.2 位域长度不应超过类型长度</a></li>
<li><a href="#singlesignedbitfield">R6.8.3 有符号整型对象的位域长度不应为 1</a></li>
<li><a href="#forbidenumbitfield">R6.8.4 不应对枚举对象声明位域</a></li>
<li><a href="#forbidbitfield">R6.8.5 禁用位域</a></li>
</ul>
</li>
<li><a href="#declaration.complexity">6.9 Complexity</a><ul>
<li><a href="#complexdeclaration">R6.9.1 不应采用复杂的声明</a></li>
<li><a href="#toomanyptrlevel">R6.9.2 声明中不应包含过多的指针嵌套</a></li>
<li><a href="#toomanydeclarators">R6.9.3 在一个语句中不应声明多个对象或函数</a></li>
</ul>
</li>
<li><a href="#declaration.other">6.10 Other</a><ul>
<li><a href="#violateodr">R6.10.1 遵循 One Definition Rule</a></li>
<li><a href="#inconsistentdeclaration">R6.10.2 声明与实现应一致</a></li>
<li><a href="#unsuitabledeclaration">R6.10.3 在合理的位置声明</a></li>
<li><a href="#labelnotused">R6.10.4 不应存在没有被用到的标签</a></li>
<li><a href="#staticnotused">R6.10.5 不应存在没有被用到的静态声明</a></li>
<li><a href="#privatenotused">R6.10.6 不应存在没有被用到的 private 成员</a></li>
<li><a href="#missingtype">R6.10.7 不应省略声明对象或函数的类型</a></li>
<li><a href="#unportabletype">R6.10.8 用 stdint.h 中的类型代替 short、int、long 等类型</a></li>
<li><a href="#obsoletestdfunction">R6.10.9 避免使用已过时的标准库组件</a><br><br/></li>
</ul>
</li>
</ul>
<p><span id="__exception"><strong><a href="#exception">7. Exception</a></strong></span></p>
<ul>
<li><a href="#exceptionunsafe">R7.1 保证异常安全</a></li>
<li><a href="#uncaughtexception">R7.2 处理所有异常</a></li>
<li><a href="#throwgenericexception">R7.3 不应抛出过于宽泛的异常</a></li>
<li><a href="#catch_generic">R7.4 不应捕获过于宽泛的异常</a></li>
<li><a href="#thrownonexceptiontype">R7.5 不应抛出非异常类型的对象</a></li>
<li><a href="#catch_nonexceptiontype">R7.6 不应捕获非异常类型的对象</a></li>
<li><a href="#throwoutofmain">R7.7 全局对象的初始化过程不可抛出异常</a></li>
<li><a href="#throwindestructor">R7.8 析构函数不可抛出异常</a></li>
<li><a href="#throwindelete">R7.9 内存回收函数不可抛出异常</a></li>
<li><a href="#throwinswap">R7.10 对象交换过程不可抛出异常</a></li>
<li><a href="#throwinmove">R7.11 移动构造函数和移动赋值运算符不可抛出异常</a></li>
<li><a href="#throwwhilethrowing">R7.12 异常类的拷贝构造函数不可抛出异常</a></li>
<li><a href="#exceptioninexception">R7.13 异常类的构造函数和异常信息相关的函数不应抛出异常</a></li>
<li><a href="#throwinhash">R7.14 与标准库相关的 hash 过程不应抛出异常</a></li>
<li><a href="#throwinnoexcept">R7.15 由 noexcept 标记的函数不可产生未处理的异常</a></li>
<li><a href="#diamondexceptioninheritance">R7.16 避免异常类多重继承自同一非虚基类</a></li>
<li><a href="#catch_value">R7.17 通过引用捕获异常</a></li>
<li><a href="#catch_slicing">R7.18 捕获异常时不应产生对象切片问题</a></li>
<li><a href="#catch_justrethrow">R7.19 捕获异常后不应直接再次抛出异常</a></li>
<li><a href="#improperrethrow">R7.20 重新抛出异常时应使用空 throw 表达式（throw;）</a></li>
<li><a href="#rethrowoutofcatch">R7.21 不应在 catch 子句外使用空 throw 表达式（throw;）</a></li>
<li><a href="#throwpointer">R7.22 不应抛出指针</a></li>
<li><a href="#thrownull">R7.23 不应抛出 NULL</a></li>
<li><a href="#thrownullptr">R7.24 不应抛出 nullptr</a></li>
<li><a href="#crossmoduleexception">R7.25 不应在模块之间传播异常</a></li>
<li><a href="#forbidthrowspecification">R7.26 禁用动态异常说明</a></li>
<li><a href="#forbidexception">R7.27 禁用 C++ 异常</a><br><br/></li>
</ul>
<p><span id="__function"><strong><a href="#function">8. Function</a></strong></span></p>
<ul>
<li><a href="#mainreturnsnonint">R8.1 main 函数的返回类型只应为 int</a></li>
<li><a href="#illformedmain">R8.2 main 函数不应被调用、重载或被 inline、static 等关键字限定</a></li>
<li><a href="#definedinheader">R8.3 在头文件中不应实现函数或定义对象</a></li>
<li><a href="#inconsistentparamname">R8.4 函数的参数名称在声明处和实现处应保持一致</a></li>
<li><a href="#parammaybeslicing">R8.5 多态类的对象作为参数时不应采用值传递的方式</a></li>
<li><a href="#paramnotused">R8.6 不应存在未被使用的具名形式参数</a></li>
<li><a href="#parampassedbyvalue">R8.7 非基本类型的常量参数不应按值传递</a></li>
<li><a href="#illforwardingreference">R8.8 转发引用只应作为 std::forward 的参数</a></li>
<li><a href="#localinitialization">R8.9 局部对象在使用前应被初始化</a></li>
<li><a href="#memberinitialization">R8.10 成员须在声明处或构造时初始化</a></li>
<li><a href="#illmembercall">R8.11 基类对象构造完毕之前不可调用成员函数</a></li>
<li><a href="#illmemberaccess">R8.12 在面向构造或析构函数体的 catch 子句中不可访问非静态成员</a></li>
<li><a href="#disorderedinitialization">R8.13 成员初始化应遵循声明的顺序</a></li>
<li><a href="#virtualcallinconstructor">R8.14 在构造函数中不应使用动态类型</a></li>
<li><a href="#virtualcallindestructor">R8.15 在析构函数中不应使用动态类型</a></li>
<li><a href="#exitcallindestructor">R8.16 在析构函数中避免调用 exit 函数</a></li>
<li><a href="#sideeffectcopyconstructor">R8.17 拷贝构造函数应避免实现复制之外的功能</a></li>
<li><a href="#sideeffectmoveconstructor">R8.18 移动构造函数应避免实现数据移动之外的功能</a></li>
<li><a href="#this_selfjudgement">R8.19 拷贝赋值运算符应处理参数是自身对象时的情况</a></li>
<li><a href="#invalidwrite">R8.20 不应存在无效的写入操作</a></li>
<li><a href="#missingsideeffect">R8.21 不应存在没有副作用的语句</a></li>
<li><a href="#unreachablecode">R8.22 不应存在得不到执行机会的代码</a></li>
<li><a href="#notallbranchreturn">R8.23 有返回值的函数其所有分枝都应显式返回</a></li>
<li><a href="#localaddressflowout">R8.24 不可返回局部对象的地址或引用</a></li>
<li><a href="#tmpaddressflowout">R8.25 不可返回临时对象的地址或引用</a></li>
<li><a href="#unsuitablecapture">R8.26 合理设置 lambda 表达式的捕获方式</a></li>
<li><a href="#returnrvaluereference">R8.27 函数返回值不应为右值引用</a></li>
<li><a href="#returnconstobject">R8.28 函数返回值不应为常量对象</a></li>
<li><a href="#returnsuperfluousconst">R8.29 函数返回值不应为基本类型的常量</a></li>
<li><a href="#returnodd">R8.30 被返回的表达式应与函数的返回类型一致</a></li>
<li><a href="#returnsameconst">R8.31 被返回的表达式不应为相同的常量</a></li>
<li><a href="#unsuitablereturn">R8.32 具有 noreturn 属性的函数不应返回</a></li>
<li><a href="#unsuitablereturntype">R8.33 具有 noreturn 属性的函数返回类型只应为 void</a></li>
<li><a href="#exithandlernoreturn">R8.34 由 atexit、at_quick_exit 指定的处理函数应正常返回</a></li>
<li><a href="#functionspecialization">R8.35 函数模板不应被特化</a></li>
<li><a href="#toomanyexit">R8.36 函数的退出点数量应在规定范围之内</a></li>
<li><a href="#toomanylabels">R8.37 函数的标签数量应在规定范围之内</a></li>
<li><a href="#toomanylines">R8.38 函数的行数应在规定范围之内</a></li>
<li><a href="#toomanylambdalines">R8.39 lambda 表达式的行数应在规定范围之内</a></li>
<li><a href="#toomanyparams">R8.40 函数参数的数量应在规定范围之内</a></li>
<li><a href="#complexinlinefunction">R8.41 不应定义过于复杂的内联函数</a></li>
<li><a href="#recursion">R8.42 避免函数调用自身</a></li>
<li><a href="#nestedtoodeep">R8.43 作用域及类型嵌套不应过深</a></li>
<li><a href="#mixedasm">R8.44 汇编代码不应与普通代码混合</a></li>
<li><a href="#functionrepetition">R8.45 避免重复的函数实现</a><br><br/></li>
</ul>
<p><span id="__control"><strong><a href="#control">9. Control</a></strong></span></p>
<ul>
<li><a href="#control.if">9.1 If</a><ul>
<li><a href="#if_semicolon">R9.1.1 if 语句不应被分号隔断</a></li>
<li><a href="#if_identicalcondition">R9.1.2 在 if…else-if 分枝中不应有重复的条件</a></li>
<li><a href="#if_hiddencondition">R9.1.3 在 if…else-if 分枝中不应有被遮盖的条件</a></li>
<li><a href="#if_identicalblock">R9.1.4 if 分枝和 else 分枝的代码不应完全相同</a></li>
<li><a href="#if_identicalelseifblock">R9.1.5 if…else-if 各分枝的代码不应完全相同</a></li>
<li><a href="#if_identicalimplicitelseblock">R9.1.6 if 分枝和隐含的 else 分枝代码不应完全相同</a></li>
<li><a href="#if_identicalsucceedingblock">R9.1.7 没有 else 子句的 if 语句与其后续代码相同是可疑的</a></li>
<li><a href="#if_commonstatements">R9.1.8 if 分枝和 else 分枝的起止语句不应相同</a></li>
<li><a href="#if_scope">R9.1.9 if 语句作用域的范围不应有误</a></li>
<li><a href="#if_maybeelseif">R9.1.10 如果 if 关键字前面是右大括号，if 关键字应另起一行</a></li>
<li><a href="#if_assignment">R9.1.11 if 语句的条件不应为赋值表达式</a></li>
<li><a href="#if_emptyblock">R9.1.12 if 语句不应为空</a></li>
<li><a href="#if_toomanyelseif">R9.1.13 if…else-if 分枝数量应在规定范围之内</a></li>
<li><a href="#if_brace">R9.1.14 if 分枝中的语句应该用大括号括起来</a></li>
<li><a href="#if_missingendingelse">R9.1.15 所有 if…else-if 分枝都应以 else 子句结束</a></li>
</ul>
</li>
<li><a href="#control.for">9.2 For</a><ul>
<li><a href="#for_semicolon">R9.2.1 for 语句不应被分号隔断</a></li>
<li><a href="#for_uncondbroken">R9.2.2 for 语句中不应存在无条件的跳转语句</a></li>
<li><a href="#for_scope">R9.2.3 for 语句作用域的范围不应有误</a></li>
<li><a href="#for_simplification">R9.2.4 for 语句没有明确的循环变量时应改用 while 语句</a></li>
<li><a href="#for_emptyblock">R9.2.5 for 循环体不应为空</a></li>
<li><a href="#for_floatcounter">R9.2.6 for 循环变量不应为浮点型</a></li>
<li><a href="#for_counterchangedinbody">R9.2.7 for 循环变量不应在循环体内被改变</a></li>
<li><a href="#for_counternested">R9.2.8 嵌套的 for 语句不应使用相同的循环变量</a></li>
<li><a href="#for_brace">R9.2.9 for 循环体应该用大括号括起来</a></li>
</ul>
</li>
<li><a href="#control.while">9.3 While</a><ul>
<li><a href="#while_semicolon">R9.3.1 while 语句不应被分号隔断</a></li>
<li><a href="#while_uncondbroken">R9.3.2 while 语句中不应存在无条件的跳转语句</a></li>
<li><a href="#while_assignment">R9.3.3 while 语句的条件不应为赋值表达式</a></li>
<li><a href="#while_scope">R9.3.4 while 语句作用域的范围不应有误</a></li>
<li><a href="#while_emptyblock">R9.3.5 while 循环体不应为空</a></li>
<li><a href="#while_brace">R9.3.6 while 循环体应该用大括号括起来</a></li>
</ul>
</li>
<li><a href="#control.do">9.4 Do</a><ul>
<li><a href="#do_suspiciouscontinue">R9.4.1 注意 do-while(0) 中可疑的 continue 语句</a></li>
<li><a href="#do_emptyblock">R9.4.2 do-while 循环体不应为空</a></li>
<li><a href="#do_brace">R9.4.3 do-while 循环体应该用大括号括起来</a></li>
<li><a href="#do_deprecated">R9.4.4 不建议使用 do 语句</a></li>
</ul>
</li>
<li><a href="#control.switch">9.5 Switch</a><ul>
<li><a href="#switch_semicolon">R9.5.1 switch 语句不应被分号隔断</a></li>
<li><a href="#switch_emptyblock">R9.5.2 switch 语句不应为空</a></li>
<li><a href="#switch_caseoutofrange">R9.5.3 case 标签的值不可超出 switch 条件的范围</a></li>
<li><a href="#switch_invalidstatement">R9.5.4 switch 语句中任何子句都应从属于某个 case 或 default 分枝</a></li>
<li><a href="#switch_badformedcase">R9.5.5 case 和 default 标签应直接从属于 switch 语句</a></li>
<li><a href="#switch_uselessfallthrough">R9.5.6 不应存在紧邻 default 标签的空 case 标签</a></li>
<li><a href="#switch_identicalbranch">R9.5.7 不应存在内容完全相同的 case 分枝</a></li>
<li><a href="#switch_bool">R9.5.8 switch 语句的条件不应为 bool 型</a></li>
<li><a href="#switch_onlydefault">R9.5.9 switch 语句不应只包含 default 标签</a></li>
<li><a href="#switch_onlyonecase">R9.5.10 switch 语句不应只包含一个 case 标签</a></li>
<li><a href="#switch_toomanycases">R9.5.11 switch 语句分枝数量应在规定范围之内</a></li>
<li><a href="#switch_missingdefault">R9.5.12 switch 语句应配有 default 分枝</a></li>
<li><a href="#switch_breakomitted">R9.5.13 switch 语句的每个非空分枝都应该用无条件的 break 或 return 语句终止</a></li>
<li><a href="#switch_brace">R9.5.14 switch 语句应该用大括号括起来</a></li>
<li><a href="#switch_forbidnest">R9.5.15 switch 语句不应嵌套</a></li>
</ul>
</li>
<li><a href="#control.try-catch">9.6 Try-catch</a><ul>
<li><a href="#try_emptyblock">R9.6.1 try 关键字的作用域不应为空</a></li>
<li><a href="#catch_emptyblock">R9.6.2 catch 子句不应为空</a></li>
<li><a href="#try_forbidnest">R9.6.3 不应嵌套 try-catch 语句</a></li>
<li><a href="#try_disorderedellipsis">R9.6.4 捕获所有异常的 catch(…) 子句应位于最后</a></li>
<li><a href="#try_disorderedhandlers">R9.6.5 面向派生类的 catch 子句应排在面向基类的 catch 子句之前</a></li>
</ul>
</li>
<li><a href="#control.jump">9.7 Jump</a><ul>
<li><a href="#forbidgotoblocks">R9.7.1 禁止 goto 语句向嵌套的或无包含关系的作用域跳转</a></li>
<li><a href="#forbidgotoback">R9.7.2 禁止 goto 语句向前跳转</a></li>
<li><a href="#forbidgoto">R9.7.3 禁用 goto 语句</a></li>
<li><a href="#forbidlongjmp">R9.7.4 禁用 setjmp、longjmp</a></li>
<li><a href="#uncondjump">R9.7.5 不应存在不受条件控制的跳转语句</a></li>
<li><a href="#redundantjump">R9.7.6 不应存在不改变程序流程的跳转语句</a></li>
<li><a href="#jumpoutloop">R9.7.7 避免使用跳转语句退出循环</a><br><br/></li>
</ul>
</li>
</ul>
<p><span id="__expression"><strong><a href="#expression">10. Expression</a></strong></span></p>
<ul>
<li><a href="#expression.logic">10.1 Logic</a><ul>
<li><a href="#illidentical">R10.1.1 不应存在无意义的重复子表达式</a></li>
<li><a href="#conflictcondition">R10.1.2 逻辑子表达式之间不应存在矛盾</a></li>
<li><a href="#invalidcondition">R10.1.3 作为条件的逻辑表达式不应恒为真或恒为假</a></li>
<li><a href="#redundantcondition">R10.1.4 不应存在多余的逻辑子表达式</a></li>
<li><a href="#constlogicexpression">R10.1.5 逻辑表达式及逻辑子表达式不应为常量</a></li>
<li><a href="#shortcircuitsideeffect">R10.1.6 逻辑表达式的右子表达式不应有副作用</a></li>
<li><a href="#simplifiablecondition">R10.1.7 化简可被合并的逻辑子表达式</a></li>
<li><a href="#simplifiableternary">R10.1.8 化简可转换为逻辑表达式的三元表达式</a></li>
</ul>
</li>
<li><a href="#expression.evaluation">10.2 Evaluation</a><ul>
<li><a href="#unevaluatedsideeffect">R10.2.1 不可依赖不会生效的副作用</a></li>
<li><a href="#evaluationorderreliance">R10.2.2 避免依赖特定的子表达式求值顺序</a></li>
<li><a href="#confusingassignment">R10.2.3 在表达式中不应多次读写同一对象</a></li>
<li><a href="#unexpectedprecedence">R10.2.4 注意运算符优先级，避免非预期的结果</a></li>
<li><a href="#illptrdiff">R10.2.5 不在同一数组或对象中的地址不可相减或比较大小</a></li>
<li><a href="#illbooloperation">R10.2.6 bool 值不应参与位运算、大小比较、数值增减</a></li>
<li><a href="#illformedcompoundassignment">R10.2.7 不应出现复合赋值的错误形式</a></li>
<li><a href="#suspiciouscompoundassignment">R10.2.8 避免出现复合赋值的可疑形式</a></li>
<li><a href="#illselfcompoundassignment">R10.2.9 &amp;=、|=、-=、/=、%= 左右子表达式不应相同</a></li>
<li><a href="#oddnullassignment">R10.2.10 不应将 NULL 当作整数使用</a></li>
<li><a href="#stickyassignmentoperator">R10.2.11 注意赋值运算符与一元运算符的空格方式</a></li>
<li><a href="#overlappingassignment">R10.2.12 不可将对象的值赋给具有部分重叠区域的对象</a></li>
<li><a href="#selfassignment">R10.2.13 赋值运算符左右子表达式不应相同</a></li>
<li><a href="#selfdivision">R10.2.14 除法和求余运算符左右子表达式不应相同</a></li>
<li><a href="#selfsubtraction">R10.2.15 减法运算符左右子表达式不应相同</a></li>
<li><a href="#selfexclusiveor">R10.2.16 异或运算符左右子表达式不应相同</a></li>
<li><a href="#minusonunsigned">R10.2.17 负号不应作用于无符号整数</a></li>
<li><a href="#repeatedunaryoperators">R10.2.18 不应重复使用一元运算符</a></li>
<li><a href="#evaloverflow">R10.2.19 运算结果不应溢出</a></li>
<li><a href="#bitwiseoperonsigned">R10.2.20 位运算符不应作用于有符号整数</a></li>
<li><a href="#illshiftcount">R10.2.21 移位数量不应超过相关类型比特位的数量</a></li>
<li><a href="#suspiciouspromotion">R10.2.22 按位取反需避免由类型提升产生的多余数据</a></li>
<li><a href="#invalidcommasubexpression">R10.2.23 逗号表达式的子表达式应具有必要的副作用</a></li>
</ul>
</li>
<li><a href="#expression.comparison">10.3 Comparison</a><ul>
<li><a href="#illcomparison">R10.3.1 参与比较的对象之间应具备合理的大小关系</a></li>
<li><a href="#illfloatcomparison">R10.3.2 不应使用 == 或 != 判断浮点数是否相等</a></li>
<li><a href="#illptrstrcomparison">R10.3.3 指针不应与字符串常量直接比较</a></li>
<li><a href="#differentenumcomparison">R10.3.4 不应比较非同类枚举值</a></li>
<li><a href="#selfcomparison">R10.3.5 比较运算符左右子表达式不应相同</a></li>
<li><a href="#successivecomparison">R10.3.6 比较运算不可作为另一个比较运算的直接子表达式</a></li>
</ul>
</li>
<li><a href="#expression.call">10.4 Call</a><ul>
<li><a href="#returnvalueignored">R10.4.1 不应忽略重要的返回值</a></li>
<li><a href="#wronguseofreturnvalue">R10.4.2 不可臆断返回值的意义</a></li>
<li><a href="#objectslicing">R10.4.3 避免对象切片</a></li>
<li><a href="#explicitdtorcall">R10.4.4 避免显式调用析构函数</a></li>
<li><a href="#nonpodvariadicargument">R10.4.5 不应将非 POD 对象传入可变参数列表</a></li>
<li><a href="#inconsistentformatargnum">R10.4.6 C 格式化字符串需要的参数个数与实际传入的参数个数应一致</a></li>
<li><a href="#inconsistentformatargtype">R10.4.7 C 格式化占位符与其对应参数的类型应一致</a></li>
<li><a href="#forbidcstringformat">R10.4.8 在 C++ 代码中禁用 C 字符串格式化方法</a></li>
<li><a href="#forbidatox">R10.4.9 禁用 atof、atoi、atol 以及 atoll 等函数</a></li>
<li><a href="#implementationdefinedfunction">R10.4.10 避免使用由实现定义的库函数</a></li>
<li><a href="#unsuitablemove">R10.4.11 合理使用 std::move</a></li>
<li><a href="#unsuitableforward">R10.4.12 合理使用 std::forward</a></li>
</ul>
</li>
<li><a href="#expression.sizeof">10.5 Sizeof</a><ul>
<li><a href="#sizeof_arrayparameter">R10.5.1 sizeof 不应作用于数组参数</a></li>
<li><a href="#sizeof_oddexpression">R10.5.2 sizeof 不应作用于逻辑表达式</a></li>
<li><a href="#sizeof_pointer">R10.5.3 sizeof 作用于指针是可疑的</a></li>
<li><a href="#sizeof_pointerdivision">R10.5.4 被除数不应是作用于指针的 sizeof 表达式</a></li>
<li><a href="#sizeof_suspiciousadd">R10.5.5 指针加减偏移量时计入 sizeof 是可疑的</a></li>
<li><a href="#sizeof_zerocomparison">R10.5.6 sizeof 表达式的结果不应与 0 或负数比较</a></li>
<li><a href="#sizeof_sizeof">R10.5.7 sizeof 不应再作用于 sizeof 表达式</a></li>
<li><a href="#sizeof_null">R10.5.8 C++ 代码中 sizeof 不应作用于 NULL</a></li>
<li><a href="#sizeof_void">R10.5.9 sizeof 不可作用于 void</a></li>
</ul>
</li>
<li><a href="#expression.assertion">10.6 Assertion</a><ul>
<li><a href="#badassertion">R10.6.1 断言中的表达式不应恒为真</a></li>
<li><a href="#sideeffectassertion">R10.6.2 断言中的表达式不应有副作用</a></li>
<li><a href="#complexassertion">R10.6.3 断言中的表达式不应过于复杂</a></li>
</ul>
</li>
<li><a href="#expression.complexity">10.7 Complexity</a><ul>
<li><a href="#complexexpression">R10.7.1 表达式不应过于复杂</a></li>
</ul>
</li>
<li><a href="#expression.other">10.8 Other</a><ul>
<li><a href="#accesspaddingdata">R10.8.1 不应访问填充数据</a></li>
<li><a href="#oddnew">R10.8.2 new 表达式只可用于赋值或当作参数</a></li>
<li><a href="#oddsubscripting">R10.8.3 数组下标应为整型表达式</a></li>
<li><a href="#forbidcommaexpression">R10.8.4 禁用逗号表达式</a><br><br/></li>
</ul>
</li>
</ul>
<p><span id="__literal"><strong><a href="#literal">11. Literal</a></strong></span></p>
<ul>
<li><a href="#literal_suspiciouschar">R11.1 转义字符的反斜杠不可误写成斜杠</a></li>
<li><a href="#literal_hardcodechar">R11.2 在字符常量中用转义字符表示制表符和控制字符</a></li>
<li><a href="#literal_hardcodestring">R11.3 在字符串常量中用转义字符表示制表符和控制字符</a></li>
<li><a href="#literal_nonstandardesc">R11.4 不应使用非标准转义字符</a></li>
<li><a href="#literal_hybridconcat">R11.5 不应连接不同前缀的字符串常量</a></li>
<li><a href="#literal_misspelling">R11.6 字符串常量中不应存在拼写错误</a></li>
<li><a href="#literal_confusingsuffix">R11.7 常量后缀由应由大写字母组成</a></li>
<li><a href="#literal_forbidoct">R11.8 禁用 8 进制常量</a></li>
<li><a href="#literal_nonstandardsuffix">R11.9 不应使用非标准常量后缀</a></li>
<li><a href="#literal_oddconcat">R11.10 小心遗漏逗号导致的非预期字符串连接</a></li>
<li><a href="#literal_magicnumber">R11.11 不应存在 magic number</a></li>
<li><a href="#literal_magicstring">R11.12 不应存在 magic string</a></li>
<li><a href="#literal_multicharacter">R11.13 不应使用多字符常量</a><br><br/></li>
</ul>
<p><span id="__cast"><strong><a href="#cast">12. Cast</a></strong></span></p>
<ul>
<li><a href="#narrowcast">R12.1 避免类型转换造成数据丢失</a></li>
<li><a href="#invalidpromotion">R12.2 避免数据丢失造成类型转换失效</a></li>
<li><a href="#signchangecast">R12.3 避免有符号整型与无符号整型相互转换</a></li>
<li><a href="#voidcast">R12.4 避免与 void* 相互转换</a></li>
<li><a href="#downcast">R12.5 避免向下类型转换</a></li>
<li><a href="#ptrintcast">R12.6 指针与整数不应相互转换</a></li>
<li><a href="#qualifiercastedaway">R12.7 类型转换不应去掉 const、volatile 等属性</a></li>
<li><a href="#castnoinheritance">R12.8 不应转换无继承关系的指针或引用</a></li>
<li><a href="#castnonpublicinheritance">R12.9 不应转换无 public 继承关系的指针或引用</a></li>
<li><a href="#nonpodbinarycast">R12.10 非 POD 类的指针与基本类型的指针不应相互转换</a></li>
<li><a href="#charwcharcast">R12.11 不同的字符串类型之间不可直接转换</a></li>
<li><a href="#stricteralignedcast">R12.12 避免向对齐要求更严格的指针转换</a></li>
<li><a href="#arraypointercast">R12.13 避免转换指向数组的指针</a></li>
<li><a href="#functionpointercast">R12.14 避免转换函数指针</a></li>
<li><a href="#nondynamicdowncast">R12.15 向下动态类型转换应使用 dynamic_cast</a></li>
<li><a href="#oddnewcast">R12.16 对 new 表达式不应进行类型转换</a></li>
<li><a href="#redundantcast">R12.17 不应存在多余的类型转换</a></li>
<li><a href="#unsuitablereinterpretcast">R12.18 可用其他方式完成的转换不应使用 reinterpret_cast</a></li>
<li><a href="#forbidreinterpretcast">R12.19 合理使用 reinterpret_cast</a></li>
<li><a href="#forbidcstylecast">R12.20 在 C++ 代码中禁用 C 风格类型转换</a><br><br/></li>
</ul>
<p><span id="__buffer"><strong><a href="#buffer">13. Buffer</a></strong></span></p>
<ul>
<li><a href="#bufferoverflow">R13.1 避免缓冲区溢出</a></li>
<li><a href="#arrayindexoverflow">R13.2 数组下标不可越界</a></li>
<li><a href="#insufficientbuffer">R13.3 为缓冲区分配足够的空间</a></li>
<li><a href="#nonpodfilling">R13.4 memset 等函数不应作用于非 POD 对象</a></li>
<li><a href="#badlength">R13.5 memset 等函数长度相关的参数不应有误</a></li>
<li><a href="#valueoverflow">R13.6 memset 等函数填充值相关的参数不应有误</a><br><br/></li>
</ul>
<p><span id="__pointer"><strong><a href="#pointer">14. Pointer</a></strong></span></p>
<ul>
<li><a href="#nullderefinscp">R14.1 避免空指针解引用</a></li>
<li><a href="#nullderefinexp">R14.2 注意逻辑表达式内的空指针解引用</a></li>
<li><a href="#wildptrderef">R14.3 不可解引用未初始化的指针</a></li>
<li><a href="#danglingderef">R14.4 不可解引用已被释放的指针</a></li>
<li><a href="#invalidnullcheck">R14.5 避免无效的空指针检查</a></li>
<li><a href="#repeatednullcheck">R14.6 不应重复检查指针是否为空</a></li>
<li><a href="#fixedaddrtopointer">R14.7 不应将非零常量值赋值给指针</a></li>
<li><a href="#zeroasptrvalue">R14.8 不应使用常量 0 表示空指针</a></li>
<li><a href="#oddptrboolassignment">R14.9 不应使用 false 对指针赋值</a></li>
<li><a href="#oddptrcharassignment">R14.10 不应使用 ‘\0’ 等字符常量对指针赋值</a></li>
<li><a href="#oddptrboolcomparison">R14.11 指针不应与 false 比较大小</a></li>
<li><a href="#oddptrcharcomparison">R14.12 指针不应与 ‘\0’ 等字符常量比较大小</a></li>
<li><a href="#oddptrzerocomparison">R14.13 指针与空指针不应比较大小</a></li>
<li><a href="#this_zerocomparison">R14.14 不应判断 this 指针是否为空</a></li>
<li><a href="#this_deleteindestructor">R14.15 析构函数中不可使用 delete this</a></li>
<li><a href="#this_forbiddeletethis">R14.16 禁用 delete this</a></li>
<li><a href="#nullderefdynamiccast">R14.17 判断 dynamic_cast 转换是否成功</a></li>
<li><a href="#missingresetnull">R14.18 指针在释放后应置空</a><br><br/></li>
</ul>
<p><span id="__interruption"><strong><a href="#interruption">15. Interruption</a></strong></span></p>
<ul>
<li><a href="#sig_dataraces">R15.1 避免由信号处理产生的数据竞争</a></li>
<li><a href="#sig_nonasyncsafecall">R15.2 处理信号时避免使用非异步信号安全函数</a></li>
<li><a href="#sig_illreturn">R15.3 SIGFPE、SIGILL、SIGSEGV 等信号的处理函数不可返回</a></li>
<li><a href="#forbidsignalfunction">R15.4 禁用 signal 函数</a><br><br/></li>
</ul>
<p><span id="__concurrency"><strong><a href="#concurrency">16. Concurrency</a></strong></span></p>
<ul>
<li><a href="#dataraces">R16.1 访问共享数据应遵循合理的同步机制</a></li>
<li><a href="#toctou">R16.2 避免在事务中通过路径多次访问同一文件</a></li>
<li><a href="#atomicraces">R16.3 避免在事务中多次非同步地访问原子对象</a></li>
<li><a href="#deadlock">R16.4 避免死锁</a></li>
<li><a href="#asynchronoustermination">R16.5 避免异步终止线程</a></li>
<li><a href="#illlifetime">R16.6 避免异步终止共享对象的生命周期</a></li>
<li><a href="#spuriouslywakeup">R16.7 避免虚假唤醒造成同步错误</a></li>
<li><a href="#bitfielddataraces">R16.8 避免并发访问位域造成的数据竞争</a></li>
<li><a href="#signalinmultithreading">R16.9 多线程环境中不可使用 signal 函数</a><br><br/></li>
</ul>
<p><span id="__style"><strong><a href="#style">17. Style</a></strong></span></p>
<ul>
<li><a href="#spacestyle">R17.1 空格应遵循统一风格</a></li>
<li><a href="#bracestyle">R17.2 大括号应遵循统一风格</a></li>
<li><a href="#assignmentassubexpression">R17.3 赋值表达式不应作为子表达式</a></li>
<li><a href="#incdecassubexpression">R17.4 自增、自减表达式不应作为子表达式</a></li>
<li><a href="#nonboolcondition">R17.5 控制条件应为 bool 型表达式</a></li>
<li><a href="#nonboolsubcondition">R17.6 !、&amp;&amp;、|| 的子表达式应为 bool 型表达式</a></li>
<li><a href="#nonpostfixsubcondition">R17.7 &amp;&amp;、|| 的子表达式应为后缀表达式</a></li>
<li><a href="#mixnullptrandnull">R17.8 在 C++ 代码中 NULL 和 nullptr 不应混用</a></li>
<li><a href="#deprecatednull">R17.9 在 C++ 代码中用 nullptr 代替 NULL</a></li>
<li><a href="#redundantparentheses">R17.10 避免多余的括号</a></li>
<li><a href="#redundantsemicolon">R17.11 避免多余的分号</a><br/><br/></li>
</ul>
<h2 id="1-Security"><a href="#1-Security" class="headerlink" title="1. Security"></a><span id="security">1. Security</span></h2><h3 id="▌R1-1-敏感数据不可写入代码"><a href="#▌R1-1-敏感数据不可写入代码" class="headerlink" title="▌R1.1 敏感数据不可写入代码"></a><span id="plainsensitiveinfo">▌R1.1 敏感数据不可写入代码</span></h3><p>ID_plainSensitiveInfo&emsp;&emsp;&emsp;&emsp;&nbsp;:shield: security warning</p>
<hr/>

<p>代码中的敏感数据极易泄露，产品及相关运维、测试工具的代码均不可记录任何敏感数据。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * My name is Rabbit</span><br><span class="line"> * My passphrase is Y2Fycm90         // Non-compliant</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">#define PASSWORD &quot;Y2Fycm90&quot;          // Non-compliant</span><br><span class="line"></span><br><span class="line">const char* passcode = &quot;Y2Fycm90&quot;;   // Non-compliant</span><br></pre></td></tr></table></figure>
<p>将密码等敏感数据写入代码是非常不安全的，即使例中 Y2Fycm90 是实际密码的某种变换，聪明的读者也会很快将其破解。  </p>
<p>敏感数据的界定是产品设计的重要环节。对具有高可靠性要求的客户端软件，不建议保存任何敏感数据，对于必须保存敏感数据的软件系统，则需要落实安全的存储机制以及相关的评审与测试。<br><br/><br><br/></p>
<h4 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h4><p>ID_secretLeak<br><br/></p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p>CWE-259<br>CWE-798<br>SEI CERT MSC41-C<br><br/><br><br/></p>
<h3 id="▌R1-2-敏感数据不可被系统外界感知"><a href="#▌R1-2-敏感数据不可被系统外界感知" class="headerlink" title="▌R1.2 敏感数据不可被系统外界感知"></a><span id="secretleak">▌R1.2 敏感数据不可被系统外界感知</span></h3><p>ID_secretLeak&emsp;&emsp;&emsp;&emsp;&nbsp;:shield: security warning</p>
<hr/>

<p>敏感数据出入软件系统时需采用有效的保护措施。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void foo(User* u) &#123;</span><br><span class="line">    log(&quot;username: %s, password: %s&quot;, u-&gt;name, u-&gt;pw);   // Non-compliant</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显然，将敏感数据直接输出到界面、日志或其他外界可感知的介质中是不安全的，需避免敏感数据的有意外传，除此之外，还需要落实具体的保护措施。  </p>
<p>保护措施包括但不限于：  </p>
<ul>
<li>避免用明文或弱加密方式传输敏感数据  </li>
<li>避免敏感数据从内存交换到外存  </li>
<li>避免避免敏感数据写入内存转储文件  </li>
<li>应具备反调试机制，使外界无法获得程序的内部数据  </li>
<li>应具备反注入机制，使外界无法篡改程序的行为  </li>
</ul>
<p>下面以 Windows 平台为例，给出阻止敏感数据从内存交换到外存的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class SecretBuf &#123;</span><br><span class="line">    size_t len = 0;</span><br><span class="line">    unsigned char* buf = nullptr;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    SecretBuf(size_t size) &#123;</span><br><span class="line">        auto* tmp = (unsigned char*)VirtualAlloc(</span><br><span class="line">            0, size, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE</span><br><span class="line">        );</span><br><span class="line">        if (VirtualLock(tmp, size)) &#123;   // The key point</span><br><span class="line">            buf = tmp;</span><br><span class="line">            len = size;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            VirtualFree(tmp, 0, MEM_RELEASE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   ~SecretBuf() &#123;</span><br><span class="line">        SecureZeroMemory(buf, len);   // Clear the secret content</span><br><span class="line">        VirtualUnlock(buf, len);</span><br><span class="line">        VirtualFree(buf, 0, MEM_RELEASE);</span><br><span class="line">        len = 0;</span><br><span class="line">        buf = nullptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    size_t size() const &#123; return len; &#125;</span><br><span class="line">    unsigned char* ptr() &#123; return buf; &#125;</span><br><span class="line">    const unsigned char* ptr() const &#123; return buf; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>例中 SecretBuf 是一个缓冲区类，其申请的内存会被锁定在物理内存中，不会与外存交换，可在一定程度上防止其他进程的恶意嗅探，保障缓冲区内数据的安全。SecretBuf 在构造函数中通过 VirtualLock 锁定物理内存，在析构函数中通过 VirtualUnlock 解除锁定，解锁之前有必要清除数据，否则解锁之后残留数据仍有可能被交换到外存，进一步可参见 ID_unsafeCleanup。  </p>
<p>SecretBuf 的使用方法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void foo() &#123;</span><br><span class="line">    SecretBuf buf(256);</span><br><span class="line">    if (buf.ptr()) &#123;</span><br><span class="line">        ....             // Do something secret using buf.ptr()</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        ....             // Handle memory error</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Linux 等系统中可参见如下有相似功能的接口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int mlock(const void* addr, size_t len);     // In &lt;sys/mman.h&gt;</span><br><span class="line">int munlock(const void* addr, size_t len);</span><br><span class="line">int mlockall(int flags);</span><br><span class="line">int munlockall(void);</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="相关-1"><a href="#相关-1" class="headerlink" title="相关"></a>相关</h4><p>ID_unsafeCleanup<br><br/></p>
<h4 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h4><p>CWE-528<br>CWE-591<br>SEI CERT MEM06-C<br><br/><br><br/></p>
<h3 id="▌R1-3-敏感数据在使用后应被有效清理"><a href="#▌R1-3-敏感数据在使用后应被有效清理" class="headerlink" title="▌R1.3 敏感数据在使用后应被有效清理"></a><span id="unsafecleanup">▌R1.3 敏感数据在使用后应被有效清理</span></h3><p>ID_unsafeCleanup&emsp;&emsp;&emsp;&emsp;&nbsp;:shield: security warning</p>
<hr/>

<p>及时清理不再使用的敏感数据是重要的安全措施，且应保证清理过程不会因为编译器的优化而失效。  </p>
<p>程序会反复利用内存，敏感数据可能会残留在未初始化的对象或对象之间的填充数据中，如果被存储到磁盘或传输到网络就会造成敏感信息的泄露，可参见 ID_secretLeak 和 ID_ignorePaddingData 的进一步讨论。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void foo() &#123;</span><br><span class="line">    char password[8] = &#123;&#125;;</span><br><span class="line">    ....</span><br><span class="line">    memset(password, 0, sizeof(password));  // Non-compliant</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例代码调用 memset 覆盖敏感数据以达到清理目的，然而保存敏感信息的 password 为局部数组且 memset 之后没有再被引用，根据相关标准，编译器可将 memset 过程去掉，使敏感数据没有得到有效清理。C11 提供了 memset_s 函数以避免这种问题，某些平台和库也提供了相关支持，如 SecureZeroMemory、explicit_bzero、OPENSSL_cleanse 等不会被优化掉的函数。  </p>
<p>在 C++ 代码中，可用 volatile 限定相关数据以避免编译器的优化，再用 std::fill_n 等方法清理，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void foo() &#123;</span><br><span class="line">    char password[8] = &#123;&#125;;</span><br><span class="line">    ....</span><br><span class="line">    volatile char  v_padding = 0;</span><br><span class="line">    volatile char* v_address = password;</span><br><span class="line">    std::fill_n(v_address, sizeof(password), v_padding);  // Compliant</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="相关-2"><a href="#相关-2" class="headerlink" title="相关"></a>相关</h4><p>ID_secretLeak<br>ID_ignorePaddingData<br><br/></p>
<h4 id="依据"><a href="#依据" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 5.1.2.3(3)<br>ISO/IEC 9899:2011 5.1.2.3(4)<br>ISO/IEC 9899:2011 K.3.7.4.1<br><br/></p>
<h4 id="参考-2"><a href="#参考-2" class="headerlink" title="参考"></a>参考</h4><p>CWE-14<br>CWE-226<br>CWE-244<br>CWE-733<br>SEI CERT MSC06-C<br><br/><br><br/></p>
<h3 id="▌R1-4-公共成员或全局对象不应记录敏感数据"><a href="#▌R1-4-公共成员或全局对象不应记录敏感数据" class="headerlink" title="▌R1.4 公共成员或全局对象不应记录敏感数据"></a><span id="sensitivename">▌R1.4 公共成员或全局对象不应记录敏感数据</span></h3><p>ID_sensitiveName&emsp;&emsp;&emsp;&emsp;&nbsp;:shield: security warning</p>
<hr/>

<p>公共成员、全局对象可被外部代码引用，如果存有敏感数据则可能会被误用或窃取。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">extern string password;   // Non-compliant</span><br><span class="line"></span><br><span class="line">struct A &#123;</span><br><span class="line">    string username;</span><br><span class="line">    string password;      // Non-compliant</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>至少应将相关成员改为 private：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">public:</span><br><span class="line">    ....                  // Interfaces for accessing passwords safely</span><br><span class="line">private:</span><br><span class="line">    string username;</span><br><span class="line">    string password;      // Compliant</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>敏感数据最好对引用者完全隐藏，避免被恶意分析、复制或序列化。使数据与接口进一步分离，可参见“<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/pimpl">Pimpl idiom</a>”等模式。<br><br/><br><br/></p>
<h4 id="参考-3"><a href="#参考-3" class="headerlink" title="参考"></a>参考</h4><p>CWE-766<br><br/><br><br/></p>
<h3 id="▌R1-5-预判用户输入造成的不良后果"><a href="#▌R1-5-预判用户输入造成的不良后果" class="headerlink" title="▌R1.5 预判用户输入造成的不良后果"></a><span id="hijack">▌R1.5 预判用户输入造成的不良后果</span></h3><p>ID_hijack&emsp;&emsp;&emsp;&emsp;&nbsp;:shield: security warning</p>
<hr/>

<p>须对用户输入的脚本、路径、资源请求等信息进行预判，对产生不良后果的输入予以拒绝。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Result foo() &#123;</span><br><span class="line">    return sqlQuery(</span><br><span class="line">        &quot;select * from db where key=&#x27;%s&#x27;&quot;, userInput()   // Non-compliant</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设 userInput 返回用户输入的字符串，sqlQuery 将用户输入替换格式化占位符后执行 SQL 语句，如果用户输入“xxx’ or ‘x’=’x”一类的字符串则相当于执行的是“select * from db where key=’xxx’ or ‘x’=’x’”，一个恒为真的条件使 where 限制失效，造成所有数据被返回，这是一种常见的攻击方式，称为“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/SQL_injection">SQL 注入（SQL injection）</a>”，对于 XPath、XQuery、LDAP 等脚本均需考虑这种问题，应在执行前判断用户输入的安全性。  </p>
<p>又如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string bar() &#123;</span><br><span class="line">    return readFile(</span><br><span class="line">        &quot;/myhome/mydata/&quot; + userInput()   // Non-compliant</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码意在将用户输入的路径限制在 /myhome/mydata 目录下，然而这么做是不安全的，如果用户输入带有“../”这种相对路径，则仍可绕过限制，这也是一种常见的攻击方式，称为“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Directory_traversal_attack">路径遍历（directory traversal）</a>”，应在读取文件之前判断路径的安全性。  </p>
<p>注意，“用户输入”不单指人的手工输入，源自环境变量、配置文件以及其他软硬件的输入均在此范围内。<br><br/><br><br/></p>
<h4 id="参考-4"><a href="#参考-4" class="headerlink" title="参考"></a>参考</h4><p>CWE-23<br>CWE-73<br>CWE-89<br>CWE-943<br><br/><br><br/></p>
<h3 id="▌R1-6-对资源设定合理的访问权限"><a href="#▌R1-6-对资源设定合理的访问权限" class="headerlink" title="▌R1.6 对资源设定合理的访问权限"></a><span id="unlimitedauthority">▌R1.6 对资源设定合理的访问权限</span></h3><p>ID_unlimitedAuthority&emsp;&emsp;&emsp;&emsp;&nbsp;:shield: security warning</p>
<hr/>

<p>对资源设定合理的访问权限，避免为攻击者提供不应拥有的权限或能力。  </p>
<p>权限的分类包括但不限于：  </p>
<ul>
<li>文件、数据库等资源的读写权限  </li>
<li>计算、IO 过程的执行权限  </li>
<li>软硬件资源的占用权限  </li>
</ul>
<p>权限设定是产品设计与实现的重要环节，需落实相关的评审与测试。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    umask(000);                     // Non-compliant</span><br><span class="line">    FILE* fp = fopen(&quot;bar&quot;, &quot;w&quot;);   // Old method</span><br><span class="line">    ....</span><br><span class="line">    fclose(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中 umask 函数开放了所有用户对文件的读写权限，这是很不安全的，进程之间不应直接通过文件通信，应实现安全的接口和交互机制。  </p>
<p>由于历史原因，C 语言的 fopen 和 C++ 语言的 fstream 都不能确保文件只能被当前用户访问，C11 提供了 fopen_s，C++17 提供了 std::filesystem::permissions 以填补这方面的需求。  </p>
<p>C11 fopen_s 简例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#define __STDC_WANT_LIB_EXT1__ 1</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    FILE* fp = NULL;</span><br><span class="line">    errno_t e = fopen_s(&amp;fp, &quot;bar&quot;, &quot;w&quot;);   // Good</span><br><span class="line">    ....</span><br><span class="line">    fclose(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与 fopen 不同，fopen_s 可以不受 umask 等函数的影响，直接将文件的权限设为当前用户私有，其他用户不可访问，降低了文件被窃取或篡改的风险，是一种更安全的方法。  </p>
<p>除此之外，如果需要对资源进行更精细的权限管理，可参见“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Access-control_list">access control list（ACL）</a>”。<br><br/><br><br/></p>
<h4 id="依据-1"><a href="#依据-1" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:2011 K.3.5.2.1(7)<br>ISO/IEC 14882:2017 30.10.15.26<br><br/></p>
<h4 id="参考-5"><a href="#参考-5" class="headerlink" title="参考"></a>参考</h4><p>CWE-266<br>CWE-732<br>SEI CERT FIO06-C<br><br/><br><br/></p>
<h3 id="▌R1-7-对用户落实有效的权限管理"><a href="#▌R1-7-对用户落实有效的权限管理" class="headerlink" title="▌R1.7 对用户落实有效的权限管理"></a><span id="improperauthorization">▌R1.7 对用户落实有效的权限管理</span></h3><p>ID_improperAuthorization&emsp;&emsp;&emsp;&emsp;&nbsp;:shield: security warning</p>
<hr/>

<p>需落实有效的权限管理，相关措施包括但不限于：  </p>
<ul>
<li>落实授权与认证机制，提供多因素认证  </li>
<li>遵循最小特权原则，对资源和相关算法设置合理的访问或执行权限  </li>
<li>避免仅在客户端认证而非服务端认证  </li>
<li>检查请求是否符合用户的权限设定，拒绝无权限的请求  </li>
<li>用户放弃某项权限后，应确保相关权限不再生效  </li>
<li>遵循合理的“认证 - 执行”顺序，避免复杂度攻击或早期放大攻击  </li>
<li>保证信道完整性，对相关用户进行充分的身份认证，避免中间人攻击  </li>
<li>验证通信通道的源和目的地，拒绝非预期的请求和应答  </li>
<li>避免攻击者使用重放攻击等手段绕过身份认证或干扰正常运营  </li>
<li>避免不恰当地信任反向 DNS（关注 DNS Cache Poisoning）  </li>
<li>避免过于严格且易触发的账户锁定机制，使攻击者通过锁定账户干扰正常运营  </li>
</ul>
<p>权限管理与安全直接相关，应落实严格的评审、测试以及攻防演练。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Result foo() &#123;</span><br><span class="line">    auto req = getRequest();</span><br><span class="line">    auto res = sqlQuery(</span><br><span class="line">        &quot;select * from db where key=&#x27;%s&#x27;&quot;, req[&quot;key&quot;]   // Non-compliant</span><br><span class="line">    );</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设例中 req 对应用户请求，sqlQuery 将请求中的 key 字段替换格式化占位符后执行查询，这个模式存在多种问题，应先判断用户是否具有读取数据库相关字段的权限，而且还应判断 req[“key”] 的值是否安全，详见 ID_hijack。  </p>
<p>又如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void bar(User* user) &#123;</span><br><span class="line">    auto buf = read_large_file();</span><br><span class="line">    if (is_admin(user)) &#123;           // Non-compliant</span><br><span class="line">        do_something(buf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设例中 read_large_file 读取大型文件，is_admin 进行身份认证，在身份认证之前访问资源使得攻击者不必获取有效账号即可消耗系统资源，从而对系统造成干扰，所以应该在访问资源之前进行身份认证。<br><br/><br><br/></p>
<h4 id="参考-6"><a href="#参考-6" class="headerlink" title="参考"></a>参考</h4><p>CWE-285<br>CWE-350<br><br/><br><br/></p>
<h3 id="▌R1-8-避免引用危险符号名称"><a href="#▌R1-8-避免引用危险符号名称" class="headerlink" title="▌R1.8 避免引用危险符号名称"></a><span id="dangerousname">▌R1.8 避免引用危险符号名称</span></h3><p>ID_dangerousName&emsp;&emsp;&emsp;&emsp;&nbsp;:shield: security warning</p>
<hr/>

<p>弱加密、弱哈希、弱随机、不安全的协议等相关库、函数、类、宏、常量等名称不应出现在代码中。  </p>
<p>这种危险符号名称主要来自：  </p>
<ul>
<li>低质量随机数生成算法，如 srand、rand 等  </li>
<li>不再适用的哈希算法，如 MD2、MD4、MD5、MD6、RIPEMD 以及 SHA-1 等  </li>
<li>非加密协议，如 HTTP、FTP 等  </li>
<li>低版本的传输层安全协议，如 TLSv1.2 之前的版本  </li>
<li>弱加密算法，如 DES、3DES 等  </li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;openssl/md5.h&gt;   // Non-compliant, obsolete hash algorithm</span><br><span class="line"></span><br><span class="line">const string myUrl = &quot;http://foo/bar&quot;;   // Non-compliant, use https instead</span><br><span class="line"></span><br><span class="line">void foo() &#123;</span><br><span class="line">    MD5_CTX c;       // Non-compliant</span><br><span class="line">    MD5_Init(&amp;c);    // Non-compliant, obsolete hash algorithm</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void bar() &#123;</span><br><span class="line">    srand(0);        // Non-compliant, unsafe random seed</span><br><span class="line">    EVP_des_ecb();   // Non-compliant, unsafe encryption algorithm</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="参考-7"><a href="#参考-7" class="headerlink" title="参考"></a>参考</h4><p>CWE-326<br>CWE-327<br><br/><br><br/></p>
<h3 id="▌R1-9-避免使用危险接口"><a href="#▌R1-9-避免使用危险接口" class="headerlink" title="▌R1.9 避免使用危险接口"></a><span id="dangerousfunction">▌R1.9 避免使用危险接口</span></h3><p>ID_dangerousFunction&emsp;&emsp;&emsp;&emsp;&nbsp;:shield: security warning</p>
<hr/>

<p>由于历史原因，有些系统接口甚至标准库函数存在缺陷，无法安全使用，也有一些接口的使用条件很苛刻，难以安全使用。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">gets       // The most dangerous function</span><br><span class="line">mktemp     // Every use of ‘mktemp’ is a security risk, use ‘mkstemp’ instead</span><br><span class="line">getpass    // Unsafe and not portable</span><br><span class="line">crypt      // Unsafe, exhaustive searches of the key space are possible</span><br><span class="line">getpw      // It may overflow the provided buffer, use ‘getpwuid’ instead</span><br><span class="line">cuserid    // Not portable and unreliable, use ‘getpwuid(geteuid())’ instead</span><br><span class="line">chgrp      // Prone to TOCTOU race conditions, use ‘fchgrp’ instead</span><br><span class="line">chown      // Prone to TOCTOU race conditions, use ‘fchown’ instead</span><br><span class="line">chmod      // Prone to TOCTOU race conditions, use ‘fchmod’ instead</span><br><span class="line"></span><br><span class="line">SuspendThread       // Forced suspension of a thread can cause many problems</span><br><span class="line">TerminateThread     // Forced termination of a thread can cause many problems</span><br><span class="line">GlobalMemoryStatus        // Return incorrect information, use ‘GlobalMemoryStatusEx’ instead</span><br><span class="line">SetProcessWorkingSetSize  // Cause adverse effects on other processes and the entire system</span><br></pre></td></tr></table></figure>
<p>例中 gets 函数不检查缓冲区边界，无法安全使用；TerminateThread 等 Windows API 强制终止线程，线程持有的资源难以正确释放，极易导致泄漏或死锁等问题，应避免使用这类函数。<br><br/><br><br/></p>
<h4 id="参考-8"><a href="#参考-8" class="headerlink" title="参考"></a>参考</h4><p>CWE-242<br>CWE-676<br><br/><br><br/></p>
<h3 id="▌R1-10-避免使用已过时的接口"><a href="#▌R1-10-避免使用已过时的接口" class="headerlink" title="▌R1.10 避免使用已过时的接口"></a><span id="obsoletefunction">▌R1.10 避免使用已过时的接口</span></h3><p>ID_obsoleteFunction&emsp;&emsp;&emsp;&emsp;&nbsp;:shield: security warning</p>
<hr/>

<p>避免使用在相关标准中已过时的接口，应改用更完善的替代方法以规避风险，提高可移植性。  </p>
<p>对于过时的 C++ 标准库接口，本规则特化为 ID_obsoleteStdFunction。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">asctime         // Use ‘strftime’ instead</span><br><span class="line">bcmp            // Use ‘memcmp’ instead</span><br><span class="line">bcopy           // Use ‘memmove’ or ‘memcpy’ instead</span><br><span class="line">bsd_signal      // Use ‘sigaction’ instead</span><br><span class="line">bzero           // Use ‘memset’ instead</span><br><span class="line">ctime           // Use ‘strftime’ instead</span><br><span class="line">gethostbyaddr   // Use ‘getnameinfo’ instead</span><br><span class="line">gethostbyname   // Use ‘getaddrinfo’ instead</span><br><span class="line">getwd           // Use ‘getcwd’ instead</span><br><span class="line">mktemp          // Use ‘mkstemp’ instead</span><br><span class="line">usleep          // Use ‘nanosleep’ instead</span><br><span class="line">utime           // Use ‘utimensat’ instead</span><br><span class="line">vfork           // Use ‘fork’ instead</span><br><span class="line">wcswcs          // Use ‘wcsstr’ instead</span><br><span class="line"></span><br><span class="line">pthread_attr_getstackaddr   // Use ‘pthread_attr_getstack’ instead</span><br><span class="line">pthread_attr_setstackaddr   // Use ‘pthread_attr_setstack’ instead</span><br><span class="line"></span><br><span class="line">CreateToolbarEx      // Use ‘CreateWindowEx’ instead</span><br><span class="line">InitCommonControls   // Use ‘InitCommonControlsEx’ instead</span><br><span class="line">NtQuerySystemTime    // Use ‘GetSystemTimeAsFileTime’ instead</span><br><span class="line">RegCreateKey         // Use ‘RegCreateKeyEx’ instead</span><br><span class="line">WinExec              // Use ‘CreateProcess’ instead</span><br></pre></td></tr></table></figure>
<p>例中 C89 引入的 ctime、asctime 等函数在 POSIX.1-2008 标准中已过时，应改用 strftime 函数；RegCreateKey 等 16 位 Windows API 在 32 和 64 位平台中不应再被使用。<br><br/><br><br/></p>
<h4 id="相关-3"><a href="#相关-3" class="headerlink" title="相关"></a>相关</h4><p>ID_obsoleteStdFunction<br><br/></p>
<h4 id="参考-9"><a href="#参考-9" class="headerlink" title="参考"></a>参考</h4><p>CWE-477<br><br/><br><br/></p>
<h3 id="▌R1-11-禁用不安全的字符串函数"><a href="#▌R1-11-禁用不安全的字符串函数" class="headerlink" title="▌R1.11 禁用不安全的字符串函数"></a><span id="unsafestringfunction">▌R1.11 禁用不安全的字符串函数</span></h3><p>ID_unsafeStringFunction&emsp;&emsp;&emsp;&emsp;&nbsp;:no_entry: security warning</p>
<hr/>

<p>由于历史原因，C 标准库中的某些字符串函数不执行边界检查，易造成运行时错误和安全漏洞。  </p>
<p>这类函数包括：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gets、strcpy、strcat、wcscpy、wcscat、</span><br><span class="line">sprintf、vsprintf、swprintf、vswprintf、</span><br><span class="line">scanf、sscanf、fscanf、vfscanf、vscanf、vsscanf</span><br></pre></td></tr></table></figure>
<p>与这类函数相似的函数同样受本规则约束，如下列 Windows API：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StrCpy、StrCpyA、StrCpyW、StrCat、StrCatA、StrCatW、</span><br><span class="line">lstrcpy、lstrcpyA、lstrcpyW、lstrcat、lstrcatA、lstrcatW</span><br></pre></td></tr></table></figure>
<p>在 C 代码中应采用更安全的库函数，如用 fgets 代替 gets，snprintf 代替 sprintf。在 C++ 代码中应采用 STL 标准库提供的相关功能。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char buf[100];</span><br><span class="line">gets(buf);      // Non-compliant</span><br></pre></td></tr></table></figure>
<p>例中 gets 函数无法检查缓冲区的大小，一旦输入超过了 buf 数组的边界，程序的数据或流程就会遭到破坏，这种情况会被攻击者利用，可参见 ID_bufferOverflow 的进一步说明。如果代码中存在 gets 等函数，可以直接判定程序是有漏洞的。  </p>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char buf[100];</span><br><span class="line">fgets(buf, sizeof(buf), stdin);  // Compliant</span><br></pre></td></tr></table></figure>
<p>fgets 与 gets 不同，当输入超过缓冲区大小时会被截断，保证缓冲区之外的数据不会被破坏。  </p>
<p>又如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char buf[100];</span><br><span class="line">scanf(&quot;%s&quot;, buf);  // Non-compliant</span><br></pre></td></tr></table></figure>
<p>例中 scanf 函数与 gets 函数有相同的问题，可改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char buf[100];</span><br><span class="line">scanf(&quot;%99s&quot;, buf);  // Let it go, but ‘fgets’ is better</span><br></pre></td></tr></table></figure>
<p>scanf、sprintf、strcpy 等函数无视缓冲区大小，需要在外部另行实现防止缓冲区溢出的代码，完全依赖于开发者的小心谨慎。历史表明，对人的单方面依赖是不可靠的，改用更安全的方法才是明智的选择。<br><br/><br><br/></p>
<h4 id="相关-4"><a href="#相关-4" class="headerlink" title="相关"></a>相关</h4><p>ID_bufferOverflow<br><br/></p>
<h4 id="依据-2"><a href="#依据-2" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:2011 Annex K<br>ISO/IEC 9899:2011 K.3.7<br>ISO/IEC 9899:2011 K.3.9<br><br/></p>
<h4 id="参考-10"><a href="#参考-10" class="headerlink" title="参考"></a>参考</h4><p>CWE-119<br>CWE-120<br>CWE-676<br>MISRA C++ 2008 18-0-5<br><br/><br><br/></p>
<h3 id="▌R1-12-确保字符串以空字符结尾"><a href="#▌R1-12-确保字符串以空字符结尾" class="headerlink" title="▌R1.12 确保字符串以空字符结尾"></a><span id="impropernulltermination">▌R1.12 确保字符串以空字符结尾</span></h3><p>ID_improperNullTermination&emsp;&emsp;&emsp;&emsp;&nbsp;:shield: security warning</p>
<hr/>

<p>语言要求字符串以空字符结尾，程序应保证有足够的内存空间安置空字符，否则会破坏程序基本的执行机制，造成严重问题。  </p>
<p>空字符指 ‘\0’、L’\0’、u’\0’、U’\0’，分别对应 char*、wchar_t*、char16_t*、char32_t* 等字符串类型。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void foo(const char* p) &#123;</span><br><span class="line">    char a[4];</span><br><span class="line">    strncpy(a, p, sizeof(a));</span><br><span class="line">    printf(&quot;%s\n&quot;, strupr(a));   // To upper case and print, dangerous</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例示代码将字符串复制到数组中，转为大写并打印，然而如果 p 所指字符串的长度超过 3，strncpy 不会在数组的结尾安置空字符 ‘\0’，导致 strupr 内存访问越界，程序可能会崩溃，也可能打印出本该隐藏的敏感数据。  </p>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void foo(const char* p) &#123;</span><br><span class="line">    char a[4] = &quot;&quot;;                 // Initialize all to &#x27;\0&#x27;</span><br><span class="line">    strncpy(a, p, sizeof(a));</span><br><span class="line">    if (a[3] == &#x27;\0&#x27;) &#123;</span><br><span class="line">        printf(&quot;%s\n&quot;, strupr(a));  // OK</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        ....                        // Handle string length exceptions</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将所有数组元素初始化为 ‘\0’，调用 strncpy 后如果数组最后一个元素是 ‘\0’，说明输入字符串的长度符合要求，否则可作出相应的异常处理。<br><br/><br><br/></p>
<h4 id="相关-5"><a href="#相关-5" class="headerlink" title="相关"></a>相关</h4><p>ID_unsafeStringFunction<br><br/></p>
<h4 id="依据-3"><a href="#依据-3" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 7.21.2.4<br>ISO/IEC 9899:2011 7.24.2.4<br><br/></p>
<h4 id="参考-11"><a href="#参考-11" class="headerlink" title="参考"></a>参考</h4><p>CWE-170<br><br/><br><br/></p>
<h3 id="▌R1-13-避免除-0-等计算异常"><a href="#▌R1-13-避免除-0-等计算异常" class="headerlink" title="▌R1.13 避免除 0 等计算异常"></a><span id="dividebyzero">▌R1.13 避免除 0 等计算异常</span></h3><p>ID_divideByZero&emsp;&emsp;&emsp;&emsp;&nbsp;:shield: security error</p>
<hr/>

<p>除 0 等在数学上没有定义的运算、浮点异常、非法指令、段错误等问题称为“计算异常”，意味着严重的底层运行时错误，而且这种异常无法用语言层面的常规方法捕获。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int foo(int n) &#123;</span><br><span class="line">    if (n) &#123;</span><br><span class="line">        return 100 / n;   // Compliant</span><br><span class="line">    &#125;</span><br><span class="line">    return 200 / n;   // Non-compliant, undefined behavior</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整数除 0 往往会使程序崩溃，浮点数除 0 可以产生“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Infinity#Computing">Inf</a>”或“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/NaN">NaN</a>”等无效结果，在某些环境中也可以设置浮点异常使程序收到特定信号。  </p>
<p>崩溃会使程序异常终止，无法或难以执行必要的善后工作。如果崩溃可由外部输入引起，会被攻击者利用从而迫使程序无法正常工作，具有高可靠性要求的服务类程序更应该注意这一点，可参见“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Denial-of-service_attack">拒绝服务攻击</a>”。对于客户端程序，也要防止攻击者对崩溃产生的“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Core_dump">core dump</a>”进行恶意调试，避免泄露敏感数据，总之程序的健壮性与安全性是紧密相关的。<br><br/><br><br/></p>
<h4 id="相关-6"><a href="#相关-6" class="headerlink" title="相关"></a>相关</h4><p>ID_sig_illReturn<br><br/></p>
<h4 id="依据-4"><a href="#依据-4" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 6.5.5(5)-undefined<br>ISO/IEC 9899:2011 6.5.5(5)-undefined<br>ISO/IEC 14882:2003 5.6(4)-undefined<br>ISO/IEC 14882:2011 5.6(4)-undefined<br>ISO/IEC 14882:2017 8.6(4)-undefined<br><br/></p>
<h4 id="参考-12"><a href="#参考-12" class="headerlink" title="参考"></a>参考</h4><p>CWE-189<br>CWE-369<br>C++ Core Guidelines ES.105<br><br/><br><br/></p>
<h3 id="▌R1-14-格式化字符串应为常量"><a href="#▌R1-14-格式化字符串应为常量" class="headerlink" title="▌R1.14 格式化字符串应为常量"></a><span id="variableformatstring">▌R1.14 格式化字符串应为常量</span></h3><p>ID_variableFormatString&emsp;&emsp;&emsp;&emsp;&nbsp;:shield: security warning</p>
<hr/>

<p>出于可读性和安全性的考量，格式化字符串最好直接写成常量字符串的形式。  </p>
<p>本规则是 ID_hijack 的特化。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int a, b, c;</span><br><span class="line">const char* fmt = foo();</span><br><span class="line">....</span><br><span class="line">printf(fmt, a, b, c);  // Non-compliant</span><br></pre></td></tr></table></figure>
<p>例中格式化字符串 fmt 是变量，这种方式可读性较差，而且要注意如果 fmt 可受外界影响，则可能被攻击者利用造成不良后果。  </p>
<p>应将 fmt 改为常量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;%d %d %d&quot;, a, b, c);  // Compliant</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="相关-7"><a href="#相关-7" class="headerlink" title="相关"></a>相关</h4><p>ID_hijack<br><br/></p>
<h4 id="参考-13"><a href="#参考-13" class="headerlink" title="参考"></a>参考</h4><p>CWE-134<br><br/><br><br/></p>
<h3 id="▌R1-15-与内存空间布局相关的信息不可被外界感知"><a href="#▌R1-15-与内存空间布局相关的信息不可被外界感知" class="headerlink" title="▌R1.15 与内存空间布局相关的信息不可被外界感知"></a><span id="addressexposure">▌R1.15 与内存空间布局相关的信息不可被外界感知</span></h3><p>ID_addressExposure&emsp;&emsp;&emsp;&emsp;&nbsp;:shield: security warning</p>
<hr/>

<p>函数、对象、缓冲区的地址以及相关内存区域的长度等信息不可被外界感知，否则会成为攻击者的线索。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int foo(int* p, int n) &#123;</span><br><span class="line">    if (n &gt;= some_value) &#123;</span><br><span class="line">        log(&quot;buffer address: %p, size: %d&quot;, p, n);   // Non-compliant</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例代码将缓冲区的地址和长度输出到日志是不安全的，这种代码多以调试为目的，不应将其编译到产品的正式版本中。<br><br/><br><br/></p>
<h4 id="相关-8"><a href="#相关-8" class="headerlink" title="相关"></a>相关</h4><p>ID_bufferOverflow<br><br/></p>
<h4 id="参考-14"><a href="#参考-14" class="headerlink" title="参考"></a>参考</h4><p>CWE-200<br><br/><br><br/></p>
<h3 id="▌R1-16-与网络地址相关的信息不应写入代码"><a href="#▌R1-16-与网络地址相关的信息不应写入代码" class="headerlink" title="▌R1.16 与网络地址相关的信息不应写入代码"></a><span id="hardcodedip">▌R1.16 与网络地址相关的信息不应写入代码</span></h3><p>ID_hardcodedIP&emsp;&emsp;&emsp;&emsp;&nbsp;:shield: security warning</p>
<hr/>

<p>在代码中记录网络地址不利于维护和移植，也容易暴露产品的网络结构，属于安全隐患。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string host = &quot;10.16.25.93&quot;;    // Non-compliant</span><br><span class="line">foo(&quot;172.16.10.36:8080&quot;);       // Non-compliant</span><br><span class="line">bar(&quot;https://192.168.73.90&quot;);   // Non-compliant</span><br></pre></td></tr></table></figure>
<p>应从配置文件中获取地址，并配以加密措施：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MyConf cfg;</span><br><span class="line">string host = cfg.host();   // Compliant</span><br><span class="line">foo(cfg.port());            // Compliant</span><br><span class="line">bar(cfg.url());             // Compliant</span><br></pre></td></tr></table></figure>
<p>特殊的 IP 地址可不受本规则限制，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0.0.0.0</span><br><span class="line">255.255.255.255</span><br><span class="line">127.0.0.1-127.255.255.255</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="相关-9"><a href="#相关-9" class="headerlink" title="相关"></a>相关</h4><p>ID_addressExposure<br><br/><br><br/></p>
<h3 id="▌R1-17-选择安全的异常处理方式"><a href="#▌R1-17-选择安全的异常处理方式" class="headerlink" title="▌R1.17 选择安全的异常处理方式"></a><span id="deprecatederrno">▌R1.17 选择安全的异常处理方式</span></h3><p>ID_deprecatedErrno&emsp;&emsp;&emsp;&emsp;&nbsp;:shield: security warning</p>
<hr/>

<p>避免使用 errno 和与其相同的模式，应根据实际需求选择通过函数返回值或 C++ 异常机制来处理异常情况。  </p>
<p>errno 被设定的位置和被读取的位置相距较远，不遵循固定的静态结构，极易误用，是不安全的异常处理方式，对异常情况的错误处理往往会成为业务漏洞，使攻击者轻易地实现其目的。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void foo() &#123;</span><br><span class="line">    if (somecall() == FAILED) &#123;</span><br><span class="line">        printf(&quot;somecall failed\n&quot;);</span><br><span class="line">        if (errno == SOME_VALUE) &#123;     // Non-compliant</span><br><span class="line">            .... </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中 somecall 执行异常，通过 errno 获取异常信息，但 errno 的值会被 printf 修改，相应的异常处理也失去了意义。  </p>
<p>又如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void bar(const char* s) &#123;</span><br><span class="line">    int i = atoi(s);</span><br><span class="line">    if (errno) &#123;        // Non-compliant</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>errno 并不能反映所有异常情况，atoi 等函数与 errno 无关，例中 errno 的值来自函数外部难以预料的位置，相应的异常处理也将是错误的。<br><br/><br><br/></p>
<h4 id="参考-15"><a href="#参考-15" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines E.28<br>MISRA C 2004 20.5<br>MISRA C++ 2008 19-3-1<br><br/><br><br/></p>
<h3 id="▌R1-18-启用平台和编译器提供的防御机制"><a href="#▌R1-18-启用平台和编译器提供的防御机制" class="headerlink" title="▌R1.18 启用平台和编译器提供的防御机制"></a><span id="missinghardening">▌R1.18 启用平台和编译器提供的防御机制</span></h3><p>ID_missingHardening&emsp;&emsp;&emsp;&emsp;&nbsp;:shield: security suggestion</p>
<hr/>

<p>针对一些常见攻击，平台和编译器会提供防御机制，如：  </p>
<ul>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Executable_space_protection">数据执行保护（NX、DEP）</a>  </li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Buffer_overflow_protection">栈溢出防护（CANARY、GS）</a>  </li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Address_space_layout_randomization">地址空间布局随机化（ASLR、PIE）</a>  </li>
</ul>
<p>程序应利用这种机制加强自身的安全性，进一步可参见“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Hardening_(computing">security hardening</a>)”。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// In test.c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void) &#123;</span><br><span class="line">    printf(&quot;%p\n&quot;, main);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果在 Linux 等平台上按如下方式编译：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cc test.c -o test</span><br></pre></td></tr></table></figure>
<p>各函数的地址在虚拟内存中是固定的，易被攻击者猜中，进而施展攻击手段。  </p>
<p>当平台启用了“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Address_space_layout_randomization">ASLR</a>”机制，再按如下方式编译：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cc test.c -o test -fPIE -pie</span><br></pre></td></tr></table></figure>
<p>可使程序各结构的地址随机化，函数的地址在每次运行时均不相同，有效提高了攻击难度。  </p>
<p>如无特殊原因，在编译程序时不应屏蔽这种防御机制，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cc test.c -o test -z execstack           # Non-compliant, disable NX</span><br><span class="line">cc test.c -o test -z norelro             # Non-compliant, disable RELRO</span><br><span class="line">cc test.c -o test -fno-stack-protector   # Non-compliant, disable CANARY</span><br></pre></td></tr></table></figure>
<p>如果必须屏蔽，应落实相关的评审与测试。<br><br/><br><br/><br><br/></p>
<h2 id="2-Resource"><a href="#2-Resource" class="headerlink" title="2. Resource"></a><span id="resource">2. Resource</span></h2><h3 id="▌R2-1-不可失去对已分配资源的控制"><a href="#▌R2-1-不可失去对已分配资源的控制" class="headerlink" title="▌R2.1 不可失去对已分配资源的控制"></a><span id="resourceleak">▌R2.1 不可失去对已分配资源的控制</span></h3><p>ID_resourceLeak&emsp;&emsp;&emsp;&emsp;&nbsp;:drop_of_blood: resource warning</p>
<hr/>

<p>对于动态分配的资源，其地址、句柄或描述符等标志性信息不可被遗失，否则资源无法被访问也无法被回收，这种问题称为“资源泄漏”，会导致资源耗尽或死锁等问题，使程序无法正常运行。  </p>
<p>在资源被回收之前，记录其标志性信息的变量如果：  </p>
<ul>
<li>均被重新赋值  </li>
<li>生命周期均已结束  </li>
<li>所在线程均被终止  </li>
</ul>
<p>相关资源便失去了控制，无法再通过正常手段访问相关资源。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int fd;</span><br><span class="line">fd = open(&quot;a&quot;, O_RDONLY);   // Open a file descriptor</span><br><span class="line">read(fd, buf1, 100);</span><br><span class="line">fd = open(&quot;b&quot;, O_RDONLY);   // Non-compliant, the previous descriptor is lost</span><br><span class="line">read(fd, buf2, 100);</span><br></pre></td></tr></table></figure>
<p>例中变量 fd 记录文件资源描述符，在回收资源之前对其重新赋值会导致资源泄漏。<br><br/><br><br/></p>
<h4 id="相关-10"><a href="#相关-10" class="headerlink" title="相关"></a>相关</h4><p>ID_memoryLeak<br>ID_asynchronousTermination<br><br/></p>
<h4 id="参考-16"><a href="#参考-16" class="headerlink" title="参考"></a>参考</h4><p>CWE-772<br>C++ Core Guidelines P.8<br><br/><br><br/></p>
<h3 id="▌R2-2-不可失去对已分配内存的控制"><a href="#▌R2-2-不可失去对已分配内存的控制" class="headerlink" title="▌R2.2 不可失去对已分配内存的控制"></a><span id="memoryleak">▌R2.2 不可失去对已分配内存的控制</span></h3><p>ID_memoryLeak&emsp;&emsp;&emsp;&emsp;&nbsp;:drop_of_blood: resource warning</p>
<hr/>

<p>动态分配的内存地址不可被遗失，否则相关内存无法被访问也无法被回收，这种问题称为“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Memory_leak">内存泄漏（memory leak）</a>”，会导致可用内存被耗尽，使程序无法正常运行。  </p>
<p>程序需要保证内存分配与回收之间的流程可达，且不可被异常中断，相关线程也不可在中途停止。  </p>
<p>本规则是 ID_resourceLeak 的特化。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void foo(size_t n) &#123;</span><br><span class="line">    void* p = malloc(n);</span><br><span class="line">    if (cond) &#123;</span><br><span class="line">        return;  // Non-compliant, ‘p’ is lost</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">    free(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中局部变量 p 记录已分配的内存地址，释放前在某种情况下函数返回，之后便再也无法访问到这块内存了，导致内存泄露。  </p>
<p>又如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void bar(size_t n) &#123;</span><br><span class="line">    void* p = malloc(n);</span><br><span class="line">    if (n &lt; 100) &#123;</span><br><span class="line">        p = realloc(p, 100);  // Non-compliant, the original value of ‘p’ is lost</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中 realloc 函数分配失败会返回 NULL，p 未经释放而被重新赋值，导致内存泄露。<br><br/><br><br/></p>
<h4 id="相关-11"><a href="#相关-11" class="headerlink" title="相关"></a>相关</h4><p>ID_resourceLeak<br>ID_ownerlessResource<br>ID_throwInConstructor<br>ID_memberDeallocation<br>ID_multiAllocation<br><br/></p>
<h4 id="依据-5"><a href="#依据-5" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 7.20.3(1)<br>ISO/IEC 9899:2011 7.22.3(1)<br>ISO/IEC 14882:2003 3.7.3.1(2)<br>ISO/IEC 14882:2003 3.7.4.1(2)<br><br/></p>
<h4 id="参考-17"><a href="#参考-17" class="headerlink" title="参考"></a>参考</h4><p>CWE-401<br>C++ Core Guidelines P.8<br>C++ Core Guidelines E.13<br><br/><br><br/></p>
<h3 id="▌R2-3-不可访问未初始化或已释放的资源"><a href="#▌R2-3-不可访问未初始化或已释放的资源" class="headerlink" title="▌R2.3 不可访问未初始化或已释放的资源"></a><span id="illaccess">▌R2.3 不可访问未初始化或已释放的资源</span></h3><p>ID_illAccess&emsp;&emsp;&emsp;&emsp;&nbsp;:drop_of_blood: resource error</p>
<hr/>

<p>访问未初始化或已释放的资源属于逻辑错误，会导致标准未定义的行为。  </p>
<p>对于访问未初始化的局部对象，本规则特化为 ID_localInitialization；对于解引用未初始化或已被释放的指针，本规则特化为 ID_wildPtrDeref 、ID_danglingDeref。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void foo(const char* path, char buf[], size_t n) &#123;</span><br><span class="line">    FILE* f;</span><br><span class="line">    if (path != NULL) &#123;</span><br><span class="line">        f = fopen(path, &quot;rb&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    fread(buf, 1, n, f);   // Non-compliant, ‘f’ may be invalid</span><br><span class="line">    fclose(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void bar(FILE* f, char buf[], size_t n) &#123;</span><br><span class="line">    if (feof(f)) &#123;</span><br><span class="line">        fclose(f);</span><br><span class="line">    &#125;</span><br><span class="line">    fread(buf, 1, n, f);   // Non-compliant, ‘f’ may be closed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="相关-12"><a href="#相关-12" class="headerlink" title="相关"></a>相关</h4><p>ID_wildPtrDeref<br>ID_danglingDeref<br>ID_localInitialization<br><br/></p>
<h4 id="依据-6"><a href="#依据-6" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 7.19.3(4)<br>ISO/IEC 9899:2011 7.21.3(4)<br><br/></p>
<h4 id="参考-18"><a href="#参考-18" class="headerlink" title="参考"></a>参考</h4><p>CWE-672<br>CWE-908<br>SEI CERT FIO46-C<br>SEI CERT EXP53-CPP<br><br/><br><br/></p>
<h3 id="▌R2-4-资源应接受对象化管理"><a href="#▌R2-4-资源应接受对象化管理" class="headerlink" title="▌R2.4 资源应接受对象化管理"></a><span id="ownerlessresource">▌R2.4 资源应接受对象化管理</span></h3><p>ID_ownerlessResource&emsp;&emsp;&emsp;&emsp;&nbsp;:drop_of_blood: resource warning</p>
<hr/>

<p>使资源接受对象化管理，免去繁琐易错的手工分配回收过程，是 C++ 程序设计的重要方法。  </p>
<p>将资源分配的结果直接在程序中传递是非常不安全的，极易产生泄漏或死锁等问题。动态申请的资源如果只用普通变量引用，不受对象的构造或析构机制控制，则称为“无主”资源，在 C++ 程序设计中应当避免。  </p>
<p>应尽量使用标准库提供的容器或智能指针，避免显式使用资源管理接口。本规则集合示例中的 new/delete、lock/unlock 意在代指一般的资源操作，仅作示例，在实际代码中应尽量避免。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">void foo(size_t size) &#123;</span><br><span class="line">    int* p = new int[size];   // Bad, ownerless</span><br><span class="line">    ....                      // If any exception is thrown, or a wrong jump, leak</span><br><span class="line">    delete[] p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct X &#123;</span><br><span class="line">    int* p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void bar() &#123;</span><br><span class="line">    X x;</span><br><span class="line">    x.p = new int[123];   // Bad, ‘X’ has no destructor, ‘x’ is not an owner</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Y &#123;</span><br><span class="line">    int* p;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    Y(size_t n): p(new int[n]) &#123;&#125;</span><br><span class="line">   ~Y() &#123; delete[] p; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void baz() &#123;</span><br><span class="line">    Y y(123);   // Good, ‘y’ is the owner of the resource</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中 foo 和 bar 函数的资源管理方式是不符合 C++ 理念的，baz 函数中的 y 对象负责资源的分配与回收，称 y 对象具有资源的所有权，相关资源的生命周期与 y 的生命周期一致，有效避免了资源泄漏或错误回收等问题。  </p>
<p>资源的所有权可以发生转移，但应保证转移前后均有对象负责管理资源，并且在转移过程中不会产生异常。进一步理解对象化管理方法，可参见“<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/raii">RAII（Resource Acquisition Is Initialization）</a>”等机制。  </p>
<p>与资源相关的系统接口不应直接被业务代码引用，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void foo(const TCHAR* path) &#123;</span><br><span class="line">    HANDLE h;</span><br><span class="line">    WIN32_FIND_DATA ffd;</span><br><span class="line"></span><br><span class="line">    h = FindFirstFile(path, &amp;ffd);  // Bad, ownerless</span><br><span class="line">    ....</span><br><span class="line">    CloseHandle(h);  // Is it right?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中 Windows API FindFirstFile 返回资源句柄，是“无主”资源，很可能被后续代码误用或遗忘。  </p>
<p>应进行合理封装：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class MY_FIND_DATA</span><br><span class="line">&#123;</span><br><span class="line">    struct HANDLE_DELETER</span><br><span class="line">    &#123;</span><br><span class="line">        using pointer = HANDLE;</span><br><span class="line">        void operator()(pointer p) &#123; FindClose(p); &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    WIN32_FIND_DATA ffd;</span><br><span class="line">    unique_ptr&lt;HANDLE, HANDLE_DELETER&gt; uptr;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    MY_FIND_DATA(const TCHAR* path): uptr(FindFirstFile(path, &amp;ffd)) &#123;&#125;</span><br><span class="line">    ....</span><br><span class="line">    HANDLE handle() &#123; return uptr.get(); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>本例将 FindFirstFile 及其相关数据封装成一个类，由 unique_ptr 对象保存 FindFirstFile 的结果，FindClose 是资源的回收方法，将其作为 unique_ptr 对象的组成部分，使资源可以被自动回收。<br><br/><br><br/></p>
<h4 id="参考-19"><a href="#参考-19" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines R.11<br>C++ Core Guidelines R.12<br><br/><br><br/></p>
<h3 id="▌R2-5-资源的分配与回收方法应成对提供"><a href="#▌R2-5-资源的分配与回收方法应成对提供" class="headerlink" title="▌R2.5 资源的分配与回收方法应成对提供"></a><span id="incompletenewdeletepair">▌R2.5 资源的分配与回收方法应成对提供</span></h3><p>ID_incompleteNewDeletePair&emsp;&emsp;&emsp;&emsp;&nbsp;:drop_of_blood: resource suggestion</p>
<hr/>

<p>资源的分配和回收方法应在同一库或主程序等可执行模块、类等逻辑模块中提供。  </p>
<p>如果一个模块分配的资源需要另一个模块回收，会打破模块之间的独立性，增加维护成本，而且 so、dll、exe 等可执行模块一般都有独立的堆栈，跨模块的分配与回收往往会造成严重错误。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// In a.dll</span><br><span class="line">int* foo() &#123;</span><br><span class="line">    return (int*)malloc(1024);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// In b.dll</span><br><span class="line">void bar() &#123;</span><br><span class="line">    int* p = foo();</span><br><span class="line">    ....</span><br><span class="line">    free(p);   // Non-compliant, crash</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中 a.dll 分配的内存由 b.dll 释放，相当于混淆了不同堆栈中的数据，程序一般会崩溃。  </p>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// In a.dll</span><br><span class="line">int* foo_alloc() &#123;</span><br><span class="line">    return (int*)malloc(1024);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void foo_dealloc(int* p) &#123;</span><br><span class="line">    free(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// In b.dll</span><br><span class="line">void bar() &#123;</span><br><span class="line">    int* p = foo_alloc();</span><br><span class="line">    ....</span><br><span class="line">    foo_dealloc(p);   // Compliant</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修正后 a.dll 成对提供分配回收函数，b.dll 配套使用这些函数，避免了冲突。  </p>
<p>类等逻辑模块提供了分配方法，也应提供回收方法，如重载了 new 运算符，也应重载相应的 delete 运算符：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    void* operator new(size_t);   // Non-compliant, missing ‘operator delete’</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class B &#123;</span><br><span class="line">    void operator delete(void*);   // Non-compliant, missing ‘operator new’</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class C &#123;</span><br><span class="line">    void* operator new(size_t);   // Compliant</span><br><span class="line">    void operator delete(void*);   // Compliant</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>placement-new 与 placement-delete 也应成对提供：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class D &#123;</span><br><span class="line">    void* operator new(size_t, bool);   // Non-compliant</span><br><span class="line"></span><br><span class="line">    void* operator new(size_t, int, int);   // Compliant</span><br><span class="line">    void operator delete(void*, int, int);   // Compliant</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="相关-13"><a href="#相关-13" class="headerlink" title="相关"></a>相关</h4><p>ID_memberDeallocation<br>ID_crossModuleTransfer<br>ID_incompatibleDealloc<br><br/></p>
<h4 id="参考-20"><a href="#参考-20" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines R.15<br><br/><br><br/></p>
<h3 id="▌R2-6-资源的分配与回收方法应配套使用"><a href="#▌R2-6-资源的分配与回收方法应配套使用" class="headerlink" title="▌R2.6 资源的分配与回收方法应配套使用"></a><span id="incompatibledealloc">▌R2.6 资源的分配与回收方法应配套使用</span></h3><p>ID_incompatibleDealloc&emsp;&emsp;&emsp;&emsp;&nbsp;:drop_of_blood: resource error</p>
<hr/>

<p>使用了某种分配方法，就应使用与其配套的回收方法，否则会引发严重错误。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void foo() &#123;</span><br><span class="line">    T* p = new T;</span><br><span class="line">    ....</span><br><span class="line">    free(p);   // Non-compliant, use ‘delete’ instead</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void bar(size_t n) &#123;</span><br><span class="line">    char* p = (char*)malloc(n);</span><br><span class="line">    ....</span><br><span class="line">    delete[] p;   // Non-compliant, use ‘free’ instead</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不同的分配回收方法属于不同的资源管理体系，用 new 分配的资源应使用 delete 回收，malloc 分配的应使用 free 回收。<br><br/><br><br/></p>
<h4 id="相关-14"><a href="#相关-14" class="headerlink" title="相关"></a>相关</h4><p>ID_incompleteNewDeletePair<br><br/></p>
<h4 id="依据-7"><a href="#依据-7" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 7.20.3.2(2)-undefined<br>ISO/IEC 9899:2011 7.22.3.3(2)-undefined<br>ISO/IEC 14882:2003 3.7.3.2(3)<br>ISO/IEC 14882:2011 3.7.4.2(3)-undefined<br><br/></p>
<h4 id="参考-21"><a href="#参考-21" class="headerlink" title="参考"></a>参考</h4><p>SEI CERT MEM51-CPP<br><br/><br><br/></p>
<h3 id="▌R2-7-不应在模块之间传递容器类对象"><a href="#▌R2-7-不应在模块之间传递容器类对象" class="headerlink" title="▌R2.7 不应在模块之间传递容器类对象"></a><span id="crossmoduletransfer">▌R2.7 不应在模块之间传递容器类对象</span></h3><p>ID_crossModuleTransfer&emsp;&emsp;&emsp;&emsp;&nbsp;:drop_of_blood: resource warning</p>
<hr/>

<p>在库或主程序等可执行模块之间传递容器类对象会造成分配回收方面的冲突。  </p>
<p>与资源管理相关的对象，如流、字符串、智能指针以及自定义对象均不应在模块间传递。  </p>
<p>不同的可执行模块往往具有独立的资源管理机制，跨模块的分配与回收会造成严重错误，而且不同的模块可能由不同的编译器生成，对同一对象的实现也可能存在冲突。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// In a.dll</span><br><span class="line">void foo(vector&lt;int&gt;&amp; v) &#123;</span><br><span class="line">    v.reserve(100);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// In b.exe</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; v &#123;   // Allocation in b.exe</span><br><span class="line">        1, 2, 3</span><br><span class="line">    &#125;;</span><br><span class="line">    foo(v);   // Non-compliant, reallocation in a.dll, crash</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中容器 v 的初始内存由 b.exe 分配，b.exe 与 a.dll 具有独立的堆栈，由于模板库的内联实现，reserve 函数会调用 a.dll 的内存管理函数重新分配 b.exe 中的内存，造成严重错误。<br><br/><br><br/></p>
<h4 id="相关-15"><a href="#相关-15" class="headerlink" title="相关"></a>相关</h4><p>ID_incompleteNewDeletePair<br>ID_ABIConflict<br><br/><br><br/></p>
<h3 id="▌R2-8-不应在模块之间传递非标准布局类型的对象"><a href="#▌R2-8-不应在模块之间传递非标准布局类型的对象" class="headerlink" title="▌R2.8 不应在模块之间传递非标准布局类型的对象"></a><span id="abiconflict">▌R2.8 不应在模块之间传递非标准布局类型的对象</span></h3><p>ID_ABIConflict&emsp;&emsp;&emsp;&emsp;&nbsp;:drop_of_blood: resource warning</p>
<hr/>

<p>非标准布局类型的运行时特性依赖编译器的具体实现，在不同编译器生成的模块间传递这种类型的对象会导致运行时错误。  </p>
<p>“<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/named_req/StandardLayoutType">标准布局（standard-layout）</a>”类型的主要特点：  </p>
<ul>
<li>没有虚函数也没有虚基类  </li>
<li>所有非静态数据成员均具有相同的访问权限  </li>
<li>所有非静态数据成员和位域都在同一个类中声明  </li>
<li>不存在相同类型的基类对象  </li>
<li>没有非标准布局的基类  </li>
<li>没有非标准布局和引用类型的非静态数据成员  </li>
</ul>
<p>除非模块均由同一编译器的同一版本生成，否则不具备上述特点的对象不应在模块之间传递。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// a.dll</span><br><span class="line">class A &#123;</span><br><span class="line">    ....</span><br><span class="line">public:</span><br><span class="line">    virtual void foo();   // Non standard-layout</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void bar(A&amp;);</span><br><span class="line"></span><br><span class="line">// b.exe</span><br><span class="line">int main() &#123;</span><br><span class="line">    A a;</span><br><span class="line">    bar(a);   // Non-compliant</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设例中 a.dll 和 b.exe 由不同的编译器生成，b.exe 中定义的 a 对象被传递给了 a.dll 中定义的接口，由于存在虚函数，不同的编译器对 a 对象的内存布局会有不同的解读，从而造成冲突。<br><br/><br><br/></p>
<h4 id="依据-8"><a href="#依据-8" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 14882:2011 9(7)<br>ISO/IEC 14882:2017 12(7)<br><br/></p>
<h4 id="参考-22"><a href="#参考-22" class="headerlink" title="参考"></a>参考</h4><p>SEI CERT EXP60-CPP<br><br/><br><br/></p>
<h3 id="▌R2-9-对象申请的资源应在析构函数中释放"><a href="#▌R2-9-对象申请的资源应在析构函数中释放" class="headerlink" title="▌R2.9 对象申请的资源应在析构函数中释放"></a><span id="memberdeallocation">▌R2.9 对象申请的资源应在析构函数中释放</span></h3><p>ID_memberDeallocation&emsp;&emsp;&emsp;&emsp;&nbsp;:drop_of_blood: resource warning</p>
<hr/>

<p>对象在析构函数中释放自己申请的资源是 C++ 程序设计的重要原则，不可被遗忘，也不应要求用户释放。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    int* p = nullptr;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    A(size_t n): p(new int[n]) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   ~A() &#123;  // Non-compliant, must delete[] p</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>例中成员 p 与内存分配有关，但析构函数为空，不符合本规则要求。<br><br/><br><br/></p>
<h4 id="相关-16"><a href="#相关-16" class="headerlink" title="相关"></a>相关</h4><p>ID_memoryLeak<br>ID_resourceLeak<br><br/></p>
<h4 id="参考-23"><a href="#参考-23" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines C.31<br>C++ Core Guidelines E.6<br><br/><br><br/></p>
<h3 id="▌R2-10-对象被移动后应重置状态再使用"><a href="#▌R2-10-对象被移动后应重置状态再使用" class="headerlink" title="▌R2.10 对象被移动后应重置状态再使用"></a><span id="useaftermove">▌R2.10 对象被移动后应重置状态再使用</span></h3><p>ID_useAfterMove&emsp;&emsp;&emsp;&emsp;&nbsp;:drop_of_blood: resource warning</p>
<hr/>

<p>对象被移动后在逻辑上不再有效，如果没有通过清空数据或重新初始化等方法更新对象的状态，不应再使用该对象。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using V = std::vector&lt;int&gt;;</span><br><span class="line"></span><br><span class="line">void foo(V&amp; a, V&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">    a = std::move(b);   // After moving, the state of ‘b’ is unspecified</span><br><span class="line">    b.push_back(0);     // Non-compliant</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中容器 b 的数据被移动到容器 a，可能是通过交换的方法实现的，也可能是通过其他方法实现的，标准容器被移动后的状态在 C++ 标准中是未声明的，程序不应依赖未声明的状态。  </p>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void foo(V&amp; a, V&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">    a = std::move(b);</span><br><span class="line">    b.clear();          // Clear</span><br><span class="line">    b.push_back(0);     // Compliant</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="相关-17"><a href="#相关-17" class="headerlink" title="相关"></a>相关</h4><p>ID_unsuitableMove<br><br/></p>
<h4 id="依据-9"><a href="#依据-9" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 14882:2011 17.6.5.15(1)-unspecified<br>ISO/IEC 14882:2017 20.5.5.15(1)-unspecified<br><br/></p>
<h4 id="参考-24"><a href="#参考-24" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines ES.56<br>SEI CERT EXP63-CPP<br><br/><br><br/></p>
<h3 id="▌R2-11-构造函数抛出异常需避免相关资源泄漏"><a href="#▌R2-11-构造函数抛出异常需避免相关资源泄漏" class="headerlink" title="▌R2.11 构造函数抛出异常需避免相关资源泄漏"></a><span id="throwinconstructor">▌R2.11 构造函数抛出异常需避免相关资源泄漏</span></h3><p>ID_throwInConstructor&emsp;&emsp;&emsp;&emsp;&nbsp;:drop_of_blood: resource warning</p>
<hr/>

<p>构造函数抛出异常表示对象构造失败，不会再执行相关析构函数，需要保证已分配的资源被有效回收。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    int *a, *b;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    A(size_t n):</span><br><span class="line">        a(new int[n]),</span><br><span class="line">        b(new int[n])     // The allocations may fail</span><br><span class="line">    &#123;</span><br><span class="line">        if (sth_wrong) &#123;</span><br><span class="line">            throw E();    // User exceptions</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   ~A() &#123;                 // May be invalid</span><br><span class="line">        delete[] a;</span><br><span class="line">        delete[] b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>例中内存分配可能会失败，抛出 bad_alloc 异常，在某种条件下还会抛出自定义的异常，任何一种异常被抛出析构函数就不会被执行，已分配的资源就无法被回收，但已构造完毕的对象还是会正常析构的，所以应采用对象化资源管理方法，使资源可以被自动回收。  </p>
<p>可改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">A::A(size_t n) &#123;</span><br><span class="line">    // Use objects to hold resources</span><br><span class="line">    auto holder_a = make_unique&lt;int[]&gt;(n);</span><br><span class="line">    auto holder_b = make_unique&lt;int[]&gt;(n);</span><br><span class="line"></span><br><span class="line">    // Do the tasks that may throw exceptions</span><br><span class="line">    if (sth_wrong) &#123;</span><br><span class="line">        throw E();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Transfer ownership, make sure no exception is thrown</span><br><span class="line">    a = holder_a.release();</span><br><span class="line">    b = holder_b.release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先用 unique_ptr 对象持有资源，完成可能抛出异常的事务之后，再将资源转移给相关成员，转移的过程不可抛出异常，这种模式可以保证异常安全，如果有异常抛出，资源均可被正常回收。对遵循 C++11 及之后标准的代码，建议用 make_unique 函数代替 new 运算符。  </p>
<p>示例代码意在讨论一种通用模式，实际代码可采用更直接的方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    vector&lt;int&gt; a, b;  // Or use ‘unique_ptr’</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    A(size_t n): a(n), b(n) &#123;  // Safe and brief</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>保证已分配的资源时刻有对象负责回收是重要的设计原则，可参见 ID_ownerlessResource 的进一步讨论。  </p>
<p>注意，“未成功初始化的对象”在 C++ 语言中是不存在的，应避免相关逻辑错误，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">struct T &#123;</span><br><span class="line">    A() &#123; throw CtorException(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void foo() &#123;</span><br><span class="line">    T* p = nullptr;</span><br><span class="line">    try &#123;</span><br><span class="line">        p = new T;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (CtorException&amp;) &#123;</span><br><span class="line">        delete p;              // Logic error, ‘p’ is nullptr</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">    delete p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中 T 类型的对象在构造时抛出异常，而实际上 p 并不会指向一个未能成功初始化的对象，赋值被异常中断，catch  中的 p 仍然是一个空指针，new 表达式中抛出异常会自动回收已分配的内存。<br><br/><br><br/></p>
<h4 id="相关-18"><a href="#相关-18" class="headerlink" title="相关"></a>相关</h4><p>ID_ownerlessResource<br>ID_multiAllocation<br>ID_memoryLeak<br><br/></p>
<h4 id="依据-10"><a href="#依据-10" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 14882:2003 5.3.4(17)<br>ISO/IEC 14882:2011 5.3.4(18)<br>ISO/IEC 14882:2017 8.3.4(21)<br><br/><br><br/></p>
<h3 id="▌R2-12-资源不可被重复释放"><a href="#▌R2-12-资源不可被重复释放" class="headerlink" title="▌R2.12 资源不可被重复释放"></a><span id="doublefree">▌R2.12 资源不可被重复释放</span></h3><p>ID_doubleFree&emsp;&emsp;&emsp;&emsp;&nbsp;:drop_of_blood: resource error</p>
<hr/>

<p>重复释放资源属于逻辑错误，导致标准未定义的行为。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void foo(const char* path) &#123;</span><br><span class="line">    FILE* p = fopen(path, &quot;r&quot;);</span><br><span class="line">    if (p) &#123;</span><br><span class="line">        ....</span><br><span class="line">        fclose(p);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(p);  // Non-compliant</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="依据-11"><a href="#依据-11" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 7.20.3.2(2)-undefined<br>ISO/IEC 9899:2011 7.22.3.3(2)-undefined<br>ISO/IEC 14882:2003 3.7.3.2(4)-undefined<br>ISO/IEC 14882:2011 3.7.4.2(4)-undefined<br><br/></p>
<h4 id="参考-25"><a href="#参考-25" class="headerlink" title="参考"></a>参考</h4><p>CWE-415<br><br/><br><br/></p>
<h3 id="▌R2-13-用-delete-释放对象需保证其类型完整"><a href="#▌R2-13-用-delete-释放对象需保证其类型完整" class="headerlink" title="▌R2.13 用 delete 释放对象需保证其类型完整"></a><span id="deleteincompletetype">▌R2.13 用 delete 释放对象需保证其类型完整</span></h3><p>ID_deleteIncompleteType&emsp;&emsp;&emsp;&emsp;&nbsp;:drop_of_blood: resource warning</p>
<hr/>

<p>如果用 delete 释放不完整类型的对象，而对象完整类型声明中有 non-trivial 析构函数，会导致标准未定义的行为。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct T;</span><br><span class="line"></span><br><span class="line">void foo(T* p) &#123;</span><br><span class="line">    delete p;       // Non-compliant, undefined behavior</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct T &#123;</span><br><span class="line">   ~T();            // Non-trivial destructor</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>例中 delete 作用于不完整类型的指针 p，析构函数不会正确执行，应保证 T 在 foo 之前定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct T &#123;</span><br><span class="line">   ~T();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void foo(T* p) &#123;</span><br><span class="line">    delete p;       // Compliant</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="依据-12"><a href="#依据-12" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 14882:2003 5.3.5(5)-undefined<br>ISO/IEC 14882:2011 5.3.5(5)-undefined<br><br/><br><br/></p>
<h3 id="▌R2-14-用-delete-释放对象不可多写中括号"><a href="#▌R2-14-用-delete-释放对象不可多写中括号" class="headerlink" title="▌R2.14 用 delete 释放对象不可多写中括号"></a><span id="excessivedelete">▌R2.14 用 delete 释放对象不可多写中括号</span></h3><p>ID_excessiveDelete&emsp;&emsp;&emsp;&emsp;&nbsp;:drop_of_blood: resource error</p>
<hr/>

<p>用 new 分配的对象应该用 delete 释放，不可用 delete[] 释放，否则导致标准未定义的行为。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auto* p = new X;  // One object</span><br><span class="line">....</span><br><span class="line">delete[] p;       // Non-compliant, use ‘delete p;’ instead</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="相关-19"><a href="#相关-19" class="headerlink" title="相关"></a>相关</h4><p>ID_insufficientDelete<br><br/></p>
<h4 id="依据-13"><a href="#依据-13" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 14882:2003 5.3.5(2)-undefined<br>ISO/IEC 14882:2011 5.3.5(2)-undefined<br>ISO/IEC 14882:2017 8.3.5(2)-undefined<br><br/></p>
<h4 id="参考-26"><a href="#参考-26" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines ES.61<br><br/><br><br/></p>
<h3 id="▌R2-15-用-delete-释放数组不可漏写中括号"><a href="#▌R2-15-用-delete-释放数组不可漏写中括号" class="headerlink" title="▌R2.15 用 delete 释放数组不可漏写中括号"></a><span id="insufficientdelete">▌R2.15 用 delete 释放数组不可漏写中括号</span></h3><p>ID_insufficientDelete&emsp;&emsp;&emsp;&emsp;&nbsp;:drop_of_blood: resource error</p>
<hr/>

<p>用 new 分配的数组应该用 delete[] 释放，不可漏写中括号，否则导致标准未定义的行为。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void foo(int n) &#123;</span><br><span class="line">    auto* p = new X[n];  // n default-constructed X objects</span><br><span class="line">    ....</span><br><span class="line">    delete p;            // Non-compliant, use ‘delete[] p;’ instead</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在某些环境中，可能只有第一个对象的析构函数被执行，其他对象的析构函数都没有被执行，如果对象与资源分配有关就会导致资源泄漏。<br><br/><br><br/></p>
<h4 id="相关-20"><a href="#相关-20" class="headerlink" title="相关"></a>相关</h4><p>ID_excessiveDelete<br><br/></p>
<h4 id="依据-14"><a href="#依据-14" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 14882:2003 5.3.5(2)-undefined<br>ISO/IEC 14882:2011 5.3.5(2)-undefined<br>ISO/IEC 14882:2017 8.3.5(2)-undefined<br><br/></p>
<h4 id="参考-27"><a href="#参考-27" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines ES.61<br><br/><br><br/></p>
<h3 id="▌R2-16-非动态申请的资源不可被释放"><a href="#▌R2-16-非动态申请的资源不可被释放" class="headerlink" title="▌R2.16 非动态申请的资源不可被释放"></a><span id="illdealloc">▌R2.16 非动态申请的资源不可被释放</span></h3><p>ID_illDealloc&emsp;&emsp;&emsp;&emsp;&nbsp;:drop_of_blood: resource error</p>
<hr/>

<p>释放非动态申请的资源会导致标准未定义的行为。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void foo(size_t n) &#123;</span><br><span class="line">    int* p = (int*)alloca(n);</span><br><span class="line">    ....</span><br><span class="line">    free(p);    // Non-compliant, ‘p’ should not be freed</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void bar() &#123;</span><br><span class="line">    int i;</span><br><span class="line">    ....</span><br><span class="line">    free(&amp;i);   // Non-compliant, naughty behavior</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>释放在栈上分配的空间或者局部对象的地址会造成严重的运行时错误。<br><br/><br><br/></p>
<h4 id="依据-15"><a href="#依据-15" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 7.20.3.2(2)-undefined<br>ISO/IEC 9899:2011 7.22.3.3(2)-undefined<br>ISO/IEC 14882:2003 5.3.5(2)-undefined<br>ISO/IEC 14882:2011 5.3.5(2)-undefined<br><br/></p>
<h4 id="参考-28"><a href="#参考-28" class="headerlink" title="参考"></a>参考</h4><p>MISRA C 2012 22.2<br><br/><br><br/></p>
<h3 id="▌R2-17-在一个表达式语句中最多使用一次-new"><a href="#▌R2-17-在一个表达式语句中最多使用一次-new" class="headerlink" title="▌R2.17 在一个表达式语句中最多使用一次 new"></a><span id="multiallocation">▌R2.17 在一个表达式语句中最多使用一次 new</span></h3><p>ID_multiAllocation&emsp;&emsp;&emsp;&emsp;&nbsp;:drop_of_blood: resource warning</p>
<hr/>

<p>如果表达式语句多次使用 new，一旦某个构造函数抛出异常就会造成内存泄漏。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fun(</span><br><span class="line">    shared_ptr&lt;T&gt;(new T),</span><br><span class="line">    shared_ptr&lt;T&gt;(new T)   // Non-compliant, potential memory leak</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>例中 fun 的两个参数均为 new 表达式，实际执行时可以先为两个对象分配内存，再分别执行对象的构造函数，如果某个构造函数抛出异常，已分配的内存就得不到回收了。  </p>
<p>保证一次内存分配对应一个构造函数可解决这种问题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auto a(shared_ptr&lt;T&gt;(new T));   // Compliant</span><br><span class="line">auto b(shared_ptr&lt;T&gt;(new T));   // Compliant</span><br><span class="line">fun(a, b);</span><br></pre></td></tr></table></figure>
<p>这样即使构造函数抛出异常也会自动回收已分配的内存。  </p>
<p>更好的方法是避免显式资源分配：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fun(</span><br><span class="line">    make_shared&lt;T&gt;(),</span><br><span class="line">    make_shared&lt;T&gt;()    // Compliant, safe and brief</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>用 make_shared、make_unique 等函数代替 new 运算符可有效规避这种问题。<br><br/><br><br/></p>
<h4 id="相关-21"><a href="#相关-21" class="headerlink" title="相关"></a>相关</h4><p>ID_memoryLeak<br><br/></p>
<h4 id="参考-29"><a href="#参考-29" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines R.13<br><br/><br><br/></p>
<h3 id="▌R2-18-流式资源对象不应被复制"><a href="#▌R2-18-流式资源对象不应被复制" class="headerlink" title="▌R2.18 流式资源对象不应被复制"></a><span id="copiedstream">▌R2.18 流式资源对象不应被复制</span></h3><p>ID_copiedStream&emsp;&emsp;&emsp;&emsp;&nbsp;:drop_of_blood: resource warning</p>
<hr/>

<p>FILE 等流式对象不应被复制，如果存在多个副本会造成数据不一致的问题。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FILE f;</span><br><span class="line">FILE* fp = fopen(path, &quot;r&quot;);</span><br><span class="line"></span><br><span class="line">f = *fp;                      // Non-compliant</span><br><span class="line">memcpy(fp, &amp;f, sizeof(*fp));  // Non-compliant</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="依据-16"><a href="#依据-16" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 7.19.3(6)<br>ISO/IEC 9899:2011 7.21.3(6)<br><br/></p>
<h4 id="参考-30"><a href="#参考-30" class="headerlink" title="参考"></a>参考</h4><p>MISRA C 2012 22.5<br><br/><br><br/></p>
<h3 id="▌R2-19-避免使用变长数组"><a href="#▌R2-19-避免使用变长数组" class="headerlink" title="▌R2.19 避免使用变长数组"></a><span id="variablelengtharray">▌R2.19 避免使用变长数组</span></h3><p>ID_variableLengthArray&emsp;&emsp;&emsp;&emsp;&nbsp;:drop_of_blood: resource warning</p>
<hr/>

<p>使用变长数组（variable length array）可以在栈上动态分配内存，但分配失败时的行为不受程序控制。  </p>
<p>变长数组由 C99 标准提出，不在 C++ 标准之内，在 C++ 代码中不应使用。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void foo(int n)</span><br><span class="line">&#123;</span><br><span class="line">    int a[n];   // Non-compliant, a variable length array</span><br><span class="line">                // Undefined behavior if n &lt;= 0</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中数组 a 的长度为变量，其内存空间在运行时动态分配，如果长度参数 n 不是合理的正整数会导致未定义的行为。  </p>
<p>另外，对于本应兼容的数组类型，如果长度不同也会导致未定义的行为，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void bar(int n)</span><br><span class="line">&#123;</span><br><span class="line">    int a[5];</span><br><span class="line">    typedef int t[n];   // Non-compliant, a variable length array type</span><br><span class="line">    t* p = &amp;a;          // Undefined behavior if n != 5</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="相关-22"><a href="#相关-22" class="headerlink" title="相关"></a>相关</h4><p>ID_stackAllocation<br><br/></p>
<h4 id="依据-17"><a href="#依据-17" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 6.7.5.2(5)<br>ISO/IEC 9899:2011 6.7.6.2(5)<br><br/></p>
<h4 id="参考-31"><a href="#参考-31" class="headerlink" title="参考"></a>参考</h4><p>MISRA C 2012 18.8<br><br/><br><br/></p>
<h3 id="▌R2-20-避免使用在栈上分配内存的函数"><a href="#▌R2-20-避免使用在栈上分配内存的函数" class="headerlink" title="▌R2.20 避免使用在栈上分配内存的函数"></a><span id="stackallocation">▌R2.20 避免使用在栈上分配内存的函数</span></h3><p>ID_stackAllocation&emsp;&emsp;&emsp;&emsp;&nbsp;:drop_of_blood: resource warning</p>
<hr/>

<p>alloca、strdupa 等函数可以在栈上动态分配内存，但分配失败时的行为不受程序控制。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;alloca.h&gt;</span><br><span class="line"></span><br><span class="line">void fun(size_t n) &#123;</span><br><span class="line">    int* p = (int*)alloca(n * sizeof(int));  // Non-compliant</span><br><span class="line">    if (!p) &#123;</span><br><span class="line">        return;  // Invalid</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中 alloca 函数在失败时往往会使程序崩溃，对其返回值的检查是无效的。这种后果不可控的函数应避免使用，尤其在循环和递归调用过程中更不应使用这种函数。<br><br/><br><br/></p>
<h4 id="相关-23"><a href="#相关-23" class="headerlink" title="相关"></a>相关</h4><p>ID_variableLengthArray<br>ID_invalidNullCheck<br><br/></p>
<h4 id="参考-32"><a href="#参考-32" class="headerlink" title="参考"></a>参考</h4><p>CWE-770<br>SEI CERT MEM05-C<br><br/><br><br/></p>
<h3 id="▌R2-21-局部数组不应过大"><a href="#▌R2-21-局部数组不应过大" class="headerlink" title="▌R2.21 局部数组不应过大"></a><span id="unsuitablearraysize">▌R2.21 局部数组不应过大</span></h3><p>ID_unsuitableArraySize&emsp;&emsp;&emsp;&emsp;&nbsp;:drop_of_blood: resource warning</p>
<hr/>

<p>局部数组在栈上分配空间，如果占用空间过大会导致栈溢出错误。  </p>
<p>应关注具有较大数组的函数，评估其在运行时的最大资源消耗是否符合执行环境的要求。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void foo() &#123;</span><br><span class="line">    int arr[1024][1024][1024];   // Non-compliant, too large</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在栈上分配空间难以控制失败情况，如果条件允许可改在堆上分配：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void foo() &#123;</span><br><span class="line">    int* arr = (int*)malloc(1024 * 1024 * 1024 * sizeof(int));   // Compliant</span><br><span class="line">    if (arr) &#123;</span><br><span class="line">        ....     // Normal procedure</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        ....     // Handle allocation failures</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>maxLocalArraySize：函数内局部数组空间之和的上限，超过则报出<br><br/></p>
<h4 id="参考-33"><a href="#参考-33" class="headerlink" title="参考"></a>参考</h4><p>CWE-770<br>SEI CERT MEM05-C<br><br/><br><br/></p>
<h3 id="▌R2-22-避免不必要的内存分配"><a href="#▌R2-22-避免不必要的内存分配" class="headerlink" title="▌R2.22 避免不必要的内存分配"></a><span id="unnecessaryallocation">▌R2.22 避免不必要的内存分配</span></h3><p>ID_unnecessaryAllocation&emsp;&emsp;&emsp;&emsp;&nbsp;:drop_of_blood: resource warning</p>
<hr/>

<p>对单独的基本变量或只包含少量基本变量的对象不应使用动态内存分配。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bool* pb = new bool;   // Non-compliant</span><br><span class="line">char* pc = new char;   // Non-compliant</span><br></pre></td></tr></table></figure>
<p>内存分配的开销远大于变量的直接使用，而且还涉及到回收问题，是得不偿失的。  </p>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bool b = false;   // Compliant</span><br><span class="line">char c = 0;       // Compliant</span><br></pre></td></tr></table></figure>
<p>用 new 分配数组时方括号被误写成小括号，或使用 unique_ptr 等智能指针时遗漏了数组括号也是常见笔误，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int* pi = new int(32);            // Non-compliant</span><br><span class="line">auto ui = make_unique&lt;int&gt;(32);   // Non-compliant</span><br></pre></td></tr></table></figure>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int* pi = new int[32];              // Compliant</span><br><span class="line">auto ui = make_unique&lt;int[]&gt;(32);   // Compliant</span><br></pre></td></tr></table></figure>
<p>有时可能需要区分变量是否存在，用空指针表示不存在，并通过资源分配创建变量的方式属于低效实现，不妨改用变量的特殊值表示变量的状态，在 C++ 代码中也可使用 std::optional 实现相关功能。<br><br/><br><br/></p>
<h4 id="相关-24"><a href="#相关-24" class="headerlink" title="相关"></a>相关</h4><p>ID_dynamicAllocation<br><br/><br><br/></p>
<h3 id="▌R2-23-避免动态内存分配"><a href="#▌R2-23-避免动态内存分配" class="headerlink" title="▌R2.23 避免动态内存分配"></a><span id="dynamicallocation">▌R2.23 避免动态内存分配</span></h3><p>ID_dynamicAllocation&emsp;&emsp;&emsp;&emsp;&nbsp;:drop_of_blood: resource warning</p>
<hr/>

<p>标准库提供的动态内存分配方法，其算法或策略不在使用者的控制之内，很多细节是标准没有规定的，而且也是内存耗尽等问题的根源，有高可靠性要求的嵌入式系统应避免动态内存分配。  </p>
<p>在内存资源有限的环境中，由于难以控制具体的分配策略，很可能会导致已分配的空间用不上，未分配的空间不够用的情况。而在资源充足的环境中，也应尽量避免动态分配，如果能在栈上创建对象，就不应采用动态分配的方式，以提高效率并降低资源管理的复杂性。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void foo() &#123;</span><br><span class="line">    std::vector&lt;int&gt; v;   // Non-compliant</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中 vector 容器使用了动态内存分配方法，容量的增长策略可能会导致内存空间的浪费，甚至使程序难以稳定运行。<br><br/><br><br/></p>
<h4 id="依据-18"><a href="#依据-18" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 7.20.3<br>ISO/IEC 9899:2011 7.22.3<br><br/></p>
<h4 id="参考-34"><a href="#参考-34" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines R.5<br>MISRA C 2004 20.4<br>MISRA C 2012 21.3<br>MISRA C++ 2008 18-4-1<br><br/><br><br/></p>
<h3 id="▌R2-24-判断资源分配函数的返回值是否有效"><a href="#▌R2-24-判断资源分配函数的返回值是否有效" class="headerlink" title="▌R2.24 判断资源分配函数的返回值是否有效"></a><span id="nullderefallocret">▌R2.24 判断资源分配函数的返回值是否有效</span></h3><p>ID_nullDerefAllocRet&emsp;&emsp;&emsp;&emsp;&nbsp;:drop_of_blood: resource warning</p>
<hr/>

<p>malloc 等函数在分配失败时返回空指针，如果不加判断直接使用会导致标准未定义的行为。  </p>
<p>在有虚拟内存支持的平台中，正常的内存分配一般不会失败，但申请内存过多或有误时（如参数为负数）也会导致分配失败，而对于没有虚拟内存支持的或可用内存有限的嵌入式系统，检查分配资源是否成功是十分重要的，所以本规则应该作为代码编写的一般性要求。  </p>
<p>库的实现更需要注意这一点，如果库由于分配失败而使程序直接崩溃，相当于干扰了主程序的决策权，很可能会造成难以排查的问题，对于有高可靠性要求的软件，在极端环境中的行为是需要明确设定的。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void foo(size_t n) &#123;</span><br><span class="line">    char* p = (char*)malloc(n);</span><br><span class="line">    p[n - 1] = &#x27;\0&#x27;;              // Non-compliant, check ‘p’ first</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例代码未检查 p 的有效性便直接使用是不符合要求的。<br><br/><br><br/></p>
<h4 id="依据-19"><a href="#依据-19" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 7.20.3(1)<br>ISO/IEC 9899:2011 7.22.3(1)<br><br/></p>
<h4 id="参考-35"><a href="#参考-35" class="headerlink" title="参考"></a>参考</h4><p>CWE-252<br>CWE-476<br><br/><br><br/></p>
<h3 id="▌R2-25-C-代码中禁用-C-内存管理函数"><a href="#▌R2-25-C-代码中禁用-C-内存管理函数" class="headerlink" title="▌R2.25 C++ 代码中禁用 C 内存管理函数"></a><span id="forbidmallocandfree">▌R2.25 C++ 代码中禁用 C 内存管理函数</span></h3><p>ID_forbidMallocAndFree&emsp;&emsp;&emsp;&emsp;&nbsp;:no_entry: resource warning</p>
<hr/>

<p>在 C++ 代码中不应使用 malloc、free 等 C 内存管理函数，应使用 C++ 内存管理方法。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void foo(size_t n) &#123;</span><br><span class="line">    int* p = (int*)malloc(n * sizeof(int));  // Unsafe and verbose</span><br><span class="line">    ....</span><br><span class="line">    free(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void foo(size_t n) &#123;</span><br><span class="line">    auto p = make_unique&lt;int[]&gt;(n);  // Safe and brief</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="相关-25"><a href="#相关-25" class="headerlink" title="相关"></a>相关</h4><p>ID_ownerlessResource<br><br/></p>
<h4 id="参考-36"><a href="#参考-36" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines R.10<br><br/><br><br/></p>
<h2 id="3-Precompile"><a href="#3-Precompile" class="headerlink" title="3. Precompile"></a><span id="precompile">3. Precompile</span></h2><h3 id="3-1-Include"><a href="#3-1-Include" class="headerlink" title="3.1 Include"></a><span id="precompile.include">3.1 Include</span></h3><h3 id="▌R3-1-1-include-指令应符合标准格式"><a href="#▌R3-1-1-include-指令应符合标准格式" class="headerlink" title="▌R3.1.1 include 指令应符合标准格式"></a><span id="illformedinclude">▌R3.1.1 include 指令应符合标准格式</span></h3><p>ID_illFormedInclude&emsp;&emsp;&emsp;&emsp;&nbsp;:boom: precompile error</p>
<hr/>

<p>#include 后只应为 &lt; 头文件路径 &gt; 或 “ 头文件路径 “，否则会导致标准未定义的行为。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;string.h&gt;         // Compliant</span><br><span class="line">#include &quot;string.h&quot;         // Compliant </span><br><span class="line"></span><br><span class="line">#define HEADER &quot;string.h&quot;</span><br><span class="line">#include HEADER             // Compliant</span><br><span class="line"></span><br><span class="line">#include stdlib.h           // Non-compliant, undefined behavior</span><br></pre></td></tr></table></figure>
<p>例中对 string.h 的引用符合标准，而对 stdlib.h 的引用会导致标准未定义的行为。  </p>
<p>注意，由引号标识的头文件路径并非字符串常量，不应对其使用字符串常量的特性，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdlib&quot; &quot;.h&quot;      // Non-compliant, implementation defined</span><br></pre></td></tr></table></figure>
<p>是否会将引号中的内容连接成一个路径是由实现定义的，这种代码是不可移植的。  </p>
<p>另外，如下形式的代码也是不符合标准的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include L&quot;foo&quot;             // Non-compliant</span><br><span class="line">#include u&quot;bar&quot;             // Non-compliant</span><br><span class="line">#include U&quot;baz&quot;             // Non-compliant</span><br><span class="line">#include R&quot;(..\foo\bar)&quot;    // Non-compliant</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="相关-26"><a href="#相关-26" class="headerlink" title="相关"></a>相关</h4><p>ID_nonStandardCharInHeaderName<br><br/></p>
<h4 id="依据-20"><a href="#依据-20" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 6.10.2<br>ISO/IEC 9899:2011 6.10.2<br>ISO/IEC 14882:2003 2.8<br>ISO/IEC 14882:2003 16.2(4)-undefined<br>ISO/IEC 14882:2003 16.2(4)-implementation<br>ISO/IEC 14882:2011 2.9<br>ISO/IEC 14882:2011 16.2(4)-undefined<br>ISO/IEC 14882:2011 16.2(4)-implementation<br><br/></p>
<h4 id="参考-37"><a href="#参考-37" class="headerlink" title="参考"></a>参考</h4><p>MISRA C 2004 19.3<br>MISRA C 2012 20.3<br>MISRA C++ 2008 16-2-6<br><br/><br><br/></p>
<h3 id="▌R3-1-2-include-指令中禁用不合规的字符"><a href="#▌R3-1-2-include-指令中禁用不合规的字符" class="headerlink" title="▌R3.1.2 include 指令中禁用不合规的字符"></a><span id="nonstandardcharinheadername">▌R3.1.2 include 指令中禁用不合规的字符</span></h3><p>ID_nonStandardCharInHeaderName&emsp;&emsp;&emsp;&emsp;&nbsp;:no_entry: precompile warning</p>
<hr/>

<p>字母、数字、下划线、点号之外的字符可能与文件系统存在冲突，也可能导致标准未定义的行为，不应出现在头文件和相关目录名称中。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;&quot;foo&quot;&gt;        // Non-compliant</span><br><span class="line">#include &lt;foo*&gt;         // Non-compliant</span><br><span class="line">#include &lt;foo&#x27;bar&gt;      // Non-compliant</span><br><span class="line"></span><br><span class="line">#include &lt;foo&gt;          // Compliant</span><br><span class="line">#include &lt;foo.h&gt;        // Compliant</span><br><span class="line">#include &lt;foo_bar&gt;      // Compliant</span><br></pre></td></tr></table></figure>
<p>可以用 / 作为路径分隔符，但不应出现  // 或 /*，  如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;foo//bar.h&gt;   // Non-Compliant, undefined behavior</span><br><span class="line">#include &lt;foo/*bar.h&gt;   // Non-Compliant, undefined behavior</span><br></pre></td></tr></table></figure>
<p>另外，某些平台的文件路径不区分大小写，建议在头文件名称中只使用小写字母以提高可移植性。<br><br/><br><br/></p>
<h4 id="依据-21"><a href="#依据-21" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 6.4.7(3)-undefined<br>ISO/IEC 9899:2011 6.4.7(3)-undefined<br>ISO/IEC 14882:2003 2.8(2)-undefined<br>ISO/IEC 14882:2011 2.9(2)-implementation<br><br/></p>
<h4 id="参考-38"><a href="#参考-38" class="headerlink" title="参考"></a>参考</h4><p>MISRA C 2004 19.2<br>MISRA C 2012 20.2<br>MISRA C++ 2008 16-2-4<br><br/><br><br/></p>
<h3 id="▌R3-1-3-include-指令中不应使用反斜杠"><a href="#▌R3-1-3-include-指令中不应使用反斜杠" class="headerlink" title="▌R3.1.3 include 指令中不应使用反斜杠"></a><span id="forbidbackslashinheadername">▌R3.1.3 include 指令中不应使用反斜杠</span></h3><p>ID_forbidBackslashInHeaderName&emsp;&emsp;&emsp;&emsp;&nbsp;:no_entry: precompile warning</p>
<hr/>

<p>如果在 include 指令中使用反斜杠，程序的行为在 C 和 C++03 标准中是未定义的，在 C++11 标准中是由实现定义的。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;foo\bar.h&gt;     // Non-compliant</span><br><span class="line">#include &quot;foo\\bar.h&quot;    // Non-compliant</span><br><span class="line"></span><br><span class="line">#include &lt;foo/bar.h&gt;     // Compliant</span><br></pre></td></tr></table></figure>
<p>在有可移植性要求的代码中应避免使用反斜杠。<br><br/><br><br/></p>
<h4 id="依据-22"><a href="#依据-22" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 6.4.7(3)-undefined<br>ISO/IEC 9899:2011 6.4.7(3)-undefined<br>ISO/IEC 14882:2003 2.8(2)-undefined<br>ISO/IEC 14882:2011 2.9(2)-implementation<br><br/></p>
<h4 id="参考-39"><a href="#参考-39" class="headerlink" title="参考"></a>参考</h4><p>MISRA C++ 2008 16-2-5<br><br/><br><br/></p>
<h3 id="▌R3-1-4-include-指令中不应使用绝对路径"><a href="#▌R3-1-4-include-指令中不应使用绝对路径" class="headerlink" title="▌R3.1.4 include 指令中不应使用绝对路径"></a><span id="forbidabspathinheadername">▌R3.1.4 include 指令中不应使用绝对路径</span></h3><p>ID_forbidAbsPathInHeaderName&emsp;&emsp;&emsp;&emsp;&nbsp;:no_entry: precompile warning</p>
<hr/>

<p>绝对路径使代码过分依赖编译环境，意味着项目的编译设置不完善，应使用相对路径。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;C:\\foo\\bar.h&quot;   // Non-compliant</span><br><span class="line">#include &quot;/foo/bar.h&quot;       // Non-compliant</span><br></pre></td></tr></table></figure>
<p><br/><br><br/><br><br/></p>
<h3 id="▌R3-1-5-include-指令应位于文件的起始部分"><a href="#▌R3-1-5-include-指令应位于文件的起始部分" class="headerlink" title="▌R3.1.5 include 指令应位于文件的起始部分"></a><span id="badincludeposition">▌R3.1.5 include 指令应位于文件的起始部分</span></h3><p>ID_badIncludePosition&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: precompile warning</p>
<hr/>

<p>include 指令之前的代码只应为预编译指令或注释，否则不利于阅读和维护。  </p>
<p>用于包含模板实现文件的 include 指令可不受本规则限制，但相关文件的命名应与普通头文件有所区别。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;a.h&quot;   // Compliant</span><br><span class="line">extern int i;</span><br><span class="line">#include &quot;b.h&quot;   // Non-compliant</span><br><span class="line">extern</span><br><span class="line">#include &quot;c.h&quot;   // Non-compliant, undefined behavior</span><br></pre></td></tr></table></figure>
<p>如果声明的一部分在头文件内，另一部分在头文件外，会导致标准未定义的行为。<br><br/><br><br/></p>
<h4 id="依据-23"><a href="#依据-23" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 7.1.2(4)<br>ISO/IEC 9899:2011 7.1.2(4)<br>ISO/IEC 14882:2003 17.4.2.1(3)<br>ISO/IEC 14882:2011 17.6.2.2(3)<br>ISO/IEC 14882:2017 20.5.2.2(3)<br><br/></p>
<h4 id="参考-40"><a href="#参考-40" class="headerlink" title="参考"></a>参考</h4><p>MISRA C 2012 20.1<br>MISRA C++ 2008 16-0-1<br><br/><br><br/></p>
<h3 id="▌R3-1-6-禁用不合规的头文件"><a href="#▌R3-1-6-禁用不合规的头文件" class="headerlink" title="▌R3.1.6 禁用不合规的头文件"></a><span id="forbiddenheader">▌R3.1.6 禁用不合规的头文件</span></h3><p>ID_forbiddenHeader&emsp;&emsp;&emsp;&emsp;&nbsp;:no_entry: precompile warning</p>
<hr/>

<p>已过时的、无意义的或有不良副作用的头文件应禁用。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;tgmath.h&gt;   // Non-compliant</span><br><span class="line">#include &lt;setjmp.h&gt;   // Non-compliant</span><br><span class="line"></span><br><span class="line">#include &lt;iso646.h&gt;   // Non-compliant in C++</span><br><span class="line">#include &lt;stdbool.h&gt;  // Non-compliant in C++</span><br><span class="line">#include &lt;ciso646&gt;    // Non-compliant in C++</span><br><span class="line">#include &lt;cstdbool&gt;   // Non-compliant in C++</span><br><span class="line">#include &lt;ctgmath&gt;    // Non-compliant in C++</span><br><span class="line">#include &lt;ccomplex&gt;   // Non-compliant in C++</span><br><span class="line">#include &lt;cstdalign&gt;  // Non-compliant in C++</span><br></pre></td></tr></table></figure>
<p>tgmath.h 和 ctgmath 会使用语言标准之外的技术实现某种重载效果，而且其中的部分函数名称会干扰其他标准库中的名称，setjmp.h 和 csetjmp 则包含危险的过程间跳转函数。  </p>
<p>iso646.h、stdalign.h、stdbool.h 以及 ciso646、cstdalign、cstdbool 等头文件对 C++ 语言没有意义，ccomplex、cstdalign、cstdbool、ctgmath 等头文件在 C++17 标准中已过时，在 C++ 代码中不应使用这些头文件。  </p>
<p>stdio.h、signal.h、time.h、fenv.h 等头文件含有较多标准未声明或由实现定义的内容，对有高可靠性要求的软件系统也不建议使用。  </p>
<p>审计工具不妨通过配置设定不合规头文件的名称，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[ID_forbiddenHeader]</span><br><span class="line">inC=tgmath.h|setjmp.h</span><br><span class="line">inCpp=tgmath.h|ctgmath|setjmp.h|csetjmp</span><br></pre></td></tr></table></figure>
<p>表示对 C 代码将 tgmath.h、setjmp.h 设为不合规，对 C++ 代码将 tgmath.h、ctgmath、setjmp.h、csetjmp 设为不合规。<br><br/><br><br/></p>
<h4 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h4><p>inC：C 代码中不合规头文件名称<br>inCpp：C++ 代码中不合规头文件名称<br><br/></p>
<h4 id="依据-24"><a href="#依据-24" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 14882:2017 C.5.1(4)<br>ISO/IEC 14882:2017 D.4(1)-deprecated<br><br/></p>
<h4 id="参考-41"><a href="#参考-41" class="headerlink" title="参考"></a>参考</h4><p>MISRA C 2012 21.4<br>MISRA C 2012 21.5<br>MISRA C 2012 21.10<br>MISRA C 2012 21.11<br>MISRA C 2012 21.12<br>MISRA C++ 2008 18-0-4<br>MISRA C++ 2008 18-7-1<br>MISRA C++ 2008 27-0-1<br><br/><br><br/></p>
<h3 id="▌R3-1-7-C-代码不应引用-C-头文件"><a href="#▌R3-1-7-C-代码不应引用-C-头文件" class="headerlink" title="▌R3.1.7 C++ 代码不应引用 C 头文件"></a><span id="forbidcheaderincpp">▌R3.1.7 C++ 代码不应引用 C 头文件</span></h3><p>ID_forbidCHeaderInCpp&emsp;&emsp;&emsp;&emsp;&nbsp;:no_entry: precompile warning</p>
<hr/>

<p>为了与 C 语言兼容，C++ 标准库也会提供 C 头文件，但在这种 C 头文件在 C++ 标准中是已过时的。  </p>
<p>C 标准头文件均有对应的 C++ 版本，C++ 版本提供了更适合 C++ 代码的命名空间、模板以及函数重载等功能。C 标准不在 C++ 标准之内，在 C++ 代码中不建议使用 C 标准库的功能，如果确有必要，应使用 C++ 版本的头文件。  </p>
<p>本规则是 ID_forbiddenHeader 的特化。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;assert.h&gt;    // Non-compliant, use &lt;cassert&gt;</span><br><span class="line">#include &lt;ctype.h&gt;     // Non-compliant, use &lt;cctype&gt;</span><br><span class="line">#include &lt;errno.h&gt;     // Non-compliant, use &lt;cerrno&gt;</span><br><span class="line">#include &lt;float.h&gt;     // Non-compliant, use &lt;cfloat&gt;</span><br><span class="line">#include &lt;limits.h&gt;    // Non-compliant, use &lt;climits&gt;</span><br><span class="line">#include &lt;locale.h&gt;    // Non-compliant, use &lt;clocale&gt;</span><br><span class="line">#include &lt;math.h&gt;      // Non-compliant, use &lt;cmath&gt;</span><br><span class="line">#include &lt;setjmp.h&gt;    // Non-compliant, use &lt;csetjmp&gt;</span><br><span class="line">#include &lt;signal.h&gt;    // Non-compliant, use &lt;csignal&gt;</span><br><span class="line">#include &lt;stdarg.h&gt;    // Non-compliant, use &lt;cstdarg&gt;</span><br><span class="line">#include &lt;stddef.h&gt;    // Non-compliant, use &lt;cstddef&gt;</span><br><span class="line">#include &lt;stdio.h&gt;     // Non-compliant, use &lt;cstdio&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;    // Non-compliant, use &lt;cstdlib&gt;</span><br><span class="line">#include &lt;string.h&gt;    // Non-compliant, use &lt;cstring&gt;</span><br><span class="line">#include &lt;time.h&gt;      // Non-compliant, use &lt;ctime&gt;</span><br><span class="line">#include &lt;wchar.h&gt;     // Non-compliant, use &lt;cwchar&gt;</span><br><span class="line">#include &lt;wctype.h&gt;    // Non-compliant, use &lt;cwctype&gt;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="相关-27"><a href="#相关-27" class="headerlink" title="相关"></a>相关</h4><p>ID_forbiddenHeader<br><br/></p>
<h4 id="依据-25"><a href="#依据-25" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 14882:1998 D.5-deprecated<br>ISO/IEC 14882:2003 D.5-deprecated<br>ISO/IEC 14882:2011 D.5-deprecated<br>ISO/IEC 14882:2017 D.5-deprecated<br><br/></p>
<h4 id="参考-42"><a href="#参考-42" class="headerlink" title="参考"></a>参考</h4><p>MISRA C++ 2008 18-0-1<br><br/><br><br/></p>
<h3 id="3-2-Macro-definition"><a href="#3-2-Macro-definition" class="headerlink" title="3.2 Macro-definition"></a><span id="precompile.macro-definition">3.2 Macro-definition</span></h3><h3 id="▌R3-2-1-宏应遵循合理的命名方式"><a href="#▌R3-2-1-宏应遵循合理的命名方式" class="headerlink" title="▌R3.2.1 宏应遵循合理的命名方式"></a><span id="macro_badname">▌R3.2.1 宏应遵循合理的命名方式</span></h3><p>ID_macro_badName&emsp;&emsp;&emsp;&emsp;&nbsp;:bulb: precompile suggestion</p>
<hr/>

<p>宏的名称应采用全大写字母的形式，非宏名称则应包含小写字母。  </p>
<p>宏用于文本处理，不受语言规则限制，易被误用，在命名方式上将其与普通代码分开可引起使用者或维护者的注意，有助于规避错误。  </p>
<p>本规则是 ID_badName 的特化，宏名称同样受 ID_badName 的约束。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define word_size 8   // Non-compliant, like a normal variable</span><br><span class="line">#define WORD_SIZE 8   // Compliant</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="相关-28"><a href="#相关-28" class="headerlink" title="相关"></a>相关</h4><p>ID_badName<br><br/></p>
<h4 id="参考-43"><a href="#参考-43" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines ES.32<br>C++ Core Guidelines ES.9<br><br/><br><br/></p>
<h3 id="▌R3-2-2-不可定义具有保留意义的宏名称"><a href="#▌R3-2-2-不可定义具有保留意义的宏名称" class="headerlink" title="▌R3.2.2 不可定义具有保留意义的宏名称"></a><span id="macro_definereserved">▌R3.2.2 不可定义具有保留意义的宏名称</span></h3><p>ID_macro_defineReserved&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: precompile warning</p>
<hr/>

<p>重新定义已有特殊用途的名称会导致标准未定义的行为，也会使代码陷入难以维护的境地。  </p>
<p>标准库、编译环境中的名称以及关键字不应重新定义。  </p>
<p>C++ 标准指明不可重新定义的宏有：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__cplusplus、__TIME__、__DATE__、__FILE__、__ LINE__、</span><br><span class="line">__STDC__、__STDC_HOSTED__、__STDCPP_THREADS__、</span><br><span class="line">__STDC_MB_MIGHT_NEQ_WC__、__STDC_VERSION__、</span><br><span class="line">__STDC_ISO_10646__、__STDCPP_STRICT_POINTER_SAFETY__</span><br></pre></td></tr></table></figure>
<p>以下划线开头的名称用于表示标准库或编译环境的保留名称，自定义名称不应以下划线开头。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#define _WIN64   0      // Non-compliant</span><br><span class="line">#define __GNUC__ 1      // Non-compliant</span><br><span class="line">#define __STDC__ 1      // Non-compliant, undefined behavior</span><br><span class="line">#define __cplusplus 0   // Non-compliant, undefined behavior</span><br></pre></td></tr></table></figure>
<p>标识平台或编译环境的宏不可在代码中写死。  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define defined            // Non-compliant, undefined behavior</span><br><span class="line">#define new new(nothrow)   // Non-compliant</span><br></pre></td></tr></table></figure>
<p>不可重定义关键字。  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define NDEBUG 0    // Non-compliant</span><br><span class="line">#define errno 0     // Non-compliant</span><br><span class="line">#define assert(x)   // Non-compliant</span><br></pre></td></tr></table></figure>
<p>编译优化相关的宏不可在代码中写死，标准库中的名称不应被重新定义。<br><br/><br><br/></p>
<h4 id="配置-2"><a href="#配置-2" class="headerlink" title="配置"></a>配置</h4><p>keywordAsReserved：是否将关键字作为保留名称<br>stdNameAsReserved：是否将标准库中的名称作为保留名称<br>underscoreAsReserved：是否将下划线开头的名称作为保留名称<br>reservedNames：用户指定的保留名称<br><br/></p>
<h4 id="相关-29"><a href="#相关-29" class="headerlink" title="相关"></a>相关</h4><p>ID_macro_undefReserved<br>ID_reservedName<br><br/></p>
<h4 id="依据-26"><a href="#依据-26" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 7.1.3(2)-undefined<br>ISO/IEC 9899:2011 7.1.3(2)-undefined<br>ISO/IEC 14882:2003 16.8(3)-undefined<br>ISO/IEC 14882:2011 16.8(4)-undefined<br><br/></p>
<h4 id="参考-44"><a href="#参考-44" class="headerlink" title="参考"></a>参考</h4><p>MISRA C 2012 20.4<br>MISRA C 2012 21.1<br>MISRA C++ 2008 17-0-1<br><br/><br><br/></p>
<h3 id="▌R3-2-3-不可取消定义具有保留意义的宏名称"><a href="#▌R3-2-3-不可取消定义具有保留意义的宏名称" class="headerlink" title="▌R3.2.3 不可取消定义具有保留意义的宏名称"></a><span id="macro_undefreserved">▌R3.2.3 不可取消定义具有保留意义的宏名称</span></h3><p>ID_macro_undefReserved&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: precompile warning</p>
<hr/>

<p>取消定义已有特殊用途的宏会导致标准未定义的行为，也会使代码陷入难以维护的境地。  </p>
<p>标准库、编译环境中的宏不可被取消定义。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#undef __LINE__      // Non-compliant</span><br><span class="line">#undef __cplusplus   // Non-compliant</span><br><span class="line">#undef _WIN64        // Non-compliant</span><br><span class="line">#undef NDEBUG        // Non-compliant</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="配置-3"><a href="#配置-3" class="headerlink" title="配置"></a>配置</h4><p>keywordAsReserved：是否将关键字作为保留名称<br>stdNameAsReserved：是否将标准库中的名称作为保留名称<br>underscoreAsReserved：是否将下划线开头的名称作为保留名称<br>reservedNames：用户指定的保留名称<br><br/></p>
<h4 id="相关-30"><a href="#相关-30" class="headerlink" title="相关"></a>相关</h4><p>ID_macro_defineReserved<br>ID_reservedName<br><br/></p>
<h4 id="依据-27"><a href="#依据-27" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 7.1.3(3)-undefined<br>ISO/IEC 9899:2011 7.1.3(3)-undefined<br>ISO/IEC 14882:2003 16.8(3)-undefined<br>ISO/IEC 14882:2011 16.8(4)-undefined<br><br/></p>
<h4 id="参考-45"><a href="#参考-45" class="headerlink" title="参考"></a>参考</h4><p>MISRA C 2012 21.1<br>MISRA C++ 2008 17-0-1<br><br/><br><br/></p>
<h3 id="▌R3-2-4-可作为子表达式的宏定义应该用括号括起来"><a href="#▌R3-2-4-可作为子表达式的宏定义应该用括号括起来" class="headerlink" title="▌R3.2.4 可作为子表达式的宏定义应该用括号括起来"></a><span id="macro_expnotenclosed">▌R3.2.4 可作为子表达式的宏定义应该用括号括起来</span></h3><p>ID_macro_expNotEnclosed&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: precompile warning</p>
<hr/>

<p>由于宏只做文本处理，不考虑运算符优先级等问题，可作为子表达式的宏定义应该用括号括起来，否则易产生意料之外的错误。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define ABS(x) (x) &lt; 0? -(x): (x)  // Non-compliant</span><br></pre></td></tr></table></figure>
<p>设 a 为变量，如果按如下使用方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = ABS(a) + 1;</span><br></pre></td></tr></table></figure>
<p>则相当于：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = (a) &lt; 0? -(a): (a) + 1;</span><br></pre></td></tr></table></figure>
<p>这显然会造成意料之外的结果，所以 ABS 的定义应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define ABS(x) ((x) &lt; 0? -(x): (x))  // Compliant</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="依据-28"><a href="#依据-28" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 6.10.3.5(4)<br>ISO/IEC 9899:2011 6.10.3.5(4)<br><br/></p>
<h4 id="参考-46"><a href="#参考-46" class="headerlink" title="参考"></a>参考</h4><p>CWE-783<br>MISRA C 2004 19.10<br>MISRA C 2012 20.7<br><br/><br><br/></p>
<h3 id="▌R3-2-5-表达式中的宏参数应该用括号括起来"><a href="#▌R3-2-5-表达式中的宏参数应该用括号括起来" class="headerlink" title="▌R3.2.5 表达式中的宏参数应该用括号括起来"></a><span id="macro_paramnotenclosed">▌R3.2.5 表达式中的宏参数应该用括号括起来</span></h3><p>ID_macro_paramNotEnclosed&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: precompile warning</p>
<hr/>

<p>由于宏只做文本处理，不考虑运算符优先级等问题，故应将宏参数用括号括起来，否则易产生意料之外的错误。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define SUM(a, b) (a + b)  // Non-compliant</span><br></pre></td></tr></table></figure>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define SUM(a, b) ((a) + (b))  // Compliant</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="依据-29"><a href="#依据-29" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 6.10.3.5(4)<br>ISO/IEC 9899:2011 6.10.3.5(4)<br><br/></p>
<h4 id="参考-47"><a href="#参考-47" class="headerlink" title="参考"></a>参考</h4><p>CWE-783<br>MISRA C++ 2008 16-0-6<br><br/><br><br/></p>
<h3 id="▌R3-2-6-由多个语句组成的宏定义应该用-do-while-0-括起来"><a href="#▌R3-2-6-由多个语句组成的宏定义应该用-do-while-0-括起来" class="headerlink" title="▌R3.2.6 由多个语句组成的宏定义应该用 do-while(0) 括起来"></a><span id="macro_stmtnotenclosed">▌R3.2.6 由多个语句组成的宏定义应该用 do-while(0) 括起来</span></h3><p>ID_macro_stmtNotEnclosed&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: precompile warning</p>
<hr/>

<p>可以作为一条语句使用的宏，且宏包含多个并列子句时，应该用“do {”和“} while(0)”括起来，否则易造成作用域的混乱。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define SWAP(a, b)\</span><br><span class="line">    a ^= b; b ^= a; a ^= b   // Non-compliant</span><br></pre></td></tr></table></figure>
<p>如果按如下使用方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (x &gt; y)</span><br><span class="line">    SWAP(x, y);</span><br></pre></td></tr></table></figure>
<p>展开后 b ^= a; a ^= b; 不在 if 语句的范围内，应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define SWAP(a, b) &#123;\          // Compliant</span><br><span class="line">    a ^= b; b ^= a; a ^= b;\</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更进一步地，建议使用 do-while(0) 结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define SWAP(a, b) do &#123;\       // Good</span><br><span class="line">    a ^= b; b ^= a; a ^= b;\</span><br><span class="line">&#125; while(0)</span><br></pre></td></tr></table></figure>
<p>这样在使用宏时必须以分号结尾，否则无法通过编译，使宏在使用风格上与函数相同，易于阅读。<br><br/><br><br/></p>
<h4 id="相关-31"><a href="#相关-31" class="headerlink" title="相关"></a>相关</h4><p>ID_if_scope<br>ID_while_scope<br>ID_for_scope<br><br/></p>
<h4 id="依据-30"><a href="#依据-30" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 6.10.3.5(4)<br>ISO/IEC 9899:2011 6.10.3.5(4)<br><br/></p>
<h4 id="参考-48"><a href="#参考-48" class="headerlink" title="参考"></a>参考</h4><p>CWE-483<br><br/><br><br/></p>
<h3 id="▌R3-2-7-宏定义中的-和-运算符不应嵌套使用"><a href="#▌R3-2-7-宏定义中的-和-运算符不应嵌套使用" class="headerlink" title="▌R3.2.7 宏定义中的 # 和 ## 运算符不应嵌套使用"></a><span id="macro_complexconcat">▌R3.2.7 宏定义中的 # 和 ## 运算符不应嵌套使用</span></h3><p>ID_macro_complexConcat&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: precompile warning</p>
<hr/>

<p># 和 ## 运算符的求值顺序在标准中是未声明的，不应嵌套使用。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#define M0(a, b) #a ## b          // Non-compliant</span><br><span class="line">#define M1(a, b, c) a ## b ## c   // Non-compliant</span><br><span class="line"></span><br><span class="line">#define M2(a) #a                  // Compliant</span><br><span class="line">#define M3(a, b) M2(a ## b)       // Compliant</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="依据-31"><a href="#依据-31" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 6.10.3.2(2)-unspecified<br>ISO/IEC 9899:1999 6.10.3.3(3)-unspecified<br>ISO/IEC 9899:2011 6.10.3.2(2)-unspecified<br>ISO/IEC 9899:2011 6.10.3.3(3)-unspecified<br>ISO/IEC 14882:2003 16.3.2(2)-unspecified<br>ISO/IEC 14882:2003 16.3.3(3)-unspecified<br>ISO/IEC 14882:2011 16.3.2(2)-unspecified<br>ISO/IEC 14882:2011 16.3.3(3)-unspecified<br>ISO/IEC 14882:2017 19.3.2(2)-unspecified<br>ISO/IEC 14882:2017 19.3.3(3)-unspecified<br><br/></p>
<h4 id="参考-49"><a href="#参考-49" class="headerlink" title="参考"></a>参考</h4><p>MISRA C 2004 19.12<br>MISRA C 2012 20.11<br>MISRA C++ 2008 16-3-1<br><br/><br><br/></p>
<h3 id="▌R3-2-8-不应使用宏定义常量"><a href="#▌R3-2-8-不应使用宏定义常量" class="headerlink" title="▌R3.2.8 不应使用宏定义常量"></a><span id="macro_const">▌R3.2.8 不应使用宏定义常量</span></h3><p>ID_macro_const&emsp;&emsp;&emsp;&emsp;&nbsp;:bulb: precompile suggestion</p>
<hr/>

<p>宏用于文本处理，不受作用域等语言规则限制，不应使用宏实现常量等语言层面的概念。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">namespace U &#123;</span><br><span class="line">    #define PI 3.14F  // Non-compliant</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">namespace V &#123;</span><br><span class="line">    #define PI 3.14159L  // Non-compliant</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">namespace W &#123;</span><br><span class="line">    void fun(double PI);  // Disturbed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中宏 PI 不受命名空间的限制，第二个宏定义会覆盖第一个宏定义，而且会干扰其他作用域中相同的名称。  </p>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">namespace U &#123;</span><br><span class="line">    const float PI = 3.14F;  // Compliant</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">namespace V &#123;</span><br><span class="line">    const long double PI = 3.14159L;  // Compliant</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了避免混乱，建议宏只作为 #if、#elif 等指令的条件，不参与具体的功能实现。<br><br/><br><br/></p>
<h4 id="相关-32"><a href="#相关-32" class="headerlink" title="相关"></a>相关</h4><p>ID_macro_typeid<br>ID_macro_function<br><br/></p>
<h4 id="参考-50"><a href="#参考-50" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines ES.31<br>C++ Core Guidelines Enum.1<br><br/><br><br/></p>
<h3 id="▌R3-2-9-不应使用宏定义类型"><a href="#▌R3-2-9-不应使用宏定义类型" class="headerlink" title="▌R3.2.9 不应使用宏定义类型"></a><span id="macro_typeid">▌R3.2.9 不应使用宏定义类型</span></h3><p>ID_macro_typeid&emsp;&emsp;&emsp;&emsp;&nbsp;:bulb: precompile suggestion</p>
<hr/>

<p>宏用于文本处理，不受作用域等语言规则限制，不应使用宏实现类型等语言层面的概念。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">namespace U &#123;</span><br><span class="line">    #define Type int  // Non-compliant</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">namespace V &#123;</span><br><span class="line">    #define Type long  // Non-compliant</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void foo(Type);  // Unreliable</span><br></pre></td></tr></table></figure>
<p>例中 Type 的最终定义是 long，第二个宏定义会覆盖第一个宏定义，这显然是不可靠的。<br><br/><br><br/></p>
<h4 id="相关-33"><a href="#相关-33" class="headerlink" title="相关"></a>相关</h4><p>ID_macro_sideEffectArgs<br>ID_macro_const<br>ID_macro_function<br><br/></p>
<h4 id="参考-51"><a href="#参考-51" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines ES.30<br><br/><br><br/></p>
<h3 id="▌R3-2-10-可由函数实现的功能不应使用宏实现"><a href="#▌R3-2-10-可由函数实现的功能不应使用宏实现" class="headerlink" title="▌R3.2.10 可由函数实现的功能不应使用宏实现"></a><span id="macro_function">▌R3.2.10 可由函数实现的功能不应使用宏实现</span></h3><p>ID_macro_function&emsp;&emsp;&emsp;&emsp;&nbsp;:bulb: precompile suggestion</p>
<hr/>

<p>宏用于文本处理，不受作用域、参数传递、重载等语言规则限制，且难以调试，可由函数实现的功能不应使用宏实现。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#define SUM(a, b) ((a) + (b))            // Non-compliant</span><br><span class="line">#define SUM(a, b, c) ((a) + (b) + (c))   // Non-compliant</span><br><span class="line"></span><br><span class="line">int foo(int a, int b) &#123;</span><br><span class="line">    return SUM(a, b);     // Error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中宏 SUM 意在获取参数的和，但宏无法被重载，最终只有一个宏被定义，foo 函数中的宏展开会造成错误。<br><br/><br><br/></p>
<h4 id="相关-34"><a href="#相关-34" class="headerlink" title="相关"></a>相关</h4><p>ID_macro_sideEffectArgs<br>ID_macro_const<br>ID_macro_typeid<br><br/></p>
<h4 id="参考-52"><a href="#参考-52" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines ES.31<br>MISRA C 2004 19.7<br>MISRA C 2012 Dir 4.9<br>MISRA C++ 2008 16-0-4<br><br/><br><br/></p>
<h3 id="▌R3-2-11-宏不应被重定义"><a href="#▌R3-2-11-宏不应被重定义" class="headerlink" title="▌R3.2.11 宏不应被重定义"></a><span id="macro_redefined">▌R3.2.11 宏不应被重定义</span></h3><p>ID_macro_redefined&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: precompile warning</p>
<hr/>

<p>宏不受作用域限制，重定义宏会使同一个全局名称产生多种不同的意义，易导致错误并降低可维护性。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#define M 1</span><br><span class="line"></span><br><span class="line">int foo() &#123;</span><br><span class="line">    #define M 0   // Non-compliant, redefined</span><br><span class="line">    return M;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int bar() &#123;</span><br><span class="line">    return M;   // Probably wrong</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中宏 M 在 foo 函数中被重定义，其影响范围是难以控制的，即使在重定义前用 #undef 取消定义也是不可取的，复用宏名称会使代码难以维护。<br><br/><br><br/></p>
<h4 id="依据-32"><a href="#依据-32" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 6.10.3(2)<br>ISO/IEC 9899:2011 6.10.3(2)<br>ISO/IEC 14882:2003 16.3(2 3)<br>ISO/IEC 14882:2011 16.3(2)<br><br/><br><br/></p>
<h3 id="▌R3-2-12-只应在全局作用域中定义宏"><a href="#▌R3-2-12-只应在全局作用域中定义宏" class="headerlink" title="▌R3.2.12 只应在全局作用域中定义宏"></a><span id="macro_inblock">▌R3.2.12 只应在全局作用域中定义宏</span></h3><p>ID_macro_inBlock&emsp;&emsp;&emsp;&emsp;&nbsp;:bulb: precompile suggestion</p>
<hr/>

<p>宏不受作用域限制，在非全局作用域中定义宏易引起误解。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void foo(void) &#123;</span><br><span class="line">    #define M 123   // Non-compliant, defined in a function scope</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中宏 M 在函数中定义，但其作用范围却是全局的。  </p>
<p>如果宏与某作用域密切相关，在该作用域内定义宏，使用后再取消定义是一种惯用方式，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void foo(void) &#123;</span><br><span class="line">    #define M 123   // Let it go?</span><br><span class="line">    ....</span><br><span class="line">    #undef M</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>审计工具不妨通过配置决定是否放过这种情况。<br><br/><br><br/></p>
<h4 id="配置-4"><a href="#配置-4" class="headerlink" title="配置"></a>配置</h4><p>allowDefineAndUndefInSameBlock：是否允许在同一非全局作用域内定义并取消定义宏<br><br/></p>
<h4 id="相关-35"><a href="#相关-35" class="headerlink" title="相关"></a>相关</h4><p>ID_macro_undef<br><br/></p>
<h4 id="依据-33"><a href="#依据-33" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 6.10.3.5(1)<br>ISO/IEC 9899:2011 6.10.3.5(1)<br><br/></p>
<h4 id="参考-53"><a href="#参考-53" class="headerlink" title="参考"></a>参考</h4><p>MISRA C 2004 19.5<br>MISRA C++ 2008 16-0-2<br><br/><br><br/></p>
<h3 id="▌R3-2-13-避免宏被取消定义"><a href="#▌R3-2-13-避免宏被取消定义" class="headerlink" title="▌R3.2.13 避免宏被取消定义"></a><span id="macro_undef">▌R3.2.13 避免宏被取消定义</span></h3><p>ID_macro_undef&emsp;&emsp;&emsp;&emsp;&nbsp;:bulb: precompile suggestion</p>
<hr/>

<p>宏不受作用域限制，不应被取消定义，否则会失去确定性，使代码难以维护。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// In a.h</span><br><span class="line">#define M 1</span><br><span class="line"></span><br><span class="line">// In b.h</span><br><span class="line">#undef M      // Non-compliant</span><br><span class="line">#define M 0   // Redefined, bad</span><br></pre></td></tr></table></figure>
<p>在一个文件中定义了宏 M，在另一个文件取消并重定义了 M，使同一个全局名称产生两种不同的意义，严重降低了可维护性。  </p>
<p>有时取消定义已使用完毕的内部宏可避免对外部产生不良影响，具有一定积极作用，但宏的定义和取消应在同一文件的同一作用域中完成，相关示例可参见 ID_macro_inBlock。<br><br/><br><br/></p>
<h4 id="配置-5"><a href="#配置-5" class="headerlink" title="配置"></a>配置</h4><p>allowUndefMacroInSameBlock：是否允许取消在同一作用域内定义的宏<br><br/></p>
<h4 id="相关-36"><a href="#相关-36" class="headerlink" title="相关"></a>相关</h4><p>ID_macro_undefReserved<br>ID_macro_inBlock<br><br/></p>
<h4 id="参考-54"><a href="#参考-54" class="headerlink" title="参考"></a>参考</h4><p>MISRA C 2004 19.6<br>MISRA C 2012 20.5<br>MISRA C++ 2008 16-0-3<br><br/><br><br/></p>
<h3 id="3-3-Macro-usage"><a href="#3-3-Macro-usage" class="headerlink" title="3.3 Macro-usage"></a><span id="precompile.macro-usage">3.3 Macro-usage</span></h3><h3 id="▌R3-3-1-宏的实参不应有副作用"><a href="#▌R3-3-1-宏的实参不应有副作用" class="headerlink" title="▌R3.3.1 宏的实参不应有副作用"></a><span id="macro_sideeffectargs">▌R3.3.1 宏的实参不应有副作用</span></h3><p>ID_macro_sideEffectArgs&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: precompile warning</p>
<hr/>

<p>当宏参数有“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Side_effect_(computer_science">副作用（side effect）</a>)”时，如果宏定义中没有或多次引用到该参数，会导致意料之外的错误。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#define I(a)</span><br><span class="line">#define M(a) ((a) + (a))</span><br><span class="line"></span><br><span class="line">int foo(int&amp; a) &#123;</span><br><span class="line">    return M(++a);   // Non-compliant, returns ‘((++a) + (++a))’</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void bar(int&amp; a) &#123;</span><br><span class="line">    I(a--);          // Non-compliant, does nothing</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中 M 和 I 看起来像是函数调用，而展开后的结果却在意料之外。<br><br/><br><br/></p>
<h4 id="相关-37"><a href="#相关-37" class="headerlink" title="相关"></a>相关</h4><p>ID_sideEffectAssertion<br>ID_macro_function<br><br/></p>
<h4 id="参考-55"><a href="#参考-55" class="headerlink" title="参考"></a>参考</h4><p>SEI CERT PRE31-C<br><br/><br><br/></p>
<h3 id="▌R3-3-2-宏的实参个数不可小于形参个数"><a href="#▌R3-3-2-宏的实参个数不可小于形参个数" class="headerlink" title="▌R3.3.2 宏的实参个数不可小于形参个数"></a><span id="macro_insufficientargs">▌R3.3.2 宏的实参个数不可小于形参个数</span></h3><p>ID_macro_insufficientArgs&emsp;&emsp;&emsp;&emsp;&nbsp;:boom: precompile error</p>
<hr/>

<p>宏的实参个数小于形参个数是不符合 C/C++ 标准的，参数个数不一致必然意味着某种错误，然而在某些编译环境下却可以通过编译。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#define M(a, b, c)  a ## b ## c</span><br><span class="line"></span><br><span class="line">const char* foo() &#123;</span><br><span class="line">    return M(&quot;x&quot;, &quot;y&quot;);  // Non-compliant</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>早期标准（ISO 9899:1990）对这种情况没有明确定义，后续标准对其进行了约束，但 MSVC 等编译器至今仍不把这种问题视作编译错误，需要特别注意。<br><br/><br><br/></p>
<h4 id="相关-38"><a href="#相关-38" class="headerlink" title="相关"></a>相关</h4><p>ID_macro_redundantArgs<br><br/></p>
<h4 id="依据-34"><a href="#依据-34" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 6.10.3(4)<br>ISO/IEC 9899:2011 6.10.3(4)<br>ISO/IEC 14882:2003 16.3(4)<br>ISO/IEC 14882:2011 16.3(4)<br><br/></p>
<h4 id="参考-56"><a href="#参考-56" class="headerlink" title="参考"></a>参考</h4><p>CWE-628<br>MISRA C 2004 19.8<br><br/><br><br/></p>
<h3 id="▌R3-3-3-宏的实参个数不可大于形参个数"><a href="#▌R3-3-3-宏的实参个数不可大于形参个数" class="headerlink" title="▌R3.3.3 宏的实参个数不可大于形参个数"></a><span id="macro_redundantargs">▌R3.3.3 宏的实参个数不可大于形参个数</span></h3><p>ID_macro_redundantArgs&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: precompile warning</p>
<hr/>

<p>宏的实参个数大于形参个数是不符合 C/C++ 标准的，多余的宏参数是没有意义的，然而在某些编译环境下却可以通过编译。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#define M(a, b, c)  a ## b ## c</span><br><span class="line"></span><br><span class="line">const char* foo() &#123;</span><br><span class="line">    return M(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;);  // Non-compliant</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例外：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#define MSG(fmt, ...) printf(fmt, __VA_ARGS__)</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    MSG(&quot;%d %d\n&quot;, 1, 2);  // Compliant</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可变宏参数列表可不受本规则约束。<br><br/><br><br/></p>
<h4 id="相关-39"><a href="#相关-39" class="headerlink" title="相关"></a>相关</h4><p>ID_macro_insufficientArgs<br><br/></p>
<h4 id="依据-35"><a href="#依据-35" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 6.10.3(4)<br>ISO/IEC 9899:2011 6.10.3(4)<br>ISO/IEC 14882:2003 16.3(4)<br>ISO/IEC 14882:2011 16.3(4)<br><br/></p>
<h4 id="参考-57"><a href="#参考-57" class="headerlink" title="参考"></a>参考</h4><p>CWE-628<br><br/><br><br/></p>
<h3 id="▌R3-3-4-va-start-或-va-copy-应配合-va-end-使用"><a href="#▌R3-3-4-va-start-或-va-copy-应配合-va-end-使用" class="headerlink" title="▌R3.3.4 va_start 或 va_copy 应配合 va_end 使用"></a><span id="incompletevamacros">▌R3.3.4 va_start 或 va_copy 应配合 va_end 使用</span></h3><p>ID_incompleteVaMacros&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: precompile warning</p>
<hr/>

<p>可变参数列表相关的 va_start 或 va_copy 和 va_end 应在同一函数中使用，否则会导致标准未定义的行为。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int foo(int n, ...) &#123;</span><br><span class="line">    va_list ap;</span><br><span class="line">    va_start(ap, n);</span><br><span class="line">    int sum = 0;</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        sum += va_arg(ap, int);</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;   // Non-compliant, missing ‘va_end(ap);’</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应在函数返回前使用 va_end。<br><br/><br><br/></p>
<h4 id="相关-40"><a href="#相关-40" class="headerlink" title="相关"></a>相关</h4><p>ID_forbidVariadicFunction<br><br/></p>
<h4 id="依据-36"><a href="#依据-36" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 7.15.1.3(2)-undefined<br>ISO/IEC 9899:2011 7.16.1.3(2)-undefined<br><br/><br><br/></p>
<h3 id="▌R3-3-5-va-arg-的类型参数应符合要求"><a href="#▌R3-3-5-va-arg-的类型参数应符合要求" class="headerlink" title="▌R3.3.5 va_arg 的类型参数应符合要求"></a><span id="badvaargtype">▌R3.3.5 va_arg 的类型参数应符合要求</span></h3><p>ID_badVaArgType&emsp;&emsp;&emsp;&emsp;&nbsp;:boom: precompile error</p>
<hr/>

<p>对于 stdarg.h 中的宏 va_arg(ap, type)，其类型参数 type 在  </p>
<p>对于宏 va_arg(ap, type) 的类型参数 type，下列情况会导致标准未定义的行为：  </p>
<ul>
<li>type 后加 * 号不能表示指针类型  </li>
<li>与“默认参数提升”后的类型不兼容  </li>
<li>与可变参数列表中对应的实参类型不兼容，或没有对应的实参  </li>
</ul>
<p>以下类型不可作为 av_arg 的参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bool、_Bool、</span><br><span class="line">char、signed char、unsigned char、char16_t、</span><br><span class="line">float、</span><br><span class="line">short、unsigned short、signed short、</span><br><span class="line">short int、signed short int、unsigned short int</span><br></pre></td></tr></table></figure>
<p>这些类型的参数在传入可变参数列表时，会被提升为 int、unsigned int、double 等类型，va_arg 如果再按提升前的类型解析参数的值就会产生错误，参见“<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/variadic_arguments#Default_conversions">默认参数提升（default argument promotion）</a>”机制。  </p>
<p>另外，C++ 代码中非 POD 类型也不可作为 va_arg 的参数，参见 ID_nonPODVariadicArgument。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void foo(int n, ...) &#123;</span><br><span class="line">    va_list ap;</span><br><span class="line">    va_start(ap, n);</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        char c = va_arg(ap, char);   // Non-compliant</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">    va_end(ap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中 va_arg 的类型参数为 char 是不符合要求的。  </p>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">    char c = (char)va_arg(ap, int);   // Compliant</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="相关-41"><a href="#相关-41" class="headerlink" title="相关"></a>相关</h4><p>ID_badParmN<br>ID_nonPODVariadicArgument<br>ID_forbidVariadicFunction<br><br/></p>
<h4 id="依据-37"><a href="#依据-37" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 7.15.1.1(2)-undefined<br>ISO/IEC 9899:2011 7.16.1.1(2)-undefined<br><br/></p>
<h4 id="参考-58"><a href="#参考-58" class="headerlink" title="参考"></a>参考</h4><p>SEI CERT EXP47-C<br><br/><br><br/></p>
<h3 id="▌R3-3-6-在-C-代码中不应使用宏-offsetof"><a href="#▌R3-3-6-在-C-代码中不应使用宏-offsetof" class="headerlink" title="▌R3.3.6 在 C++ 代码中不应使用宏 offsetof"></a><span id="deprecatedoffsetof">▌R3.3.6 在 C++ 代码中不应使用宏 offsetof</span></h3><p>ID_deprecatedOffsetof&emsp;&emsp;&emsp;&emsp;&nbsp;:bulb: precompile suggestion</p>
<hr/>

<p>宏 offsetof 很难适用于具有 C++ 特性的类，在 C++ 代码中不应使用。  </p>
<p>如果 offsetof 用于：  </p>
<ul>
<li>非“<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/named_req/StandardLayoutType">standard-layout</a>”类型  </li>
<li>计算静态成员或成员函数的偏移量  </li>
</ul>
<p>会导致标准未定义的行为。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">struct A &#123;</span><br><span class="line">    int i;</span><br><span class="line">    virtual int f();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int foo() &#123;</span><br><span class="line">    return offsetof(A, i);  // Non-compliant, undefined behavior</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct B &#123;</span><br><span class="line">    static int i;</span><br><span class="line">    int f();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int bar() &#123;</span><br><span class="line">    return offsetof(B, i);  // Non-compliant, undefined behavior</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int baz() &#123;</span><br><span class="line">    return offsetof(B, f);  // Non-compliant, undefined behavior</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="依据-38"><a href="#依据-38" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 14882:2003 18.1(5)-undefined<br>ISO/IEC 14882:2011 18.2(4)-undefined<br><br/></p>
<h4 id="参考-59"><a href="#参考-59" class="headerlink" title="参考"></a>参考</h4><p>MISRA C++ 2008 18-2-1<br>SEI CERT EXP59-CPP<br><br/><br><br/></p>
<h3 id="3-4-Directive"><a href="#3-4-Directive" class="headerlink" title="3.4 Directive"></a><span id="precompile.directive">3.4 Directive</span></h3><h3 id="▌R3-4-1-头文件不应缺少守卫"><a href="#▌R3-4-1-头文件不应缺少守卫" class="headerlink" title="▌R3.4.1 头文件不应缺少守卫"></a><span id="missingheaderguard">▌R3.4.1 头文件不应缺少守卫</span></h3><p>ID_missingHeaderGuard&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: precompile warning</p>
<hr/>

<p>以 .h 或 .hpp 为扩展名的头文件应包含头文件守卫。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Header file foo.h</span><br><span class="line">#ifndef LIBRARY_FOO_H</span><br><span class="line">#define LIBRARY_FOO_H</span><br><span class="line">....</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>例中 foo.h 是“Library”模块中的头文件，宏 LIBRARY_FOO_H 即可作为它的守卫，保证头文件被重复引入也不会出现问题，守卫名称不可有重复，建议守卫名称遵循“模块名_文件名”的形式。  </p>
<p>#pragma once 指令也可作为头文件守卫，但并不是 C/C++ 的标准方式，只是多数编译器均有支持。这种方式由编译器维护一个列表，引入头文件时，如果发现文件中有 #pragma once 指令就将文件路径加入列表，当这个文件再次被 include 时便不会加载，而宏守卫的方式仍然要对文件进行预编译，所以 #pragma once 方式在编译效率上会更高一些。  </p>
<p>宏守卫用宏名区分头文件，所以不能有重复。宏的引入可以使相关设定更灵活，比如声明头文件之间的依赖或排斥关系，如果 bar.h 依赖 foo.h，在 #include “bar.h” 之前必须 #include “foo.h”，可在 bar.h 中设置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Header file bar.h</span><br><span class="line">#ifndef LIBRARY_FOO_H</span><br><span class="line">#error foo.h should be included first</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>这样如果不满足条件无法通过编译。  </p>
<p>本规则建议使用宏守卫的方式，但 #pragma once 方法也是惯用写法，不妨通过配置项决定其是否合规。<br><br/><br><br/></p>
<h4 id="配置-6"><a href="#配置-6" class="headerlink" title="配置"></a>配置</h4><p>allowPragmaOnce：是否允许 #pragma once 作为头文件守卫<br><br/></p>
<h4 id="参考-60"><a href="#参考-60" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines SF.8<br>MISRA C 2004 19.15<br>MISRA C++ 2008 16-2-3<br><br/><br><br/></p>
<h3 id="▌R3-4-2-不应出现非标准格式的预编译指令"><a href="#▌R3-4-2-不应出现非标准格式的预编译指令" class="headerlink" title="▌R3.4.2 不应出现非标准格式的预编译指令"></a><span id="illformeddirective">▌R3.4.2 不应出现非标准格式的预编译指令</span></h3><p>ID_illFormedDirective&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: precompile warning</p>
<hr/>

<p>非标准格式的预编译指令往往意味着错误，也会导致标准未定义的行为。  </p>
<p>需注意：  </p>
<ul>
<li>defined 只应作用于宏名称或括号括起来的宏名称  </li>
<li>defined 不应出现在宏定义中  </li>
<li>#if、#elif 之后应为正确的常量表达式  </li>
<li>#ifdef、#ifndef 之后只应为宏名称  </li>
<li>#else、#endif 之后应直接换行  </li>
<li>#line 之后应接整数常量，或整数常量和文件名称  </li>
<li>#line 指定的行号应在有效范围内  </li>
<li>#line 不应出现在非自动生成的代码中  </li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#if defined M            // Compliant</span><br><span class="line">#if defined(M)           // Compliant</span><br><span class="line">#if defined(M == 0)      // Non-compliant, undefined behavior</span><br><span class="line"></span><br><span class="line">#define DEFINED defined  // Non-compliant</span><br><span class="line">#if DEFINED M            // Undefined behavior</span><br><span class="line"></span><br><span class="line">#line 0                  // Non-compliant, invalid line number</span><br><span class="line">#line 4294967295         // Non-compliant, line number too large</span><br></pre></td></tr></table></figure>
<p>例中作用于比较表达式的 defined 和 #if 条件中由宏展开产生的 defined 均会导致未定义的行为，由 #line 指定的行号应大于 0 且小于 2147483648（按 C++03 标准则应小于 32768），否则也会导致未定义的行为。  </p>
<p>又如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#define M 2</span><br><span class="line"></span><br><span class="line">int foo() &#123;</span><br><span class="line">    int x = 0;</span><br><span class="line">#ifdef M</span><br><span class="line">        x = M;</span><br><span class="line">#elif            // Non-compliant, use ‘#else’ instead</span><br><span class="line">        x = 1;</span><br><span class="line">#endif M         // Non-compliant, remove ‘M’</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种代码是不符合标准的，但可被某些编译器接受，应避免。<br><br/><br><br/></p>
<h4 id="依据-39"><a href="#依据-39" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 6.10(1)<br>ISO/IEC 9899:1999 6.10.1(3)-undefined<br>ISO/IEC 9899:2011 6.10(1)<br>ISO/IEC 9899:2011 6.10.1(4)-undefined<br>ISO/IEC 14882:2003 16.1(4)-undefined<br>ISO/IEC 14882:2003 16.2(4)-undefined<br>ISO/IEC 14882:2003 16.4(3)-undefined<br>ISO/IEC 14882:2003 16.4(5)-undefined<br>ISO/IEC 14882:2011 16.1(4)-undefined<br>ISO/IEC 14882:2011 16.2(4)-undefined<br>ISO/IEC 14882:2011 16.4(3)-undefined<br>ISO/IEC 14882:2011 16.4(5)-undefined<br><br/></p>
<h4 id="参考-61"><a href="#参考-61" class="headerlink" title="参考"></a>参考</h4><p>MISRA C++ 2008 16-0-7<br>MISRA C++ 2008 16-0-8<br>MISRA C++ 2008 16-1-1<br><br/><br><br/></p>
<h3 id="▌R3-4-3-不应使用非标准预编译指令"><a href="#▌R3-4-3-不应使用非标准预编译指令" class="headerlink" title="▌R3.4.3 不应使用非标准预编译指令"></a><span id="nonstddirective">▌R3.4.3 不应使用非标准预编译指令</span></h3><p>ID_nonStdDirective&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: precompile warning</p>
<hr/>

<p>非标准预编译指令往往属于某种编译器独有，在有可移植性要求的代码中应避免使用。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;foo&quot;          // Non-compliant</span><br><span class="line">#include_next &quot;bar.h&quot;  // Non-compliant</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="依据-40"><a href="#依据-40" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 6.10(1)<br>ISO/IEC 9899:2011 6.10(1)<br>ISO/IEC 14882:2003 16(1)<br>ISO/IEC 14882:2011 16(1)<br>ISO/IEC 14882:2017 19(1)<br><br/></p>
<h4 id="参考-62"><a href="#参考-62" class="headerlink" title="参考"></a>参考</h4><p>MISRA C 2004 19.16<br>MISRA C 2012 20.13<br><br/><br><br/></p>
<h3 id="▌R3-4-4-避免使用-pragma-指令"><a href="#▌R3-4-4-避免使用-pragma-指令" class="headerlink" title="▌R3.4.4 避免使用 pragma 指令"></a><span id="forbidpragmadirective">▌R3.4.4 避免使用 pragma 指令</span></h3><p>ID_forbidPragmaDirective&emsp;&emsp;&emsp;&emsp;&nbsp;:no_entry: precompile warning</p>
<hr/>

<p>应避免使用由实现定义的 pragma 指令以提高可移植性。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#pragma once   // Non-compliant, use macro header guards instead</span><br></pre></td></tr></table></figure>
<p>应使用标准方法代替 pragma 指令，如果难以代替，相关 pragma 指令应备以文档说明。<br><br/><br><br/></p>
<h4 id="依据-41"><a href="#依据-41" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 6.10.6(1)-implementation<br>ISO/IEC 9899:2011 6.10.6(1)-implementation<br><br/></p>
<h4 id="参考-63"><a href="#参考-63" class="headerlink" title="参考"></a>参考</h4><p>MISRA C++ 2008 16-6-1<br><br/><br><br/></p>
<h3 id="▌R3-4-5-非自动生成的代码中不应出现-line-指令"><a href="#▌R3-4-5-非自动生成的代码中不应出现-line-指令" class="headerlink" title="▌R3.4.5 非自动生成的代码中不应出现 line 指令"></a><span id="explicitlinedirective">▌R3.4.5 非自动生成的代码中不应出现 line 指令</span></h3><p>ID_explicitLineDirective&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: precompile warning</p>
<hr/>

<p>在非自动生成的代码中没有必要使用 line 指令，否则会干扰编译器的输出，使问题难以定位。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#line 123           // Non-compliant</span><br><span class="line">#line 456 &quot;foo.c&quot;   // Non-compliant</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="依据-42"><a href="#依据-42" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 6.10.4<br>ISO/IEC 9899:2011 6.10.4<br><br/><br><br/></p>
<h3 id="▌R3-4-6-宏的参数列表中不应出现预编译指令"><a href="#▌R3-4-6-宏的参数列表中不应出现预编译指令" class="headerlink" title="▌R3.4.6 宏的参数列表中不应出现预编译指令"></a><span id="directiveinmacroargument">▌R3.4.6 宏的参数列表中不应出现预编译指令</span></h3><p>ID_directiveInMacroArgument&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: precompile warning</p>
<hr/>

<p>如果预编译指令出现在宏的参数列表中，会导致标准未定义的行为。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#define PRINT(s) printf(#s)</span><br><span class="line"></span><br><span class="line">PRINT(</span><br><span class="line">#ifdef MAC      // Non-compliant, undefined behavior</span><br><span class="line">    rabbit</span><br><span class="line">#else           // Non-compliant</span><br><span class="line">    hamster</span><br><span class="line">#endif          // Non-compliant</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>可能会打印出 hamster，也可能是 #ifdef MAC rabbit #else hamster #endif 这种怪异的结果。<br><br/><br><br/></p>
<h4 id="依据-43"><a href="#依据-43" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 6.10.3(11)-undefined<br>ISO/IEC 9899:2011 6.10.3(11)-undefined<br>ISO/IEC 14882:2003 16.3(10)-undefined<br>ISO/IEC 14882:2011 16.3(11)-undefined<br><br/></p>
<h4 id="参考-64"><a href="#参考-64" class="headerlink" title="参考"></a>参考</h4><p>MISRA C 2012 20.6<br>MISRA C++ 2008 16-0-5<br><br/><br><br/></p>
<h3 id="▌R3-4-7-条件编译代码块应在同一文件中"><a href="#▌R3-4-7-条件编译代码块应在同一文件中" class="headerlink" title="▌R3.4.7 条件编译代码块应在同一文件中"></a><span id="incompletedirective">▌R3.4.7 条件编译代码块应在同一文件中</span></h3><p>ID_incompleteDirective&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: precompile warning</p>
<hr/>

<p>#if、#ifdef 与对应的 #else、#elif、#endif 应在同一文件中，否则会增加代码的维护成本。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// a.h</span><br><span class="line">#ifdef M      // Non-compliant</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line">// b.h</span><br><span class="line">#else         // Non-compliant</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line">// c.h</span><br><span class="line">#include &quot;a.h&quot;</span><br><span class="line">#include &quot;b.h&quot;</span><br><span class="line">#endif           // Non-compliant</span><br></pre></td></tr></table></figure>
<p>示例代码将 #ifdef、#else、#endif 分成了三个文件，使这些文件的依赖关系变得复杂，也使单个文件失去了可读性。<br><br/><br><br/></p>
<h4 id="参考-65"><a href="#参考-65" class="headerlink" title="参考"></a>参考</h4><p>MISRA C 2004 19.17<br>MISRA C 2012 20.14<br>MISRA C++ 2008 16-1-2<br><br/><br><br/></p>
<h3 id="▌R3-4-8-对编译警告的屏蔽应慎重"><a href="#▌R3-4-8-对编译警告的屏蔽应慎重" class="headerlink" title="▌R3.4.8 对编译警告的屏蔽应慎重"></a><span id="warningdisabled">▌R3.4.8 对编译警告的屏蔽应慎重</span></h3><p>ID_warningDisabled&emsp;&emsp;&emsp;&emsp;&nbsp;:bulb: precompile suggestion</p>
<hr/>

<p>编译器一般允许使用预编译指令屏蔽某些编译警告，但对于反映风险或安全问题的警告不应屏蔽。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#ifdef _MSC_VER</span><br><span class="line">#pragma warning(disable: 4172)  // Non-compliant</span><br><span class="line">#elif defined __GNUC__</span><br><span class="line">#pragma GCC diagnostic ignored &quot;-Wreturn-local-addr&quot;  // Non-compliant</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>示例代码屏蔽了 Visual Studio C4172 和 GCC -Wreturn-local-addr 对应的警告，当局部变量的地址被返回时编译器不会给出警告，但这种警告是不应该被屏蔽的，详见 ID_localAddressFlowOut。  </p>
<p>本规则集合提到的部分问题编译器也可以给出警告，这种警告均不应被屏蔽。<br><br/><br><br/></p>
<h4 id="相关-42"><a href="#相关-42" class="headerlink" title="相关"></a>相关</h4><p>ID_warningDefault<br><br/><br><br/></p>
<h3 id="▌R3-4-9-在高级别的警告设置下编译"><a href="#▌R3-4-9-在高级别的警告设置下编译" class="headerlink" title="▌R3.4.9 在高级别的警告设置下编译"></a><span id="warningdefault">▌R3.4.9 在高级别的警告设置下编译</span></h3><p>ID_warningDefault&emsp;&emsp;&emsp;&emsp;&nbsp;:bulb: precompile suggestion</p>
<hr/>

<p>编译器一般允许设定编译警告的级别，级别越高关注的问题就越多，也可以将警告设为错误，当有警告产生时停止编译，建议代码在高级别的警告设置下编译。  </p>
<p>应避免代码中出现 #pragma warning(default:…) 等指令，这种指令将警告级别设为默认，可能与整个项目的设置不一致，如果一定要使用，应改用 #pragma warning(pop) 方式。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#pragma warning(disable:4706)</span><br><span class="line">#include &quot;somecode&quot;</span><br><span class="line">#pragma warning(default:4706)  // Non-compliant</span><br></pre></td></tr></table></figure>
<p>示例代码在导入某些代码之前将代号为 4706 的警告屏蔽，之后又将其设为默认级别，首先要关注 4706 是否应该被屏蔽，还要关注如果将其设为默认是否与整个项目的设置有冲突。  </p>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#pragma warning(push)</span><br><span class="line">#pragma warning(disable:4706)</span><br><span class="line">#include &quot;somecode&quot;</span><br><span class="line">#pragma warning(pop)  // Compliant</span><br></pre></td></tr></table></figure>
<p>改用这种方式之后不必再关注是否与整个项目的设置有冲突了。<br><br/><br><br/></p>
<h4 id="相关-43"><a href="#相关-43" class="headerlink" title="相关"></a>相关</h4><p>ID_warningDisabled<br><br/></p>
<h4 id="参考-66"><a href="#参考-66" class="headerlink" title="参考"></a>参考</h4><p>SEI CERT MSC00-C<br><br/><br><br/></p>
<h3 id="3-5-Comment"><a href="#3-5-Comment" class="headerlink" title="3.5 Comment"></a><span id="precompile.comment">3.5 Comment</span></h3><h3 id="▌R3-5-1-关注-TODO、FIXME、XXX、BUG-等特殊注释"><a href="#▌R3-5-1-关注-TODO、FIXME、XXX、BUG-等特殊注释" class="headerlink" title="▌R3.5.1 关注 TODO、FIXME、XXX、BUG 等特殊注释"></a><span id="specialcomment">▌R3.5.1 关注 TODO、FIXME、XXX、BUG 等特殊注释</span></h3><p>ID_specialComment&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: precompile warning</p>
<hr/>

<p>TODO、FIXME、XXX、BUG 等特殊注释表示代码中存在问题，这种问题不应被遗忘，应有计划地予以解决。  </p>
<p>及时记录问题是一种好习惯，而且最好有署名和日期。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void foo() &#123;</span><br><span class="line">    /*</span><br><span class="line">     * Some plans...         // Bad, easy to forget</span><br><span class="line">     */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void foo() &#123;</span><br><span class="line">    /* TODO:</span><br><span class="line">     * Some plans...  -- my name, date     // Good</span><br><span class="line">     */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>审计工具不妨定期搜索这些关键词对应的注释，以供相关人员核对问题解决情况。<br><br/><br><br/></p>
<h4 id="配置-7"><a href="#配置-7" class="headerlink" title="配置"></a>配置</h4><p>specialCommentPatterns：特殊注释的模式字符串（如正则表达式等），供审计工具查找<br><br/></p>
<h4 id="参考-67"><a href="#参考-67" class="headerlink" title="参考"></a>参考</h4><p>CWE-546<br><br/><br><br/></p>
<h3 id="▌R3-5-2-注释不可嵌套"><a href="#▌R3-5-2-注释不可嵌套" class="headerlink" title="▌R3.5.2 注释不可嵌套"></a><span id="nestedcomment">▌R3.5.2 注释不可嵌套</span></h3><p>ID_nestedComment&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: precompile warning</p>
<hr/>

<p>嵌套的 /*…*/ 注释不符合标准，/* 与 */ 之间不应出现 /*，某些编译器可以接受嵌套，但不具备可移植性。  </p>
<p>示例：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/*                         // #1</span><br><span class="line">    /*                     // #2, Non-compliant</span><br><span class="line">    nested comments</span><br><span class="line">     */                    // #3</span><br><span class="line">*/                         // #4, Non-compliant</span><br></pre></td></tr></table></figure>
<p>根据标准，<code>#1</code> 处的 /* 与 <code>#3</code> 处的 */ 匹配，而 <code>#4</code> 处的 */ 处于失配状态。<br><br/><br><br/></p>
<h4 id="依据-44"><a href="#依据-44" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 6.4.9(1)<br>ISO/IEC 9899:2011 6.4.9(1)<br><br/></p>
<h4 id="参考-68"><a href="#参考-68" class="headerlink" title="参考"></a>参考</h4><p>MISRA C 2004 2.3<br>MISRA C 2012 3.1<br>MISRA C++ 2008 2-7-1<br><br/><br><br/></p>
<h3 id="▌R3-5-3-注释应出现在合理的位置"><a href="#▌R3-5-3-注释应出现在合理的位置" class="headerlink" title="▌R3.5.3 注释应出现在合理的位置"></a><span id="badcommentposition">▌R3.5.3 注释应出现在合理的位置</span></h3><p>ID_badCommentPosition&emsp;&emsp;&emsp;&emsp;&nbsp;:bulb: precompile suggestion</p>
<hr/>

<p>注释应出现在段落的前后或行尾，不应出现在行首或中间，否则干扰阅读，甚至会导致标准未定义的行为。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#/*comment*/include &quot;foo.h&quot;         // Non-compliant</span><br><span class="line">#include &lt;bar.h /*comment*/&gt;        // Non-compliant, undefined behavior</span><br><span class="line"></span><br><span class="line">/*comment*/ int main()              // Non-compliant</span><br><span class="line">&#123;</span><br><span class="line">    return a + b /*comment*/ + c;   // Non-compliant</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;foo.h&quot;    // comment      // Compliant</span><br><span class="line">#include &lt;bar.h&gt;    // comment      // Compliant</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * comment                          // Compliant</span><br><span class="line"> */</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    return a + b + c;  // comment   // Compliant</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例外：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void foo(int i = 0);                // Declaration</span><br><span class="line"></span><br><span class="line">void foo(int i /*= 0*/) &#123;           // Let it go</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果参数有默认值，在函数实现中参数声明的结尾可用注释说明，不受本规则限制。<br><br/><br><br/></p>
<h4 id="依据-45"><a href="#依据-45" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 6.4.7(3)-undefined<br>ISO/IEC 9899:2011 6.4.7(3)-undefined<br>ISO/IEC 14882:2003 2.8(2)-undefined<br>ISO/IEC 14882:2011 2.9(2)-implementation<br><br/><br><br/></p>
<h3 id="3-6-Other"><a href="#3-6-Other" class="headerlink" title="3.6 Other"></a><span id="precompile.other">3.6 Other</span></h3><h3 id="▌R3-6-1-非空源文件应以换行符结尾"><a href="#▌R3-6-1-非空源文件应以换行符结尾" class="headerlink" title="▌R3.6.1 非空源文件应以换行符结尾"></a><span id="missingnewlinefileend">▌R3.6.1 非空源文件应以换行符结尾</span></h3><p>ID_missingNewLineFileEnd&emsp;&emsp;&emsp;&emsp;&nbsp;:bulb: precompile suggestion</p>
<hr/>

<p>如果非空源文件未以换行符结尾，或以换行符结尾但换行符之前是反斜杠，在 C 和 C++03 标准中会导致未定义的行为。  </p>
<p>一般情况下 IDE 或编辑器会保证源文件以空行结尾，而且 C++11 规定编译器应补全所需的空行，但为了提高兼容性，并便于各种相关工具的使用，所有与代码相关的文本文件均应以有效的换行符结尾。<br><br/><br><br/></p>
<h4 id="配置-8"><a href="#配置-8" class="headerlink" title="配置"></a>配置</h4><p>allTxtFileNeedNewLineEnd：是否要求所有文本文件均以换行符结尾<br><br/></p>
<h4 id="依据-46"><a href="#依据-46" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 5.1.1.2(1)-undefined<br>ISO/IEC 9899:2011 5.1.1.2(1)-undefined<br>ISO/IEC 14882:2003 2.1(1)-undefined<br>ISO/IEC 14882:2011 2.2(1)<br><br/><br><br/></p>
<h3 id="▌R3-6-2-除转义字符、宏定义之外不应使用反斜杠"><a href="#▌R3-6-2-除转义字符、宏定义之外不应使用反斜杠" class="headerlink" title="▌R3.6.2 除转义字符、宏定义之外不应使用反斜杠"></a><span id="badbackslash">▌R3.6.2 除转义字符、宏定义之外不应使用反斜杠</span></h3><p>ID_badBackslash&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: precompile warning</p>
<hr/>

<p>反斜杠可用于标识转义字符，也可用于实现“伪换行”，即代码换行显示但在语法上并没有换行，一般用于宏定义，除此之外不应再使用反斜杠，否则没有实际意义，也会造成混乱。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#define M(x, y) if(x) &#123;\    // Compliant</span><br><span class="line">    foo(y);\                // Compliant</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void foo() &#123;</span><br><span class="line">    if (condition1 \        // Non-compliant, meaningless</span><br><span class="line">     || condition2) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int a\                      // Non-compliant, odd usage</span><br><span class="line">b\</span><br><span class="line">c = 123;</span><br><span class="line"></span><br><span class="line">void bar() &#123;</span><br><span class="line">    // comment  \           // Non-compliant, The next line is also commented out</span><br><span class="line">    do_something();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果“universal character name”被反斜杠截断会导致标准未定义的行为，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const char* s = &quot;\u4e\      // Non-compliant, undefined behavior</span><br><span class="line">2d&quot;;</span><br></pre></td></tr></table></figure>
<p>应去掉反斜杠：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const char* s = &quot;\u4e2d&quot;;   // Compliant</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="依据-47"><a href="#依据-47" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 14882:2003 2.1(1)-undefined<br>ISO/IEC 14882:2011 2.2(1)-undefined<br><br/></p>
<h4 id="参考-69"><a href="#参考-69" class="headerlink" title="参考"></a>参考</h4><p>MISRA C 2012 3.2<br><br/><br><br/></p>
<h2 id="4-Global"><a href="#4-Global" class="headerlink" title="4. Global"></a><span id="global">4. Global</span></h2><h3 id="▌R4-1-全局名称应遵循合理的命名方式"><a href="#▌R4-1-全局名称应遵循合理的命名方式" class="headerlink" title="▌R4.1 全局名称应遵循合理的命名方式"></a><span id="nametooshort">▌R4.1 全局名称应遵循合理的命名方式</span></h3><p>ID_nameTooShort&emsp;&emsp;&emsp;&emsp;&nbsp;:bulb: global suggestion</p>
<hr/>

<p>全局名称应具有标识性，长度不应过短，否则易与局部名称产生冲突。  </p>
<p>本规则是 ID_badName 的特化。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// In global scope</span><br><span class="line">const int i = 0;     // Non-compliant, name too short</span><br><span class="line">typedef int t;       // Non-compliant, name too short</span><br><span class="line">class A &#123; .... &#125;;    // Non-compliant, name too short</span><br><span class="line"></span><br><span class="line">int foo(int i) &#123;</span><br><span class="line">    return i + i;    // Confusing</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>名称适用的作用域范围越广，其长度也应该越长，建议全局名称长度不小于 3 个字符。<br><br/><br><br/></p>
<h4 id="配置-9"><a href="#配置-9" class="headerlink" title="配置"></a>配置</h4><p>minVariableNameLength：全局对象名称长度下限，小于则报出<br>minFunctionNameLength：全局函数名称长度下限，小于则报出<br>minNameSpaceNameLength：全局命名空间名称长度下限，小于则报出<br>minTypeNameLength：全局类型名称长度下限，小于则报出<br><br/></p>
<h4 id="相关-44"><a href="#相关-44" class="headerlink" title="相关"></a>相关</h4><p>ID_badName<br><br/></p>
<h4 id="参考-70"><a href="#参考-70" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines NL.7<br><br/><br><br/></p>
<h3 id="▌R4-2-为代码设定合理的命名空间"><a href="#▌R4-2-为代码设定合理的命名空间" class="headerlink" title="▌R4.2 为代码设定合理的命名空间"></a><span id="missingnamespace">▌R4.2 为代码设定合理的命名空间</span></h3><p>ID_missingNamespace&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: global warning</p>
<hr/>

<p>命名空间是 C++ 项目的必要组成结构，可有效规避名称冲突等问题。  </p>
<p>C++ 代码的顶层作用域应为具名非内联命名空间，命名空间名称应与项目名称相符，且具有标识性。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">namespace NS &#123;</span><br><span class="line">    int foo();           // Compliant</span><br><span class="line">    int foo(char*);      // Compliant</span><br><span class="line">    int foo(wchar_t*);   // Compliant</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int foo() &#123;              // Non-compliant, it is not ‘int NS::foo()’</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int NS::foo(char*) &#123;     // Compliant</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">namespace NS &#123;</span><br><span class="line">    int foo(wchar_t*) &#123;  // Compliant</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 main 函数和 extern “C” 声明的代码可不受本规则限制，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">extern &quot;C&quot; int bar();    // Compliant</span><br><span class="line"></span><br><span class="line">int main () &#123;            // Compliant</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="相关-45"><a href="#相关-45" class="headerlink" title="相关"></a>相关</h4><p>ID_usingNamespaceInHeader<br>ID_forbidUsingDirectives<br><br/></p>
<h4 id="参考-71"><a href="#参考-71" class="headerlink" title="参考"></a>参考</h4><p>MISRA C++ 2008 7-3-1<br><br/><br><br/></p>
<h3 id="▌R4-3-main-函数只应处于全局作用域中"><a href="#▌R4-3-main-函数只应处于全局作用域中" class="headerlink" title="▌R4.3 main 函数只应处于全局作用域中"></a><span id="nonglobalmain">▌R4.3 main 函数只应处于全局作用域中</span></h3><p>ID_nonGlobalMain&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: global warning</p>
<hr/>

<p>main 函数作为程序的入口，链接器需对其特殊处理，不应受命名空间等作用域的限制。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;   // Compliant</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">namespace &#123;</span><br><span class="line">    int main() &#123;   // Non-compliant</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">namespace NS &#123;</span><br><span class="line">    int main() &#123;   // Non-compliant</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="依据-48"><a href="#依据-48" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 14882:2003 3.6.1(1)<br>ISO/IEC 14882:2011 3.6.1(1)<br><br/></p>
<h4 id="参考-72"><a href="#参考-72" class="headerlink" title="参考"></a>参考</h4><p>MISRA C++ 2008 7-3-2<br><br/><br><br/></p>
<h3 id="▌R4-4-头文件中不应使用-using-directive"><a href="#▌R4-4-头文件中不应使用-using-directive" class="headerlink" title="▌R4.4 头文件中不应使用 using directive"></a><span id="usingnamespaceinheader">▌R4.4 头文件中不应使用 using directive</span></h3><p>ID_usingNamespaceInHeader&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: global warning</p>
<hr/>

<p>在头文件的全局作用域中使用 using directive 极易造成命名冲突，且影响范围难以控制。  </p>
<p>如果代码涉及多个命名空间，而这些命名空间中又有名称相同且功能相似的代码元素时，将造成难以排查的混乱。对于库的头文件，更应该严禁使用全局的 using directive，否则造成对用户命名空间的干扰。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// In a header file</span><br><span class="line">namespace NS &#123;</span><br><span class="line">    void foo(short);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">using namespace NS;   // Non-compliant</span><br><span class="line">using namespace std;  // Non-compliant</span><br></pre></td></tr></table></figure>
<p>下例展示的问题是头文件不同的包含顺序竟导致同一函数产生了不同的行为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// In a.h</span><br><span class="line">void foo(char);</span><br><span class="line"></span><br><span class="line">namespace ns &#123;</span><br><span class="line">    void foo(int);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline void bar() &#123;</span><br><span class="line">    foo(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// In b.h</span><br><span class="line">namespace ns &#123;&#125;</span><br><span class="line">using namespace ns;</span><br><span class="line"></span><br><span class="line">// In a.cpp</span><br><span class="line">#include &quot;a.h&quot;</span><br><span class="line">#include &quot;b.h&quot;</span><br><span class="line"></span><br><span class="line">void fun1() &#123;</span><br><span class="line">    bar();      // ‘bar’ calls ‘foo(char)’</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// In b.cpp</span><br><span class="line">#include &quot;b.h&quot;</span><br><span class="line">#include &quot;a.h&quot;</span><br><span class="line"></span><br><span class="line">void fun2() &#123;</span><br><span class="line">    bar();      // ‘bar’ calls ‘foo(int)’</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>头文件 a.h 和 b.h 以不同的顺序被包含，使 bar 函数调用了不同的 foo 函数，导致这种混乱的正是 b.h 中的 using directive。<br><br/><br><br/></p>
<h4 id="相关-46"><a href="#相关-46" class="headerlink" title="相关"></a>相关</h4><p>ID_forbidUsingDirectives<br><br/></p>
<h4 id="参考-73"><a href="#参考-73" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines SF.7<br>MISRA C++ 2008 7-3-6<br><br/><br><br/></p>
<h3 id="▌R4-5-头文件中不应使用静态声明"><a href="#▌R4-5-头文件中不应使用静态声明" class="headerlink" title="▌R4.5 头文件中不应使用静态声明"></a><span id="staticinheader">▌R4.5 头文件中不应使用静态声明</span></h3><p>ID_staticInHeader&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: global warning</p>
<hr/>

<p>头文件中由 static 关键字声明的对象、数组或函数，会在每个包含该头文件的翻译单元或模块中生成副本造成数据冗余，如果将静态数据误用作全局数据也会造成逻辑错误。  </p>
<p>类的静态成员不受本规则限制。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// In a header file</span><br><span class="line">static int i = 0;    // Non-compliant</span><br><span class="line"></span><br><span class="line">static int foo() &#123;   // Non-compliant</span><br><span class="line">    return i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在编译每个包含该头文件的源文件时，变量 i 和函数 foo 都会生成不必要的副本。  </p>
<p>在头文件中实现的内联或模板函数中，也不应使用静态声明，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// In a header file</span><br><span class="line">inline void bar() &#123;</span><br><span class="line">    static Type obj;   // Non-compliant</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果该头文件被不同的模块（so、dll、exe）包含，obj 对象会生成不同的副本，很可能造成逻辑错误。  </p>
<p>另外，由 const 或 constexpr 关键字限定的常量也具有静态数据的特性，在头文件中定义常量也面对这种问题，基本类型的常量经过编译优化可以不占用存储空间（有取地址操作的除外），而对于非基本类型的常量对象或数组也不应在头文件中定义，建议采用单件模式，将其数据定义在 cpp 等源文件中，在头文件中定义访问这些数据的接口，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// In arr.h</span><br><span class="line">using Arr = int[256];</span><br><span class="line">const Arr&amp; getArr();</span><br><span class="line"></span><br><span class="line">// In arr.cpp</span><br><span class="line">#include &quot;arr.h&quot;</span><br><span class="line"></span><br><span class="line">const Arr&amp; getArr() &#123;</span><br><span class="line">    static Arr a = &#123;</span><br><span class="line">        1, 2, 3, ....</span><br><span class="line">    &#125;;</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在需要用到常量数组的地方调用 getArr 函数，即可获取该数组的引用，没有任何重复的数据产生，并可保证数组在使用之前被有效初始化。<br><br/><br><br/></p>
<h4 id="相关-47"><a href="#相关-47" class="headerlink" title="相关"></a>相关</h4><p>ID_unsuitableDeclaration<br><br/></p>
<h4 id="依据-49"><a href="#依据-49" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 6.2.2(3)<br>ISO/IEC 9899:2011 6.2.2(3)<br>ISO/IEC 14882:2003 3.5(3)<br>ISO/IEC 14882:2011 3.5(3)<br><br/><br><br/></p>
<h3 id="▌R4-6-头文件中不应定义匿名命名空间"><a href="#▌R4-6-头文件中不应定义匿名命名空间" class="headerlink" title="▌R4.6 头文件中不应定义匿名命名空间"></a><span id="anonymousnamespaceinheader">▌R4.6 头文件中不应定义匿名命名空间</span></h3><p>ID_anonymousNamespaceInHeader&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: global warning</p>
<hr/>

<p>在头文件中定义匿名命名空间相当于在头文件中定义静态数据，头文件被多个源文件包含时会造成数据冗余。  </p>
<p>可参见 ID_staticInHeader 的进一步讨论。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// In a header file</span><br><span class="line">namespace &#123;       // Non-compliant</span><br><span class="line">    void foo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="相关-48"><a href="#相关-48" class="headerlink" title="相关"></a>相关</h4><p>ID_staticInHeader<br>ID_unsuitableDeclaration<br><br/></p>
<h4 id="依据-50"><a href="#依据-50" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 14882:2003 7.3.1.1<br>ISO/IEC 14882:2011 7.3.1.1<br><br/></p>
<h4 id="参考-74"><a href="#参考-74" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines SF.21<br>MISRA C++ 2008 7-3-3<br><br/><br><br/></p>
<h3 id="▌R4-7-匿名命名空间中不应使用静态声明"><a href="#▌R4-7-匿名命名空间中不应使用静态声明" class="headerlink" title="▌R4.7 匿名命名空间中不应使用静态声明"></a><span id="staticinanonymousnamespace">▌R4.7 匿名命名空间中不应使用静态声明</span></h3><p>ID_staticInAnonymousNamespace&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: global warning</p>
<hr/>

<p>匿名命名空间中的元素已具有内部链接性（internal linkage），不应再用 static 关键字限定。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">namespace &#123;</span><br><span class="line">    static int i = 0;   // Non-compliant</span><br><span class="line">    static int foo() &#123;  // Non-compliant</span><br><span class="line">        return i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中 static 关键字是多余的。  </p>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">namespace &#123;</span><br><span class="line">    int i = 0;          // Compliant</span><br><span class="line">    int foo() &#123;         // Compliant</span><br><span class="line">        return i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="依据-51"><a href="#依据-51" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 14882:2011 3.5(4)<br>ISO/IEC 14882:2017 6.5(4)<br><br/><br><br/></p>
<h3 id="▌R4-8-全局对象的初始化不可依赖未初始化的对象"><a href="#▌R4-8-全局对象的初始化不可依赖未初始化的对象" class="headerlink" title="▌R4.8 全局对象的初始化不可依赖未初始化的对象"></a><span id="relyonexternalobject">▌R4.8 全局对象的初始化不可依赖未初始化的对象</span></h3><p>ID_relyOnExternalObject&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: global warning</p>
<hr/>

<p>全局对象的初始化或构造过程不可依赖在其他源文件中定义的全局对象，也不可依赖在其后面定义的对象。  </p>
<p>在不同源文件中定义的全局对象，以及类的静态成员对象，其初始化顺序是不确定的，在同一源文件中定义的对象，排在前面的会先于后面的初始化。为避免产生问题，建议只使用基本类型的常量作为全局对象，且尽量不要使用 extern 关键字。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">extern int i;   // Defined in other translate unit</span><br><span class="line">int j = i;      // Non-compliant</span><br></pre></td></tr></table></figure>
<p>例中 i 是在其他源文件中定义的对象，j 初始化时无法保证 i 已被正确初始化。  </p>
<p>又如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int foo() &#123;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line">extern int x;   // Defined after ‘y’</span><br><span class="line">int y = x;      // Non-compliant, unspecified</span><br><span class="line">int x = foo();</span><br></pre></td></tr></table></figure>
<p>例中 x 在 y 的后面定义，y 会先于 x 初始化，y 的值是 0 还是 foo 函数的返回值在标准中是未声明的。<br><br/><br><br/></p>
<h4 id="依据-52"><a href="#依据-52" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:2011 5.1.2(1)-unspecified<br>ISO/IEC 14882:2011 3.6.2(2)<br>ISO/IEC 14882:2011 3.6.2(3)-unspecified<br>ISO/IEC 14882:2017 6.6.2(3)-unspecified<br>ISO/IEC 14882:2017 6.6.3(2)<br><br/></p>
<h4 id="参考-75"><a href="#参考-75" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines I.22<br><br/><br><br/></p>
<h3 id="▌R4-9-全局对象只应为常量或静态对象"><a href="#▌R4-9-全局对象只应为常量或静态对象" class="headerlink" title="▌R4.9 全局对象只应为常量或静态对象"></a><span id="nonconstnonstaticglobalobject">▌R4.9 全局对象只应为常量或静态对象</span></h3><p>ID_nonConstNonStaticGlobalObject&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: global warning</p>
<hr/>

<p>非常量全局对象破坏了面向对象的封装理念，如果必须使用全局对象，应将其限定在文件范围之内。  </p>
<p>本规则放宽了 ID_nonConstGlobalObject 的要求，对于 C++ 代码不建议选取本规则，对于 C 代码可酌情选取。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// In global scope</span><br><span class="line">int i = 0;          // Non-compliant</span><br><span class="line">static int j = 0;   // Let it go</span><br><span class="line">const int k = 0;    // Compliant</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="相关-49"><a href="#相关-49" class="headerlink" title="相关"></a>相关</h4><p>ID_nonConstGlobalObject<br><br/></p>
<h4 id="参考-76"><a href="#参考-76" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines I.2<br>C++ Core Guidelines CP.3<br>C++ Core Guidelines R.6<br><br/><br><br/></p>
<h3 id="▌R4-10-全局对象只应为常量"><a href="#▌R4-10-全局对象只应为常量" class="headerlink" title="▌R4.10 全局对象只应为常量"></a><span id="nonconstglobalobject">▌R4.10 全局对象只应为常量</span></h3><p>ID_nonConstGlobalObject&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: global warning</p>
<hr/>

<p>非常量全局对象对外部的读写没有限制，破坏了面向对象的封装理念，不利于维护。  </p>
<p>全局对象的初始化顺序和依赖关系也是开发与维护的难点，建议只允许基本类型的常量作为全局对象。  </p>
<p>进一步讨论可参见 ID_nonPrivateData、ID_relyOnExternalObject。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">char foo;               // Non-compliant</span><br><span class="line">extern char bar;        // Non-compliant, worse</span><br><span class="line">const char baz = &#x27;c&#x27;;   // Compliant</span><br><span class="line"></span><br><span class="line">void fun() &#123;</span><br><span class="line">    do_something(foo, bar);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应将全局对象和相关函数封装成类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    char foo;   // Compliant</span><br><span class="line">    char bar;   // Compliant</span><br><span class="line">public:</span><br><span class="line">    void fun() &#123;</span><br><span class="line">        do_something(foo, bar);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果变量 foo、bar 确有全局意义，多个模块都需要访问，不妨将其单件化：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A&amp; getGlobal() &#123;</span><br><span class="line">    static A obj;</span><br><span class="line">    return obj;     // The object must be initialized before returning</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用 getGlobal 函数获取对象，再由其成员函数对数据进行读写，有效实现封装理念，而且可以保证对象在使用之前已被初始化。<br><br/><br><br/></p>
<h4 id="配置-10"><a href="#配置-10" class="headerlink" title="配置"></a>配置</h4><p>onlyConstBasicTypeAllowed：是否只允许基本类型的常量作为全局对象<br><br/></p>
<h4 id="相关-50"><a href="#相关-50" class="headerlink" title="相关"></a>相关</h4><p>ID_nonPrivateData<br>ID_relyOnExternalObject<br><br/></p>
<h4 id="参考-77"><a href="#参考-77" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines I.2<br>C++ Core Guidelines CP.3<br>C++ Core Guidelines R.6<br><br/><br><br/></p>
<h3 id="▌R4-11-全局对象不应同时被-static-和-const-等关键字限定"><a href="#▌R4-11-全局对象不应同时被-static-和-const-等关键字限定" class="headerlink" title="▌R4.11 全局对象不应同时被 static 和 const 等关键字限定"></a><span id="staticandconst">▌R4.11 全局对象不应同时被 static 和 const 等关键字限定</span></h3><p>ID_staticAndConst&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: global warning</p>
<hr/>

<p>在 C++ 语言中，由 const 或 constexpr 关键字限定的全局对象已具有内部链接性（internal linkage），不应再被 static 关键字限定。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static const int i = 123;   // Non-compliant, redundant ‘static’</span><br></pre></td></tr></table></figure>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const int i = 123;   // Compliant</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="相关-51"><a href="#相关-51" class="headerlink" title="相关"></a>相关</h4><p>ID_staticInHeader<br><br/></p>
<h4 id="依据-53"><a href="#依据-53" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 14882:2003 7.1.1(6)<br>ISO/IEC 14882:2011 7.1.1(7)<br><br/><br><br/></p>
<h3 id="▌R4-12-全局及命名空间作用域中禁用-using-directive"><a href="#▌R4-12-全局及命名空间作用域中禁用-using-directive" class="headerlink" title="▌R4.12 全局及命名空间作用域中禁用 using directive"></a><span id="forbidusingdirectives">▌R4.12 全局及命名空间作用域中禁用 using directive</span></h3><p>ID_forbidUsingDirectives&emsp;&emsp;&emsp;&emsp;&nbsp;:no_entry: global suggestion</p>
<hr/>

<p>通过 using directive 将其他命名空间中的名称一并引入当前命名空间，是对命名空间机制的破坏，会造成难以预料的冲突与混乱。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// In global namespace</span><br><span class="line">using namespace std;           // Non-compliant</span><br><span class="line">using namespace myspace;       // Non-compliant</span><br><span class="line"></span><br><span class="line">namespace myspace &#123;</span><br><span class="line">    using namespace hisspace   // Non-compliant</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在函数作用域内可适当放宽要求，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void foo() &#123;</span><br><span class="line">    using namespace myspace;   // Let it go</span><br><span class="line"></span><br><span class="line">    type x;                    // Using myspace::type</span><br><span class="line">    some_fun(x);               // Using mysapce::some_fun</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>建议用 using declaration 代替 using directive：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void foo() &#123;</span><br><span class="line">    using myspace::type;       // Compliant</span><br><span class="line">    using myspace::some_fun;   // Compliant</span><br><span class="line"></span><br><span class="line">    type x;</span><br><span class="line">    some_fun(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="相关-52"><a href="#相关-52" class="headerlink" title="相关"></a>相关</h4><p>ID_usingNamespaceInHeader<br><br/></p>
<h4 id="参考-78"><a href="#参考-78" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines SF.6<br>MISRA C++ 2008 7-3-4<br><br/><br><br/></p>
<h3 id="▌R4-13-避免无效的-using-directive"><a href="#▌R4-13-避免无效的-using-directive" class="headerlink" title="▌R4.13 避免无效的 using directive"></a><span id="usingself">▌R4.13 避免无效的 using directive</span></h3><p>ID_usingSelf&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: global warning</p>
<hr/>

<p>用 using directive 引用当前命名空间属于无效代码，可能意味着某种错误。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">namespace NS</span><br><span class="line">&#123;</span><br><span class="line">    using namespace NS;  // Non-compliant, meaningless</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/><br><br/></p>
<h3 id="▌R4-14-不应定义全局-inline-命名空间"><a href="#▌R4-14-不应定义全局-inline-命名空间" class="headerlink" title="▌R4.14 不应定义全局 inline 命名空间"></a><span id="topinlinenamespace">▌R4.14 不应定义全局 inline 命名空间</span></h3><p>ID_topInlineNamespace&emsp;&emsp;&emsp;&emsp;&nbsp;:bulb: global suggestion</p>
<hr/>

<p>定义全局 inline 命名空间相当于没有命名空间，应在普通命名空间之内使用 inline 命令空间。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">namespace V0 &#123;</span><br><span class="line">    int foo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline namespace V1 &#123;  // Non-compliant</span><br><span class="line">    int foo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应该用普通命名空间加以限定：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">namespace NS</span><br><span class="line">&#123;</span><br><span class="line">    namespace V0 &#123;</span><br><span class="line">        int foo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    inline namespace V1 &#123;  // Compliant</span><br><span class="line">        int foo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/><br><br/></p>
<h3 id="▌R4-15-不可修改-std-命名空间"><a href="#▌R4-15-不可修改-std-命名空间" class="headerlink" title="▌R4.15 不可修改 std 命名空间"></a><span id="stdnamespacemodified">▌R4.15 不可修改 std 命名空间</span></h3><p>ID_stdNamespaceModified&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: global warning</p>
<hr/>

<p>可以为用户定义的类型特化某些标准模板类，除此之外对 std 命名空间添加、修改甚至删除任何代码所导致的后果都是标准未定义的。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class MyType &#123; .... &#125;;</span><br><span class="line"></span><br><span class="line">namespace std</span><br><span class="line">&#123;</span><br><span class="line">    size_t foo(const MyType&amp; x);   // Non-compliant</span><br><span class="line"></span><br><span class="line">    template &lt;&gt;</span><br><span class="line">    struct hash&lt;MyType&gt; &#123;</span><br><span class="line">        size_t operator()(const MyType&amp; x) const &#123;</span><br><span class="line">            return foo(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中对 hash 标准模板类的特化是可被允许的，但在 std 命名空间中添加的 foo 函数是不被允许的。  </p>
<p>应去掉 std 命名空间作用域声明，改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">size_t foo(const MyType&amp; x);   // OK</span><br><span class="line"></span><br><span class="line">template &lt;&gt;</span><br><span class="line">struct std::hash&lt;MyType&gt; &#123;</span><br><span class="line">    size_t operator()(const MyType&amp; x) const &#123;</span><br><span class="line">        return foo(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="依据-54"><a href="#依据-54" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 14882:2011 17.6.4.2.1(1 2)-undefined<br>ISO/IEC 14882:2017 20.5.4.2.1(1 2)-undefined<br><br/></p>
<h4 id="参考-79"><a href="#参考-79" class="headerlink" title="参考"></a>参考</h4><p>SEI CERT DCL58-CPP<br><br/><br><br/></p>
<h2 id="5-Type"><a href="#5-Type" class="headerlink" title="5. Type"></a><span id="type">5. Type</span></h2><h3 id="5-1-Class"><a href="#5-1-Class" class="headerlink" title="5.1 Class"></a><span id="type.class">5.1 Class</span></h3><h3 id="▌R5-1-1-类的非常量数据成员均应为-private"><a href="#▌R5-1-1-类的非常量数据成员均应为-private" class="headerlink" title="▌R5.1.1 类的非常量数据成员均应为 private"></a><span id="nonprivatedata">▌R5.1.1 类的非常量数据成员均应为 private</span></h3><p>ID_nonPrivateData&emsp;&emsp;&emsp;&emsp;&nbsp;:bulb: type suggestion</p>
<hr/>

<p>类的数据成员均应设为 private，对外统一由成员函数提供访问方法，且应避免返回 private 成员的非常量引用或指针。  </p>
<p>将类的所有接口都实现为成员函数，由成员函数按指定逻辑读写数据，以便保证有效地改变对象状态。良好的接口设计会对代码的职责进行合理划分，显著提升可维护性。理想状态下，当有错误需要修正或有功能需要调整时，只改动相关接口的实现即可，调用接口的代码不需要改动，从而将改动降到最低。这种设计的基础便是将数据设为 private，只能由本类的成员函数访问，否则数据可被各个模块随意读写，当有一处需要改动时，很难控制其影响范围。  </p>
<p>常量数据成员不可被改变，所以可不受本规则约束。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct A &#123;</span><br><span class="line">    int *p, n;   // Non-compliant</span><br><span class="line"></span><br><span class="line">    A(int n): p(new int[n]), n(n) &#123;&#125;</span><br><span class="line">   ~A() &#123; delete[] p; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>例中类的数据成员 p 指向动态分配的内存区域，n 记录区域大小，p 和 n 之间存在紧密的逻辑关系，这种内在关系应由成员函数统一维护，不暴露给类的使用者，这便是面向对象的封装理念，也是 C++ 语言的核心理念之一。  </p>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    int *p, n;   // Compliant</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    A(int n): p(new int[n]), n(n) &#123;&#125;</span><br><span class="line">   ~A() &#123; delete[] p; &#125;</span><br><span class="line"></span><br><span class="line">    int* begin() &#123; return p; &#125;     // Interfaces for members</span><br><span class="line">    int* end() &#123; return p + n; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这样数据成员不能被外界直接访问，成员之间的关系也不会被随意打破，显著提升可维护性。<br><br/><br><br/></p>
<h4 id="相关-53"><a href="#相关-53" class="headerlink" title="相关"></a>相关</h4><p>ID_protectedData<br>ID_mixPublicPrivateData<br><br/></p>
<h4 id="参考-80"><a href="#参考-80" class="headerlink" title="参考"></a>参考</h4><p>MISRA C++ 2008 11-0-1<br><br/><br><br/></p>
<h3 id="▌R5-1-2-类的非常量数据成员不应定义为-protected"><a href="#▌R5-1-2-类的非常量数据成员不应定义为-protected" class="headerlink" title="▌R5.1.2 类的非常量数据成员不应定义为 protected"></a><span id="protecteddata">▌R5.1.2 类的非常量数据成员不应定义为 protected</span></h3><p>ID_protectedData&emsp;&emsp;&emsp;&emsp;&nbsp;:bulb: type suggestion</p>
<hr/>

<p>protected 数据成员在派生类中仍可被随意读写，破坏了封装理念。  </p>
<p>本规则是 ID_nonPrivateData 的特化，关于封装的进一步讨论可参见 ID_nonPrivateData。  </p>
<p>常量数据成员不可被改变，所以可不受本规则约束。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    ....</span><br><span class="line">protected:</span><br><span class="line">    int data;   // Non-compliant</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>应改为由接口访问：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    ....</span><br><span class="line">protected:</span><br><span class="line">    int access_data();   // Interfaces for data</span><br><span class="line">private:</span><br><span class="line">    int data;   // Compliant</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="相关-54"><a href="#相关-54" class="headerlink" title="相关"></a>相关</h4><p>ID_mixPublicPrivateData<br>ID_nonPrivateData<br><br/></p>
<h4 id="参考-81"><a href="#参考-81" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines C.9<br>C++ Core Guidelines C.133<br><br/><br><br/></p>
<h3 id="▌R5-1-3-类不应既有-public-数据成员又有-private-数据成员"><a href="#▌R5-1-3-类不应既有-public-数据成员又有-private-数据成员" class="headerlink" title="▌R5.1.3 类不应既有 public 数据成员又有 private 数据成员"></a><span id="mixpublicprivatedata">▌R5.1.3 类不应既有 public 数据成员又有 private 数据成员</span></h3><p>ID_mixPublicPrivateData&emsp;&emsp;&emsp;&emsp;&nbsp;:bulb: type suggestion</p>
<hr/>

<p>类的设计应遵循：  </p>
<ul>
<li>成员之间没有依赖关系，且都可以随意被读写时，则都应声明为 public  </li>
<li>成员之间有依赖关系，或成员的状态会影响到整个对象的状态时，则都应声明为 private  </li>
</ul>
<p>否则应对类进行改造或拆分。  </p>
<p>面向对象的封装理念更倾向于将所有数据成员都设为 private，由成员函数按指定逻辑控制每个成员的读写方法，以供外部访问，对代码的职责进行有效地划分，从而提高可维护性并降低风险，关于封装的进一步讨论可参见 ID_nonPrivateData。  </p>
<p>常量数据成员不可被改变，所以可不受本规则约束。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;  // Non-compliant</span><br><span class="line">public:</span><br><span class="line">    int n;</span><br><span class="line">    ....</span><br><span class="line">private:</span><br><span class="line">    int d;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;  // Compliant</span><br><span class="line">public:</span><br><span class="line">    int method_for_n();</span><br><span class="line">    ....</span><br><span class="line">private:</span><br><span class="line">    int n, d;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="相关-55"><a href="#相关-55" class="headerlink" title="相关"></a>相关</h4><p>ID_nonPrivateData<br>ID_protectedData<br><br/></p>
<h4 id="参考-82"><a href="#参考-82" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines C.9<br>C++ Core Guidelines C.134<br><br/><br><br/></p>
<h3 id="▌R5-1-4-有虚函数的基类应具有虚析构函数"><a href="#▌R5-1-4-有虚函数的基类应具有虚析构函数" class="headerlink" title="▌R5.1.4 有虚函数的基类应具有虚析构函数"></a><span id="missingvirtualdestructor">▌R5.1.4 有虚函数的基类应具有虚析构函数</span></h3><p>ID_missingVirtualDestructor&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: type warning</p>
<hr/>

<p>为了避免意料之外的资源泄漏，有虚函数的基类都应该具有虚析构函数。  </p>
<p>通过基类指针析构派生类对象时，如果基类没有虚析构函数会导致标准未定义的行为，无法正确执行派生类的析构函数。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">public:</span><br><span class="line">    A() = default;</span><br><span class="line">   ~A() = default;          // Non-compliant, missing ‘virtual’</span><br><span class="line">    virtual int foo() = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class B: public A &#123;</span><br><span class="line">    int *m, n;              // New resource</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    B(int s): m(new int[s]), n(s) &#123;&#125;</span><br><span class="line">   ~B() &#123; delete[] m; &#125;</span><br><span class="line">    int foo() override &#123; return n; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A* p = new B(10);</span><br><span class="line">....</span><br><span class="line">delete p;                   // Undefined behavior, may leak</span><br></pre></td></tr></table></figure>
<p>由于基类 A 的析构函数不是虚函数，delete p 只调用了基类析构函数，派生类对象的资源没有得到释放。  </p>
<p>例外：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class C &#123;</span><br><span class="line">    ....</span><br><span class="line">protected:</span><br><span class="line">   ~C();     // Compliant</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果有意阻止外界通过基类指针析构对象，如析构函数是 protected，可不受本规则限制。<br><br/><br><br/></p>
<h4 id="依据-55"><a href="#依据-55" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 14882:2003 5.3.5(3)-undefined<br>ISO/IEC 14882:2003 12.4(7)<br>ISO/IEC 14882:2011 5.3.5(3)-undefined<br>ISO/IEC 14882:2011 12.4(9)<br><br/></p>
<h4 id="参考-83"><a href="#参考-83" class="headerlink" title="参考"></a>参考</h4><p>CWE-1045<br>CWE-1079<br>CWE-1087<br>C++ Core Guidelines C.35<br>C++ Core Guidelines C.127<br><br/><br><br/></p>
<h3 id="▌R5-1-5-避免多重继承自同一非虚基类"><a href="#▌R5-1-5-避免多重继承自同一非虚基类" class="headerlink" title="▌R5.1.5 避免多重继承自同一非虚基类"></a><span id="diamondinheritance">▌R5.1.5 避免多重继承自同一非虚基类</span></h3><p>ID_diamondInheritance&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: type warning</p>
<hr/>

<p>当派生类有多个基类，这些基类又派生自同一非虚基类时，派生类对象会持有该非虚基类的多个实例，造成逻辑和存储上的冗余。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct A &#123;</span><br><span class="line">    int i = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class B: public A &#123;&#125;;</span><br><span class="line">class C: public A &#123;&#125;;</span><br><span class="line">class D: public B, public C &#123;&#125;;   // Non-compliant</span><br><span class="line"></span><br><span class="line">void foo(D&amp; d) &#123;</span><br><span class="line">    d.i = 1;       // Compile error</span><br><span class="line">    d.B::i = 1;    // Odd</span><br><span class="line">    d.C::i = 1;    // Odd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 D 类对象 d 中，基类 A 的成员 i 有两个不同的实例，d 不能直接访问 i，只能通过 d.B::i 或 d.C::i 这种怪异的方式访问。  </p>
<p>将共同的基类设为虚基类可以解决这种问题： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class B: virtual public A &#123;&#125;;</span><br><span class="line">class C: virtual public A &#123;&#125;;</span><br><span class="line">class D: public B, public C &#123;&#125;;   // Compliant</span><br><span class="line"></span><br><span class="line">void foo(D&amp; d) &#123;</span><br><span class="line">    d.i = 1;       // OK</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，直接将虚基类指针转为派生类指针会导致标准未定义的行为，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void bar(A* a) &#123;</span><br><span class="line">    B* p = (B*)a;  // Undefined behavior</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种转换一般不会通过编译，但标准并未要求编译器必须阻止这种转换，改用 dynamic_cast 可解决这些问题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void bar(A* a) &#123;</span><br><span class="line">    B* p = dynamic_cast&lt;B*&gt;(a);  // OK</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="相关-56"><a href="#相关-56" class="headerlink" title="相关"></a>相关</h4><p>ID_diamondExceptionInheritance<br><br/></p>
<h4 id="依据-56"><a href="#依据-56" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 14882:2003 5.2.9(5 8)-undefined<br>ISO/IEC 14882:2003 10.1(4 5 6)<br>ISO/IEC 14882:2011 5.2.9(11 12)-undefined<br>ISO/IEC 14882:2011 10.1(4 5 6 7)<br><br/></p>
<h4 id="参考-84"><a href="#参考-84" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines C.137<br><br/><br><br/></p>
<h3 id="▌R5-1-6-存在析构函数或拷贝赋值运算符时，不应缺少拷贝构造函数"><a href="#▌R5-1-6-存在析构函数或拷贝赋值运算符时，不应缺少拷贝构造函数" class="headerlink" title="▌R5.1.6 存在析构函数或拷贝赋值运算符时，不应缺少拷贝构造函数"></a><span id="missingcopyconstructor">▌R5.1.6 存在析构函数或拷贝赋值运算符时，不应缺少拷贝构造函数</span></h3><p>ID_missingCopyConstructor&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: type warning</p>
<hr/>

<p>三个紧密相关的函数：  </p>
<ol>
<li>拷贝构造函数  </li>
<li>拷贝赋值运算符  </li>
<li>析构函数  </li>
</ol>
<p>当这三个函数中的任何一个函数被定义时，说明对象在资源管理等方面有特定的需求，其他两个函数也需要被定义，否则难以适应各种应用场景，易产生意料之外的错误，这种规则称为“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Rule_of_three_(C%2B%2B_programming">Rule of three</a>)”。  </p>
<p>如果缺少某个函数，编译器会生成相关默认函数，但其特定需求不会被实现。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class A   // Non-compliant</span><br><span class="line">&#123;</span><br><span class="line">    int* p = new int[8];</span><br><span class="line">public:</span><br><span class="line">   ~A() &#123;</span><br><span class="line">        delete[] p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;      // Missing copy constructor and assignment operator</span><br><span class="line"></span><br><span class="line">void foo()</span><br><span class="line">&#123;</span><br><span class="line">    A a;</span><br><span class="line">    A b(a);   // Shallow copy</span><br><span class="line">    ....</span><br><span class="line">&#125;             // Double free</span><br><span class="line"></span><br><span class="line">void bar(A&amp; a, A&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">    a = b;    // Memory leak</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中的类有析构函数，但没有拷贝构造函数和拷贝赋值运算符，只能进行变量值的复制，使多个对象的资源指针指向同一块内存区域，导致重复释放和内存泄漏，所以应定义拷贝构造函数和拷贝赋值运算符重新分配内存并复制数据。  </p>
<p>同理，在遵循 C++11 及之后标准的代码中：  </p>
<ol>
<li>拷贝构造函数  </li>
<li>拷贝赋值运算符  </li>
<li>析构函数  </li>
<li>移动构造函数  </li>
<li>移动赋值运算符  </li>
</ol>
<p>当定义了这五个函数中的任何一个函数时，其他四个函数也需要定义，详见 ID_violateRuleOfFive。<br><br/><br><br/></p>
<h4 id="相关-57"><a href="#相关-57" class="headerlink" title="相关"></a>相关</h4><p>ID_missingDestructor<br>ID_missingCopyAssignOperator<br>ID_violateRuleOfFive<br><br/></p>
<h4 id="参考-85"><a href="#参考-85" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines C.21<br><br/><br><br/></p>
<h3 id="▌R5-1-7-存在拷贝构造函数或析构函数时，不应缺少拷贝赋值运算符"><a href="#▌R5-1-7-存在拷贝构造函数或析构函数时，不应缺少拷贝赋值运算符" class="headerlink" title="▌R5.1.7 存在拷贝构造函数或析构函数时，不应缺少拷贝赋值运算符"></a><span id="missingcopyassignoperator">▌R5.1.7 存在拷贝构造函数或析构函数时，不应缺少拷贝赋值运算符</span></h3><p>ID_missingCopyAssignOperator&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: type warning</p>
<hr/>

<p>三个紧密相关的函数：  </p>
<ol>
<li>拷贝构造函数  </li>
<li>拷贝赋值运算符  </li>
<li>析构函数  </li>
</ol>
<p>当这三个函数中的任何一个函数被定义时，其他两个函数也需要被定义，详见“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Rule_of_three_(C%2B%2B_programming">Rule of three</a>)”。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;  // Non-compliant, missing copy assignment operator</span><br><span class="line">public:</span><br><span class="line">    A();</span><br><span class="line">    A(const A&amp;);</span><br><span class="line">   ~A();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>应明确定义赋值运算符：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;  // Compliant</span><br><span class="line">public:</span><br><span class="line">    A();</span><br><span class="line">    A(const A&amp;);</span><br><span class="line">   ~A();</span><br><span class="line"></span><br><span class="line">    A&amp; operator = (const A&amp;);  // Copy assignment operator</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="相关-58"><a href="#相关-58" class="headerlink" title="相关"></a>相关</h4><p>ID_missingDestructor<br>ID_missingCopyConstructor<br>ID_violateRuleOfFive<br><br/></p>
<h4 id="参考-86"><a href="#参考-86" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines C.21<br><br/><br><br/></p>
<h3 id="▌R5-1-8-存在拷贝构造函数或拷贝赋值运算符时，不应缺少析构函数"><a href="#▌R5-1-8-存在拷贝构造函数或拷贝赋值运算符时，不应缺少析构函数" class="headerlink" title="▌R5.1.8 存在拷贝构造函数或拷贝赋值运算符时，不应缺少析构函数"></a><span id="missingdestructor">▌R5.1.8 存在拷贝构造函数或拷贝赋值运算符时，不应缺少析构函数</span></h3><p>ID_missingDestructor&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: type warning</p>
<hr/>

<p>三个紧密相关的函数：  </p>
<ol>
<li>拷贝构造函数  </li>
<li>拷贝赋值运算符  </li>
<li>析构函数  </li>
</ol>
<p>当这三个函数中的任何一个函数被定义时，其他两个函数也需要被定义，详见“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Rule_of_three_(C%2B%2B_programming">Rule of three</a>)”。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;  // Non-compliant, missing destructor</span><br><span class="line">public:</span><br><span class="line">    A();</span><br><span class="line">    A(const A&amp;);</span><br><span class="line">    A&amp; operator = (const A&amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>应明确定义析构函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;  // Compliant</span><br><span class="line">public:</span><br><span class="line">    A();</span><br><span class="line">    A(const A&amp;);</span><br><span class="line">    A&amp; operator = (const A&amp;);</span><br><span class="line"></span><br><span class="line">   ~A();   // Destructor</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="相关-59"><a href="#相关-59" class="headerlink" title="相关"></a>相关</h4><p>ID_missingCopyConstructor<br>ID_missingCopyAssignOperator<br>ID_violateRuleOfFive<br><br/></p>
<h4 id="参考-87"><a href="#参考-87" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines C.21<br>C++ Core Guidelines C.30<br>C++ Core Guidelines C.33<br><br/><br><br/></p>
<h3 id="▌R5-1-9-存在任一拷贝、移动、析构相关的函数时，应定义所有相关函数"><a href="#▌R5-1-9-存在任一拷贝、移动、析构相关的函数时，应定义所有相关函数" class="headerlink" title="▌R5.1.9 存在任一拷贝、移动、析构相关的函数时，应定义所有相关函数"></a><span id="violateruleoffive">▌R5.1.9 存在任一拷贝、移动、析构相关的函数时，应定义所有相关函数</span></h3><p>ID_violateRuleOfFive&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: type warning</p>
<hr/>

<p>五个紧密相关的函数：  </p>
<ol>
<li>拷贝构造函数  </li>
<li>拷贝赋值运算符  </li>
<li>析构函数  </li>
<li>移动构造函数  </li>
<li>移动赋值运算符  </li>
</ol>
<p>当这五个函数中的任何一个函数被定义时，说明对象在资源管理等方面有特定的需求，其他四个函数也需要被定义，否则难以适应各种应用场景，易产生意料之外的错误，这种规则称为“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Rule_of_three_(C%2B%2B_programming">Rule of five</a>#Rule_of_Five)”。如果缺少某个函数，编译器会生成相关默认函数，但其特定需求不会被实现。  </p>
<p>如果确实不需要某个函数，也应将其明确地设定为 private 或 =delete，如果确实只需要默认处理，应将其声明为 =default，这样可明确对象的行为，规避意料之外的错误。  </p>
<p>本规则适用于遵循 C++11 及之后标准的代码，对于遵循 C++03 及之前标准的代码，本规则特化为 ID_missingCopyConstructor、ID_missingCopyAssignOperator、ID_missingDestructor。  </p>
<p>另外，如果类只负责成员对象的包装或组合而没有特殊的复制、移动、析构需求时，这些函数就都不要定义，参见 ID_violateRuleOfZero。<br><br/><br><br/></p>
<h4 id="相关-60"><a href="#相关-60" class="headerlink" title="相关"></a>相关</h4><p>ID_missingCopyConstructor<br>ID_missingCopyAssignOperator<br>ID_missingDestructor<br>ID_violateRuleOfZero<br><br/></p>
<h4 id="参考-88"><a href="#参考-88" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines C.21<br><br/><br><br/></p>
<h3 id="▌R5-1-10-避免重复实现由默认拷贝、移动、析构函数完成的功能"><a href="#▌R5-1-10-避免重复实现由默认拷贝、移动、析构函数完成的功能" class="headerlink" title="▌R5.1.10 避免重复实现由默认拷贝、移动、析构函数完成的功能"></a><span id="violateruleofzero">▌R5.1.10 避免重复实现由默认拷贝、移动、析构函数完成的功能</span></h3><p>ID_violateRuleOfZero&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: type warning</p>
<hr/>

<p>当类只负责成员对象的包装或组合而没有特殊的复制、移动、析构需求时，不应定义下列函数：  </p>
<ol>
<li>拷贝构造函数  </li>
<li>拷贝赋值运算符  </li>
<li>析构函数  </li>
<li>移动构造函数  </li>
<li>移动赋值运算符  </li>
</ol>
<p>应由编译器生成相关默认函数，否则会产生多余的代码，增加维护成本，这种规则称为“<a target="_blank" rel="noopener" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-zero">Rule of zero</a>”。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    string a, b;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    A(const A&amp; rhs): a(rhs.a), b(rhs.b) &#123;  // Redundant</span><br><span class="line">    &#125;</span><br><span class="line">    A&amp; operator = (const A&amp; rhs) &#123;  // Redundant</span><br><span class="line">        a = rhs.a;</span><br><span class="line">        b = rhs.b;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">   ~A() &#123;  // Redundant</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>例中的类只涉及字符串对象的组合，复制、移动和析构可交由成员对象完成，其拷贝构造函数、赋值运算符以及析构函数是多余的，应该去掉，编译器会进行更好地处理。<br><br/><br><br/></p>
<h4 id="相关-61"><a href="#相关-61" class="headerlink" title="相关"></a>相关</h4><p>ID_violateRuleOfFive<br><br/></p>
<h4 id="参考-89"><a href="#参考-89" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines C.21<br><br/><br><br/></p>
<h3 id="▌R5-1-11-可接受一个参数的构造函数需用-explicit-关键字限定"><a href="#▌R5-1-11-可接受一个参数的构造函数需用-explicit-关键字限定" class="headerlink" title="▌R5.1.11 可接受一个参数的构造函数需用 explicit 关键字限定"></a><span id="missingexplicitconstructor">▌R5.1.11 可接受一个参数的构造函数需用 explicit 关键字限定</span></h3><p>ID_missingExplicitConstructor&emsp;&emsp;&emsp;&emsp;&nbsp;:bulb: type suggestion</p>
<hr/>

<p>为了避免意料之外的类型转换，可接受一个参数的构造函数应该用 explicit 关键字限定。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class String &#123;</span><br><span class="line">public:</span><br><span class="line">    String(int capacity);   // Non-compliant, missing ‘explicit’</span><br><span class="line">    ....</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void foo(const String&amp;);</span><br><span class="line"></span><br><span class="line">int bar() &#123;</span><br><span class="line">    foo(100);   // Can be compiled, but very odd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于 String 类的构造函数接受一个 int 型参数，foo(100) 相当于将 100 隐式转为 String 类的对象，这种隐式转换是怪异的，也往往意味着意料之外的错误。  </p>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class String &#123;</span><br><span class="line">public:</span><br><span class="line">    explicit String(int capacity);   // Compliant</span><br><span class="line">    ....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这样 foo(100) 这种写法便不会通过编译。  </p>
<p>例外：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class String &#123;</span><br><span class="line">public:</span><br><span class="line">    String(const String&amp;);   // Explicit or not depends on your design intent</span><br><span class="line">    String(String&amp;&amp;);        // ditto</span><br><span class="line">    ....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>拷贝、移动构造函数可不受本规则约束，如果将拷贝、移动构造函数声明为 explicit 则无法再按值传递参数或按值返回对象。在类的接口设计中，应尽量减少隐式转换以避免不易察觉的问题。<br><br/><br><br/></p>
<h4 id="相关-62"><a href="#相关-62" class="headerlink" title="相关"></a>相关</h4><p>ID_missingExplicitConvertor<br><br/></p>
<h4 id="参考-90"><a href="#参考-90" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines C.46<br>MISRA C++ 2008 12-1-3<br><br/><br><br/></p>
<h3 id="▌R5-1-12-重载的类型转换运算符需用-explicit-关键字限定"><a href="#▌R5-1-12-重载的类型转换运算符需用-explicit-关键字限定" class="headerlink" title="▌R5.1.12 重载的类型转换运算符需用 explicit 关键字限定"></a><span id="missingexplicitconvertor">▌R5.1.12 重载的类型转换运算符需用 explicit 关键字限定</span></h3><p>ID_missingExplicitConvertor&emsp;&emsp;&emsp;&emsp;&nbsp;:bulb: type suggestion</p>
<hr/>

<p>为了避免意料之外的类型转换，重载的类型转换运算符需用 explicit 关键字限定。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct A &#123;</span><br><span class="line">    ....</span><br><span class="line">    operator char*();   // Non-compliant</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A foo();</span><br><span class="line"></span><br><span class="line">char* bar() &#123;</span><br><span class="line">    return foo();   // Invalid address returned</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中 foo 返回临时对象，类型转换运算符被隐式调用，然而当 bar 返回后，临时对象被销毁，返回的指针是无效的。  </p>
<p>将类型转换运算符用 explicit 关键字限定，有问题的代码便不会通过编译：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct A &#123;</span><br><span class="line">    ....</span><br><span class="line">    explicit operator char*();   // Compliant</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在类的接口设计中，应尽量减少隐式转换以避免不易察觉的问题。<br><br/><br><br/></p>
<h4 id="相关-63"><a href="#相关-63" class="headerlink" title="相关"></a>相关</h4><p>ID_missingExplicitConstructor<br><br/></p>
<h4 id="参考-91"><a href="#参考-91" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines C.164<br><br/><br><br/></p>
<h3 id="▌R5-1-13-不应过度使用-explicit-关键字"><a href="#▌R5-1-13-不应过度使用-explicit-关键字" class="headerlink" title="▌R5.1.13 不应过度使用 explicit 关键字"></a><span id="excessiveexplicit">▌R5.1.13 不应过度使用 explicit 关键字</span></h3><p>ID_excessiveExplicit&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: type warning</p>
<hr/>

<p>对类的拷贝、移动以及不接受 1 个参数的构造函数一般不用 explicit 限定，否则有损代码的易用性和可扩展性。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">public:</span><br><span class="line">    explicit A(const A&amp;);  // In general, ‘explicit’ is not required</span><br><span class="line">    explicit A(A&amp;&amp;);       // Ditto</span><br><span class="line">    explicit A(int, int);  // Ditto</span><br><span class="line">    ....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当类的拷贝、移动构造函数被 explicit 限定时，无法再按值传递参数或按值返回对象，当不接受 1 个参数的构造函数被 explicit 限定时，无法再用初始化列表定义临时对象，如下代码将无法通过编译：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void foo(A);</span><br><span class="line">void bar(const A&amp;);</span><br><span class="line"></span><br><span class="line">A a(1, 2);</span><br><span class="line"></span><br><span class="line">foo(a);       // Compile error</span><br><span class="line">bar(&#123;3, 4&#125;);  // Compile error</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="参考-92"><a href="#参考-92" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines C.46<br><br/><br><br/></p>
<h3 id="▌R5-1-14-带模板的赋值运算符不应与拷贝或移动赋值运算符混淆"><a href="#▌R5-1-14-带模板的赋值运算符不应与拷贝或移动赋值运算符混淆" class="headerlink" title="▌R5.1.14 带模板的赋值运算符不应与拷贝或移动赋值运算符混淆"></a><span id="roughtemplateassignoperator">▌R5.1.14 带模板的赋值运算符不应与拷贝或移动赋值运算符混淆</span></h3><p>ID_roughTemplateAssignOperator&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: type warning</p>
<hr/>

<p>带模板的赋值运算符不应与拷贝或移动赋值运算符混淆，存在带模板的赋值运算符时应明确声明拷贝和移动赋值运算符。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class A   // Non-compliant, missing copy and move assignment operators</span><br><span class="line">&#123;</span><br><span class="line">    int* dat;   // Need deep copy</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    A();</span><br><span class="line">   ~A();</span><br><span class="line">    template &lt;class T&gt;</span><br><span class="line">    A&amp; operator = (const T&amp; a) &#123;   // Not a copy assignment operator</span><br><span class="line">        return do_copy(a.dat);</span><br><span class="line">    &#125;</span><br><span class="line">    template &lt;class T&gt;</span><br><span class="line">    A&amp; operator = (T&amp;&amp; a) &#123;   // Not a move assignment operator</span><br><span class="line">        return do_move(a.dat);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void foo(A&amp; x, A&amp; y)</span><br><span class="line">&#123;</span><br><span class="line">    x = y;   // Not a deep copy</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设例中的类需要深拷贝，标准规定即使带模板的赋值运算符在功能上可以满足拷贝或移动赋值运算符的需求，也不能作为拷贝或移动赋值运算符，故其拷贝和移动赋值运算符仍然是默认的，无法完成深拷贝以及正确的数据移动。  </p>
<p>应明确声明拷贝和移动赋值运算符：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class A   // Compliant</span><br><span class="line">&#123;</span><br><span class="line">    ....</span><br><span class="line">    A&amp; operator = (const A&amp;);</span><br><span class="line">    A&amp; operator = (A&amp;&amp;);  </span><br><span class="line">    ....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="相关-64"><a href="#相关-64" class="headerlink" title="相关"></a>相关</h4><p>ID_roughTemplateConstructor<br><br/></p>
<h4 id="依据-57"><a href="#依据-57" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 14882:2003 12.8(9)<br>ISO/IEC 14882:2011 12.8(17)<br>ISO/IEC 14882:2011 12.8(19)<br><br/></p>
<h4 id="参考-93"><a href="#参考-93" class="headerlink" title="参考"></a>参考</h4><p>MISRA C++ 2008 14-5-3<br><br/><br><br/></p>
<h3 id="▌R5-1-15-带模板的构造函数不应与拷贝或移动构造函数混淆"><a href="#▌R5-1-15-带模板的构造函数不应与拷贝或移动构造函数混淆" class="headerlink" title="▌R5.1.15 带模板的构造函数不应与拷贝或移动构造函数混淆"></a><span id="roughtemplateconstructor">▌R5.1.15 带模板的构造函数不应与拷贝或移动构造函数混淆</span></h3><p>ID_roughTemplateConstructor&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: type warning</p>
<hr/>

<p>带模板的构造函数不应与拷贝或移动构造函数混淆，存在带模板的构造函数时应明确声明拷贝和移动构造函数。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class A   // Non-compliant, missing copy and move constructors</span><br><span class="line">&#123;</span><br><span class="line">    int* dat;   // Need deep copy</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    A();</span><br><span class="line">   ~A();</span><br><span class="line">    template &lt;class T&gt; A(const T&amp; a) &#123;   // Not a copy constructor</span><br><span class="line">        do_copy(a.dat);</span><br><span class="line">    &#125;</span><br><span class="line">    template &lt;class T&gt; A(T&amp;&amp; a) &#123;   // Not a move constructor</span><br><span class="line">        do_move(a.dat);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void foo(A&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">    A y(x);   // Not a deep copy</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设例中的类需要深拷贝，标准规定即使带模板的构造函数在功能上可以满足拷贝或移动构造函数的需求，也不能作为拷贝或移动构造函数，故其拷贝和移动构造函数仍然是默认的，无法完成深拷贝以及正确的数据移动。  </p>
<p>应明确声明拷贝和移动构造函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class A   // Compliant</span><br><span class="line">&#123;</span><br><span class="line">    ....</span><br><span class="line">    A(const A&amp;);</span><br><span class="line">    A(A&amp;&amp;);</span><br><span class="line">    ....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="相关-65"><a href="#相关-65" class="headerlink" title="相关"></a>相关</h4><p>ID_roughTemplateAssignOperator<br><br/></p>
<h4 id="依据-58"><a href="#依据-58" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 14882:2003 12.8(2)<br>ISO/IEC 14882:2011 12.8(2)<br>ISO/IEC 14882:2011 12.8(3)<br><br/></p>
<h4 id="参考-94"><a href="#参考-94" class="headerlink" title="参考"></a>参考</h4><p>MISRA C++ 2008 14-5-2<br><br/><br><br/></p>
<h3 id="▌R5-1-16-抽象类禁用拷贝和移动赋值运算符"><a href="#▌R5-1-16-抽象类禁用拷贝和移动赋值运算符" class="headerlink" title="▌R5.1.16 抽象类禁用拷贝和移动赋值运算符"></a><span id="unsuitableassignoperator">▌R5.1.16 抽象类禁用拷贝和移动赋值运算符</span></h3><p>ID_unsuitableAssignOperator&emsp;&emsp;&emsp;&emsp;&nbsp;:no_entry: type warning</p>
<hr/>

<p>抽象类只能作为基类，没有独立的对象，调用拷贝或移动赋值运算符会造成数据不完整。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct A &#123;</span><br><span class="line">    virtual ~A() = 0;</span><br><span class="line">    A&amp; operator = (const A&amp;);   // Non-compliant</span><br><span class="line">    A&amp; operator = (A&amp;&amp;);        // Non-compliant</span><br><span class="line">    ....</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void foo(A&amp; x, A&amp; y) &#123;</span><br><span class="line">    x = y;               // Incomplete assignment</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中 foo 函数的参数只能是 A 的派生类对象，派生类对象调用基类的拷贝赋值运算符会得到不完整的复制结果。  </p>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct A &#123;</span><br><span class="line">    virtual ~A() = 0;</span><br><span class="line">    A&amp; operator = (const A&amp;) = delete;   // Compliant</span><br><span class="line">    A&amp; operator = (A&amp;&amp;) = delete;        // Compliant</span><br><span class="line">    ....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>将抽象类的拷贝和移动赋值运算符设为 =delete 或 private，可在编译期阻止不完整的复制和移动。<br><br/><br><br/></p>
<h4 id="参考-95"><a href="#参考-95" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines C.67<br>MISRA C++ 2008 12-8-2<br><br/><br><br/></p>
<h3 id="▌R5-1-17-数据成员的数量应在规定范围之内"><a href="#▌R5-1-17-数据成员的数量应在规定范围之内" class="headerlink" title="▌R5.1.17 数据成员的数量应在规定范围之内"></a><span id="toomanyfields">▌R5.1.17 数据成员的数量应在规定范围之内</span></h3><p>ID_tooManyFields&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: type warning</p>
<hr/>

<p>类或联合体的数据成员过多意味着一个逻辑或功能单位承担了过多的职责，违反了模块化设计理念，是难以维护的。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class C</span><br><span class="line">&#123;</span><br><span class="line">    // ... 3000 members ...</span><br><span class="line">    // Who has the courage to read?</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">union U</span><br><span class="line">&#123;</span><br><span class="line">    // ... 3000 members ...</span><br><span class="line">    // Here is hell!</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="配置-11"><a href="#配置-11" class="headerlink" title="配置"></a>配置</h4><p>maxClassFieldsCount：类数据成员的数量上限，超过则报出<br>maxUnionFieldsCount：联合体数据成员的数量上限，超过则报出<br><br/><br><br/></p>
<h3 id="▌R5-1-18-数据成员之间的填充数据不应被忽视"><a href="#▌R5-1-18-数据成员之间的填充数据不应被忽视" class="headerlink" title="▌R5.1.18 数据成员之间的填充数据不应被忽视"></a><span id="ignorepaddingdata">▌R5.1.18 数据成员之间的填充数据不应被忽视</span></h3><p>ID_ignorePaddingData&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: type warning</p>
<hr/>

<p>成员之间存在填充数据，且没有声明对齐方式时，填充数据的长度是由实现定义的，这种数据不应在不同的环境之间传输，而且应注意成员的声明顺序，避免由填充数据造成的空间浪费。  </p>
<p>关于填充数据的具体组织方式，详见“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Data_structure_alignment">内存对齐</a>”。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct T &#123;</span><br><span class="line">    int8_t  a;</span><br><span class="line">    int32_t b;</span><br><span class="line">&#125; obj;</span><br><span class="line"></span><br><span class="line">recv(sockfd, &amp;obj, sizeof obj, flags);   // Non-compliant</span><br></pre></td></tr></table></figure>
<p>例中成员 a 和 b 之间存在填充数据，但没有声明对齐方式，直接在网络上传输这种类型的对象是不符合要求的，如果发送端的对齐方式与接收端不一致就会造成混乱。  </p>
<p>应在发送端和接收端统一声明对齐方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct alignas(4) T &#123;   // Or use _Alignas in C</span><br><span class="line">    int8_t  a;</span><br><span class="line">    int32_t b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意，敏感数据可能会残留在填充数据中，所以当存储或传输对象前有必要清理填充数据的值，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">T obj;</span><br><span class="line">memset(&amp;obj, 0, sizeof(obj));   // Required</span><br><span class="line">....</span><br><span class="line">fwrite(&amp;obj, sizeof(obj), 1, fp);</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="相关-66"><a href="#相关-66" class="headerlink" title="相关"></a>相关</h4><p>ID_accessPaddingData<br><br/></p>
<h4 id="依据-59"><a href="#依据-59" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:2011 6.2.8(1)-implementation<br>ISO/IEC 14882:2011 3.11(1)-implementation<br><br/></p>
<h4 id="参考-96"><a href="#参考-96" class="headerlink" title="参考"></a>参考</h4><p>SEI CERT DCL39-C<br><br/><br><br/></p>
<h3 id="▌R5-1-19-常量成员函数不应返回数据成员的非常量指针或引用"><a href="#▌R5-1-19-常量成员函数不应返回数据成员的非常量指针或引用" class="headerlink" title="▌R5.1.19 常量成员函数不应返回数据成员的非常量指针或引用"></a><span id="returnnonconstdata">▌R5.1.19 常量成员函数不应返回数据成员的非常量指针或引用</span></h3><p>ID_returnNonConstData&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: type warning</p>
<hr/>

<p>如果常量成员函数返回数据成员的非常量指针或引用，既打破了常量限定，又违反了封装理念，属于不良实现方式。  </p>
<p>本规则是 ID_qualifierCastedAway 的特化。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    int&amp; foo() const &#123;</span><br><span class="line">        return (int&amp;)i;   // Non-compliant</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="相关-67"><a href="#相关-67" class="headerlink" title="相关"></a>相关</h4><p>ID_nonPrivateData<br>ID_qualifierCastedAway<br><br/></p>
<h4 id="参考-97"><a href="#参考-97" class="headerlink" title="参考"></a>参考</h4><p>MISRA C++ 2008 9-3-1<br><br/><br><br/></p>
<h3 id="▌R5-1-20-类成员应按-public、protected、private-的顺序声明"><a href="#▌R5-1-20-类成员应按-public、protected、private-的顺序声明" class="headerlink" title="▌R5.1.20 类成员应按 public、protected、private 的顺序声明"></a><span id="accessspecifierdisorder">▌R5.1.20 类成员应按 public、protected、private 的顺序声明</span></h3><p>ID_accessSpecifierDisorder&emsp;&emsp;&emsp;&emsp;&nbsp;:bulb: type suggestion</p>
<hr/>

<p>类成员统一按 public、protected、private 的顺序声明，有利于提高可读性。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class A   // Bad</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    int baz();</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    int foo();</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">    int bar();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>供外部使用的 public 成员应作为重点写在前面，其次是 protected 成员，private 成员应写在最后：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class A   // Good</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int foo();</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">    int bar();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    int baz();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/><br><br/></p>
<h3 id="▌R5-1-21-存在构造、析构或虚函数的类不应采用-struct-关键字"><a href="#▌R5-1-21-存在构造、析构或虚函数的类不应采用-struct-关键字" class="headerlink" title="▌R5.1.21 存在构造、析构或虚函数的类不应采用 struct 关键字"></a><span id="unsuitablestructtag">▌R5.1.21 存在构造、析构或虚函数的类不应采用 struct 关键字</span></h3><p>ID_unsuitableStructTag&emsp;&emsp;&emsp;&emsp;&nbsp;:bulb: type suggestion</p>
<hr/>

<p>简单结构体应采用 struct 关键字，具有封装或多态等特性的类应采用 class 关键字，以便提高可读性。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct A &#123;     // Compliant</span><br><span class="line">    int x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct B &#123;     // Non-compliant</span><br><span class="line">    B();</span><br><span class="line">   ~B();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    int x, y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="参考-98"><a href="#参考-98" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines C.2<br>C++ Core Guidelines C.8<br><br/><br><br/></p>
<h3 id="5-2-Enum"><a href="#5-2-Enum" class="headerlink" title="5.2 Enum"></a><span id="type.enum">5.2 Enum</span></h3><h3 id="▌R5-2-1-同类枚举项的值不应相同"><a href="#▌R5-2-1-同类枚举项的值不应相同" class="headerlink" title="▌R5.2.1 同类枚举项的值不应相同"></a><span id="duplicateenumerator">▌R5.2.1 同类枚举项的值不应相同</span></h3><p>ID_duplicateEnumerator&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: type warning</p>
<hr/>

<p>枚举项用于标记不同的事物，名称不同但值相同的枚举项往往意味着错误。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enum Color &#123;</span><br><span class="line">    red = 1,</span><br><span class="line">    yellow = 2,</span><br><span class="line">    blue = 2,    // Non-compliant, see ‘yellow’</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>例中三个枚举项应分别表示三种颜色，但 blue 与 yellow 的值相同会造成逻辑错误。  </p>
<p>又如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum Fruit &#123;</span><br><span class="line">    apple,</span><br><span class="line">    pear,</span><br><span class="line">    grape,</span><br><span class="line">    favorite = grape,  // Non-compliant</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>例中 Fruit 定义了三种水果，而 favorite 表示最喜欢的水果，与其他枚举项不是同一层面的概念，不应聚为一类。  </p>
<p>应采用更结构化的方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">enum Fruit &#123;</span><br><span class="line">    apple, pear, grape</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Fruit favorite () &#123;</span><br><span class="line">    return grape;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="参考-99"><a href="#参考-99" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines Enum.8<br>MISRA C 2012 8.12<br><br/><br><br/></p>
<h3 id="▌R5-2-2-合理初始化各枚举项"><a href="#▌R5-2-2-合理初始化各枚举项" class="headerlink" title="▌R5.2.2 合理初始化各枚举项"></a><span id="casualinitialization">▌R5.2.2 合理初始化各枚举项</span></h3><p>ID_casualInitialization&emsp;&emsp;&emsp;&emsp;&nbsp;:bulb: type suggestion</p>
<hr/>

<p>合理初始化各枚举项，只应从下列方式中选择一种：   </p>
<ul>
<li>全不初始化  </li>
<li>只初始化第一个  </li>
<li>全部初始化为不同的值  </li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum Color &#123;</span><br><span class="line">    red,</span><br><span class="line">    blue,</span><br><span class="line">    green,</span><br><span class="line">    yellow = 2   // Non-compliant</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum Color &#123;</span><br><span class="line">    red,</span><br><span class="line">    blue,</span><br><span class="line">    green,</span><br><span class="line">    yellow   // Compliant</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="相关-68"><a href="#相关-68" class="headerlink" title="相关"></a>相关</h4><p>ID_duplicateEnumerator<br><br/></p>
<h4 id="参考-100"><a href="#参考-100" class="headerlink" title="参考"></a>参考</h4><p>MISRA C 2004 9.3<br>MISRA C++ 2008 8-5-3<br><br/><br><br/></p>
<h3 id="▌R5-2-3-不应使用匿名枚举声明"><a href="#▌R5-2-3-不应使用匿名枚举声明" class="headerlink" title="▌R5.2.3 不应使用匿名枚举声明"></a><span id="forbidunnamedenum">▌R5.2.3 不应使用匿名枚举声明</span></h3><p>ID_forbidUnnamedEnum&emsp;&emsp;&emsp;&emsp;&nbsp;:no_entry: type suggestion</p>
<hr/>

<p>匿名枚举声明相当于在当前作用域定义常量，但类型不够明确。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enum &#123; rabbit = 0xAA, carrot = 1234 &#125;;  // Non-compliant</span><br></pre></td></tr></table></figure>
<p>如果无法确定枚举类型的名称，也意味着各枚举项不应聚为一类。  </p>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const int rabbit = 0xAA;  // Compliant</span><br><span class="line">const int carrot = 1234;  // Compliant</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="参考-101"><a href="#参考-101" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines Enum.6<br><br/><br><br/></p>
<h3 id="▌R5-2-4-用-enum-class-取代-enum"><a href="#▌R5-2-4-用-enum-class-取代-enum" class="headerlink" title="▌R5.2.4 用 enum class 取代 enum"></a><span id="forbidunscopedenum">▌R5.2.4 用 enum class 取代 enum</span></h3><p>ID_forbidUnscopedEnum&emsp;&emsp;&emsp;&emsp;&nbsp;:no_entry: type suggestion</p>
<hr/>

<p>传统 C 枚举没有有效的类型和作用域控制，极易造成类型混淆和名称冲突，在 C++ 代码中建议改用 enum class。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">enum E &#123;      // Non-compliant</span><br><span class="line">    e0 = 0,</span><br><span class="line">    e1 = 1,</span><br><span class="line">    e2 = -1</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">E foo();</span><br><span class="line"></span><br><span class="line">void bar() &#123;</span><br><span class="line">    if (foo()) &#123;   // ‘e1’ or ‘e2’??</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>传统 C 枚举值与 int 等类型可以随意转换，如果 e0 和 e2 表示某种错误情况，e1 表示正确情况，那么 bar 函数中对 foo 返回值的判断就是错误的，这也是一种常见问题，C++11 提出了 enum class 的概念加强了类型检查，提倡在新项目中尽量使用 enum class。  </p>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">enum class E &#123;   // Compliant</span><br><span class="line">    e0 = 0,</span><br><span class="line">    e1 = 1,</span><br><span class="line">    e2 = -1</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void bar() &#123;</span><br><span class="line">    if (foo() == E::e1) &#123;   // OK</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">    if (foo()) &#123;   // Compile error, cannot cast the enum class casually</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="依据-60"><a href="#依据-60" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 14882:2011 7.2(2)<br>ISO/IEC 14882:2017 10.2(2)<br><br/></p>
<h4 id="参考-102"><a href="#参考-102" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines Enum.3<br><br/><br><br/></p>
<h3 id="5-3-Union"><a href="#5-3-Union" class="headerlink" title="5.3 Union"></a><span id="type.union">5.3 Union</span></h3><h3 id="▌R5-3-1-联合体内禁用非基本类型的对象"><a href="#▌R5-3-1-联合体内禁用非基本类型的对象" class="headerlink" title="▌R5.3.1 联合体内禁用非基本类型的对象"></a><span id="forbidnonbasicfield">▌R5.3.1 联合体内禁用非基本类型的对象</span></h3><p>ID_forbidNonBasicField&emsp;&emsp;&emsp;&emsp;&nbsp;:no_entry: type warning</p>
<hr/>

<p>因为联合体成员之间共享内存地址，所以成员具有构造或析构函数时会导致混乱。  </p>
<p>C++98/03 禁止具有拷贝构造函数或析构函数的对象出现在联合体中，C++11 解除了这条禁令，但在语言层面上不保障正确性，相当于把问题抛给了用户。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">union U &#123;</span><br><span class="line">    int i;</span><br><span class="line">    string s;  // Non-compliant</span><br><span class="line"></span><br><span class="line">    U(int x): i(x) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    U(const char* x) &#123;</span><br><span class="line">        new(&amp;s) string(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   ~U() &#123;</span><br><span class="line">        s.~string();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">U u(1);</span><br><span class="line">u.s = &quot;abc&quot;;  // No error, no warning, just crash</span><br></pre></td></tr></table></figure>
<p>示例代码在某些环境中会崩溃，原因是没能正确区分对象当前持有的类型，执行了错误的构造或析构过程。  </p>
<p>正确的做法是在类中用一个成员变量记录当前持有的类型，再将匿名联合体与类的构造函数以及析构函数相关联，从而根据当前持有的类型正确地初始化或销毁对象。<br><br/><br><br/></p>
<h4 id="依据-61"><a href="#依据-61" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 14882:1998 9.5(1)<br>ISO/IEC 14882:2003 9.5(1)<br>ISO/IEC 14882:2011 9.5(2 3 4)<br><br/><br><br/></p>
<h3 id="▌R5-3-2-禁用在类之外定义的联合体"><a href="#▌R5-3-2-禁用在类之外定义的联合体" class="headerlink" title="▌R5.3.2 禁用在类之外定义的联合体"></a><span id="forbidnakedunion">▌R5.3.2 禁用在类之外定义的联合体</span></h3><p>ID_forbidNakedUnion&emsp;&emsp;&emsp;&emsp;&nbsp;:no_entry: type suggestion</p>
<hr/>

<p>联合体各成员共享存储地址，易引发意料之外的错误。如果一定要使用联合体，需对其进行一定的封装，避免对成员的错误访问。  </p>
<p>不应出现：  </p>
<ul>
<li>在命名空间作用域内定义的联合体  </li>
<li>在类中定义的具有 public 访问权限的联合体  </li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">union U &#123;      // Non-compliant, global union</span><br><span class="line">    ....</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class A &#123;</span><br><span class="line">public:</span><br><span class="line">    union &#123;    // Non-compliant, public union</span><br><span class="line">        ....</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class B &#123;</span><br><span class="line">public:</span><br><span class="line">    ....       // Interfaces about the union</span><br><span class="line">private:</span><br><span class="line">    union &#123;    // Compliant, the union is under control</span><br><span class="line">        ....</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>类的 public 数据成员本来就违反了封装原则，如果这种数据成员又处于联合体中，会进一步增加风险。<br><br/><br><br/></p>
<h4 id="相关-69"><a href="#相关-69" class="headerlink" title="相关"></a>相关</h4><p>ID_forbidUnion<br><br/></p>
<h4 id="参考-103"><a href="#参考-103" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines C.181<br>MISRA C 2004 18.4<br>MISRA C 2012 19.2<br>MISRA C++ 2008 9-5-1<br><br/><br><br/></p>
<h3 id="▌R5-3-3-禁用联合体"><a href="#▌R5-3-3-禁用联合体" class="headerlink" title="▌R5.3.3 禁用联合体"></a><span id="forbidunion">▌R5.3.3 禁用联合体</span></h3><p>ID_forbidUnion&emsp;&emsp;&emsp;&emsp;&nbsp;:no_entry: type suggestion</p>
<hr/>

<p>联合体的问题主要有：  </p>
<ul>
<li>无法只通过对象获取当前有效的成员  </li>
<li>访问不同的成员相当于不安全的类型转换  </li>
<li>对非基本类型的成员造成构造和析构的混乱  </li>
<li>不能作为基类  </li>
</ul>
<p>这些问题在本质上是对类型理念的破坏，面向对象的程序设计应避免使用联合体。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">union U &#123;    // Non-compliant</span><br><span class="line">    int i;</span><br><span class="line">    char c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">U u;</span><br><span class="line">u.i = 1000;</span><br><span class="line">cout &lt;&lt; u.c &lt;&lt; &#x27;\n&#x27;;   // Equivalent to a cast without any restrictions</span><br></pre></td></tr></table></figure>
<p>例中对 u.c 的访问也相当于一种没有任何限制的类型转换。  </p>
<p>在 C++ 代码中建议用 std::variant 或 std::any 取代联合体：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::variant&lt;int, char&gt; u;</span><br><span class="line">u = 1000;</span><br><span class="line">cout &lt;&lt; get&lt;int&gt;(u) &lt;&lt; &#x27;\n&#x27;;    // OK</span><br><span class="line">cout &lt;&lt; get&lt;char&gt;(u) &lt;&lt; &#x27;\n&#x27;;   // Throw ‘std::bad_variant_access’</span><br></pre></td></tr></table></figure>
<p>std::variant 可以有效记录对象当前持有的类型，如果以不正确的类型访问对象会及时抛出异常。  </p>
<p>本规则比 ID_forbidNakedUnion 更严格，针对所有联合体。<br><br/><br><br/></p>
<h4 id="相关-70"><a href="#相关-70" class="headerlink" title="相关"></a>相关</h4><p>ID_forbidNakedUnion<br><br/></p>
<h4 id="参考-104"><a href="#参考-104" class="headerlink" title="参考"></a>参考</h4><p>MISRA C 2004 18.4<br>MISRA C 2012 19.2<br>MISRA C++ 2008 9-5-1<br><br/><br><br/></p>
<h2 id="6-Declaration"><a href="#6-Declaration" class="headerlink" title="6. Declaration"></a><span id="declaration">6. Declaration</span></h2><h3 id="6-1-Naming"><a href="#6-1-Naming" class="headerlink" title="6.1 Naming"></a><span id="declaration.naming">6.1 Naming</span></h3><h3 id="▌R6-1-1-遵循合理的命名方式"><a href="#▌R6-1-1-遵循合理的命名方式" class="headerlink" title="▌R6.1.1 遵循合理的命名方式"></a><span id="badname">▌R6.1.1 遵循合理的命名方式</span></h3><p>ID_badName&emsp;&emsp;&emsp;&emsp;&nbsp;:bulb: declaration suggestion</p>
<hr/>

<p>应遵循易于读写，并可准确表达代码意图的命名方式。  </p>
<p>不应出现下列情况：  </p>
<ul>
<li>超长的名称  </li>
<li>易造成混淆或冲突的名称  </li>
<li>无意义或意义过于空泛的名称  </li>
<li>不易于读写的名称  </li>
<li>有违公序良俗的名称  </li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int xxx(int);   // Bad, meaningless name</span><br><span class="line"></span><br><span class="line">int fun(int);   // Bad, vague name</span><br><span class="line"></span><br><span class="line">int l, I, O, l0, Il;   // Bad, like numbers</span><br><span class="line"></span><br><span class="line">int YE5, N0;   // Bad, like a word but not</span><br><span class="line"></span><br><span class="line">int \u540d\u79f0;   // Bad, no readability</span><br><span class="line"></span><br><span class="line">int nVarietyisthespiceoflife = 123;   // Bad, hard to read or write</span><br></pre></td></tr></table></figure>
<p>例中 xxx、fun 这种无意义或意义过于空泛的名称，以及 l、lI、N0 这种易与数字或其他单词混淆的名称均是不符合要求的；Unicode 转义名称只应出现在字符串中，否则没有可读性；名称中各单词间应有下划线或大小写变化，否则不便于读写。本规则集合示例中出现的 foo、bar 等名称，意在代指一般的代码元素，仅作示例，实际代码中不应出现。  </p>
<p>不良命名方式甚至会导致标准未定义的行为，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">extern int identifier_of_a_very_very_long_name_1;</span><br><span class="line">extern int identifier_of_a_very_very_long_name_2;   // Dangerous</span><br></pre></td></tr></table></figure>
<p>注意，如果两个名称有相同的前缀，而且相同前缀超过一定长度时是危险的，有可能会导致编译器无法有效区分相关名称。C 标准指明，保证名称前 31 位不同即可避免这种问题，可参见 ISO/IEC 9899:2011 5.2.4.1 的相关规定。  </p>
<p>不建议采用相同“长前缀”+ 不同“短后缀”的命名方式，这种名称非常容易形成笔误或由复制粘贴造成错误，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct BinExpr &#123;</span><br><span class="line">    BinExpr* sub0;   // Bad</span><br><span class="line">    BinExpr* sub1;   // Bad</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>设 BinExpr 是“二元表达式”类，sub0、sub1 为左右子表达式，这种命名方式应改进：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct BinExpr &#123;</span><br><span class="line">    BinExpr* left;   // Better</span><br><span class="line">    BinExpr* right;  // Better</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="配置-12"><a href="#配置-12" class="headerlink" title="配置"></a>配置</h4><p>maxObjNameLength：对象名称长度上限，超过则报出<br>maxFunNameLength：函数名称长度上限，超过则报出<br>maxTypeNameLength：类型名称长度上限，超过则报出<br>maxWordLength：连续无大小写变化的字符数量上限，超过则报出<br><br/></p>
<h4 id="依据-62"><a href="#依据-62" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 5.2.4.1(1)<br>ISO/IEC 9899:1999 6.4.2.1(6)-undefined<br>ISO/IEC 9899:2011 5.2.4.1(1)<br>ISO/IEC 9899:2011 6.4.2.1(6)-undefined<br><br/></p>
<h4 id="参考-105"><a href="#参考-105" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines NL.19<br>C++ Core Guidelines ES.8<br>MISRA C 2004 5.1<br>MISRA C 2012 5.1<br>MISRA C 2012 5.2<br>MISRA C 2012 5.4<br>MISRA C 2012 5.5<br>MISRA C++ 2008 2-10-1<br><br/><br><br/></p>
<h3 id="▌R6-1-2-不应定义具有保留意义的名称"><a href="#▌R6-1-2-不应定义具有保留意义的名称" class="headerlink" title="▌R6.1.2 不应定义具有保留意义的名称"></a><span id="reservedname">▌R6.1.2 不应定义具有保留意义的名称</span></h3><p>ID_reservedName&emsp;&emsp;&emsp;&emsp;&nbsp;:bulb: declaration suggestion</p>
<hr/>

<p>自定义的名称不应与标准库或编译环境中的名称相同，否则会导致标准未定义的行为，也不利于阅读和维护。  </p>
<p>下列名称具有保留意义，自定义名称不应与之相同：  </p>
<ul>
<li>标准库或编译环境中的宏名称  </li>
<li>标准库中具有外部链接性的对象或函数名称  </li>
<li>标准库中的类型名称  </li>
</ul>
<p>自定义字面常量后缀应以下划线开头，否则为保留名称，除此之外：  </p>
<ul>
<li>以两个下划线开头的名称  </li>
<li>以一个下划线和一个大写字母开头的名称  </li>
<li>以下划线开头的全局名称  </li>
</ul>
<p>均具有保留意义，自定义名称应避免这种命名方式。  </p>
<p>对于宏，本规则特化为 ID_macro_defineReserved、ID_macro_undefReserved。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;errno.h&gt;</span><br><span class="line"></span><br><span class="line">struct A &#123;</span><br><span class="line">    void foo() &#123;</span><br><span class="line">        if (errno != 0) &#123;  // Which errno?</span><br><span class="line">            ....</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    int errno;  // Non-compliant</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>例中成员变量 errno 与标准库中的 errno 名称相同，不便于区分是自定义的还是系统定义的。  </p>
<p>又如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">size_t _Size();   // Non-compliant</span><br><span class="line"></span><br><span class="line">size_t operator &quot;&quot; KB(unsigned long long n) &#123;   // Non-compliant</span><br><span class="line">    return n * 1024;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中函数名 _Size 以一个下划线和一个大写字母开头，自定义字面常量后缀 KB 未以下划线开头，均不符合要求。  </p>
<p>为避免冲突和误解，以下命名方式可供参考：  </p>
<ul>
<li>除自定义字面常量后缀之外，避免名称以下划线开头  </li>
<li>无命名空间限制的全局名称以模块名称开头  </li>
<li>从名称上体现作用域，如全局对象名以 g_ 开头，成员对象名以 m_ 开头或以 _ 结尾  </li>
<li>从名称上体现类别，如宏名采用全大写字母，类型名以大写字母开头，函数或对象名以小写字母开头  </li>
</ul>
<p>本规则集合对具体的命名方式暂不作量化要求，但读者应具备相关意识。<br><br/><br><br/></p>
<h4 id="相关-71"><a href="#相关-71" class="headerlink" title="相关"></a>相关</h4><p>ID_macro_defineReserved<br>ID_macro_undefReserved<br><br/></p>
<h4 id="依据-63"><a href="#依据-63" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 7.1.3(1)<br>ISO/IEC 9899:2011 7.1.3(1)<br>ISO/IEC 14882:2003 17.4.3.1<br>ISO/IEC 14882:2011 17.6.4.3<br>ISO/IEC 14882:2017 20.5.4.3<br><br/></p>
<h4 id="参考-106"><a href="#参考-106" class="headerlink" title="参考"></a>参考</h4><p>MISRA C 2012 21.2<br>MISRA C++ 2008 17-0-1<br>MISRA C++ 2008 17-0-2<br>MISRA C++ 2008 17-0-3<br>SEI CERT DCL37-C<br>SEI CERT DCL51-CPP<br><br/><br><br/></p>
<h3 id="▌R6-1-3-局部名称不应被覆盖"><a href="#▌R6-1-3-局部名称不应被覆盖" class="headerlink" title="▌R6.1.3 局部名称不应被覆盖"></a><span id="hidelocal">▌R6.1.3 局部名称不应被覆盖</span></h3><p>ID_hideLocal&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: declaration warning</p>
<hr/>

<p>不应在嵌套的作用域中声明相同的名称，否则干扰阅读，极易引起误解。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int foo() &#123;</span><br><span class="line">    int i = 0;       // Declares an object ‘i’</span><br><span class="line">    if (cond) &#123;</span><br><span class="line">        int i = 1;   // Non-compliant, hides previous ‘i’</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">    return i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在一个函数中出现了多个名为 i 的变量，当实际代码较为复杂时，很容易出现意图与实现不符的问题。<br><br/><br><br/></p>
<h4 id="参考-107"><a href="#参考-107" class="headerlink" title="参考"></a>参考</h4><p>CWE-1109<br>C++ Core Guidelines ES.12<br>MISRA C 2004 5.2<br>MISRA C 2012 5.3<br>MISRA C++ 2008 2-10-2<br><br/><br><br/></p>
<h3 id="▌R6-1-4-成员名称不应被覆盖"><a href="#▌R6-1-4-成员名称不应被覆盖" class="headerlink" title="▌R6.1.4 成员名称不应被覆盖"></a><span id="hidemember">▌R6.1.4 成员名称不应被覆盖</span></h3><p>ID_hideMember&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: declaration warning</p>
<hr/>

<p>成员函数内的局部名称与成员名称相同会干扰阅读，易引起误解。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    int i = 0;          // Member object ‘i’</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    int foo() &#123;</span><br><span class="line">        int i = 0;      // Non-compliant, hides the member ‘i’</span><br><span class="line">        return bar(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int bar(int i) &#123;    // Non-compliant, hides the member ‘i’</span><br><span class="line">        return i + i;   // Which ‘i’ is used?</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>建议成员对象遵循统一的命名约定，如以“_”结尾或以“m_”开头，可有效规避这类问题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    int i_ = 0;         // Member object ‘i_’</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    int foo() &#123;</span><br><span class="line">        int i = 0;      // Compliant</span><br><span class="line">        return bar(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int bar(int i) &#123;    // Compliant</span><br><span class="line">        return i_ + i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="参考-108"><a href="#参考-108" class="headerlink" title="参考"></a>参考</h4><p>CWE-1109<br>MISRA C 2004 5.2<br>MISRA C 2012 5.3<br>MISRA C++ 2008 2-10-2<br><br/><br><br/></p>
<h3 id="▌R6-1-5-全局名称不应被覆盖"><a href="#▌R6-1-5-全局名称不应被覆盖" class="headerlink" title="▌R6.1.5 全局名称不应被覆盖"></a><span id="hideglobal">▌R6.1.5 全局名称不应被覆盖</span></h3><p>ID_hideGlobal&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: declaration warning</p>
<hr/>

<p>局部、成员名称不应与全局或命名空间内的名称相同，否则干扰阅读，易引起误解。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">extern int i;</span><br><span class="line"></span><br><span class="line">void foo() &#123;</span><br><span class="line">    int i = 0;      // Non-compliant, hides the global ‘i’</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class A &#123;</span><br><span class="line">    int i;          // Non-compliant, hides the global ‘i’</span><br><span class="line">public:</span><br><span class="line">    int bar() &#123;</span><br><span class="line">        return i;   // Which ‘i’?</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>建议全局对象遵循统一的命名约定，如以“g_”开头，且名称长度不宜过短，可有效规避这类问题。  </p>
<p>例外：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">extern int i;</span><br><span class="line"></span><br><span class="line">struct S &#123;</span><br><span class="line">    int i;   // Compliant</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>无成员函数的结构体或联合体成员可不受本规则限制。<br><br/><br><br/></p>
<h4 id="参考-109"><a href="#参考-109" class="headerlink" title="参考"></a>参考</h4><p>CWE-1109<br>MISRA C 2004 5.2<br>MISRA C 2012 5.3<br>MISRA C++ 2008 2-10-2<br><br/><br><br/></p>
<h3 id="▌R6-1-6-类型名称不应重复定义"><a href="#▌R6-1-6-类型名称不应重复定义" class="headerlink" title="▌R6.1.6 类型名称不应重复定义"></a><span id="duplicatedtypename">▌R6.1.6 类型名称不应重复定义</span></h3><p>ID_duplicatedTypeName&emsp;&emsp;&emsp;&emsp;&nbsp;:bulb: declaration suggestion</p>
<hr/>

<p>如果类型相关的名称有重复，极易引起误解，不利于阅读和维护，对于：  </p>
<ul>
<li>C++ 类、联合体、枚举类型的名称  </li>
<li>C 结构体、联合体、枚举类型的标签名称  </li>
<li>用 typedef 或 using 定义的类型别名  </li>
</ul>
<p>均不应重复定义。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typedef double A;</span><br><span class="line"></span><br><span class="line">void foo() &#123;</span><br><span class="line">    typedef float A;   // Non-compliant</span><br><span class="line">    typedef short B;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void bar() &#123;</span><br><span class="line">    typedef short B;   // Non-compliant, even if they are identical</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例外：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">namespace N &#123;</span><br><span class="line">    typedef double A;</span><br><span class="line">&#125;</span><br><span class="line">namespace M &#123;</span><br><span class="line">    typedef float A;   // Compliant</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果类型定义处于不同的命名空间，可不受本规则约束。<br><br/><br><br/></p>
<h4 id="参考-110"><a href="#参考-110" class="headerlink" title="参考"></a>参考</h4><p>MISRA C 2004 5.3<br>MISRA C 2004 5.4<br>MISRA C 2012 5.6<br>MISRA C 2012 5.7<br>MISRA C++ 2008 2-10-3<br>MISRA C++ 2008 2-10-4<br><br/><br><br/></p>
<h3 id="▌R6-1-7-类型名称不应与对象或函数名称相同"><a href="#▌R6-1-7-类型名称不应与对象或函数名称相同" class="headerlink" title="▌R6.1.7 类型名称不应与对象或函数名称相同"></a><span id="duplicatedname">▌R6.1.7 类型名称不应与对象或函数名称相同</span></h3><p>ID_duplicatedName&emsp;&emsp;&emsp;&emsp;&nbsp;:bulb: declaration suggestion</p>
<hr/>

<p>不同的代码元素使用相同的名称不利于阅读和维护。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct A &#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">enum &#123;</span><br><span class="line">    A, B, C   // Non-compliant</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">size_t x = sizeof(A);   // Which ‘A’?</span><br></pre></td></tr></table></figure>
<p>例中结构体名称 A 与枚举项 A 重名，sizeof(A) 的意义是非常令人困惑的。<br><br/><br><br/></p>
<h4 id="参考-111"><a href="#参考-111" class="headerlink" title="参考"></a>参考</h4><p>MISRA C++ 2008 2-10-6<br><br/><br><br/></p>
<h3 id="▌R6-1-8-不应存在拼写错误"><a href="#▌R6-1-8-不应存在拼写错误" class="headerlink" title="▌R6.1.8 不应存在拼写错误"></a><span id="misspelling">▌R6.1.8 不应存在拼写错误</span></h3><p>ID_misspelling&emsp;&emsp;&emsp;&emsp;&nbsp;:bulb: declaration suggestion</p>
<hr/>

<p>代码中不应存在拼写错误，尤其是供他人调用的代码，如命名空间名称、公共接口名称等，更不应存在拼写错误。  </p>
<p>拼写错误会使用户对代码的质量产生疑虑，而且相关代码被大量引用后也不便于改正。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void destory() = 0;  // Non-compliant, should be ‘destroy’</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>例中“destory”函数的名称有拼写错误，应改为“destroy”。<br><br/><br><br/><br><br/></p>
<h3 id="6-2-Qualifier"><a href="#6-2-Qualifier" class="headerlink" title="6.2 Qualifier"></a><span id="declaration.qualifier">6.2 Qualifier</span></h3><h3 id="▌R6-2-1-const、volatile-不应重复"><a href="#▌R6-2-1-const、volatile-不应重复" class="headerlink" title="▌R6.2.1 const、volatile 不应重复"></a><span id="qualifierrepeated">▌R6.2.1 const、volatile 不应重复</span></h3><p>ID_qualifierRepeated&emsp;&emsp;&emsp;&emsp;&nbsp;:boom: declaration error</p>
<hr/>

<p>重复的 const 或 volatile 限定符是没意义的，很可能意味着某种错误。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const const char* p0 = &quot;....&quot;;   // Non-compliant</span><br><span class="line">const char const* p1 = &quot;....&quot;;   // Non-compliant</span><br><span class="line">char* const const p2 = &quot;....&quot;;   // Non-compliant</span><br></pre></td></tr></table></figure>
<p>对于 p0 和 p1，const 重复限定 char，其中一个 const 很可能是为了限定 * 号，但形成了笔误，应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const char * const p0 = &quot;....&quot;;  // Compliant</span><br><span class="line">const char * const p1 = &quot;....&quot;;  // Compliant</span><br></pre></td></tr></table></figure>
<p>对于 p2，const 重复限定 * 号，其中一个 const 很可能是为了限定 char，应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const char * const p2 = &quot;....&quot;;  // Compliant</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="相关-72"><a href="#相关-72" class="headerlink" title="相关"></a>相关</h4><p>ID_badQualifierPosition<br><br/><br><br/></p>
<h3 id="▌R6-2-2-const、volatile-限定指针类型的别名是可疑的"><a href="#▌R6-2-2-const、volatile-限定指针类型的别名是可疑的" class="headerlink" title="▌R6.2.2 const、volatile 限定指针类型的别名是可疑的"></a><span id="qualifierforptralias">▌R6.2.2 const、volatile 限定指针类型的别名是可疑的</span></h3><p>ID_qualifierForPtrAlias&emsp;&emsp;&emsp;&emsp;&nbsp;:question: declaration suspicious</p>
<hr/>

<p>如果用 const、volatile 限定指针类型的别名，很可能会造成意料之外的错误。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct Type &#123;</span><br><span class="line">    void foo();</span><br><span class="line">    void foo() const;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef Type* Alias;</span><br><span class="line"></span><br><span class="line">void bar(const Alias a) &#123;  // Rather suspicious</span><br><span class="line">    a-&gt;foo();              // Calls ‘void Type::foo();’</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中 Alias 是 Type* 的别名，“const Alias a”很容易引起误解，好像对象是不可被改变的，但实际上 a 的类型是 Type *const，const 限定的是指针而不是指针指向的对象，对象仍可被修改，其调用的函数也可能与预期不符。  </p>
<p>应避免为指针类型定义别名，否则应提供常量和非常量两种别名，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef Type* Alias;</span><br><span class="line">typedef const Type* ConstAlias;</span><br><span class="line"></span><br><span class="line">void bar(ConstAlias a) &#123;</span><br><span class="line">    a-&gt;foo();              // Calls ‘void Type::foo() const;’</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，如果用 const、volatile 限定引用的别名则是错误的，详见 ID_qualifierInvalid。<br><br/><br><br/></p>
<h4 id="相关-73"><a href="#相关-73" class="headerlink" title="相关"></a>相关</h4><p>ID_qualifierInvalid<br><br/></p>
<h4 id="参考-112"><a href="#参考-112" class="headerlink" title="参考"></a>参考</h4><p>SEI CERT DCL05-C<br><br/><br><br/></p>
<h3 id="▌R6-2-3-const、volatile-不可限定引用"><a href="#▌R6-2-3-const、volatile-不可限定引用" class="headerlink" title="▌R6.2.3 const、volatile 不可限定引用"></a><span id="qualifierinvalid">▌R6.2.3 const、volatile 不可限定引用</span></h3><p>ID_qualifierInvalid&emsp;&emsp;&emsp;&emsp;&nbsp;:boom: declaration error</p>
<hr/>

<p>在 C++ 语言中，const 或 volatile 可以限定指针，但不可限定引用，否则起不到任何作用。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a = 0;</span><br><span class="line">int &amp;const i = a;     // Non-compliant</span><br><span class="line">int &amp;volatile j = a;  // Non-compliant</span><br></pre></td></tr></table></figure>
<p>限定 &amp; 号的 const 和 volatile 是无效的，i 可被随意修改，j 也可能被优化。  </p>
<p>应去掉限定符，或使限定符作用于类型名称：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const int&amp; i = a;     // Compliant</span><br><span class="line">volatile int&amp; j = a;  // Compliant</span><br></pre></td></tr></table></figure>
<p>注意，如果限定符作用于引用类型的别名，会引起很大误解，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typedef int&amp; int_r;   // Reference type alias, bad</span><br><span class="line">const int_r r0 = a;   // Non-compliant, r0 is not a const-reference at all</span><br><span class="line">const int_r&amp; r1 = a;  // Non-compliant, r1 is not a const-reference at all</span><br></pre></td></tr></table></figure>
<p>例中 r0 像是一个常量对象，而 r1 像是常量对象的引用，但 const int_r 展开后相当于 int &amp; const，r0 不是常量，r1 也不是常量的引用。<br><br/><br><br/></p>
<h4 id="依据-64"><a href="#依据-64" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 14882:2003 8.3.2(1)<br>ISO/IEC 14882:2011 8.3.2(1)<br>ISO/IEC 14882:2017 11.3.2(1)<br><br/><br><br/></p>
<h3 id="▌R6-2-4-const、volatile-限定类型时的位置应统一"><a href="#▌R6-2-4-const、volatile-限定类型时的位置应统一" class="headerlink" title="▌R6.2.4 const、volatile 限定类型时的位置应统一"></a><span id="badqualifierposition">▌R6.2.4 const、volatile 限定类型时的位置应统一</span></h3><p>ID_badQualifierPosition&emsp;&emsp;&emsp;&emsp;&nbsp;:bulb: declaration suggestion</p>
<hr/>

<p>语言允许 const、volatile 等关键字出现在类型名称的左侧，也可以出现在其右侧，甚至可以出现在基本类型名称的中间，应对其位置进行统一规范以提高可读性。  </p>
<p>可从下列方案中选择一种作为规范，即统一要求 const、volatile：  </p>
<ol>
<li>出现在类型名称的左侧  </li>
<li>出现在类型名称的右侧  </li>
<li>出现在指针类型名称的右侧，非指针类型名称的左侧  </li>
</ol>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Non-compliant, inconsistent positions of cv-qualifiers</span><br><span class="line">const long long i = 0;</span><br><span class="line">unsigned int const j = 0;</span><br><span class="line">const int volatile k = 0;</span><br></pre></td></tr></table></figure>
<p>例中 const、volatile 的位置不统一是不符合要求的。  </p>
<p>const、volatile 出现在类型名称右侧时，和 * 号一起易被误用，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char const const * p = &quot;....&quot;;   // Wrong, redundant const-qualifiers</span><br><span class="line">char const * const q = &quot;....&quot;;   // Right</span><br></pre></td></tr></table></figure>
<p>const、volatile 出现在类型名称左侧时，如果类型为指针类型，则易引起误解，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typedef int* ptr;</span><br><span class="line">const ptr cp = &amp;x;</span><br><span class="line">*cp = 1;             // Looks a bit strange</span><br></pre></td></tr></table></figure>
<p>可参见 ID_qualifierForPtrAlias 的进一步讨论。  </p>
<p>如果约定 const、volatile 出现左侧表示类型为对象类型，右侧表示类型为指针类型，有助于提高可读性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef int obj;</span><br><span class="line">typedef int* ptr;</span><br><span class="line"></span><br><span class="line">const obj i = 0;    // Indicates that ‘obj’ is an object type</span><br><span class="line">ptr const p = &amp;x;   // Indicates that ‘ptr’ is a pointer type</span><br></pre></td></tr></table></figure>
<p>审计工具不妨通过配置决定具体检查方案。<br><br/><br><br/></p>
<h4 id="配置-13"><a href="#配置-13" class="headerlink" title="配置"></a>配置</h4><p>positionScheme：const、volatile 的位置方案，对应说明中的 1、2、3 号方案<br>volatileInFront：volatile 是否应写在 const 的前面，如果值为 false 则应写在后面，不设此项则不考虑相关顺序<br><br/></p>
<h4 id="相关-74"><a href="#相关-74" class="headerlink" title="相关"></a>相关</h4><p>ID_sandwichedModifier<br>ID_badSpecifierPosition<br><br/></p>
<h4 id="依据-65"><a href="#依据-65" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 6.7(1)<br>ISO/IEC 9899:1999 6.7.2(1)<br>ISO/IEC 9899:2011 6.7(1)<br>ISO/IEC 9899:2011 6.7.2(1)<br>ISO/IEC 14882:2003 A.6<br>ISO/IEC 14882:2011 A.6<br><br/></p>
<h4 id="参考-113"><a href="#参考-113" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines NL.26<br><br/><br><br/></p>
<h3 id="▌R6-2-5-const、volatile-等关键字不应出现在基本类型名称的中间"><a href="#▌R6-2-5-const、volatile-等关键字不应出现在基本类型名称的中间" class="headerlink" title="▌R6.2.5 const、volatile 等关键字不应出现在基本类型名称的中间"></a><span id="sandwichedmodifier">▌R6.2.5 const、volatile 等关键字不应出现在基本类型名称的中间</span></h3><p>ID_sandwichedModifier&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: declaration warning</p>
<hr/>

<p>某些基本类型名称可由多个符号组成，const、volatile 等关键字不应出现在类型名称的中间，否则可读性较差。  </p>
<p>本规则对下列 C 或 C++ 关键字有同样的要求：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const、volatile、</span><br><span class="line">inline、virtual、explicit、</span><br><span class="line">register、static、thread_local、extern、mutable、</span><br><span class="line">friend、typedef、constexpr、</span><br><span class="line">_Alignas、_Atomic、_Noreturn、_Thread_local</span><br></pre></td></tr></table></figure>
<p>即使对这些关键字的位置不作统一要求，也不应使其出现在类型名称的中间，否则很容易引起误解。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const long volatile long cvll = 0;    // Non-compliant</span><br><span class="line">long const double volatile cvld = 0;  // Non-compliant</span><br></pre></td></tr></table></figure>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const volatile long long cvll = 0;    // Compliant</span><br><span class="line">const volatile long double cvld = 0;  // Compliant</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="相关-75"><a href="#相关-75" class="headerlink" title="相关"></a>相关</h4><p>ID_badQualifierPosition<br>ID_badSpecifierPosition<br><br/></p>
<h4 id="依据-66"><a href="#依据-66" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 6.7(1)<br>ISO/IEC 9899:1999 6.7.2(1)<br>ISO/IEC 9899:2011 6.7(1)<br>ISO/IEC 9899:2011 6.7.2(1)<br>ISO/IEC 14882:2003 A.6<br>ISO/IEC 14882:2011 A.6<br><br/></p>
<h4 id="参考-114"><a href="#参考-114" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines NL.26<br><br/><br><br/></p>
<h3 id="▌R6-2-6-指向常量字符串的指针应使用-const-声明"><a href="#▌R6-2-6-指向常量字符串的指针应使用-const-声明" class="headerlink" title="▌R6.2.6 指向常量字符串的指针应使用 const 声明"></a><span id="conststrtononconstptr">▌R6.2.6 指向常量字符串的指针应使用 const 声明</span></h3><p>ID_constStrToNonConstPtr&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: declaration warning</p>
<hr/>

<p>常量字符串与非常量字符串指针的隐式转换是不安全的，一旦相关内存被修改会导致标准未定义的行为，这种转换在 C++ 标准中是过时的，在 C 代码中也不应出现。  </p>
<p>指向常量字符串的指针应声明为 const chartype *，chartype 为常量字符串中的字符类型，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char、wchar_t、char16_t、char32_t</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char* p = &quot;....&quot;;   // Non-compliant</span><br><span class="line">p[x] = &#x27;\0&#x27;;        // Undefined behavior</span><br></pre></td></tr></table></figure>
<p>例中非常量指针 p 指向常量字符串，通过 p 修改常量数据一般会引发“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Segmentation_fault">段错误</a>”而导致崩溃，应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const char* p = &quot;....&quot;;   // Compliant</span><br><span class="line">p[x] = &#x27;\0&#x27;;              // Compile-time protected</span><br></pre></td></tr></table></figure>
<p>改为常量字符串指针后，错误的操作无法通过编译。  </p>
<p>又如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void foo(char*);</span><br><span class="line"></span><br><span class="line">void bar() &#123;</span><br><span class="line">    foo(&quot;....&quot;);   // Non-compliant</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应将 foo 的参数类型改为 const char*，或将常量字符串复制后传给 foo 函数。<br><br/><br><br/></p>
<h4 id="相关-76"><a href="#相关-76" class="headerlink" title="相关"></a>相关</h4><p>ID_nonConstUnmodified<br><br/></p>
<h4 id="依据-67"><a href="#依据-67" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 6.4.5(6)-undefined<br>ISO/IEC 9899:2011 6.4.5(7)-undefined<br>ISO/IEC 14882:1998 D.4(1)-deprecated<br>ISO/IEC 14882:2003 2.13.4(2)-undefined<br>ISO/IEC 14882:2003 D.4(1)-deprecated<br>ISO/IEC 14882:2011 2.14.5(12)-undefined<br>ISO/IEC 14882:2017 5.13.5(16)-undefined<br><br/></p>
<h4 id="参考-115"><a href="#参考-115" class="headerlink" title="参考"></a>参考</h4><p>MISRA C 2012 7.4<br><br/><br><br/></p>
<h3 id="▌R6-2-7-枚举类型的底层类型不应为-const-或-volatile"><a href="#▌R6-2-7-枚举类型的底层类型不应为-const-或-volatile" class="headerlink" title="▌R6.2.7 枚举类型的底层类型不应为 const 或 volatile"></a><span id="uselessqualifier">▌R6.2.7 枚举类型的底层类型不应为 const 或 volatile</span></h3><p>ID_uselessQualifier&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: declaration warning</p>
<hr/>

<p>将 enum 或 enum class 的底层类型（underlying type）设为 const 或 volatile 是没有意义的，会被编译器忽略，属于语言运用错误。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enum E: const unsigned int  // Non-compliant, ‘const’ is invalid</span><br><span class="line">&#123;</span><br><span class="line">    e0, e1, e2</span><br><span class="line">&#125;;</span><br><span class="line">E e = e0;  // ‘e’ is not const</span><br></pre></td></tr></table></figure>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enum E: unsigned int  // Compliant</span><br><span class="line">&#123;</span><br><span class="line">    e0, e1, e2</span><br><span class="line">&#125;;</span><br><span class="line">const E e = e0;  // OK, ‘e’ is const</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="依据-68"><a href="#依据-68" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 14882:2011 7.2(2)<br>ISO/IEC 14882:2011 10.2(2)<br><br/><br><br/></p>
<h3 id="▌R6-2-8-对常量的定义不应为引用"><a href="#▌R6-2-8-对常量的定义不应为引用" class="headerlink" title="▌R6.2.8 对常量的定义不应为引用"></a><span id="constliteralreference">▌R6.2.8 对常量的定义不应为引用</span></h3><p>ID_constLiteralReference&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: declaration warning</p>
<hr/>

<p>虽然 C++ 语言十分灵活，可以通过多种方式达到同一种目的，但应该选择最简洁且通俗易懂的方式实现。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const int&amp; i = 1024;   // Non-compliant</span><br><span class="line">const int&amp;&amp; j = 1024;  // Non-compliant</span><br></pre></td></tr></table></figure>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const int i = 1024;  // Compliant</span><br><span class="line">const int j = 1024;  // Compliant</span><br></pre></td></tr></table></figure>
<p><br/><br><br/><br><br/></p>
<h3 id="▌R6-2-9-禁用-restrict-指针"><a href="#▌R6-2-9-禁用-restrict-指针" class="headerlink" title="▌R6.2.9 禁用 restrict 指针"></a><span id="forbidrestrictptr">▌R6.2.9 禁用 restrict 指针</span></h3><p>ID_forbidRestrictPtr&emsp;&emsp;&emsp;&emsp;&nbsp;:no_entry: declaration warning</p>
<hr/>

<p>C 语言中的 restrict 指针要求其他指针不能再指向相同区域，有助于编译器优化，但不符合这种限制时会导致标准未定义的行为，相当于增加了误用风险，也增加了测试成本。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void foo(int c[]) &#123;</span><br><span class="line">    int *restrict a = &amp;c[0];   // Non-compliant</span><br><span class="line">    int *restrict b = &amp;c[1];   // Non-compliant</span><br><span class="line">    ....</span><br><span class="line">    a = b;                     // Undefined behavior</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int bar(int *restrict x, int *restrict y) &#123;   // Non-compliant</span><br><span class="line">    return *x + *y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int baz(int* p) &#123;</span><br><span class="line">    return bar(p, p);   // Undefined behavior</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>restrict 指针虽然有助于编译器优化，但应在效率的提高和存在的风险之间进行取舍，非系统库中的代码、改动频繁的代码不建议使用 restrict 指针，而且这种优化大部分情况下也难以真正解决效率的瓶颈问题。<br><br/><br><br/></p>
<h4 id="依据-69"><a href="#依据-69" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 6.7.3.1(4 9 11)-undefined<br>ISO/IEC 9899:2011 6.7.3.1(4 9 11)-undefined<br><br/></p>
<h4 id="参考-116"><a href="#参考-116" class="headerlink" title="参考"></a>参考</h4><p>MISRA C 2012 8.14<br>SEI CERT EXP43-C<br><br/><br><br/></p>
<h3 id="▌R6-2-10-非适当场景禁用-volatile"><a href="#▌R6-2-10-非适当场景禁用-volatile" class="headerlink" title="▌R6.2.10 非适当场景禁用 volatile"></a><span id="forbidvolatile">▌R6.2.10 非适当场景禁用 volatile</span></h3><p>ID_forbidVolatile&emsp;&emsp;&emsp;&emsp;&nbsp;:no_entry: declaration suggestion</p>
<hr/>

<p>应在适当的场景中合理使用 volatile，否则会导致优化或同步相关的多种问题。  </p>
<p>下列场景可使用 volatile：  </p>
<ul>
<li>对象读写对应外设 IO  </li>
<li>与信号等中断处理过程共享对象  </li>
<li>局部对象在 setjmp、longjmp 之间被修改  </li>
<li>出于安全目的清理内存中的数据  </li>
<li>在 C/C++ 之外，通过与编译优化不兼容的方式访问对象  </li>
</ul>
<p>在这些场景中，如果相关对象没有用 volatile 限定会导致程序和预期不符，volatile 关键字可以保证对象具有稳定的内存地址，任何读取或写入都可以来源于或作用于内存中的实际数据。  </p>
<p>除此之外不应使用 volatile，不参与过程间跳转的局部 volatile 对象往往意味着 volatile 的滥用，审计工具不妨重点关注这种对象，而且要注意 volatile 和 C/C++ 的并发或同步机制没有直接关系，也无法保证相关操作的原子性。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">volatile int x;  // Non-compliant, ‘volatile’ is abused</span><br><span class="line"></span><br><span class="line">void thd() &#123;</span><br><span class="line">    LockGuard g;</span><br><span class="line">    read_and_write(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中 x 是不涉及外设的共享对象，thd 是线程函数，LockGuard 是某种 RAII 锁，在已落实同步机制的情况下，不应再使用 volatile。<br><br/><br><br/></p>
<h4 id="依据-70"><a href="#依据-70" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 6.7.3(6)<br>ISO/IEC 9899:2011 6.7.3(7)<br>ISO/IEC 14882:2003 7.1.5.1(8)<br>ISO/IEC 14882:2011 7.1.6.1(7)<br><br/></p>
<h4 id="参考-117"><a href="#参考-117" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines CP.8<br>C++ Core Guidelines CP.200<br><br/><br><br/></p>
<h3 id="▌R6-2-11-相关对象未被修改时应使用-const-声明"><a href="#▌R6-2-11-相关对象未被修改时应使用-const-声明" class="headerlink" title="▌R6.2.11 相关对象未被修改时应使用 const 声明"></a><span id="nonconstunmodified">▌R6.2.11 相关对象未被修改时应使用 const 声明</span></h3><p>ID_nonConstUnmodified&emsp;&emsp;&emsp;&emsp;&nbsp;:bulb: declaration suggestion</p>
<hr/>

<p>用 const 显式区分数据是只读的还是可写的，细化数据的访问方式可显著提高可读性，并保护数据不被错误修改，有助于编译器优化。  </p>
<p>下列情况应使用 const 声明：  </p>
<ul>
<li>不需要被修改的非参数对象应声明为常量对象  </li>
<li>通过指针或引用访问对象但不修改对象时，应声明为常量指针或引用  </li>
<li>成员函数访问非静态成员对象但不修改相关对象时，应声明为常量成员函数  </li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">double pi = 3.14;   // Non-compliant</span><br><span class="line"></span><br><span class="line">class Circle &#123;</span><br><span class="line">    double r;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    Circle(double);</span><br><span class="line">    Circle(Circle&amp;) = default;   // Non-compliant</span><br><span class="line"></span><br><span class="line">    double area() &#123;              // Non-compliant</span><br><span class="line">        return pi * r * r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>例中 pi 未被修改，应作为常量；拷贝构造函数的参数未被修改，应声明为常量引用；成员函数 area 未修改成员对象，应声明为常量成员函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const double pi = 3.14;   // Compliant</span><br><span class="line"></span><br><span class="line">class Circle &#123;</span><br><span class="line">    ....</span><br><span class="line">    Circle(const Circle&amp;) = default;   // Compliant</span><br><span class="line"></span><br><span class="line">    double area() const &#123;              // Compliant</span><br><span class="line">        return pi * r * r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="相关-77"><a href="#相关-77" class="headerlink" title="相关"></a>相关</h4><p>ID_constStrToNonConstPtr<br><br/></p>
<h4 id="参考-118"><a href="#参考-118" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines Con.1<br>C++ Core Guidelines Con.2<br>C++ Core Guidelines Con.3<br>C++ Core Guidelines Con.4<br>MISRA C 2012 18.3<br>MISRA C++ 2008 7-1-1<br>MISRA C++ 2008 7-1-2<br><br/><br><br/></p>
<h3 id="6-3-Specifier"><a href="#6-3-Specifier" class="headerlink" title="6.3 Specifier"></a><span id="declaration.specifier">6.3 Specifier</span></h3><h3 id="▌R6-3-1-合理使用-auto-关键字"><a href="#▌R6-3-1-合理使用-auto-关键字" class="headerlink" title="▌R6.3.1 合理使用 auto 关键字"></a><span id="abusedauto">▌R6.3.1 合理使用 auto 关键字</span></h3><p>ID_abusedAuto&emsp;&emsp;&emsp;&emsp;&nbsp;:bulb: declaration suggestion</p>
<hr/>

<p>auto 关键字隐藏了类型名称，在使用时需注意不应降低可读性。  </p>
<p>非局部对象不宜用 auto 声明，如接口的返回类型、参数、全局对象等。如果局部对象的类型对程序的行为有显著影响，也不宜用 auto 声明。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">auto foo() &#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">auto bar() &#123;</span><br><span class="line">    auto x = foo();</span><br><span class="line">    ....</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">auto obj = bar();  // What the hell is ‘obj’??</span><br></pre></td></tr></table></figure>
<p>如果想确定 obj 对象的类型，必须通读所有与之相关的代码，可读性很差。  </p>
<p>将代码中所有可以替换成 auto 的标识符全部替换成 auto，其结果是不可想象的，与 Python 等语言不同，C++ 语言存在重载、模板等多种严格依赖于类型的特性，如果类型名称不明确，必然会造成阅读和维护等方面的障碍。  </p>
<p>下面给出 auto 关键字的合理用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Type* a = static_cast&lt;Type*&gt;(ptr);               // Repeated type name</span><br><span class="line">unique_ptr&lt;Type[]&gt; b = make_unique&lt;Type[]&gt;(10);  // Repeated type name</span><br></pre></td></tr></table></figure>
<p>重复的类型名称使代码变得繁琐，这种情况使用 auto 是更好的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto* a = static_cast&lt;Type*&gt;(ptr);  // OK</span><br><span class="line">auto b = make_unique&lt;Type[]&gt;(10);   // OK</span><br></pre></td></tr></table></figure>
<p>又如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;Type&gt; v&#123; .... &#125;;</span><br><span class="line">vector&lt;Type&gt;::iterator i = v.begin();  // Verbose</span><br></pre></td></tr></table></figure>
<p>begin 函数返回迭代器是一种常识，且迭代器类型名称往往较长，这种情况应使用 auto：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto i = v.begin();  // OK</span><br></pre></td></tr></table></figure>
<p>又如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct SomeClass &#123;</span><br><span class="line">    struct Sub &#123;</span><br><span class="line">        ....</span><br><span class="line">    &#125;;</span><br><span class="line">    Sub foo();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SomeClass::Sub SomeClass::foo() &#123;  // Repeated ‘SomeClass’</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重复的类作用域声明十分繁琐，可用 auto 关键字配合后置返回类型改善：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auto SomeClass::foo() -&gt; Sub &#123;  // OK</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总之，使用 auto 关键字的目的应是提高可读性，而不是单纯地简化代码。<br><br/><br><br/></p>
<h4 id="相关-78"><a href="#相关-78" class="headerlink" title="相关"></a>相关</h4><p>ID_roughAuto<br><br/></p>
<h4 id="参考-119"><a href="#参考-119" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines ES.11<br><br/><br><br/></p>
<h3 id="▌R6-3-2-不应使用已过时的关键字"><a href="#▌R6-3-2-不应使用已过时的关键字" class="headerlink" title="▌R6.3.2 不应使用已过时的关键字"></a><span id="deprecatedspecifier">▌R6.3.2 不应使用已过时的关键字</span></h3><p>ID_deprecatedSpecifier&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: declaration warning</p>
<hr/>

<p>在 C++11 标准中，register 关键字已过时，auto 关键字也不可再作为“<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/storage_duration">存储类说明符（storage class specifier）</a>”。  </p>
<p>本规则对 C++ 代码适用，C 代码可不受限制。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">register int a;            // Non-compliant</span><br><span class="line">auto int b;                // Non-compliant</span><br><span class="line">int foo(register int x);   // Non-compliant</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="依据-71"><a href="#依据-71" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 14882:2011 7.1.6.4(3)<br>ISO/IEC 14882:2011 D.2(1)-deprecated<br><br/><br><br/></p>
<h3 id="▌R6-3-3-不应使用多余的-inline-关键字"><a href="#▌R6-3-3-不应使用多余的-inline-关键字" class="headerlink" title="▌R6.3.3 不应使用多余的 inline 关键字"></a><span id="inlineredundant">▌R6.3.3 不应使用多余的 inline 关键字</span></h3><p>ID_inlineRedundant&emsp;&emsp;&emsp;&emsp;&nbsp;:bulb: declaration suggestion</p>
<hr/>

<p>由 constexpr 关键字限定的函数已经相当于被声明为 inline，不应再重复声明。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">inline constexpr int foo(int n) &#123;  // Non-compliant, ‘inline’ is redundant</span><br><span class="line">    return n + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">constexpr int foo(int n) &#123;  // Compliant</span><br><span class="line">    return n + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外，在类声明中实现的函数也相当于被声明为 inline，不应重复声明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    ....</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    inline int foo() &#123;  // Non-compliant, ‘inline’ is redundant</span><br><span class="line">        return 123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int bar() &#123;         // Compliant</span><br><span class="line">        return 456;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="依据-72"><a href="#依据-72" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 14882:2003 7.1.2(3)<br>ISO/IEC 14882:2011 7.1.2(3)<br>ISO/IEC 14882:2011 7.1.5(2)<br><br/><br><br/></p>
<h3 id="▌R6-3-4-extern-关键字不应作用于类成员的声明或定义"><a href="#▌R6-3-4-extern-关键字不应作用于类成员的声明或定义" class="headerlink" title="▌R6.3.4 extern 关键字不应作用于类成员的声明或定义"></a><span id="invalidexternspecifier">▌R6.3.4 extern 关键字不应作用于类成员的声明或定义</span></h3><p>ID_invalidExternSpecifier&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: declaration warning</p>
<hr/>

<p>extern 关键字作用于类成员的声明或定义是没有意义的，属于语言运用错误。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    void foo();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">extern void A::foo() &#123;  // Non-compliant, invalid ‘extern’</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="依据-73"><a href="#依据-73" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 14882:2003 9.2(6)<br>ISO/IEC 14882:2011 9.2(6)<br>ISO/IEC 14882:2017 12.2(9)<br><br/><br><br/></p>
<h3 id="▌R6-3-5-重写的虚函数应声明为-override-或-final"><a href="#▌R6-3-5-重写的虚函数应声明为-override-或-final" class="headerlink" title="▌R6.3.5 重写的虚函数应声明为 override 或 final"></a><span id="missingexplicitoverride">▌R6.3.5 重写的虚函数应声明为 override 或 final</span></h3><p>ID_missingExplicitOverride&emsp;&emsp;&emsp;&emsp;&nbsp;:bulb: declaration suggestion</p>
<hr/>

<p>将重写的虚函数都声明为 override 或 final 有利于提高可读性，并可确保虚函数被有效重写。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    virtual int foo();</span><br><span class="line">    virtual int bar();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class B: public A &#123;</span><br><span class="line">    int foo();          // Non-compliant</span><br><span class="line">    virtual int bar();  // Non-compliant</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>例中 B 重写 A 的 foo 和 bar 这两个虚函数，如果不看 A 的声明，则看不出 B::foo 是虚函数，也看不出 B::bar 是重写的虚函数。  </p>
<p>改为如下方式会清晰很多：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class B: public A &#123;</span><br><span class="line">    int foo() override;  // Compliant</span><br><span class="line">    int bar() override;  // Compliant</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>而且当重写的函数名、参数、返回类型与基类声明不符时，不能通过编译，可及时修正问题。<br><br/><br><br/></p>
<h4 id="依据-74"><a href="#依据-74" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 14882:2011 10.3(4 5)<br>ISO/IEC 14882:2017 13.3(4 5)<br><br/></p>
<h4 id="参考-120"><a href="#参考-120" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines C.128<br><br/><br><br/></p>
<h3 id="▌R6-3-6-override-和-final-关键字不应同时出现在声明中"><a href="#▌R6-3-6-override-和-final-关键字不应同时出现在声明中" class="headerlink" title="▌R6.3.6 override 和 final 关键字不应同时出现在声明中"></a><span id="redundantoverride">▌R6.3.6 override 和 final 关键字不应同时出现在声明中</span></h3><p>ID_redundantOverride&emsp;&emsp;&emsp;&emsp;&nbsp;:bulb: declaration suggestion</p>
<hr/>

<p>final 表示不可重写的重写，override 表示可再次重写的重写，这两个关键字不应同时出现在声明中。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class D: public B &#123;</span><br><span class="line">public:</span><br><span class="line">    int foo() override final;  // Non-compliant, ‘override’ is redundant</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="参考-121"><a href="#参考-121" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines C.128<br><br/><br><br/></p>
<h3 id="▌R6-3-7-override-或-final-关键字不应与-virtual-关键字同时出现在声明中"><a href="#▌R6-3-7-override-或-final-关键字不应与-virtual-关键字同时出现在声明中" class="headerlink" title="▌R6.3.7 override 或 final 关键字不应与 virtual 关键字同时出现在声明中"></a><span id="redundantvirtual">▌R6.3.7 override 或 final 关键字不应与 virtual 关键字同时出现在声明中</span></h3><p>ID_redundantVirtual&emsp;&emsp;&emsp;&emsp;&nbsp;:bulb: declaration suggestion</p>
<hr/>

<p>只应在定义新的虚函数时使用 virtual 关键字，重写虚函数应使用 override 或 final 关键字，不应再出现 virtual 关键字。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual int foo();   // Compliant, a new virtual function</span><br><span class="line">    virtual int bar();   // Compliant, a new virtual function</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class B: public A &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual int foo() final;     // Non-compliant, ‘virtual’ is redundant</span><br><span class="line">    virtual int bar() override;  // Non-compliant, ‘virtual’ is redundant</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>去掉多余的 virtual 关键字使代码更简洁：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class B: public A &#123;</span><br><span class="line">public:</span><br><span class="line">    int foo() final;     // Compliant</span><br><span class="line">    int bar() override;  // Compliant</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="参考-122"><a href="#参考-122" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines C.128<br><br/><br><br/></p>
<h3 id="▌R6-3-8-不应将-union-设为-final"><a href="#▌R6-3-8-不应将-union-设为-final" class="headerlink" title="▌R6.3.8 不应将 union 设为 final"></a><span id="invalidfinal">▌R6.3.8 不应将 union 设为 final</span></h3><p>ID_invalidFinal&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: declaration warning</p>
<hr/>

<p>在 C++ 语言中，union 不可作为基类，将 union 声明为 final 是没有意义的，属于语言运用错误。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">union U final  // Non-compliant, meaningless</span><br><span class="line">&#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="依据-75"><a href="#依据-75" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 14882:2011 9.5(2)<br>ISO/IEC 14882:2017 12.3(3)<br><br/><br><br/></p>
<h3 id="▌R6-3-9-未访问-this-指针的成员函数应使用-static-声明"><a href="#▌R6-3-9-未访问-this-指针的成员函数应使用-static-声明" class="headerlink" title="▌R6.3.9 未访问 this 指针的成员函数应使用 static 声明"></a><span id="this_notused">▌R6.3.9 未访问 this 指针的成员函数应使用 static 声明</span></h3><p>ID_this_notUsed&emsp;&emsp;&emsp;&emsp;&nbsp;:bulb: declaration suggestion</p>
<hr/>

<p>如果未访问 this 指针的成员函数没有被设计为静态成员函数，很可能意味着错误或功能不完整。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    static int s;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    static int bar() &#123;   // Compliant</span><br><span class="line">        return s--;</span><br><span class="line">    &#125;</span><br><span class="line">    int foo() &#123;          // Non-compliant, missing ‘static’</span><br><span class="line">        return s++;</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>例中 foo 函数只访问了静态数据成员，但在调用时仍会将 this 指针作为参数，这在逻辑上是矛盾的，所以应使用 static 关键字明确声明。<br><br/><br><br/></p>
<h4 id="参考-123"><a href="#参考-123" class="headerlink" title="参考"></a>参考</h4><p>MISRA C++ 2008 9-3-3<br><br/><br><br/></p>
<h3 id="▌R6-3-10-声明和定义内部链接的对象和函数时均应使用-static-关键字"><a href="#▌R6-3-10-声明和定义内部链接的对象和函数时均应使用-static-关键字" class="headerlink" title="▌R6.3.10 声明和定义内部链接的对象和函数时均应使用 static 关键字"></a><span id="missingstatic">▌R6.3.10 声明和定义内部链接的对象和函数时均应使用 static 关键字</span></h3><p>ID_missingStatic&emsp;&emsp;&emsp;&emsp;&nbsp;:bulb: declaration suggestion</p>
<hr/>

<p>声明和定义内部链接的对象和函数时均应使用 static 关键字，不可使用 extern 关键字，否则极易引起误解。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">extern int a;   // Non-compliant</span><br><span class="line">....</span><br><span class="line">static int a;   // ‘a’ is a static object</span><br><span class="line">static int b;   // ‘b’ is a static object</span><br><span class="line">....</span><br><span class="line">extern int b;   // Non-compliant</span><br></pre></td></tr></table></figure>
<p>例中 a、b 是内部链接的静态对象，在定义的前后不可再用 extern 声明，否则极易与全域对象混淆。  </p>
<p>又如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int foo(int);          // Bad, missing ‘static’</span><br><span class="line"></span><br><span class="line">static int foo(int) &#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int bar(int);</span><br><span class="line"></span><br><span class="line">int bar(int) &#123;         // Bad, missing ‘static’</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在声明和定义内部链接的函数时，均应使用 static 关键字，否则也易引起误解。<br><br/><br><br/></p>
<h4 id="参考-124"><a href="#参考-124" class="headerlink" title="参考"></a>参考</h4><p>MISRA C 2004 8.11<br>MISRA C 2012 8.8<br>MISRA C++ 2008 3-3-2<br><br/><br><br/></p>
<h3 id="▌R6-3-11-inline、virtual、static、typedef-等关键字的位置应统一"><a href="#▌R6-3-11-inline、virtual、static、typedef-等关键字的位置应统一" class="headerlink" title="▌R6.3.11 inline、virtual、static、typedef 等关键字的位置应统一"></a><span id="badspecifierposition">▌R6.3.11 inline、virtual、static、typedef 等关键字的位置应统一</span></h3><p>ID_badSpecifierPosition&emsp;&emsp;&emsp;&emsp;&nbsp;:bulb: declaration suggestion</p>
<hr/>

<p>语言允许 inline、virtual、static、typedef 等关键字出现在类型名称的左侧，也可以出现在其右侧，甚至可以出现在基本类型名称的中间，应对其位置进行统一规范以提高可读性。  </p>
<p>本规则对下列 C 或 C++ 关键字有同样的要求：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">inline、virtual、explicit、</span><br><span class="line">register、static、thread_local、extern、mutable、</span><br><span class="line">friend、typedef、constexpr、</span><br><span class="line">_Alignas、_Atomic、_Noreturn、_Thread_local</span><br></pre></td></tr></table></figure>
<p>这些关键字应统一出现在声明的起始，类型名称的左侧。  </p>
<p>对于 const 和 volatile 也需面对类似的问题，参见 ID_badQualifierPosition。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct A &#123;</span><br><span class="line">    long long typedef LL;        // Non-compliant</span><br><span class="line">    bool static foo();           // Non-compliant</span><br><span class="line">    char friend bar();           // Non-compliant</span><br><span class="line">    unsigned int virtual baz();  // Non-compliant</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>例中各种声明均有一定的特殊性，如果声明其特殊性的关键字在类型名称之后，不便于阅读甚至会引起误解。  </p>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct A &#123;</span><br><span class="line">    typedef long long LL;        // Compliant</span><br><span class="line">    static bool foo();           // Compliant</span><br><span class="line">    friend char bar();           // Compliant</span><br><span class="line">    virtual unsigned int baz();  // Compliant</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="相关-79"><a href="#相关-79" class="headerlink" title="相关"></a>相关</h4><p>ID_sandwichedModifier<br>ID_badQualifierPosition<br><br/></p>
<h4 id="依据-76"><a href="#依据-76" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 6.7(1)<br>ISO/IEC 9899:1999 6.7.2(1)<br>ISO/IEC 9899:2011 6.7(1)<br>ISO/IEC 9899:2011 6.7.2(1)<br>ISO/IEC 14882:2003 A.6<br>ISO/IEC 14882:2011 A.6<br><br/><br><br/></p>
<h3 id="6-4-Declarator"><a href="#6-4-Declarator" class="headerlink" title="6.4 Declarator"></a><span id="declaration.declarator">6.4 Declarator</span></h3><h3 id="▌R6-4-1-用-auto-声明指针或引用时应显式标明-、-amp-等符号"><a href="#▌R6-4-1-用-auto-声明指针或引用时应显式标明-、-amp-等符号" class="headerlink" title="▌R6.4.1 用 auto 声明指针或引用时应显式标明 *、&amp; 等符号"></a><span id="roughauto">▌R6.4.1 用 auto 声明指针或引用时应显式标明 *、&amp; 等符号</span></h3><p>ID_roughAuto&emsp;&emsp;&emsp;&emsp;&nbsp;:bulb: declaration suggestion</p>
<hr/>

<p>用 auto 声明指针时显式标明 * 号有利于提高可读性，否则会使人误以为是某种非指针的对象。在声明引用时必须显式标明 &amp; 或 &amp;&amp; 号，否则成为对象声明，导致逻辑错误或造成不必要的复制开销。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int* foo();</span><br><span class="line">int&amp; bar();</span><br><span class="line"></span><br><span class="line">auto p = foo();   // Bad</span><br><span class="line">auto* q = foo();  // Good</span><br><span class="line"></span><br><span class="line">auto r = bar();   // Be careful, ‘r’ is not a reference</span><br><span class="line"></span><br><span class="line">for (auto e: container) &#123;  // Is it necessary to copy elements?</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中 p 为指针，但看起来像是个对象，bar 返回引用，但 r 并不是引用，e 是容器元素的复本，这些问题可能与预期不符，需谨慎对待。<br><br/><br><br/></p>
<h4 id="依据-77"><a href="#依据-77" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 14882:2011 7.1.6.4<br>ISO/IEC 14882:2017 10.1.7.4<br><br/><br><br/></p>
<h3 id="▌R6-4-2-禁用可变参数列表"><a href="#▌R6-4-2-禁用可变参数列表" class="headerlink" title="▌R6.4.2 禁用可变参数列表"></a><span id="forbidvariadicfunction">▌R6.4.2 禁用可变参数列表</span></h3><p>ID_forbidVariadicFunction&emsp;&emsp;&emsp;&emsp;&nbsp;:no_entry: declaration warning</p>
<hr/>

<p>可变参数列表对参数的类型和数量缺乏有效的限定和控制，是公认的不安全因素。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string format(const char* fmt, ...);  // Non-compliant</span><br></pre></td></tr></table></figure>
<p>假设 format 函数与 sprintf 函数功能相似，由参数 fmt 设定格式，将其他参数转为字符串后依次替换 fmt 中的占位符并返回结果。设 ‘@’ 和 ‘$’ 为占位符，分别对应字符串和整数，如调用 format(“@: $”, “value”, 123) 则返回字符串 “value: 123”。  </p>
<p>如果用可变参数列表实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">string format(const char* fmt, ...) &#123;</span><br><span class="line">    va_list ap;</span><br><span class="line">    stringstream res;</span><br><span class="line">    va_start(ap, fmt);</span><br><span class="line">    for (auto* c = fmt; *c; c++) &#123;   </span><br><span class="line">        switch (*c) &#123;</span><br><span class="line">            case &#x27;@&#x27;: res &lt;&lt; va_arg(ap, char*); break;</span><br><span class="line">            case &#x27;$&#x27;: res &lt;&lt; va_arg(ap, int); break;</span><br><span class="line">            default:  res &lt;&lt; *c; break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    va_end(ap);</span><br><span class="line">    return res.str();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中 va_start、va_arg、va_end 是可变参数列表的标准支持，这种方法只能在运行时以 fmt 为依据获取后续参数，当实际参数与 fmt 不符时会造成严重问题，单纯地要求开发者小心谨慎是不可靠的，改用更安全的方法才是明智的选择。  </p>
<p>在 C++ 代码中可采用“<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/parameter_pack">模板参数包</a>”来实现这种功能：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class T, class ...Args&gt;</span><br><span class="line">void get_argstrs(vector&lt;string&gt;&amp; vs, const T&amp; arg, const Args&amp; ...rest) &#123;</span><br><span class="line">    ostringstream oss;</span><br><span class="line">    oss &lt;&lt; arg;</span><br><span class="line">    vs.emplace_back(oss.str());</span><br><span class="line">    if constexpr(sizeof...(rest) &gt; 0) &#123;</span><br><span class="line">        get_argstrs(vs, rest...);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class ...Args&gt;</span><br><span class="line">string format(const char* fmt, const Args&amp; ...args) &#123;  // Compliant</span><br><span class="line">    string res;</span><br><span class="line">    if constexpr(sizeof...(args) &gt; 0) &#123;</span><br><span class="line">        vector&lt;string&gt; vs;</span><br><span class="line">        const size_t n = strlen(fmt);</span><br><span class="line">        get_argstrs(vs, args...);</span><br><span class="line">        for (size_t i = 0, j = 0; i &lt; n; i++) &#123;</span><br><span class="line">            if ((fmt[i] == &#x27;@&#x27; || fmt[j] == &#x27;$&#x27;) &amp;&amp; j &lt; vs.size()) &#123;</span><br><span class="line">                res.append(vs[j++]);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                res.push_back(fmt[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例代码用 get_argstrs 函数递归地将参数都转为 string 对象存入容器，再将 fmt 中的 ‘@’ 和 ‘$’ 依次替换成容器中的字符串，实际上这种实现是可以不区分 ‘@’ 和 ‘$’ 的，这个过程中参数的个数和类型是可以由代码主动判断的，如果参数不能转为字符串则不会通过编译，如果参数个数与占位符不符也容易作出处理。  </p>
<p>“<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/parameter_pack">模板参数包</a>”、“<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/constexpr">constexpr</a>”等特性是 C++ 语言在编译理论上的重大突破，合理运用这些特性可以有效提升代码的安全性和可维护性。<br><br/><br><br/></p>
<h4 id="相关-80"><a href="#相关-80" class="headerlink" title="相关"></a>相关</h4><p>ID_badParmN<br>ID_badVaArgType<br><br/></p>
<h4 id="依据-78"><a href="#依据-78" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 14882:2003 5.2.2(7)-undefined<br>ISO/IEC 14882:2011 5.2.2(7)-implementation<br><br/></p>
<h4 id="参考-125"><a href="#参考-125" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines ES.34<br>C++ Core Guidelines F.55<br>MISRA C 2004 16.1<br>MISRA C 2012 17.1<br>MISRA C++ 2008 8-4-1<br><br/><br><br/></p>
<h3 id="▌R6-4-3-禁用柔性数组"><a href="#▌R6-4-3-禁用柔性数组" class="headerlink" title="▌R6.4.3 禁用柔性数组"></a><span id="forbidflexiblearray">▌R6.4.3 禁用柔性数组</span></h3><p>ID_forbidFlexibleArray&emsp;&emsp;&emsp;&emsp;&nbsp;:no_entry: declaration suggestion</p>
<hr/>

<p>柔性数组（flexible array）一般是指结构体最后不完整定义的数组成员，表示不占用空间的指针，这种数组在 C99 中有所定义，但不在 C++ 标准之中，在 C++ 代码中不应使用。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct A &#123;</span><br><span class="line">    int len;</span><br><span class="line">    int dat[];  // Non-compliant</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A* cpy(const A* p) &#123;</span><br><span class="line">    A* a = (A*)malloc(</span><br><span class="line">        sizeof(A) + p-&gt;len * sizeof(int)</span><br><span class="line">    );</span><br><span class="line">    *a = *p;    // Error, only p-&gt;len is copied</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中 *a = *p 这种拷贝赋值运算会漏掉数组的内容，而且数组不会计入 sizeof 的结果，易引起意料之外的错误，所以在 C 代码中也不建议使用柔性数组。<br><br/><br><br/></p>
<h4 id="依据-79"><a href="#依据-79" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 6.7.2.1(16)<br>ISO/IEC 9899:2011 6.7.2.1(18)<br><br/></p>
<h4 id="参考-126"><a href="#参考-126" class="headerlink" title="参考"></a>参考</h4><p>MISRA C 2012 18.7<br><br/><br><br/></p>
<h3 id="▌R6-4-4-接口的参数类型和返回类型不应为-void"><a href="#▌R6-4-4-接口的参数类型和返回类型不应为-void" class="headerlink" title="▌R6.4.4 接口的参数类型和返回类型不应为 void*"></a><span id="forbidfunctionvoidptr">▌R6.4.4 接口的参数类型和返回类型不应为 void*</span></h3><p>ID_forbidFunctionVoidPtr&emsp;&emsp;&emsp;&emsp;&nbsp;:no_entry: declaration warning</p>
<hr/>

<p>与接口相关的数据类型应保持精确，不应将参数类型或返回类型设为 void*。  </p>
<p>在 C++ 代码中，如果参数或返回值需要面对多种不同类型的数据，应合理使用重载或模板机制。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">public:</span><br><span class="line">    void* foo();      // Non-compliant</span><br><span class="line">    void bar(void*);  // Non-compliant</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>例中 foo 和 bar 函数的返回值以及参数是不符合要求的。  </p>
<p>C 语言中存在大量的库函数不符合本规则要求，在 C++ 代码中应避免使用，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int buf[123];</span><br><span class="line">memset(buf, 0, 123);  // Logic error, should be ‘123 * sizeof(int)’</span><br></pre></td></tr></table></figure>
<p>例中 memset 函数的第一个形式参数就是 void* 型，只能通过更底层的二进制方式访问对象序列，是一种对类型设计的破坏，应改用 STL 标准库提供的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int buf[123];</span><br><span class="line">std::fill_n(buf, 123, 0);  // Safe and brief</span><br></pre></td></tr></table></figure>
<p>改用类型明确的方法可以使很多问题在编译期得到控制。  </p>
<p>例外：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct T &#123;</span><br><span class="line">    void* operator new(size_t);   // Compliant</span><br><span class="line">    void operator delete(void*);  // Compliant</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>C++ 语言规定 new 运算符的返回类型为 void*，delete 运算符的参数类型为 void*，这些情况可不受本规则约束。<br><br/><br><br/></p>
<h4 id="相关-81"><a href="#相关-81" class="headerlink" title="相关"></a>相关</h4><p>ID_voidCast<br>ID_forbidMemberVoidPtr<br><br/></p>
<h4 id="参考-127"><a href="#参考-127" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines I.4<br><br/><br><br/></p>
<h3 id="▌R6-4-5-类成员的类型不应为-void"><a href="#▌R6-4-5-类成员的类型不应为-void" class="headerlink" title="▌R6.4.5 类成员的类型不应为 void*"></a><span id="forbidmembervoidptr">▌R6.4.5 类成员的类型不应为 void*</span></h3><p>ID_forbidMemberVoidPtr&emsp;&emsp;&emsp;&emsp;&nbsp;:no_entry: declaration warning</p>
<hr/>

<p>与接口相关的数据类型应保持精确，不应将成员类型设为 void*，尤其是非 private 成员的类型，更不应设为 void*。  </p>
<p>在 C++ 代码中，如果成员需要面对多种不同类型的数据，应合理使用模板机制。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">public:</span><br><span class="line">    void* dat;   // Non-compliant</span><br><span class="line">    ....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class T&gt;</span><br><span class="line">class A &#123;</span><br><span class="line">public:</span><br><span class="line">    T* method_about_dat();</span><br><span class="line">private:</span><br><span class="line">    T* dat;   // Compliant</span><br><span class="line">    ....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="相关-82"><a href="#相关-82" class="headerlink" title="相关"></a>相关</h4><p>ID_voidCast<br>ID_forbidFunctionVoidPtr<br><br/></p>
<h4 id="参考-128"><a href="#参考-128" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines I.4<br><br/><br><br/></p>
<h3 id="▌R6-4-6-数组大小应被显式声明"><a href="#▌R6-4-6-数组大小应被显式声明" class="headerlink" title="▌R6.4.6 数组大小应被显式声明"></a><span id="missingarraysize">▌R6.4.6 数组大小应被显式声明</span></h3><p>ID_missingArraySize&emsp;&emsp;&emsp;&emsp;&nbsp;:bulb: declaration suggestion</p>
<hr/>

<p>显式声明数组大小有利于提高可读性。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">extern int a[];     // Non-compliant</span><br><span class="line">extern int b[10];   // Compliant</span><br></pre></td></tr></table></figure>
<p>由初始化列表定义数组大小是一种惯用方式，但列表较为复杂时不便于读出数组大小，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a[] = &#123;</span><br><span class="line">    1, 2, 3, ....   // Many items, let it go?</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>审计工具不妨通过配置决定这种方式是否合规。  </p>
<p>例外：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void foo(int a[], int n);   // Let it go</span><br></pre></td></tr></table></figure>
<p>数组参数可不受本规则限制。<br><br/><br><br/></p>
<h4 id="配置-14"><a href="#配置-14" class="headerlink" title="配置"></a>配置</h4><p>allowNoArraySizeWithInitList：是否放过带有初始化列表的数组<br><br/></p>
<h4 id="参考-129"><a href="#参考-129" class="headerlink" title="参考"></a>参考</h4><p>MISRA C 2004 8.12<br>MISRA C 2012 8.11<br>MISRA C++ 2008 3-1-3<br><br/><br><br/></p>
<h3 id="▌R6-4-7-不应将类型定义和对象声明写在一个语句中"><a href="#▌R6-4-7-不应将类型定义和对象声明写在一个语句中" class="headerlink" title="▌R6.4.7 不应将类型定义和对象声明写在一个语句中"></a><span id="mixedtypeobjdefinition">▌R6.4.7 不应将类型定义和对象声明写在一个语句中</span></h3><p>ID_mixedTypeObjDefinition&emsp;&emsp;&emsp;&emsp;&nbsp;:bulb: declaration suggestion</p>
<hr/>

<p>将类型定义和对象声明写在一个语句中可读性较差，应分开书写。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct T &#123;</span><br><span class="line">    ....</span><br><span class="line">&#125; obj, *ptr, fun();   // Non-compliant</span><br></pre></td></tr></table></figure>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct T &#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">T obj;   // Compliant</span><br><span class="line">T* ptr;   // Compliant</span><br><span class="line">T fun();   // Compliant</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="参考-130"><a href="#参考-130" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines C.7<br><br/><br><br/></p>
<h3 id="▌R6-4-8-不应将不同类别的声明写在一个语句中"><a href="#▌R6-4-8-不应将不同类别的声明写在一个语句中" class="headerlink" title="▌R6.4.8 不应将不同类别的声明写在一个语句中"></a><span id="mixeddeclarations">▌R6.4.8 不应将不同类别的声明写在一个语句中</span></h3><p>ID_mixedDeclarations&emsp;&emsp;&emsp;&emsp;&nbsp;:bulb: declaration suggestion</p>
<hr/>

<p>将对象、指针、引用、数组、函数等不同类别的声明写入一个语句可读性较差，易引起误解。  </p>
<p>本规则是 ID_tooManyDeclarators 的特化。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typedef int* p, n;                // Non-compliant</span><br><span class="line">int* a, b, c[8], d(int), e = 0;   // Non-compliant</span><br></pre></td></tr></table></figure>
<p>混在一起的声明易引起误解，例中 p 和 n 是不同的类型，只有 e 被初始化，d 为函数。  </p>
<p>应分开声明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef int* p;   // Compliant</span><br><span class="line">typedef int n;    // Compliant</span><br><span class="line"></span><br><span class="line">int* a;       // Compliant</span><br><span class="line">int b;        // Compliant</span><br><span class="line">int c[8];     // Compliant</span><br><span class="line">int d(int);   // Compliant</span><br><span class="line">int e = 0;    // Compliant</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="相关-83"><a href="#相关-83" class="headerlink" title="相关"></a>相关</h4><p>ID_tooManyDeclarators<br><br/></p>
<h4 id="参考-131"><a href="#参考-131" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines ES.10<br><br/><br><br/></p>
<h3 id="6-5-Object"><a href="#6-5-Object" class="headerlink" title="6.5 Object"></a><span id="declaration.object">6.5 Object</span></h3><h3 id="▌R6-5-1-不应产生无效的临时对象"><a href="#▌R6-5-1-不应产生无效的临时对象" class="headerlink" title="▌R6.5.1 不应产生无效的临时对象"></a><span id="inaccessibletmpobject">▌R6.5.1 不应产生无效的临时对象</span></h3><p>ID_inaccessibleTmpObject&emsp;&emsp;&emsp;&emsp;&nbsp;:boom: declaration error</p>
<hr/>

<p>无名且不受控制的临时对象在构造之后会立即析构，在逻辑上没有意义，往往意味着错误。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    int a;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    A() &#123;</span><br><span class="line">        A(0);   // Non-compliant, just created an inaccessible temporary object</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    A(int x): a(x) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>示例代码意在调用重载的构造函数，但 A(0); 只生成了一个无效的临时对象，成员并没有被正确初始化，应改用 this-&gt;A::A(0); 等形式，在遵循 C++11 标准的代码中也可将 A(0) 移入初始化列表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    int a;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    A(): A(0) &#123;&#125;        // Compliant</span><br><span class="line">    A(int x): a(x) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>又如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class LockGuard &#123; .... &#125;;</span><br><span class="line"></span><br><span class="line">void fun() &#123;</span><br><span class="line">    LockGuard();   // Non-compliant, meaningless</span><br><span class="line">    ....</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>设 LockGuard 是某种 RAII 锁，LockGuard(); 只生成了一个临时对象，该对象会立即析构，起不到作用，这也是一种常见的错误。  </p>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void fun() &#123;</span><br><span class="line">    LockGuard guard;   // Compliant</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="参考-132"><a href="#参考-132" class="headerlink" title="参考"></a>参考</h4><p>CWE-665<br>C++ Core Guidelines ES.84<br><br/><br><br/></p>
<h3 id="▌R6-5-2-不应存在没有被用到的局部声明"><a href="#▌R6-5-2-不应存在没有被用到的局部声明" class="headerlink" title="▌R6.5.2 不应存在没有被用到的局部声明"></a><span id="invalidlocaldeclaration">▌R6.5.2 不应存在没有被用到的局部声明</span></h3><p>ID_invalidLocalDeclaration&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: declaration warning</p>
<hr/>

<p>没有被用到的局部声明是没有意义的，往往意味着代码冗余或功能不完整，也可能导致严重的逻辑错误。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int foo(int n) &#123;</span><br><span class="line">    int x = 0;</span><br><span class="line">    if (n) &#123;</span><br><span class="line">        int x = 100 / n;   // Non-compliant</span><br><span class="line">    &#125;</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 if 作用域中声明的 x 对象没有被使用，与其相关的计算过程是无效的。  </p>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int foo(int n) &#123;</span><br><span class="line">    int x = 0;</span><br><span class="line">    if (n) &#123;</span><br><span class="line">        x = 100 / n;   // Compliant</span><br><span class="line">    &#125;</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具有特定构造或析构函数的 C++ 对象可以做到“声明即使用”，但要注意如下情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class LockGuard &#123;</span><br><span class="line">    LockGuard();</span><br><span class="line">   ~LockGuard();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void bar() &#123;</span><br><span class="line">    LockGuard guard();   // Non-compliant, this is a function</span><br><span class="line">    do_something();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中 guard 意在实现某种 RAII 锁，但 LockGuard guard(); 声明的是函数而不是对象，构造和析构函数不会按预期执行，这也是一种常见笔误。  </p>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void bar() &#123;</span><br><span class="line">    LockGuard guard;   // Compliant</span><br><span class="line">    do_something();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="参考-133"><a href="#参考-133" class="headerlink" title="参考"></a>参考</h4><p>MISRA C++ 2008 0-1-3<br><br/><br><br/></p>
<h3 id="▌R6-5-3-对象初始化不可依赖自身的值"><a href="#▌R6-5-3-对象初始化不可依赖自身的值" class="headerlink" title="▌R6.5.3 对象初始化不可依赖自身的值"></a><span id="selfdependentinitialization">▌R6.5.3 对象初始化不可依赖自身的值</span></h3><p>ID_selfDependentInitialization&emsp;&emsp;&emsp;&emsp;&nbsp;:boom: declaration error</p>
<hr/>

<p>对象初始化依赖自身的值属于逻辑错误，也是常见的笔误。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void foo(int i) &#123;</span><br><span class="line">    if (i &gt; 0) &#123;</span><br><span class="line">        int i = i + 1;  // Non-compliant</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中局部变量 i 的初始化依赖自身的值，这种问题往往是错误地定义了与外层作用域中名称相同的对象。  </p>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void foo(int i) &#123;</span><br><span class="line">    if (i &gt; 0) &#123;</span><br><span class="line">        int j = i + 1;  // OK</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/><br><br/></p>
<h3 id="▌R6-5-4-参与数值运算的-char-对象应显式声明-signed-或-unsigned"><a href="#▌R6-5-4-参与数值运算的-char-对象应显式声明-signed-或-unsigned" class="headerlink" title="▌R6.5.4 参与数值运算的 char 对象应显式声明 signed 或 unsigned"></a><span id="plainnumericchar">▌R6.5.4 参与数值运算的 char 对象应显式声明 signed 或 unsigned</span></h3><p>ID_plainNumericChar&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: declaration warning</p>
<hr/>

<p>char 类型是否有符号由实现定义，为了提高可移植性并规避意料之外的错误，参与数值运算的 char 对象应显式声明符号属性。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int foo(char c) &#123;     // Compliant</span><br><span class="line">    return c == &#x27;a&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int bar(char c) &#123;     // Non-compliant</span><br><span class="line">    return c &gt;= 0;    // May be always true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中 foo 函数的 char 型参数只与字符有关，可不必声明符号属性；而 bar 函数的参数被当作整数参与了数值运算，应显式声明为 signed，否则在 char 为无符号整型的环境中会得到错误的结果。  </p>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int bar(signed char c) &#123;   // Compliant</span><br><span class="line">    return c &gt;= 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="依据-80"><a href="#依据-80" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 6.2.5(3 15)-implementation<br>ISO/IEC 9899:2011 6.2.5(3 15)-implementation<br>ISO/IEC 14882:2003 3.9.1(1)-implementation<br>ISO/IEC 14882:2011 3.9.1(1)-implementation<br><br/></p>
<h4 id="参考-134"><a href="#参考-134" class="headerlink" title="参考"></a>参考</h4><p>MISRA C++ 2008 5-0-11<br>SEI CERT INT07-C<br><br/><br><br/></p>
<h3 id="▌R6-5-5-字节的类型应为-std-byte-或-unsigned-char"><a href="#▌R6-5-5-字节的类型应为-std-byte-或-unsigned-char" class="headerlink" title="▌R6.5.5 字节的类型应为 std::byte 或 unsigned char"></a><span id="plainbinarychar">▌R6.5.5 字节的类型应为 std::byte 或 unsigned char</span></h3><p>ID_plainBinaryChar&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: declaration warning</p>
<hr/>

<p>字节等二进制概念不应受对齐方式或符号位的干扰，字节的类型应为 std::byte 或 unsigned char。  </p>
<p>std::byte  是 C++17 的标准字节类型，对字节相关的运算和操作提供了更安全的限定。在 C 代码或不便于遵循新标准的 C++ 代码中，应将字节类型声明为 unsigned char。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef char byte;       // Non-compliant</span><br><span class="line">byte buf[100];</span><br><span class="line">FILE* fp = fopen(&quot;foo&quot;, &quot;rb&quot;);</span><br><span class="line">fread(buf, 1, 100, fp);</span><br><span class="line">if (buf[0] == 0xff) &#123;    // May be always false</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line">if (buf[1] &lt;&lt; 1) &#123;       // May cause undefined behavior</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>char 类型的符号由实现定义，有符号的 char 变量在数值计算、位运算等方面很容易产生意料之外的结果。  </p>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef unsigned char byte;   // Compliant</span><br></pre></td></tr></table></figure>
<p>这样做也可有效区分二进制数据与字符串，提高可读性。<br><br/><br><br/></p>
<h4 id="相关-84"><a href="#相关-84" class="headerlink" title="相关"></a>相关</h4><p>ID_plainNumericChar<br>ID_bitwiseOperOnSigned<br><br/></p>
<h4 id="依据-81"><a href="#依据-81" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 6.2.5(3 15)-implementation<br>ISO/IEC 9899:2011 6.2.5(3 15)-implementation<br>ISO/IEC 14882:2003 3.9.1(1)-implementation<br>ISO/IEC 14882:2011 3.9.1(1)-implementation<br><br/><br><br/></p>
<h3 id="6-6-Parameter"><a href="#6-6-Parameter" class="headerlink" title="6.6 Parameter"></a><span id="declaration.parameter">6.6 Parameter</span></h3><h3 id="▌R6-6-1-函数原型声明中的参数应具有合理的名称"><a href="#▌R6-6-1-函数原型声明中的参数应具有合理的名称" class="headerlink" title="▌R6.6.1 函数原型声明中的参数应具有合理的名称"></a><span id="missingparamname">▌R6.6.1 函数原型声明中的参数应具有合理的名称</span></h3><p>ID_missingParamName&emsp;&emsp;&emsp;&emsp;&nbsp;:bulb: declaration suggestion</p>
<hr/>

<p>参数的名称是其用途的直接说明，合理的名称可显著提高可读性。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char* strstr(const char* haystack, const char* needle);   // Good</span><br></pre></td></tr></table></figure>
<p>这是标准库函数 strstr 的原型声明，利用形象的比喻，表示在 haystack 中查找 needle。  </p>
<p>如果将声明改为如下形式，就令人费解了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char* strstr(const char*, const char*);       // Bad</span><br><span class="line">char* strstr(const char* a, const char* b);   // Bad</span><br></pre></td></tr></table></figure>
<p>例中无名称或名称无实际意义的参数是不符合要求的。<br><br/><br><br/></p>
<h4 id="参考-135"><a href="#参考-135" class="headerlink" title="参考"></a>参考</h4><p>MISRA C 2004 16.3<br>MISRA C 2012 8.2<br><br/><br><br/></p>
<h3 id="▌R6-6-2-不应将数组作为函数的形式参数"><a href="#▌R6-6-2-不应将数组作为函数的形式参数" class="headerlink" title="▌R6.6.2 不应将数组作为函数的形式参数"></a><span id="invalidparamarraysize">▌R6.6.2 不应将数组作为函数的形式参数</span></h3><p>ID_invalidParamArraySize&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: declaration warning</p>
<hr/>

<p>数组作为形式参数时，其大小声明起不到实际的限制作用。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int foo(int a[100]);   // Non-compliant</span><br><span class="line"></span><br><span class="line">int bar() &#123;</span><br><span class="line">    int a[50] = &#123;&#125;;</span><br><span class="line">    return foo(a);     // It can be compiled</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>建议在 C++ 代码中采用数组引用或模板的方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void foo(int (&amp;a)[100]);     // Compliant</span><br><span class="line"></span><br><span class="line">template &lt;size_t size&gt;</span><br><span class="line">void foo(int (&amp;a)[size]) &#123;   // Compliant</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例外：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int foo(int a[], int n);   // Let it go</span><br></pre></td></tr></table></figure>
<p>用空的方括号声明数组，并用另一个参数表示数组大小的情况可不受本规则限制。<br><br/><br><br/></p>
<h4 id="依据-82"><a href="#依据-82" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 6.7.5.3(7)<br>ISO/IEC 9899:2011 6.7.6.3(7)<br><br/></p>
<h4 id="参考-136"><a href="#参考-136" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines I.13<br>C++ Core Guidelines R.14<br>MISRA C++ 2008 5-2-12<br><br/><br><br/></p>
<h3 id="▌R6-6-3-parmN-的声明应符合要求"><a href="#▌R6-6-3-parmN-的声明应符合要求" class="headerlink" title="▌R6.6.3 parmN 的声明应符合要求"></a><span id="badparmn">▌R6.6.3 parmN 的声明应符合要求</span></h3><p>ID_badParmN&emsp;&emsp;&emsp;&emsp;&nbsp;:boom: declaration error</p>
<hr/>

<p>可变参数列表中省略号的前一个参数称为 parmN，如果：  </p>
<ul>
<li>在 C 代码中，parmN 为数组、函数，或具有寄存器存储期，以及与默认参数提升后不兼容的类型  </li>
<li>在 C++ 代码中，parmN 为引用、数组、函数，或具有与默认参数提升后不兼容的类型  </li>
</ul>
<p>会导致标准未定义的行为。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void foo(float f, ...);          // Non-compliant</span><br><span class="line">void bar(int&amp; i, ...);           // Non-compliant in C++</span><br><span class="line">void baz(register int n, ...);   // Non-compliant in C</span><br></pre></td></tr></table></figure>
<p>例中参数 f 为 float 型，与“<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/variadic_arguments#Default_conversions">默认参数提升（default argument promotion）</a>”后的类型 double 不兼容，参数 i 为引用，参数 n 被 register 限定具有寄存器存储期，这种代码均会导致标准未定义的行为。<br><br/><br><br/></p>
<h4 id="相关-85"><a href="#相关-85" class="headerlink" title="相关"></a>相关</h4><p>ID_badVaArgType<br>ID_forbidVariadicFunction<br><br/></p>
<h4 id="依据-83"><a href="#依据-83" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 7.15.1.4(4)-undefined<br>ISO/IEC 9899:2011 7.16.1.4(4)-undefined<br>ISO/IEC 14882:2003 18.7(3)-undefined<br>ISO/IEC 14882:2011 18.10(3)-undefined<br><br/></p>
<h4 id="参考-137"><a href="#参考-137" class="headerlink" title="参考"></a>参考</h4><p>SEI CERT EXP58-CPP<br><br/><br><br/></p>
<h3 id="▌R6-6-4-虚函数参数的默认值应与基类中声明的一致"><a href="#▌R6-6-4-虚函数参数的默认值应与基类中声明的一致" class="headerlink" title="▌R6.6.4 虚函数参数的默认值应与基类中声明的一致"></a><span id="inconsistentdefaultargument">▌R6.6.4 虚函数参数的默认值应与基类中声明的一致</span></h3><p>ID_inconsistentDefaultArgument&emsp;&emsp;&emsp;&emsp;&nbsp;:boom: declaration error</p>
<hr/>

<p>虚函数参数的默认值不受多态规则控制，通过基类指针或引用调用派生类重写的虚函数时，默认值仍采用基类中的定义。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual int foo(int i = 0) &#123;</span><br><span class="line">        return i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class B: public A &#123;</span><br><span class="line">public:</span><br><span class="line">    int foo(int i = 1) override &#123;  // Non-compliant</span><br><span class="line">        return i + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A* p = new B;</span><br><span class="line">cout &lt;&lt; p-&gt;foo() &lt;&lt; &#x27;\n&#x27;;  // What is output?</span><br></pre></td></tr></table></figure>
<p>输出 1，这种虚函数的非多态行为是非常令人困惑的。<br><br/><br><br/></p>
<h4 id="相关-86"><a href="#相关-86" class="headerlink" title="相关"></a>相关</h4><p>ID_deprecatedDefaultArgument<br><br/></p>
<h4 id="依据-84"><a href="#依据-84" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 14882:2003 8.3.6(10)<br>ISO/IEC 14882:2011 8.3.6(10)<br>ISO/IEC 14882:2017 11.3.6(10)<br><br/></p>
<h4 id="参考-138"><a href="#参考-138" class="headerlink" title="参考"></a>参考</h4><p>CWE-628<br>C++ Core Guidelines C.140<br>MISRA C++ 2008 8-3-1<br><br/><br><br/></p>
<h3 id="▌R6-6-5-不建议虚函数的参数有默认值"><a href="#▌R6-6-5-不建议虚函数的参数有默认值" class="headerlink" title="▌R6.6.5 不建议虚函数的参数有默认值"></a><span id="deprecateddefaultargument">▌R6.6.5 不建议虚函数的参数有默认值</span></h3><p>ID_deprecatedDefaultArgument&emsp;&emsp;&emsp;&emsp;&nbsp;:bulb: declaration suggestion</p>
<hr/>

<p>虚函数参数的默认值不受多态规则控制，通过基类指针或引用调用派生类重写的虚函数时，默认值仍采用基类中的定义，易造成混淆，故不建议虚函数的参数有默认值。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual int foo(int i = 0);   // Bad</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>应尽量去掉默认参数值，或改用重载函数的方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual int foo();        // OK</span><br><span class="line">    virtual int foo(int i);   // OK</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="相关-87"><a href="#相关-87" class="headerlink" title="相关"></a>相关</h4><p>ID_inconsistentDefaultArgument<br><br/></p>
<h4 id="依据-85"><a href="#依据-85" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 14882:2003 8.3.6(10)<br>ISO/IEC 14882:2011 8.3.6(10)<br>ISO/IEC 14882:2017 11.3.6(10)<br><br/></p>
<h4 id="参考-139"><a href="#参考-139" class="headerlink" title="参考"></a>参考</h4><p>CWE-628<br>C++ Core Guidelines C.140<br>MISRA C++ 2008 8-3-1<br><br/><br><br/></p>
<h3 id="▌R6-6-6-C-代码中参数列表如果为空应声明为“-void-”"><a href="#▌R6-6-6-C-代码中参数列表如果为空应声明为“-void-”" class="headerlink" title="▌R6.6.6 C 代码中参数列表如果为空应声明为“(void)”"></a><span id="missingvoid">▌R6.6.6 C 代码中参数列表如果为空应声明为“(void)”</span></h3><p>ID_missingVoid&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: declaration warning</p>
<hr/>

<p>在 C 语言中，如果函数的参数列表声明为空括号，表示函数的参数还没有声明，而不是表示没有参数，这很容易使人误解，所以在 C 代码中没有参数的参数列表应声明为“(void)”。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// In a.h</span><br><span class="line">int foo();  // Non-compliant</span><br><span class="line"></span><br><span class="line">// In a.c</span><br><span class="line">#include &quot;a.h&quot;</span><br><span class="line"></span><br><span class="line">int foo(int a) &#123;</span><br><span class="line">    return a + 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// In main.c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &quot;a.h&quot;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    printf(&quot;%d\n&quot;, foo(1));  // Output: 2</span><br><span class="line">    printf(&quot;%d\n&quot;, foo());   // Can be compiled, but what is output?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中 foo(1) 和 foo() 两种调用都可以通过编译，然而声明与实现不一致的问题总是令人困惑的，如果明确将参数声明为 void 或 int a 则可以解决这种问题。  </p>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int foo(void);   // Compliant, ‘foo(1)’ cannot be compiled</span><br></pre></td></tr></table></figure>
<p>或者：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int foo(int a);  // Compliant, ‘foo()’ cannot be compiled</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="相关-88"><a href="#相关-88" class="headerlink" title="相关"></a>相关</h4><p>ID_superfluousVoid<br><br/></p>
<h4 id="依据-86"><a href="#依据-86" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 6.7.5.3(14)<br>ISO/IEC 9899:1999 6.11.6(1)<br>ISO/IEC 9899:2011 6.7.6.3(14)<br>ISO/IEC 9899:2011 6.11.6(1)<br><br/></p>
<h4 id="参考-140"><a href="#参考-140" class="headerlink" title="参考"></a>参考</h4><p>MISRA C 2004 16.5<br><br/><br><br/></p>
<h3 id="▌R6-6-7-C-代码中参数列表如果为空不应声明为“-void-”"><a href="#▌R6-6-7-C-代码中参数列表如果为空不应声明为“-void-”" class="headerlink" title="▌R6.6.7 C++ 代码中参数列表如果为空不应声明为“(void)”"></a><span id="superfluousvoid">▌R6.6.7 C++ 代码中参数列表如果为空不应声明为“(void)”</span></h3><p>ID_superfluousVoid&emsp;&emsp;&emsp;&emsp;&nbsp;:bulb: declaration suggestion</p>
<hr/>

<p>与 C 语言不同，在 C++ 语言中空括号和“(void)”均表示没有参数，所以应采用更简洁的方式。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct A &#123;</span><br><span class="line">    int foo(void);  // Verbose</span><br><span class="line">    int bar();      // OK</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="相关-89"><a href="#相关-89" class="headerlink" title="相关"></a>相关</h4><p>ID_missingVoid<br><br/></p>
<h4 id="依据-87"><a href="#依据-87" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 14882:2003 C.1.6 Clause 8<br>ISO/IEC 14882:2011 C.1.7 Clause 8<br>ISO/IEC 14882:2017 C.1.7 Clause 11<br><br/></p>
<h4 id="参考-141"><a href="#参考-141" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines NL.25<br><br/><br><br/></p>
<h3 id="▌R6-6-8-声明数组参数的大小时禁用-static-关键字"><a href="#▌R6-6-8-声明数组参数的大小时禁用-static-关键字" class="headerlink" title="▌R6.6.8 声明数组参数的大小时禁用 static 关键字"></a><span id="forbidstaticarrsize">▌R6.6.8 声明数组参数的大小时禁用 static 关键字</span></h3><p>ID_forbidStaticArrSize&emsp;&emsp;&emsp;&emsp;&nbsp;:no_entry: declaration warning</p>
<hr/>

<p>C 语言规定数组作为形式参数时，可用 static 关键字限定大小，要求传入数组的大小不能小于由 static 关键字限定的值，有助于编译器优化，但不符合这种限制时会导致标准未定义的行为，相当于增加了误用风险，也增加了测试成本。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int foo(int a[static 5], int n) &#123;   // Non-compliant</span><br><span class="line">    int i;</span><br><span class="line">    int s = 0;</span><br><span class="line">    for (i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        s += a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int bar() &#123;</span><br><span class="line">    int a[3] = &#123;1, 2, 3&#125;;</span><br><span class="line">    return foo(a, 3);       // Undefined behavior</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种机制虽然有助于编译器优化，但应在效率的提高和存在的风险之间进行取舍，非系统库中的代码、改动频繁的代码不建议使用这种机制，而且这种优化大部分情况下也难以真正解决效率的瓶颈问题。<br><br/><br><br/></p>
<h4 id="依据-88"><a href="#依据-88" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 6.7.6.3(7)<br>ISO/IEC 9899:2011 6.7.6.3(7)<br><br/></p>
<h4 id="参考-142"><a href="#参考-142" class="headerlink" title="参考"></a>参考</h4><p>MISRA C 2012 17.6<br><br/><br><br/></p>
<h3 id="6-7-Function"><a href="#6-7-Function" class="headerlink" title="6.7 Function"></a><span id="declaration.function">6.7 Function</span></h3><h3 id="▌R6-7-1-派生类不应重新定义与基类相同的非虚函数"><a href="#▌R6-7-1-派生类不应重新定义与基类相同的非虚函数" class="headerlink" title="▌R6.7.1 派生类不应重新定义与基类相同的非虚函数"></a><span id="nonvirtualoverride">▌R6.7.1 派生类不应重新定义与基类相同的非虚函数</span></h3><p>ID_nonVirtualOverride&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: declaration warning</p>
<hr/>

<p>派生类不应重新定义与基类相同的非虚函数，否则与多态机制相矛盾，易造成意料之外的问题。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">struct A &#123;</span><br><span class="line">    int foo() const &#123; return 0; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct B: A &#123;</span><br><span class="line">    int foo() const &#123; return 1; &#125;  // Non-compliant</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int bar(A* a) &#123;</span><br><span class="line">    return a-&gt;foo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    B b;</span><br><span class="line">    return bar(&amp;b);  // Problematic</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果将 B 类型的指针传入 bar 函数，将执行 A::foo，然而参数实际指向的是 B 类型的对象，但 B::foo 不会被执行，这就形成了逻辑上的矛盾，极易造成意料之外的问题。<br><br/><br><br/></p>
<h4 id="参考-143"><a href="#参考-143" class="headerlink" title="参考"></a>参考</h4><p>Effective C++ item 36<br><br/><br><br/></p>
<h3 id="▌R6-7-2-重载运算符的返回类型应与内置运算符相符"><a href="#▌R6-7-2-重载运算符的返回类型应与内置运算符相符" class="headerlink" title="▌R6.7.2 重载运算符的返回类型应与内置运算符相符"></a><span id="illoperatorrettype">▌R6.7.2 重载运算符的返回类型应与内置运算符相符</span></h3><p>ID_illOperatorRetType&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: declaration warning</p>
<hr/>

<p>为了便于调用者使用，并满足泛型编程的要求，重载运算符的返回类型应与内置运算符相符：  </p>
<ul>
<li>比较和逻辑运算符应返回 bool 型对象  </li>
<li>算术和位运算符应返回相关类的对象  </li>
<li>符号运算符 +、- 应返回相关类的对象  </li>
<li>后置 ++、-- 运算符应返回相关类的对象  </li>
<li>前置 ++、-- 运算符应返回相关类的引用  </li>
<li>下标运算符 [ ] 应返回相关类的引用  </li>
<li>赋值及复合赋值运算符应返回相关类的引用  </li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct A &#123;</span><br><span class="line">    int operator &lt; (const A&amp;);   // Non-compliant</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>例中重载的比较运算符返回 int 型对象，而内置比较运算符的结果为 bool 型，重载运算符的行为和内置运算符不一致会导致意料之外的错误，相关对象也可能无法被通用泛型算法接受。  </p>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct A &#123;</span><br><span class="line">    bool operator &lt; (const A&amp;);   // Compliant</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="相关-90"><a href="#相关-90" class="headerlink" title="相关"></a>相关</h4><p>ID_nonStdAssignmentRetType<br><br/><br><br/></p>
<h3 id="▌R6-7-3-赋值运算符应返回所属类的非-const-左值引用"><a href="#▌R6-7-3-赋值运算符应返回所属类的非-const-左值引用" class="headerlink" title="▌R6.7.3 赋值运算符应返回所属类的非 const 左值引用"></a><span id="nonstdassignmentrettype">▌R6.7.3 赋值运算符应返回所属类的非 const 左值引用</span></h3><p>ID_nonStdAssignmentRetType&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: declaration warning</p>
<hr/>

<p>赋值运算符应返回所属类不受 const 关键字限定的左值引用，以便调用者使用并满足泛型编程的要求。  </p>
<p>重载赋值运算符的行为应与内置赋值运算符一致，使类对象的赋值表达式可以灵活地作为各种语句的子表达式，这也是“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Generic_programming">泛型程序设计</a>”的必要条件，使同一套代码既可以适应普通变量，也可以适应类对象。  </p>
<p>本规则是 ID_illOperatorRetType 的特化，对复合赋值运算符也有相同的要求。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct A &#123;</span><br><span class="line">    void operator = (const A&amp;);  // Non-compliant</span><br><span class="line">    void operator = (A&amp;&amp;);       // Non-compliant</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct A &#123;</span><br><span class="line">    A&amp; operator = (const A&amp;);  // Compliant</span><br><span class="line">    A&amp; operator = (A&amp;&amp;);       // Compliant</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="相关-91"><a href="#相关-91" class="headerlink" title="相关"></a>相关</h4><p>ID_illOperatorRetType<br><br/></p>
<h4 id="依据-89"><a href="#依据-89" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 14882:2003 12.8(10)<br>ISO/IEC 14882:2011 12.8(22)<br><br/></p>
<h4 id="参考-144"><a href="#参考-144" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines F.47<br>C++ Core Guidelines C.60<br>C++ Core Guidelines C.63<br><br/><br><br/></p>
<h3 id="▌R6-7-4-拷贝构造函数的参数应为同类对象的-const-左值引用"><a href="#▌R6-7-4-拷贝构造函数的参数应为同类对象的-const-左值引用" class="headerlink" title="▌R6.7.4 拷贝构造函数的参数应为同类对象的 const 左值引用"></a><span id="illcopyconstructorparam">▌R6.7.4 拷贝构造函数的参数应为同类对象的 const 左值引用</span></h3><p>ID_illCopyConstructorParam&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: declaration warning</p>
<hr/>

<p>如果构造函数的参数不是同类对象的左值引用，则不构成拷贝构造函数，拷贝构造函数不应具备复制之外的功能，故其参数不应被修改，应受 const 关键字限制。  </p>
<p>拷贝构造函数可能会被优化而导致复制之外的功能不生效，可参见 ID_sideEffectCopyConstructor 的进一步讨论。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct A &#123;</span><br><span class="line">    A(A);    // Non-compliant, logic and compile error</span><br><span class="line">    A(A&amp;);   // Non-compliant, missing ‘const’</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>拷贝构造函数不可按值传递参数，否则会再次调用拷贝构造函数，从而陷入无限递归。  </p>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct A &#123;</span><br><span class="line">    A(const A&amp;);   // Compliant</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="相关-92"><a href="#相关-92" class="headerlink" title="相关"></a>相关</h4><p>ID_sideEffectCopyConstructor<br>ID_nonStdCopyAssignmentParam<br>ID_nonConstUnmodified<br><br/><br><br/></p>
<h3 id="▌R6-7-5-拷贝赋值运算符的参数应为同类对象的-const-左值引用"><a href="#▌R6-7-5-拷贝赋值运算符的参数应为同类对象的-const-左值引用" class="headerlink" title="▌R6.7.5 拷贝赋值运算符的参数应为同类对象的 const 左值引用"></a><span id="nonstdcopyassignmentparam">▌R6.7.5 拷贝赋值运算符的参数应为同类对象的 const 左值引用</span></h3><p>ID_nonStdCopyAssignmentParam&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: declaration warning</p>
<hr/>

<p>拷贝赋值运算符应专注于复制参数的数据，且参数不应按值传递，否则会产生不必要的复制开销以及“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Object_slicing">对象切片</a>”等问题。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct A &#123;</span><br><span class="line">    A&amp; operator = (A);  // Non-compliant</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct A &#123;</span><br><span class="line">    A&amp; operator = (const A&amp;);  // Compliant</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="相关-93"><a href="#相关-93" class="headerlink" title="相关"></a>相关</h4><p>ID_illCopyConstructorParam<br>ID_nonConstUnmodified<br><br/></p>
<h4 id="依据-90"><a href="#依据-90" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 14882:2003 12.8(9)<br>ISO/IEC 14882:2011 12.8(17)<br><br/></p>
<h4 id="参考-145"><a href="#参考-145" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines C.60<br><br/><br><br/></p>
<h3 id="▌R6-7-6-移动构造函数的参数应为同类对象的非-const-右值引用"><a href="#▌R6-7-6-移动构造函数的参数应为同类对象的非-const-右值引用" class="headerlink" title="▌R6.7.6 移动构造函数的参数应为同类对象的非 const 右值引用"></a><span id="illmoveconstructorparam">▌R6.7.6 移动构造函数的参数应为同类对象的非 const 右值引用</span></h3><p>ID_illMoveConstructorParam&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: declaration warning</p>
<hr/>

<p>移动构造意在将参数的数据转移到当前对象中，故参数应为右值引用，且不应受 const 关键字限制。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct A &#123;</span><br><span class="line">    A(const A&amp;&amp;);   // Non-compliant</span><br><span class="line">    ....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="相关-94"><a href="#相关-94" class="headerlink" title="相关"></a>相关</h4><p>ID_nonStdMoveAssignmentParam<br><br/><br><br/></p>
<h3 id="▌R6-7-7-移动赋值运算符的参数应为同类对象的非-const-右值引用"><a href="#▌R6-7-7-移动赋值运算符的参数应为同类对象的非-const-右值引用" class="headerlink" title="▌R6.7.7 移动赋值运算符的参数应为同类对象的非 const 右值引用"></a><span id="nonstdmoveassignmentparam">▌R6.7.7 移动赋值运算符的参数应为同类对象的非 const 右值引用</span></h3><p>ID_nonStdMoveAssignmentParam&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: declaration warning</p>
<hr/>

<p>移动赋值意在将参数的数据转移到当前对象中，故参数应为右值引用，且不应受 const 关键字限制。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    char* p;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    A&amp; operator = (const A&amp;&amp; a) &#123;   // Non-compliant</span><br><span class="line">        free(p);</span><br><span class="line">        p = copy(a.p);   // Not necessary</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>例中赋值运算符先释放持有的资源，再复制 a 的资源，不是真正的移动赋值，仍是一种低效实现。应将 a.p 与 this-&gt;p 交换，省去复制过程，并使原有资源由 a 的析构函数释放，才是真正意义上的移动赋值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">A&amp; A::operator = (A&amp;&amp; a) &#123;   // Compliant</span><br><span class="line">    char* tmp = p;</span><br><span class="line">    p = a.p;</span><br><span class="line">    a.p = tmp;</span><br><span class="line">    return *this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="依据-91"><a href="#依据-91" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 14882:2011 12.8(19)<br>ISO/IEC 14882:2017 15.8.2(3)<br><br/></p>
<h4 id="参考-146"><a href="#参考-146" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines C.63<br><br/><br><br/></p>
<h3 id="▌R6-7-8-不应重载取地址运算符"><a href="#▌R6-7-8-不应重载取地址运算符" class="headerlink" title="▌R6.7.8 不应重载取地址运算符"></a><span id="overloadaddressoperator">▌R6.7.8 不应重载取地址运算符</span></h3><p>ID_overloadAddressOperator&emsp;&emsp;&emsp;&emsp;&nbsp;:bulb: declaration suggestion</p>
<hr/>

<p>取地址运算符（一元 &amp; 运算符），重载之后可以返回任意地址，极易误用。  </p>
<p>获取不完整类型的对象地址时，如果其完整类型重载了取地址运算符，会导致标准未定义的行为。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct X;   // Incomplete type</span><br><span class="line"></span><br><span class="line">X* foo(X&amp; x) &#123;</span><br><span class="line">    return &amp;x;   // Undefined behavior</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct X &#123;</span><br><span class="line">    X* operator &amp;() &#123;   // Non-compliant</span><br><span class="line">        return nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">X* bar(X&amp; x) &#123;</span><br><span class="line">    return &amp;x;   // Call ‘X::operator&amp;’</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中 foo 会导致未定义的行为，可能会返回 x 对象的实际地址，而 bar 会调用重载了的取地址运算符，这是一种混乱的局面。<br><br/><br><br/></p>
<h4 id="依据-92"><a href="#依据-92" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 14882:2003 5.3.1(4)-undefined<br>ISO/IEC 14882:2011 5.3.1(5)-undefined<br><br/></p>
<h4 id="参考-147"><a href="#参考-147" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines C.166<br>MISRA C++ 2008 5-3-3<br><br/><br><br/></p>
<h3 id="▌R6-7-9-不应重载逗号运算符"><a href="#▌R6-7-9-不应重载逗号运算符" class="headerlink" title="▌R6.7.9 不应重载逗号运算符"></a><span id="overloadcomma">▌R6.7.9 不应重载逗号运算符</span></h3><p>ID_overloadComma&emsp;&emsp;&emsp;&emsp;&nbsp;:bulb: declaration suggestion</p>
<hr/>

<p>逗号表达式意在从左至右依次执行各子表达式，但重载逗号运算符会打破这一规则，易造成意料之外的结果。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class A &#123; .... &#125;;</span><br><span class="line"></span><br><span class="line">A&amp; foo(int);</span><br><span class="line">A&amp; operator , (int, A&amp;);  // Non-compliant</span><br><span class="line"></span><br><span class="line">int bar(int i) &#123;</span><br><span class="line">    ++i, foo(i);   // Disordered</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中逗号运算符被重载后变成了一个函数，++i 和 foo(i) 变成了函数参数，函数参数的求值顺序在标准中是未声明的，foo(i) 很有可能会先被求值，++i 则失去了意义。  </p>
<p>另外，也不应重载逻辑运算符，参见 ID_overloadLogicOperator。<br><br/><br><br/></p>
<h4 id="相关-95"><a href="#相关-95" class="headerlink" title="相关"></a>相关</h4><p>ID_overloadLogicOperator<br><br/></p>
<h4 id="依据-93"><a href="#依据-93" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 14882:2003 5.2.2(8)-unspecified<br>ISO/IEC 14882:2011 5.2.2(8)<br><br/></p>
<h4 id="参考-148"><a href="#参考-148" class="headerlink" title="参考"></a>参考</h4><p>MISRA C++ 2008 5-2-11<br><br/><br><br/></p>
<h3 id="▌R6-7-10-不应重载“逻辑与”和“逻辑或”运算符"><a href="#▌R6-7-10-不应重载“逻辑与”和“逻辑或”运算符" class="headerlink" title="▌R6.7.10 不应重载“逻辑与”和“逻辑或”运算符"></a><span id="overloadlogicoperator">▌R6.7.10 不应重载“逻辑与”和“逻辑或”运算符</span></h3><p>ID_overloadLogicOperator&emsp;&emsp;&emsp;&emsp;&nbsp;:bulb: declaration suggestion</p>
<hr/>

<p>对“逻辑与”、“逻辑或”等运算符的重载会影响效率，甚至造成不符合预期的结果。  </p>
<p>C/C++ 标准明确规定了内置逗号、逻辑与、逻辑或等运算符的子表达式求值顺序。对于逻辑表达式，从左到右计算子表达式的值，当可以确定整个表达式的值时立即结束计算，如果还有其他子表达式未求值也不再计算了，这种规则称为“短路规则”，意在提高效率，然而运算符的重载却打破了这一规则。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    A(int x = 0): i(x) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool valid() const &#123;</span><br><span class="line">        return i != 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    A&amp; assign(const A&amp; a) &#123;</span><br><span class="line">        i = a.i;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">bool operator &amp;&amp; (const A&amp; a, const A&amp; b) &#123;  // Non-compliant</span><br><span class="line">    return a.valid() &amp;&amp; b.valid();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意表达式（设 a 和 b 为 A 类对象）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b &amp;&amp; a.assign(b)</span><br></pre></td></tr></table></figure>
<p>按常理，此表达式的意思应该是如果 b 在某种意义上“有效”，就将 b 赋给 a，所以 b 的值应先被求出，但由于 &amp;&amp; 被重载成了一个函数，其左右子表达式成了函数的参数，“短路规则”不再有效，而且参数的求值顺序在标准中是未声明的，所以常规逻辑子表达式的求值顺序无法得到保证。目前 MSVC、g++ 等主流编译器默认都是从右到左计算参数的值，例中 a.assign(b) 会先被执行，造成完全不符合预期的结果。  </p>
<p>解决方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    ....</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    explicit operator bool() const &#123;</span><br><span class="line">        return valid();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>去掉对 &amp;&amp; 的重载，在 A 中定义 bool 类型转换运算符，既可保证“短路规则”，又可保证求值顺序。<br><br/><br><br/></p>
<h4 id="相关-96"><a href="#相关-96" class="headerlink" title="相关"></a>相关</h4><p>ID_overloadComma<br><br/></p>
<h4 id="依据-94"><a href="#依据-94" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 14882:2003 5.2.2(8)-unspecified<br>ISO/IEC 14882:2011 5.2.2(8)<br><br/></p>
<h4 id="参考-149"><a href="#参考-149" class="headerlink" title="参考"></a>参考</h4><p>MISRA C++ 2008 5-2-11<br><br/><br><br/></p>
<h3 id="▌R6-7-11-拷贝和移动赋值运算符不应为虚函数"><a href="#▌R6-7-11-拷贝和移动赋值运算符不应为虚函数" class="headerlink" title="▌R6.7.11 拷贝和移动赋值运算符不应为虚函数"></a><span id="virtualassignment">▌R6.7.11 拷贝和移动赋值运算符不应为虚函数</span></h3><p>ID_virtualAssignment&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: declaration warning</p>
<hr/>

<p>拷贝和移动赋值运算符的参数应分别为所属类的左值和右值引用，这类运算符即使是虚函数也不便于被重写。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual A&amp; operator = (const A&amp;);  // Non-compliant</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class B: public A &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual B&amp; operator = (const B&amp;);  // Not override</span><br><span class="line">    virtual A&amp; operator = (const A&amp;);  // Override, but too complex</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="相关-97"><a href="#相关-97" class="headerlink" title="相关"></a>相关</h4><p>ID_nonStdAssignmentRetType<br><br/></p>
<h4 id="依据-95"><a href="#依据-95" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 14882:2003 12.8(9)<br>ISO/IEC 14882:2011 12.8(17)<br>ISO/IEC 14882:2011 12.8(19)<br><br/></p>
<h4 id="参考-150"><a href="#参考-150" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines C.60<br>C++ Core Guidelines C.63<br><br/><br><br/></p>
<h3 id="▌R6-7-12-比较运算符不应为虚函数"><a href="#▌R6-7-12-比较运算符不应为虚函数" class="headerlink" title="▌R6.7.12 比较运算符不应为虚函数"></a><span id="virtualcomparison">▌R6.7.12 比较运算符不应为虚函数</span></h3><p>ID_virtualComparison&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: declaration warning</p>
<hr/>

<p>重载的比较运算符很难正确触发 C++ 的多态机制，将其设为虚函数很可能引发意料之外的错误。  </p>
<p>运算符 ==、!=、&lt;、&gt;、&lt;=、&gt;= 均受本规则限制。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    ....</span><br><span class="line">public:</span><br><span class="line">    virtual bool operator == (const A&amp;) const;  // Non-compliant</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class B: public A &#123;</span><br><span class="line">    ....</span><br><span class="line">public:</span><br><span class="line">    virtual bool operator == (const B&amp;) const;  // Non-compliant, not overloaded</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="参考-151"><a href="#参考-151" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines C.87<br><br/><br><br/></p>
<h3 id="▌R6-7-13-final-类中不应声明虚函数"><a href="#▌R6-7-13-final-类中不应声明虚函数" class="headerlink" title="▌R6.7.13 final 类中不应声明虚函数"></a><span id="virtualinfinal">▌R6.7.13 final 类中不应声明虚函数</span></h3><p>ID_virtualInFinal&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: declaration warning</p>
<hr/>

<p>final 类不再产生派生类，其中的虚函数也不会再被重写，故不应声明虚函数。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class A final &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual int foo();  // Non-compliant, a new virtual function in a final class</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class B &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual int bar();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class C final: public B &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual int bar();  // Non-compliant, use keyword ‘override’ or ‘final’</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="依据-96"><a href="#依据-96" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 14882:2011 9(3)<br>ISO/IEC 14882:2017 12(3)<br><br/><br><br/></p>
<h3 id="6-8-Bitfield"><a href="#6-8-Bitfield" class="headerlink" title="6.8 Bitfield"></a><span id="declaration.bitfield">6.8 Bitfield</span></h3><h3 id="▌R6-8-1-对位域声明合理的类型"><a href="#▌R6-8-1-对位域声明合理的类型" class="headerlink" title="▌R6.8.1 对位域声明合理的类型"></a><span id="improperbitfieldtype">▌R6.8.1 对位域声明合理的类型</span></h3><p>ID_improperBitfieldType&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: declaration warning</p>
<hr/>

<p>为了提高可移植性和可维护性，应对位域声明合理的类型，如：  </p>
<ul>
<li>显式声明 signed 或 unsigned 的整数类型  </li>
<li>C++ 语言的 bool 或 C 语言的 _Bool 类型  </li>
<li>各种实现中取值范围均一致的整数类型  </li>
</ul>
<p>C90 标准只允许 signed int 或 unsigned int 作为位域类型，在之后的 C 标准以及 C++14 之前的 C++ 标准中，用于位域的 char、short、int、long 或 long long 等整数类型是否有符号由实现定义。  </p>
<p>为了避免意料之外的符号扩展、溢出等问题，建议统一使用无符号整型作为位域类型。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct A &#123;</span><br><span class="line">    char c: 2;   // Non-compliant</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>char 是否有符号由实现定义，位域 c 的取值范围可能是 [-2, 1] 也可能是 [0, 3]，故应明确声明位域的符号属性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct A &#123;</span><br><span class="line">    unsigned char c: 2;   // Compliant, or use uint8_t</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>又如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct B &#123;</span><br><span class="line">    unsigned long a: 4;    // Bad</span><br><span class="line">    unsigned long b: 32;   // Bad</span><br><span class="line">    unsigned long c: 24;   // Bad</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>例中结构体只涉及 60 个比特位，但由于 long 的取值范围是由实现定义的，结构体的内存布局在不同的平台上会有较大差异，可能会产生意料之外的填充数据，造成对接口或协议的解析错误。  </p>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdint.h&gt;   // Or &lt;cstdint&gt; in C++</span><br><span class="line"></span><br><span class="line">struct B &#123;</span><br><span class="line">    uint64_t a: 4;    // OK</span><br><span class="line">    uint64_t b: 32;   // OK</span><br><span class="line">    uint64_t c: 24;   // OK</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="配置-15"><a href="#配置-15" class="headerlink" title="配置"></a>配置</h4><p>bitfieldMustBeUnsigned：位域类型是否必须为无符号整型<br>bitfieldMustBeStdInt：位域类型是否必须为 stdint.h 或 cstdint 中定义的类型<br><br/></p>
<h4 id="依据-97"><a href="#依据-97" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 J.3.9(1)-implementation<br>ISO/IEC 9899:2011 J.3.9(1)-implementation<br>ISO/IEC 14882:2003 9.6(3)-implementation<br>ISO/IEC 14882:2011 9.6(3)-implementation<br><br/></p>
<h4 id="参考-152"><a href="#参考-152" class="headerlink" title="参考"></a>参考</h4><p>MISRA C 2004 6.4<br>MISRA C 2012 6.1<br>MISRA C++ 2008 9-6-2<br><br/><br><br/></p>
<h3 id="▌R6-8-2-位域长度不应超过类型长度"><a href="#▌R6-8-2-位域长度不应超过类型长度" class="headerlink" title="▌R6.8.2 位域长度不应超过类型长度"></a><span id="exceededbitfield">▌R6.8.2 位域长度不应超过类型长度</span></h3><p>ID_exceededBitfield&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: declaration warning</p>
<hr/>

<p>位域长度超过类型长度易误导维护者，而且也可能是笔误。  </p>
<p>C 标准不允许位域长度超过类型长度，但 C++ 标准允许，超过的部分作为“padding bits”不参与数据的存储。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct A &#123;</span><br><span class="line">    uint32_t x: 64;    // Non-compliant</span><br><span class="line">&#125; a;</span><br><span class="line"></span><br><span class="line">a.x = UINT64_MAX;      // Truncated </span><br></pre></td></tr></table></figure>
<p>例中 x 的位域长度超过了类型长度，但有效位域长度仍为 32，有效位域和声明位域不一致易误导维护者，造成截断或溢出等错误。  </p>
<p>如果是为了特殊的对齐，可改用成员占位的方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct A &#123;</span><br><span class="line">    int32_t x;         // Compliant</span><br><span class="line">    int32_t padding;   // Compliant</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>成员 padding 特殊的名称表明它是用于占位的特殊成员，这种方式比位域更有利于维护。<br><br/><br><br/></p>
<h4 id="依据-98"><a href="#依据-98" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 6.7.2.1(3)<br>ISO/IEC 9899:2011 6.7.2.1(4)<br>ISO/IEC 14882:2003 9.6(1)<br>ISO/IEC 14882:2011 9.6(1)<br><br/><br><br/></p>
<h3 id="▌R6-8-3-有符号整型对象的位域长度不应为-1"><a href="#▌R6-8-3-有符号整型对象的位域长度不应为-1" class="headerlink" title="▌R6.8.3 有符号整型对象的位域长度不应为 1"></a><span id="singlesignedbitfield">▌R6.8.3 有符号整型对象的位域长度不应为 1</span></h3><p>ID_singleSignedBitfield&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: declaration warning</p>
<hr/>

<p>有符号整型对象的位域长度如果为 1 表示只有一个比特位，而该比特位是符号位，极易造成意料之外的错误。  </p>
<p>匿名成员的位域长度不受本规则限制。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct X &#123;</span><br><span class="line">    signed a: 1;     // Non-compliant</span><br><span class="line"></span><br><span class="line">    signed  : 0;     // Compliant</span><br><span class="line">    signed  : 1;     // Compliant</span><br><span class="line">    signed b: 2;     // Compliant</span><br><span class="line"></span><br><span class="line">    unsigned c: 1;   // Compliant</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    X x;</span><br><span class="line">    x.a = 1, x.b = 1, x.c = 1;</span><br><span class="line">    printf(&quot;%d %d %u\n&quot;, x.a, x.b, x.c);   // What is output?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出 -1 1 1，x.b 和 x.c 为 1 与预期相符，x.a 预期是 1，但实际是 -1。<br><br/><br><br/></p>
<h4 id="参考-153"><a href="#参考-153" class="headerlink" title="参考"></a>参考</h4><p>MISRA C 2012 6.2<br>MISRA C++ 2008 9-6-4<br><br/><br><br/></p>
<h3 id="▌R6-8-4-不应对枚举对象声明位域"><a href="#▌R6-8-4-不应对枚举对象声明位域" class="headerlink" title="▌R6.8.4 不应对枚举对象声明位域"></a><span id="forbidenumbitfield">▌R6.8.4 不应对枚举对象声明位域</span></h3><p>ID_forbidEnumBitfield&emsp;&emsp;&emsp;&emsp;&nbsp;:no_entry: declaration warning</p>
<hr/>

<p>枚举类型是否有符号由实现定义，而且符号位与位域结合易导致意料之外的错误。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">enum E &#123;</span><br><span class="line">    A, B, C, D</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct X &#123;</span><br><span class="line">    E e: 2;   // Non-compliant</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    X x;</span><br><span class="line">    x.e = D;</span><br><span class="line">    if (x.e == D) &#123;    // What is output?</span><br><span class="line">        cout &lt;&lt; &quot;OK&quot;;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Oops&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可能输出 Oops。例中枚举项的取值范围是 [0, 3]，位域长度为 2 即可满足这个范围，但如果位域有符号位，会导致意料之外的问题，如用 D 对 x.e 赋值，但 x.e == D 的结果却是 false （因为 D 的值为 3 而 x.e 的值为 -1）。  </p>
<p>例外：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">enum E: unsigned &#123;   // Explicit underlying type</span><br><span class="line">    A, B, C, D</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct X &#123;</span><br><span class="line">    E e: 2;   // Compliant</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在遵循 C++11 及之后标准的代码中，如果显式指定了枚举类型的的底层类型，可不受本规则限制。<br><br/><br><br/></p>
<h4 id="相关-98"><a href="#相关-98" class="headerlink" title="相关"></a>相关</h4><p>ID_improperBitfieldType<br>ID_singleSignedBitfield<br><br/></p>
<h4 id="依据-99"><a href="#依据-99" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 6.7.2.2(4)-implementation<br>ISO/IEC 9899:2011 6.7.2.2(4)-implementation<br>ISO/IEC 14882:2011 7.2(6)-implementation<br>ISO/IEC 14882:2017 10.2(7)-implementation<br><br/></p>
<h4 id="参考-154"><a href="#参考-154" class="headerlink" title="参考"></a>参考</h4><p>MISRA C++ 2008 9-6-3<br><br/><br><br/></p>
<h3 id="▌R6-8-5-禁用位域"><a href="#▌R6-8-5-禁用位域" class="headerlink" title="▌R6.8.5 禁用位域"></a><span id="forbidbitfield">▌R6.8.5 禁用位域</span></h3><p>ID_forbidBitfield&emsp;&emsp;&emsp;&emsp;&nbsp;:no_entry: declaration suggestion</p>
<hr/>

<p>位域改变了类型约定俗成的取值范围和存储方式，易造成理解上的偏差，增加维护成本，在不受特定协议限制的代码中不应使用位域。  </p>
<p>位域与“引用”等 C++ 概念有冲突，而且标准在位域的内存布局等方面定义的不够充分，存在很多由实现定义的内容，要特别注意的是多线程访问位域还会造成数据竞争，参见 ID_bitfieldDataRaces。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct A &#123;</span><br><span class="line">    int x: 3;   // Non-compliant</span><br><span class="line">&#125; a;</span><br><span class="line"></span><br><span class="line">int&amp; x = a.x;   // Error</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="相关-99"><a href="#相关-99" class="headerlink" title="相关"></a>相关</h4><p>ID_exceededBitfield<br>ID_singleSignedBitfield<br>ID_bitfieldDataRaces<br>ID_forbidEnumBitfield<br><br/></p>
<h4 id="依据-100"><a href="#依据-100" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 J.3.9(1)-implementation<br>ISO/IEC 9899:2011 J.3.9(1)-implementation<br>ISO/IEC 14882:2003 9.6(1)-implementation<br>ISO/IEC 14882:2003 9.6(3)<br>ISO/IEC 14882:2011 9.6(1)-implementation<br>ISO/IEC 14882:2011 9.6(3)<br>ISO/IEC 14882:2017 12.2.4(1)-implementation<br>ISO/IEC 14882:2017 12.2.4(3)<br><br/><br><br/></p>
<h3 id="6-9-Complexity"><a href="#6-9-Complexity" class="headerlink" title="6.9 Complexity"></a><span id="declaration.complexity">6.9 Complexity</span></h3><h3 id="▌R6-9-1-不应采用复杂的声明"><a href="#▌R6-9-1-不应采用复杂的声明" class="headerlink" title="▌R6.9.1 不应采用复杂的声明"></a><span id="complexdeclaration">▌R6.9.1 不应采用复杂的声明</span></h3><p>ID_complexDeclaration&emsp;&emsp;&emsp;&emsp;&nbsp;:bulb: declaration suggestion</p>
<hr/>

<p>复杂的声明可读性较差，容易造成理解上的偏差。  </p>
<p>对于：  </p>
<ul>
<li>函数指针的数组  </li>
<li>返回函数指针、数组指针的函数  </li>
<li>以函数指针、数组指针为参数的函数  </li>
</ul>
<p>应先将各子类型取别名，再用简单声明的方式书写。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int (*foo(int))(bool);   // Bad, returns a function pointer</span><br><span class="line">int (*foo(char))[123];   // Bad, returns an array pointer</span><br></pre></td></tr></table></figure>
<p>例中声明的是两个函数，但看起来像是函数指针，而且参数列表也显得混乱。  </p>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef int(*funptr)(bool);</span><br><span class="line">typedef int(*arrptr)[123];</span><br><span class="line"></span><br><span class="line">funptr foo(int);    // Good</span><br><span class="line">arrptr foo(char);   // Good</span><br></pre></td></tr></table></figure>
<p><br/><br><br/><br><br/></p>
<h3 id="▌R6-9-2-声明中不应包含过多的指针嵌套"><a href="#▌R6-9-2-声明中不应包含过多的指针嵌套" class="headerlink" title="▌R6.9.2 声明中不应包含过多的指针嵌套"></a><span id="toomanyptrlevel">▌R6.9.2 声明中不应包含过多的指针嵌套</span></h3><p>ID_tooManyPtrLevel&emsp;&emsp;&emsp;&emsp;&nbsp;:bulb: declaration suggestion</p>
<hr/>

<p>指针嵌套层级过多意味着指针的解引用逻辑过于复杂，相关代码将难以理解，指针嵌套不宜超过 2 级。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">T *** x;   // Bad</span><br><span class="line">T * volatile * * const * y;   // Terrible</span><br></pre></td></tr></table></figure>
<p>例中 T 为任意类型，如果发现这种指针，意味着需要改进对相关数据的访问方式。  </p>
<p>出于灵活性的考虑，非连续的指针嵌套可不受本规则约束，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int** (*pa)[100];   // Let it go</span><br><span class="line">int** (*pf)(int);   // Let it go</span><br></pre></td></tr></table></figure>
<p>例中 pa 是指向数组的指针，数组元素为 2 级指针，pf 是函数指针，函数返回 2 级指针，这种情况是可接受的。<br><br/><br><br/></p>
<h4 id="配置-16"><a href="#配置-16" class="headerlink" title="配置"></a>配置</h4><p>maxPtrLevel：指针嵌套的最大层数，超过则报出<br><br/></p>
<h4 id="相关-100"><a href="#相关-100" class="headerlink" title="相关"></a>相关</h4><p>ID_complexDeclaration<br><br/></p>
<h4 id="参考-155"><a href="#参考-155" class="headerlink" title="参考"></a>参考</h4><p>MISRA C 2004 17.5<br>MISRA C 2012 18.5<br><br/><br><br/></p>
<h3 id="▌R6-9-3-在一个语句中不应声明多个对象或函数"><a href="#▌R6-9-3-在一个语句中不应声明多个对象或函数" class="headerlink" title="▌R6.9.3 在一个语句中不应声明多个对象或函数"></a><span id="toomanydeclarators">▌R6.9.3 在一个语句中不应声明多个对象或函数</span></h3><p>ID_tooManyDeclarators&emsp;&emsp;&emsp;&emsp;&nbsp;:bulb: declaration suggestion</p>
<hr/>

<p>在一个语句中声明多个对象或函数不利于阅读和维护，建议在一个语句中只声明一个对象或函数。  </p>
<p>函数、数组以及相关指针、引用的声明相对复杂，不应和其他声明混在一起。为了便于查阅，对于类及结构体成员、全局对象、具有外部链接性或静态存储期的对象，也不应将多项声明混在一个语句中。对于简单的局部对象声明可适当放宽要求，但仍以一个语句一项声明为宜。  </p>
<p>不应将指针、引用、数组、函数等不同类别的声明混在一个语句中，对此本规则特化为  ID_mixedDeclarations。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int a, b, c, d, e, f, g, ....;   // Non-compliant, too many objects</span><br><span class="line"></span><br><span class="line">int fn1(void), fn2(int, int*), fn3(int);   // Non-compliant</span><br><span class="line"></span><br><span class="line">struct T &#123;</span><br><span class="line">    int i, j, k;   // Non-compliant</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>例中一个语句声明多个函数、成员或全局对象是不符合要求的。  </p>
<p>又如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void foo() &#123;</span><br><span class="line">    int long_name, name;             // Non-compliant</span><br><span class="line">    int u = complex_expression, v;   // Non-compliant</span><br><span class="line">    ....</span><br><span class="line">    int x, y;   // Simple declarations, let it go?</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于局部对象，审计工具不妨统计声明项及其初始化表达式的字符个数，如果超过指定限制，则判其应在单独的语句中声明。<br><br/><br><br/></p>
<h4 id="配置-17"><a href="#配置-17" class="headerlink" title="配置"></a>配置</h4><p>maxLocalDeclaratorCount：局部作用域中一个语句能声明的对象个数上限，超过则报出<br>maxMemberDeclaratorCount：类或结构体中一个语句能声明的对象个数上限，超过则报出<br>maxGlobalDeclaratorCount：全局及命名空间作用域中一个语句能声明的对象个数上限，超过则报出<br>simpleDeclaratorLengthThreshold：声明字符数量阈值，超过此值则判其应在单独的语句中声明<br><br/></p>
<h4 id="相关-101"><a href="#相关-101" class="headerlink" title="相关"></a>相关</h4><p>ID_mixedDeclarations<br><br/></p>
<h4 id="参考-156"><a href="#参考-156" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines ES.10<br>MISRA C++ 2008 8-0-1<br><br/><br><br/></p>
<h3 id="6-10-Other"><a href="#6-10-Other" class="headerlink" title="6.10 Other"></a><span id="declaration.other">6.10 Other</span></h3><h3 id="▌R6-10-1-遵循-One-Definition-Rule"><a href="#▌R6-10-1-遵循-One-Definition-Rule" class="headerlink" title="▌R6.10.1 遵循 One Definition Rule"></a><span id="violateodr">▌R6.10.1 遵循 One Definition Rule</span></h3><p>ID_violateODR&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: declaration warning</p>
<hr/>

<p>One Definition Rule 即任何翻译单元不得包含对象、函数、类型或模板的多个定义，否则会导致标准未定义的行为。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// In a.cpp</span><br><span class="line">struct T &#123;    // One Definition</span><br><span class="line">    int i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">T* foo() &#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// In b.cpp</span><br><span class="line">struct T &#123;    // Non-compliant, another definition</span><br><span class="line">    long i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void bar(T*) &#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// In c.cpp</span><br><span class="line">struct T;</span><br><span class="line">T* foo();</span><br><span class="line">void bar(T*);</span><br><span class="line"></span><br><span class="line">void baz() &#123;</span><br><span class="line">    bar(foo());   // Problems</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中 T 类型在两个翻译单元中有不同的定义，违反了 One Definition Rule，易造成难以排查的错误，应在头文件中统一定义类型。<br><br/><br><br/></p>
<h4 id="依据-101"><a href="#依据-101" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 14882:2003 3.2(5)-undefined<br>ISO/IEC 14882:2011 3.2(5)-undefined<br><br/></p>
<h4 id="参考-157"><a href="#参考-157" class="headerlink" title="参考"></a>参考</h4><p>MISRA C++ 2008 3-2-2<br><br/><br><br/></p>
<h3 id="▌R6-10-2-声明与实现应一致"><a href="#▌R6-10-2-声明与实现应一致" class="headerlink" title="▌R6.10.2 声明与实现应一致"></a><span id="inconsistentdeclaration">▌R6.10.2 声明与实现应一致</span></h3><p>ID_inconsistentDeclaration&emsp;&emsp;&emsp;&emsp;&nbsp;:bulb: declaration suggestion</p>
<hr/>

<p>声明与实现在书写上应完全一致，否则极易引起误解，而且对同一对象或函数进行类型不兼容的声明，也会导致标准未定义的行为。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">extern long n;   // Non-compliant, undefined behavior</span><br><span class="line"></span><br><span class="line">int foo() &#123;</span><br><span class="line">    return n++;   // Undefined behavior</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">short n;</span><br></pre></td></tr></table></figure>
<p>例中变量 n 有多处声明，但类型不一致，会导致标准未定义的行为。  </p>
<p>又如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int foo(int x);</span><br><span class="line"></span><br><span class="line">typedef int type;</span><br><span class="line">type foo(type x) &#123;   // Non-compliant, confusing</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中在实现处为参数类型定义别名是不符合要求的，在允许重载的 C++ 代码中会引起更大的误解。  </p>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef int type;</span><br><span class="line">type foo(type x);</span><br><span class="line"></span><br><span class="line">type foo(type x) &#123;   // Compliant</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="相关-102"><a href="#相关-102" class="headerlink" title="相关"></a>相关</h4><p>ID_inconsistentParamName<br><br/></p>
<h4 id="依据-102"><a href="#依据-102" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 6.2.7(2)-undefined<br>ISO/IEC 9899:2011 6.2.7(2)-undefined<br><br/></p>
<h4 id="参考-158"><a href="#参考-158" class="headerlink" title="参考"></a>参考</h4><p>MISRA C 2004 8.4<br>MISRA C 2012 8.3<br>MISRA C++ 2008 3-9-1<br>SEI CERT DCL40-C<br><br/><br><br/></p>
<h3 id="▌R6-10-3-在合理的位置声明"><a href="#▌R6-10-3-在合理的位置声明" class="headerlink" title="▌R6.10.3 在合理的位置声明"></a><span id="unsuitabledeclaration">▌R6.10.3 在合理的位置声明</span></h3><p>ID_unsuitableDeclaration&emsp;&emsp;&emsp;&emsp;&nbsp;:bulb: declaration suggestion</p>
<hr/>

<p>如果声明的位置不合理会降低代码的可维护性，甚至会导致标准未定义的行为。  </p>
<p>应遵循如下原则：  </p>
<ul>
<li>外部链接的对象或函数应在头文件中声明，并避免重复声明  </li>
<li>内部链接的对象或函数应在源文件中声明，不应在头文件中声明  </li>
<li>避免在头文件外手工书写外部声明  </li>
<li>避免在局部作用域内声明函数或全局对象  </li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int fun()</span><br><span class="line">&#123;</span><br><span class="line">    extern int g;       // Non-compliant, bad practice</span><br><span class="line">    extern int foo();   // Non-compliant, bad practice</span><br><span class="line">    static int bar();   // Non-compliant, undefined behavior</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>外部链接的对象或函数应通过头文件引入，如果分散在函数中声明是不便于统一管理和维护的。另外，在局部作用域中使用除 extern 之外的存储类说明符声明函数会导致标准未定义的行为。<br><br/><br><br/></p>
<h4 id="相关-103"><a href="#相关-103" class="headerlink" title="相关"></a>相关</h4><p>ID_staticInHeader<br>ID_anonymousNamespaceInHeader<br><br/></p>
<h4 id="依据-103"><a href="#依据-103" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 6.7.1(5)-undefined<br>ISO/IEC 9899:2011 6.7.1(7)-undefined<br><br/></p>
<h4 id="参考-159"><a href="#参考-159" class="headerlink" title="参考"></a>参考</h4><p>MISRA C++ 2008 3-1-2<br>MISRA C++ 2008 3-3-1<br><br/><br><br/></p>
<h3 id="▌R6-10-4-不应存在没有被用到的标签"><a href="#▌R6-10-4-不应存在没有被用到的标签" class="headerlink" title="▌R6.10.4 不应存在没有被用到的标签"></a><span id="labelnotused">▌R6.10.4 不应存在没有被用到的标签</span></h3><p>ID_labelNotUsed&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: declaration warning</p>
<hr/>

<p>没有被用到的标签意味着 goto 语句的缺失，也可能是残留代码，应当去除。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int foo() &#123;</span><br><span class="line">    int i = 0;</span><br><span class="line">lab:                 // Non-compliant</span><br><span class="line">    return bar(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>标签只应与 goto 语句对应，不可有其他用途，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int bar(int x) &#123;</span><br><span class="line">    int i = 0;</span><br><span class="line">strange_comment:     // Non-compliant</span><br><span class="line">    return x + i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中标签被当作注释，这是一种怪异的用法，也可能会干扰编译器的优化。<br><br/><br><br/></p>
<h4 id="参考-160"><a href="#参考-160" class="headerlink" title="参考"></a>参考</h4><p>MISRA C 2012 2.6<br><br/><br><br/></p>
<h3 id="▌R6-10-5-不应存在没有被用到的静态声明"><a href="#▌R6-10-5-不应存在没有被用到的静态声明" class="headerlink" title="▌R6.10.5 不应存在没有被用到的静态声明"></a><span id="staticnotused">▌R6.10.5 不应存在没有被用到的静态声明</span></h3><p>ID_staticNotUsed&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: declaration warning</p>
<hr/>

<p>没有被用到的静态声明往往是没有意义的，应删除或修正引用关系。  </p>
<p>类的静态成员可不受本规则限制。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static int foo();   // Compliant, used</span><br><span class="line">static int bar();   // Non-compliant, unused</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    return foo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="相关-104"><a href="#相关-104" class="headerlink" title="相关"></a>相关</h4><p>ID_unreachableCode<br><br/></p>
<h4 id="参考-161"><a href="#参考-161" class="headerlink" title="参考"></a>参考</h4><p>MISRA C++ 2008 0-1-10<br><br/><br><br/></p>
<h3 id="▌R6-10-6-不应存在没有被用到的-private-成员"><a href="#▌R6-10-6-不应存在没有被用到的-private-成员" class="headerlink" title="▌R6.10.6 不应存在没有被用到的 private 成员"></a><span id="privatenotused">▌R6.10.6 不应存在没有被用到的 private 成员</span></h3><p>ID_privateNotUsed&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: declaration warning</p>
<hr/>

<p>没有被用到的 private 成员是没有意义的，应删除或修正引用关系。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct A &#123;</span><br><span class="line">    int foo() &#123; return 1; &#125;     // Compliant</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    int bar;                    // Non-compliant, unused</span><br><span class="line">    int foo(int) &#123; return 0; &#125;  // Non-compliant, unused</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="相关-105"><a href="#相关-105" class="headerlink" title="相关"></a>相关</h4><p>ID_unreachableCode<br><br/></p>
<h4 id="参考-162"><a href="#参考-162" class="headerlink" title="参考"></a>参考</h4><p>MISRA C++ 2008 0-1-10<br><br/><br><br/></p>
<h3 id="▌R6-10-7-不应省略声明对象或函数的类型"><a href="#▌R6-10-7-不应省略声明对象或函数的类型" class="headerlink" title="▌R6.10.7 不应省略声明对象或函数的类型"></a><span id="missingtype">▌R6.10.7 不应省略声明对象或函数的类型</span></h3><p>ID_missingType&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: declaration warning</p>
<hr/>

<p>C90 允许省略对象或函数的类型声明，但实践表明这并不是一种良好的编程方式，可读性较差。  </p>
<p>本规则仅针对 C 语言，C++ 语言不存在这种问题。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">extern a;     // Non-compliant</span><br><span class="line">const b;      // Non-compliant</span><br><span class="line">fun(void);    // Non-compliant</span><br><span class="line">typedef tp;   // Non-compliant</span><br></pre></td></tr></table></figure>
<p>例中 a、b、fun、tp 的类型被省略，默认为 int，应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">extern int a;     // Compliant</span><br><span class="line">const int b;      // Compliant</span><br><span class="line">int fun(void);    // Compliant</span><br><span class="line">typedef int tp;   // Compliant</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="参考-163"><a href="#参考-163" class="headerlink" title="参考"></a>参考</h4><p>MISRA C 2004 8.2<br>MISRA C 2012 8.1<br><br/><br><br/></p>
<h3 id="▌R6-10-8-用-stdint-h-中的类型代替-short、int、long-等类型"><a href="#▌R6-10-8-用-stdint-h-中的类型代替-short、int、long-等类型" class="headerlink" title="▌R6.10.8 用 stdint.h 中的类型代替 short、int、long 等类型"></a><span id="unportabletype">▌R6.10.8 用 stdint.h 中的类型代替 short、int、long 等类型</span></h3><p>ID_unportableType&emsp;&emsp;&emsp;&emsp;&nbsp;:bulb: declaration suggestion</p>
<hr/>

<p>short、int、long 等类型的取值范围由执行环境的架构决定，可移植性较差。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct T &#123;</span><br><span class="line">    long int x;    // Non-compliant</span><br><span class="line">    long long y;   // Non-compliant</span><br><span class="line">    short z;       // Non-compliant</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>例中成员变量在不同的平台会有不同的取值范围，C99 引入 stdint.h 解决了这一问题。  </p>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdint.h&gt;   // Or &lt;cstdint&gt; in C++</span><br><span class="line"></span><br><span class="line">struct T &#123;</span><br><span class="line">    int32_t x;   // Compliant</span><br><span class="line">    int64_t y;   // Compliant</span><br><span class="line">    int16_t z;   // Compliant</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>另外，char、wchar_t 等基本类型均有此问题，在有高可移植性要求的代码中应避免直接使用基本类型。<br><br/><br><br/></p>
<h4 id="依据-104"><a href="#依据-104" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:2011 6.2.5(5)<br>ISO/IEC 9899:2011 7.20<br>ISO/IEC 14882:2011 3.9.1(2)<br><br/></p>
<h4 id="参考-164"><a href="#参考-164" class="headerlink" title="参考"></a>参考</h4><p>MISRA C 2004 6.3<br>MISRA C 2012 Dir 4.6<br><br/><br><br/></p>
<h3 id="▌R6-10-9-避免使用已过时的标准库组件"><a href="#▌R6-10-9-避免使用已过时的标准库组件" class="headerlink" title="▌R6.10.9 避免使用已过时的标准库组件"></a><span id="obsoletestdfunction">▌R6.10.9 避免使用已过时的标准库组件</span></h3><p>ID_obsoleteStdFunction&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: declaration warning</p>
<hr/>

<p>已过时的标准库组件会被语言标准弃用，应改用更完善的替代方法。  </p>
<p>下列 C++ 标准库组件已过时：  </p>
<ul>
<li>类型 auto_ptr  </li>
<li>类型 binder1st、binder2nd 和函数 bind1st、bind2nd  </li>
<li>类型 const_mem_fun1_ref_t、const_mem_fun1_t、const_mem_fun_ref_t、const_mem_fun_t  </li>
<li>类型 ios_base 的成员 io_state、open_mode、seek_dir、streamoff、streampos  </li>
<li>类型 mem_fun1_ref_t、mem_fun1_t、mem_fun_ref_t、mem_fun_ref、mem_fun_t 和函数 mem_fun  </li>
<li>类型 pointer_to_binary_function、pointer_to_unary_function 和函数 ptr_fun  </li>
<li>函数 random_shuffle  </li>
<li>类型 strstream、strstreambuf、istrstream、ostrstream  </li>
<li>类型 unary_function、binary_function  </li>
<li>类型 unexpected_handler 和函数 unexpected、set_unexpected、get_unexpected  </li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">auto_ptr&lt;T&gt; a(new T);      // Non-compliant</span><br><span class="line">auto_ptr&lt;T&gt; b;             // Non-compliant</span><br><span class="line">void foo(auto_ptr&lt;T&gt; p);   // Non-compliant</span><br><span class="line"></span><br><span class="line">b = a;    // ‘a’ is invalid after the assignment</span><br><span class="line">foo(b);   // ‘b’ is invalid after the call</span><br><span class="line">....      // Undefined behavior if dereference ‘a’ or ‘b’</span><br></pre></td></tr></table></figure>
<p>auto_ptr 对象的赋值或传参都会引起资源所有权的转移，如 b = a 会使 a 的资源被转移到 b 中，foo(b) 会使 b 的资源转移到参数中，这种方式很容易使人误解，故 auto_ptr 被 C++11 标准判为已过时，并从 C++17 标准中移出。  </p>
<p>可使用 unique_ptr 代替 auto_ptr：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr&lt;T&gt; a = make_unique&lt;T&gt;();</span><br><span class="line">unique_ptr&lt;T&gt; b;</span><br><span class="line"></span><br><span class="line">b = a;         // Compile error</span><br><span class="line">b = move(a);   // OK, explicit moving</span><br></pre></td></tr></table></figure>
<p>unique_ptr 禁止资源所有权隐式转移，语义更为明确。<br><br/><br><br/></p>
<h4 id="相关-106"><a href="#相关-106" class="headerlink" title="相关"></a>相关</h4><p>ID_obsoleteFunction<br><br/></p>
<h4 id="依据-105"><a href="#依据-105" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 14882:2011 D.6-deprecated<br>ISO/IEC 14882:2011 D.7-deprecated<br>ISO/IEC 14882:2011 D.8-deprecated<br>ISO/IEC 14882:2011 D.9-deprecated<br>ISO/IEC 14882:2011 D.10-deprecated<br>ISO/IEC 14882:2011 D.11-deprecated<br>ISO/IEC 14882:2017 20.5.4.3.1(1)<br><br/><br><br/></p>
<h2 id="7-Exception"><a href="#7-Exception" class="headerlink" title="7. Exception"></a><span id="exception">7. Exception</span></h2><h3 id="▌R7-1-保证异常安全"><a href="#▌R7-1-保证异常安全" class="headerlink" title="▌R7.1 保证异常安全"></a><span id="exceptionunsafe">▌R7.1 保证异常安全</span></h3><p>ID_exceptionUnsafe&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: exception warning</p>
<hr/>

<p>当产生异常时，保证：  </p>
<ul>
<li>相关资源不会泄漏  </li>
<li>相关对象处于正确状态  </li>
</ul>
<p>是 C++ 异常机制可以正确工作的重要基础。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void foo() &#123;</span><br><span class="line">    lock();</span><br><span class="line">    procedure_may_throw();  // Unsafe</span><br><span class="line">    unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设 lock 是某种获取资源的操作，unlock 是释放资源的操作，procedure_may_throw 是可能抛出异常的过程，那么 foo 函数就不是异常安全的，一旦有异常抛出会导致死锁或泄露等问题。  </p>
<p>应保证资源从分配到回收的过程不被异常中断，采用对象化管理方法，使分配和回收得以自动完成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void foo() &#123;</span><br><span class="line">    LockOwner object;</span><br><span class="line">    procedure_may_throw();  // Safe</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将 lock 和 unlock 分别由 object 的构造和析构函数完成，即使 procedure_may_throw 抛出异常，相关资源也可被自动回收，实现了异常安全，资源的对象化管理方法可参见 ID_ownerlessResource。  </p>
<p>异常安全的另一个重要方面是抛出异常时应保证相关对象的状态是正确的，事务或算法在处理对象时可能要分多个步骤处理对象的多个成员，要注意中途抛出异常会造成数据不一致等问题。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class X &#123;</span><br><span class="line">    T a, b;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    void foo() &#123;</span><br><span class="line">        proc(a);</span><br><span class="line">        // ... if throw an exception ...</span><br><span class="line">        proc(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>设 a 和 b 是两个密切相关的成员，如账号和金额等，foo 是一个处理事务的函数，如果在中途抛出异常就会使对象处于错误的状态，解决方法可以考虑“复制 - 交换”模式，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class X &#123;</span><br><span class="line">    T a, b;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    void foo() &#123;</span><br><span class="line">        X copy(*this);</span><br><span class="line">        proc(copy.a);</span><br><span class="line">        proc(copy.b);</span><br><span class="line">        this-&gt;swap(copy);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void swap(X&amp; v) noexcept &#123;</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>事务先处理对象的副本，处理成功后交换副本与对象的数据，交换过程需要保证不抛出异常，这样从对象副本的生成到事务处理完毕的过程中即使抛出异常也不影响对象的状态。  </p>
<p>swap 过程不可抛出异常也是一个规则，参见 ID_throwInSwap。<br><br/><br><br/></p>
<h4 id="相关-107"><a href="#相关-107" class="headerlink" title="相关"></a>相关</h4><p>ID_resourceLeak<br>ID_ownerlessResource<br>ID_throwInSwap<br><br/></p>
<h4 id="参考-165"><a href="#参考-165" class="headerlink" title="参考"></a>参考</h4><p>SEI CERT ERR56-CPP<br>Effective C++ item 29<br><br/><br><br/></p>
<h3 id="▌R7-2-处理所有异常"><a href="#▌R7-2-处理所有异常" class="headerlink" title="▌R7.2 处理所有异常"></a><span id="uncaughtexception">▌R7.2 处理所有异常</span></h3><p>ID_uncaughtException&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: exception warning</p>
<hr/>

<p>如果被抛出的异常没有被相应的 catch 子句处理会引发 std::terminate 函数的执行，使程序异常终止。  </p>
<p>应避免 std::terminate 函数被执行。std::terminate 函数执行前相关调用栈中的对象是否会被析构由实现定义。std::terminate 函数会调用由 std::set_terminate 指定的回调函数，在默认情况下会执行 abort 函数终止进程，但打开的流是否会被关闭，缓冲区内的数据是否会写入文件，临时文件是否会被清理等问题仍由实现定义。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;&#125;;</span><br><span class="line">class B &#123;&#125;;</span><br><span class="line">class C &#123;&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        int i = userInput();</span><br><span class="line">        if (i &lt; 0) &#123;</span><br><span class="line">            throw A();   // Compliant </span><br><span class="line">        &#125;</span><br><span class="line">        if (i == 0) &#123;</span><br><span class="line">            throw B();   // Compliant</span><br><span class="line">        &#125;</span><br><span class="line">        if (i &gt; 5) &#123;</span><br><span class="line">            throw C();   // Non-compliant, missing handler</span><br><span class="line">        &#125;</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">    catch (A&amp;) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (B&amp;) &#123;</span><br><span class="line">        throw;     // Non-compliant, missing handler</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="相关-108"><a href="#相关-108" class="headerlink" title="相关"></a>相关</h4><p>ID_throwOutOfMain<br>ID_implementationDefinedFunction<br><br/></p>
<h4 id="依据-106"><a href="#依据-106" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 14882:2003 15.3(9)-implementation<br>ISO/IEC 14882:2003 15.5.1(2)-implementation<br>ISO/IEC 14882:2011 15.3(9)-implementation<br>ISO/IEC 14882:2011 15.5.1(2)-implementation<br><br/></p>
<h4 id="参考-166"><a href="#参考-166" class="headerlink" title="参考"></a>参考</h4><p>MISRA C++ 2008 15-3-2<br>MISRA C++ 2008 15-3-4<br>SEI CERT ERR51-CPP<br><br/><br><br/></p>
<h3 id="▌R7-3-不应抛出过于宽泛的异常"><a href="#▌R7-3-不应抛出过于宽泛的异常" class="headerlink" title="▌R7.3 不应抛出过于宽泛的异常"></a><span id="throwgenericexception">▌R7.3 不应抛出过于宽泛的异常</span></h3><p>ID_throwGenericException&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: exception warning</p>
<hr/>

<p>抛出过于宽泛的异常，如 std::exception、std::logic_error、std::runtime_error 等类型的异常，会使异常处理失去针对性，而且处理这种异常时很可能会将本不应处理的异常一并捕获。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void foo(int a) try</span><br><span class="line">&#123;</span><br><span class="line">    if (a &lt; 0) &#123;</span><br><span class="line">        throw std::exception();   // Non-compliant</span><br><span class="line">    &#125;</span><br><span class="line">    bar(a);   // Other exceptions may be thrown</span><br><span class="line">&#125;</span><br><span class="line">catch (std::exception&amp;)   // Other exceptions are also caught</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;wrong argument\n&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>foo 函数在参数不符合要求时抛出 std::exception 类的异常，过于宽泛，如果 bar 函数抛出从 std::exception 派生的其他异常，也会被当作“参数不符合要求”处理。  </p>
<p>应为异常定义具体的类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class WrongArg &#123;&#125;;</span><br><span class="line"></span><br><span class="line">void foo(int a) try</span><br><span class="line">&#123;</span><br><span class="line">    if (a &lt; 0) &#123;</span><br><span class="line">        throw WrongArg();   // Compliant</span><br><span class="line">    &#125;</span><br><span class="line">    bar(a);</span><br><span class="line">&#125;</span><br><span class="line">catch (WrongArg&amp;)   // Right</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;wrong argument\n&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="相关-109"><a href="#相关-109" class="headerlink" title="相关"></a>相关</h4><p>ID_catch_generic<br><br/></p>
<h4 id="参考-167"><a href="#参考-167" class="headerlink" title="参考"></a>参考</h4><p>CWE-397<br><br/><br><br/></p>
<h3 id="▌R7-4-不应捕获过于宽泛的异常"><a href="#▌R7-4-不应捕获过于宽泛的异常" class="headerlink" title="▌R7.4 不应捕获过于宽泛的异常"></a><span id="catch_generic">▌R7.4 不应捕获过于宽泛的异常</span></h3><p>ID_catch_generic&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: exception warning</p>
<hr/>

<p>捕获过于宽泛的异常，如捕获 std::exception、std::logic_error、std::runtime_error 等类型的异常，或使用 catch(…) 子句捕获所有异常，会使异常处理失去针对性，而且很可能会将本不应处理的异常一并捕获。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class WrongArg &#123;&#125;;</span><br><span class="line"></span><br><span class="line">void foo(int a) try</span><br><span class="line">&#123;</span><br><span class="line">    if (a &lt; 0) &#123;</span><br><span class="line">        throw WrongArg();</span><br><span class="line">    &#125;</span><br><span class="line">    bar(a);   // Other exceptions may be thrown</span><br><span class="line">&#125;</span><br><span class="line">catch (...)   // Non-compliant</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;wrong argument\n&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中 foo 函数在参数不符合要求时抛出异常，bar 函数会抛出其他异常，用 catch(…) 子句将所有异常都当作“参数不符合要求”是不合理的。  </p>
<p>例外：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">try</span><br><span class="line">&#123;</span><br><span class="line">    ext_interface();   // External interface</span><br><span class="line">&#125;</span><br><span class="line">catch (std::exception&amp; e)   // Let it go, but comments are required</span><br><span class="line">&#123;</span><br><span class="line">    log(e.what());</span><br><span class="line">&#125;</span><br><span class="line">catch (...)   // Let it go, but comments are required</span><br><span class="line">&#123;</span><br><span class="line">    log(&quot;unknown exception&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当不受控制的外部代码会抛出未知的异常时，可酌情捕获宽泛类型的异常，但应配以文档说明问题。<br><br/><br><br/></p>
<h4 id="相关-110"><a href="#相关-110" class="headerlink" title="相关"></a>相关</h4><p>ID_throwGenericException<br><br/></p>
<h4 id="参考-168"><a href="#参考-168" class="headerlink" title="参考"></a>参考</h4><p>CWE-396<br><br/><br><br/></p>
<h3 id="▌R7-5-不应抛出非异常类型的对象"><a href="#▌R7-5-不应抛出非异常类型的对象" class="headerlink" title="▌R7.5 不应抛出非异常类型的对象"></a><span id="thrownonexceptiontype">▌R7.5 不应抛出非异常类型的对象</span></h3><p>ID_throwNonExceptionType&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: exception warning</p>
<hr/>

<p>不应将整数、字符串等非异常类的对象当作异常抛出，否则意味着异常相关的设计是不健全的。  </p>
<p>完善的异常类型应满足如下需求：  </p>
<ul>
<li>可以将异常合理分类  </li>
<li>提供对异常情况的准确描述  </li>
<li>使异常便于处理和调试  </li>
</ul>
<p>非异常类型难以满足这种需求。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void foo() &#123;</span><br><span class="line">    if (cond) &#123;</span><br><span class="line">        throw 1;   // Non-compliant</span><br><span class="line">    &#125;</span><br><span class="line">    throw &quot;message&quot;;   // Non-compliant</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整数或字符串无法区分异常的种类，如果不同的功能模块均将简单变量作为异常，很容易产生冲突。  </p>
<p>如果条件允许，应选择适当的标准异常类作为基类，并实现相关接口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class MyError: public std::logic_error &#123;</span><br><span class="line">public:</span><br><span class="line">    MyError(const char* msg): std::logic_error(msg) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void bar() &#123;</span><br><span class="line">    throw MyError(&quot;message&quot;);   // Compliant</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样可使异常类形成继承体系，便于分类管理。  </p>
<p>另外，要注意 throw、try、catch 等关键字应专注于异常处理，不应使用这些关键字控制程序的业务流程，业务代码与异常处理代码应有明显区别，否则会使代码含混不明，效率也会降低，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void bar(const vector&lt;string&gt;&amp; v, const string&amp; s) &#123;</span><br><span class="line">    auto b = v.begin();</span><br><span class="line">    auto e = v.end();</span><br><span class="line">    for (auto i = b; i != e; ++i) &#123;</span><br><span class="line">        if (*i == s) &#123;</span><br><span class="line">            throw i - b;   // Non-compliant</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    throw -1;   // Non-compliant</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中 bar 函数抛出字符串 s 在容器 v 中的位置，用异常机制实现与异常无关的功能，是不符合要求的。<br><br/><br><br/></p>
<h4 id="配置-18"><a href="#配置-18" class="headerlink" title="配置"></a>配置</h4><p>mustInheritStdException：是否要求异常类必须派生自 std::exception<br><br/></p>
<h4 id="相关-111"><a href="#相关-111" class="headerlink" title="相关"></a>相关</h4><p>ID_catch_nonExceptionType<br><br/></p>
<h4 id="参考-169"><a href="#参考-169" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines E.14<br>C++ Core Guidelines E.3<br><br/><br><br/></p>
<h3 id="▌R7-6-不应捕获非异常类型的对象"><a href="#▌R7-6-不应捕获非异常类型的对象" class="headerlink" title="▌R7.6 不应捕获非异常类型的对象"></a><span id="catch_nonexceptiontype">▌R7.6 不应捕获非异常类型的对象</span></h3><p>ID_catch_nonExceptionType&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: exception warning</p>
<hr/>

<p>整数、字符串等非异常类的对象不应被当作异常捕获，否则意味着异常相关的设计是不健全的。  </p>
<p>可参见  ID_throwNonExceptionType 的进一步讨论。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    ....</span><br><span class="line">&#125; catch (int) &#123;   // Non-compliant</span><br><span class="line">    ....</span><br><span class="line">&#125; catch (char*) &#123;   // Non-compliant</span><br><span class="line">    ....</span><br><span class="line">&#125; catch (string&amp;) &#123;   // Non-compliant</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="相关-112"><a href="#相关-112" class="headerlink" title="相关"></a>相关</h4><p>ID_throwNonExceptionType<br><br/></p>
<h4 id="参考-170"><a href="#参考-170" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines E.14<br><br/><br><br/></p>
<h3 id="▌R7-7-全局对象的初始化过程不可抛出异常"><a href="#▌R7-7-全局对象的初始化过程不可抛出异常" class="headerlink" title="▌R7.7 全局对象的初始化过程不可抛出异常"></a><span id="throwoutofmain">▌R7.7 全局对象的初始化过程不可抛出异常</span></h3><p>ID_throwOutOfMain&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: exception warning</p>
<hr/>

<p>在全局对象初始化过程中抛出的异常没有被处理的机会，导致程序异常终止。  </p>
<p>本规则是 ID_uncaughtException 的特化。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct G &#123;</span><br><span class="line">    G() noexcept(0);   // May throw exceptions</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static G g;   // Non-compliant</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果例中全局对象 g 的构造函数抛出异常，会引发 std::terminate 函数的执行，使程序异常终止。  </p>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">G* getG() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        static G g;</span><br><span class="line">        return &amp;g;</span><br><span class="line">    &#125; catch (Exceptions&amp;) &#123;  // Exceptions thrown by ‘G::G()’</span><br><span class="line">        ....                 // Handle the exceptions</span><br><span class="line">    &#125;</span><br><span class="line">    return nullptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    if (!getG()) &#123;</span><br><span class="line">        return 1;     // Good, exit gracefully</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="相关-113"><a href="#相关-113" class="headerlink" title="相关"></a>相关</h4><p>ID_uncaughtException<br><br/></p>
<h4 id="依据-107"><a href="#依据-107" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 14882:2003 15.3(9)-implementation<br>ISO/IEC 14882:2003 15.5.1(2)-implementation<br>ISO/IEC 14882:2011 15.3(9)-implementation<br>ISO/IEC 14882:2011 15.5.1(2)-implementation<br><br/></p>
<h4 id="参考-171"><a href="#参考-171" class="headerlink" title="参考"></a>参考</h4><p>MISRA C++ 2008 15-3-1<br>SEI CERT ERR58-CPP<br><br/><br><br/></p>
<h3 id="▌R7-8-析构函数不可抛出异常"><a href="#▌R7-8-析构函数不可抛出异常" class="headerlink" title="▌R7.8 析构函数不可抛出异常"></a><span id="throwindestructor">▌R7.8 析构函数不可抛出异常</span></h3><p>ID_throwInDestructor&emsp;&emsp;&emsp;&emsp;&nbsp;:boom: exception error</p>
<hr/>

<p>析构函数抛出异常会违反异常处理机制。  </p>
<p>当抛出异常时，从异常被抛出到异常被处理之间的对象，也就是从“throw”到“catch”各层调用栈中的对象会被自动析构，如果这个过程中某个对象的析构函数又抛出异常便违反了异常处理机制，这种情况将直接引发 std::terminate 函数的执行，所以从析构函数抛出的异常可能无法被捕获和处理，也可能导致程序异常终止。  </p>
<p>示例（设 E0 和 E1 是不相关的异常类）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    ....</span><br><span class="line">public:</span><br><span class="line">   ~A() try &#123;</span><br><span class="line">        if (cond0) &#123;</span><br><span class="line">            throw E0();    // Non-compliant, propagate out</span><br><span class="line">        &#125;</span><br><span class="line">        else if (cond1) &#123;</span><br><span class="line">            throw E1();    // OK, digested by itself</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (const E1&amp;) &#123;</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>建议将析构函数声明为 noexcept。  </p>
<p>与析构相关的过程也不应抛出异常：  </p>
<ul>
<li>资源回收  </li>
<li>delete、delete[] 运算符  </li>
<li>具有 free、clear、release 等语义的函数  </li>
</ul>
<p>另外，具有 swap、hash 等语义以及移动构造或赋值相关的过程也不应抛出异常，详见相关规则。<br><br/><br><br/></p>
<h4 id="相关-114"><a href="#相关-114" class="headerlink" title="相关"></a>相关</h4><p>ID_throwInDelete<br>ID_throwInHash<br>ID_throwInSwap<br>ID_throwInMove<br><br/></p>
<h4 id="依据-108"><a href="#依据-108" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 14882:2003 15.2(3)<br>ISO/IEC 14882:2011 3.7.4.2(3)-undefined<br>ISO/IEC 14882:2011 15.2(3)<br><br/></p>
<h4 id="参考-172"><a href="#参考-172" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines C.36<br>C++ Core Guidelines C.37<br>MISRA C++ 2008 15-5-1<br>SEI CERT DCL57-CPP<br><br/><br><br/></p>
<h3 id="▌R7-9-内存回收函数不可抛出异常"><a href="#▌R7-9-内存回收函数不可抛出异常" class="headerlink" title="▌R7.9 内存回收函数不可抛出异常"></a><span id="throwindelete">▌R7.9 内存回收函数不可抛出异常</span></h3><p>ID_throwInDelete&emsp;&emsp;&emsp;&emsp;&nbsp;:boom: exception error</p>
<hr/>

<p>内存回收函数抛出异常会导致标准未定义的行为。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    ....</span><br><span class="line">public:</span><br><span class="line">    void operator delete(void* p) &#123;</span><br><span class="line">        if (!p) &#123;</span><br><span class="line">            throw Exception();    // Non-compliant, undefined behavior</span><br><span class="line">        &#125;</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="相关-115"><a href="#相关-115" class="headerlink" title="相关"></a>相关</h4><p>ID_throwInDestructor<br>ID_throwInHash<br>ID_throwInSwap<br>ID_throwInMove<br><br/></p>
<h4 id="依据-109"><a href="#依据-109" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 14882:2003 15.2(3)<br>ISO/IEC 14882:2011 3.7.4.2(3)-undefined<br>ISO/IEC 14882:2011 15.2(3)<br><br/></p>
<h4 id="参考-173"><a href="#参考-173" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines E.16<br><br/><br><br/></p>
<h3 id="▌R7-10-对象交换过程不可抛出异常"><a href="#▌R7-10-对象交换过程不可抛出异常" class="headerlink" title="▌R7.10 对象交换过程不可抛出异常"></a><span id="throwinswap">▌R7.10 对象交换过程不可抛出异常</span></h3><p>ID_throwInSwap&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: exception warning</p>
<hr/>

<p>两个对象在交换（swap）过程中，每个对象的状态都是不完整的，如果在交换中途抛出异常，对象将处于错误的状态。  </p>
<p>注意，交换是保证异常安全的重要手段，不抛出异常是基本要求，详见 ID_exceptionUnsafe。标准库中存在大量与交换相关的接口和算法，如果抛出异常也会使标准库无法按约定工作，所有交换相关的函数均应标记为 noexcept。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">struct T &#123;</span><br><span class="line">    int* ptr = nullptr;</span><br><span class="line"></span><br><span class="line">    void swap(T&amp; a) &#123;</span><br><span class="line">        int* tmp = ptr;</span><br><span class="line">        ptr = a.ptr;</span><br><span class="line">        if (!ptr) &#123;</span><br><span class="line">            throw Exception();   // Non-compliant</span><br><span class="line">        &#125;</span><br><span class="line">        a.ptr = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   ~T() &#123;</span><br><span class="line">        delete[] p;  // Problems</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="相关-116"><a href="#相关-116" class="headerlink" title="相关"></a>相关</h4><p>ID_exceptionUnsafe<br>ID_throwInMove<br><br/></p>
<h4 id="参考-174"><a href="#参考-174" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines C.84<br>C++ Core Guidelines C.85<br><br/><br><br/></p>
<h3 id="▌R7-11-移动构造函数和移动赋值运算符不可抛出异常"><a href="#▌R7-11-移动构造函数和移动赋值运算符不可抛出异常" class="headerlink" title="▌R7.11 移动构造函数和移动赋值运算符不可抛出异常"></a><span id="throwinmove">▌R7.11 移动构造函数和移动赋值运算符不可抛出异常</span></h3><p>ID_throwInMove&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: exception warning</p>
<hr/>

<p>在移动过程中，对象的状态是不完整的，如果在中途抛出异常，对象将处于错误的状态。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct T &#123;</span><br><span class="line">    void swap(T&amp;) noexcept(false);   // May throw, breaks ID_throwInSwap</span><br><span class="line"></span><br><span class="line">    T(T&amp;&amp; a) &#123;   // Non-compliant</span><br><span class="line">        swap(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T&amp; operator = (T&amp;&amp; a) &#123;   // Non-compliant</span><br><span class="line">        swap(a);</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>例中 swap 函数会抛出异常，意味着移动构造函数和移动赋值运算符也会抛出异常，是不符合要求的。<br><br/><br><br/></p>
<h4 id="相关-117"><a href="#相关-117" class="headerlink" title="相关"></a>相关</h4><p>ID_throwInSwap<br><br/></p>
<h4 id="参考-175"><a href="#参考-175" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines C.66<br><br/><br><br/></p>
<h3 id="▌R7-12-异常类的拷贝构造函数不可抛出异常"><a href="#▌R7-12-异常类的拷贝构造函数不可抛出异常" class="headerlink" title="▌R7.12 异常类的拷贝构造函数不可抛出异常"></a><span id="throwwhilethrowing">▌R7.12 异常类的拷贝构造函数不可抛出异常</span></h3><p>ID_throwWhileThrowing&emsp;&emsp;&emsp;&emsp;&nbsp;:boom: exception error</p>
<hr/>

<p>异常类的拷贝构造函数抛出异常违反异常处理机制，导致程序异常终止。  </p>
<p>当抛出异常时，throw 表达式指定的异常对象会被复制，用以初始化对应的 catch 子句的参数，如果在复制过程中又抛出异常便违反了异常处理机制，这种情况将直接引发 std::terminate 函数的执行，使程序异常终止。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class E &#123;</span><br><span class="line">public:</span><br><span class="line">    E() &#123;&#125;</span><br><span class="line">    E(const E&amp;) &#123;</span><br><span class="line">        throw 0;    // Non-compliant</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        E e0;</span><br><span class="line">        throw e0;   // Throw while throwing, calls std::terminate()</span><br><span class="line">    &#125;</span><br><span class="line">    catch (E&amp; e1) &#123;</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中 catch 子句的参数 e1 引用由 e0 复制而成的临时对象，在复制过程中抛出的异常无法被捕获，会直接导致程序异常终止。<br><br/><br><br/></p>
<h4 id="相关-118"><a href="#相关-118" class="headerlink" title="相关"></a>相关</h4><p>ID_exceptionInException<br><br/></p>
<h4 id="依据-110"><a href="#依据-110" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 14882:2003 15.1(3)<br>ISO/IEC 14882:2011 15.1(3 7)<br>ISO/IEC 14882:2017 18.1(3 7)<br><br/></p>
<h4 id="参考-176"><a href="#参考-176" class="headerlink" title="参考"></a>参考</h4><p>SEI CERT ERR60-CPP<br><br/><br><br/></p>
<h3 id="▌R7-13-异常类的构造函数和异常信息相关的函数不应抛出异常"><a href="#▌R7-13-异常类的构造函数和异常信息相关的函数不应抛出异常" class="headerlink" title="▌R7.13 异常类的构造函数和异常信息相关的函数不应抛出异常"></a><span id="exceptioninexception">▌R7.13 异常类的构造函数和异常信息相关的函数不应抛出异常</span></h3><p>ID_exceptionInException&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: exception warning</p>
<hr/>

<p>创建、复制异常对象以及获取异常信息时不应再抛出异常，否则不利于异常的定位与处理。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Exception &#123;</span><br><span class="line">    string msg;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    Exception(const char* s) &#123;</span><br><span class="line">        if (!s) &#123;</span><br><span class="line">            throw AnotherException();  // Non-compliant</span><br><span class="line">        &#125;</span><br><span class="line">        msg.assign(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const char* what() const &#123;</span><br><span class="line">        if (msg.empty()) &#123;</span><br><span class="line">            throw AnotherException();  // Non-compliant</span><br><span class="line">        &#125;</span><br><span class="line">        return msg.c_str();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>例中在异常类的构造函数和 what 函数中抛出异常是不符合要求的，而且要注意 string 的构造及拷贝构造函数需要动态内存分配，当分配失败时也会抛出异常，有高可靠性要求的软件系统需要规避。  </p>
<p>自定义的异常类可从标准异常类派生，成员也应尽量简单，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Exception: public logic_error &#123;</span><br><span class="line">public:</span><br><span class="line">    explicit Exception(const string&amp; msg):</span><br><span class="line">        logic_error(msg)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中 logic_error 是标准异常类，在实际代码中也可以选择 runtime_error 等其他标准异常类作为基类。<br><br/><br><br/></p>
<h4 id="相关-119"><a href="#相关-119" class="headerlink" title="相关"></a>相关</h4><p>ID_throwWhileThrowing<br><br/></p>
<h4 id="依据-111"><a href="#依据-111" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 14882:2003 18.6.1<br>ISO/IEC 14882:2011 18.8.1<br><br/></p>
<h4 id="参考-177"><a href="#参考-177" class="headerlink" title="参考"></a>参考</h4><p>MISRA C++ 2008 15-1-1<br><br/><br><br/></p>
<h3 id="▌R7-14-与标准库相关的-hash-过程不应抛出异常"><a href="#▌R7-14-与标准库相关的-hash-过程不应抛出异常" class="headerlink" title="▌R7.14 与标准库相关的 hash 过程不应抛出异常"></a><span id="throwinhash">▌R7.14 与标准库相关的 hash 过程不应抛出异常</span></h3><p>ID_throwInHash&emsp;&emsp;&emsp;&emsp;&nbsp;:bulb: exception suggestion</p>
<hr/>

<p>对象的 hash 过程中不应抛出异常，否则相关的容器和算法无法正常工作。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct U &#123;   // User defined type</span><br><span class="line">    int* p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;&gt; struct std::hash&lt;U&gt; &#123;   // Hash specialization</span><br><span class="line">    using argument_type = U;</span><br><span class="line">    using result_type = size_t;</span><br><span class="line"></span><br><span class="line">    size_t operator()(const U&amp; u) const &#123;</span><br><span class="line">        if (!u.p) &#123;</span><br><span class="line">            throw Exception();   // Non-compliant</span><br><span class="line">        &#125;</span><br><span class="line">        return hash&lt;int*&gt;()(u.p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>标准库规定容器的 find、count 等方法应通过返回值表示对象存在与否，然而如果 hash 过程抛出异常，这些方法也会抛出异常，相当于打破了这种约定，易造成意料之外的结果。<br><br/><br><br/></p>
<h4 id="参考-178"><a href="#参考-178" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines C.89<br><br/><br><br/></p>
<h3 id="▌R7-15-由-noexcept-标记的函数不可产生未处理的异常"><a href="#▌R7-15-由-noexcept-标记的函数不可产生未处理的异常" class="headerlink" title="▌R7.15 由 noexcept 标记的函数不可产生未处理的异常"></a><span id="throwinnoexcept">▌R7.15 由 noexcept 标记的函数不可产生未处理的异常</span></h3><p>ID_throwInNoexcept&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: exception warning</p>
<hr/>

<p>由 noexcept 标记的函数产生未被处理的异常属于逻辑错误，会引发 std::terminate 函数的执行，使程序异常终止。  </p>
<p>程序异常终止所产生的问题可参见 ID_uncaughtException 的进一步讨论。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void foo() noexcept</span><br><span class="line">&#123;</span><br><span class="line">    throw Exception();   // Non-compliant, calls std::terminate()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应处理相关异常或修正异常说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void foo() noexcept(false)</span><br><span class="line">&#123;</span><br><span class="line">    throw Exception();   // Compliant</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="相关-120"><a href="#相关-120" class="headerlink" title="相关"></a>相关</h4><p>ID_uncaughtException<br><br/></p>
<h4 id="依据-112"><a href="#依据-112" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 14882:2011 15.4(9)<br>ISO/IEC 14882:2017 18.4(5)<br><br/></p>
<h4 id="参考-179"><a href="#参考-179" class="headerlink" title="参考"></a>参考</h4><p>SEI CERT ERR55-CPP<br><br/><br><br/></p>
<h3 id="▌R7-16-避免异常类多重继承自同一非虚基类"><a href="#▌R7-16-避免异常类多重继承自同一非虚基类" class="headerlink" title="▌R7.16 避免异常类多重继承自同一非虚基类"></a><span id="diamondexceptioninheritance">▌R7.16 避免异常类多重继承自同一非虚基类</span></h3><p>ID_diamondExceptionInheritance&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: exception warning</p>
<hr/>

<p>当异常类有多个基类，这些基类又派生自同一非虚基类时，无法通过该非虚基类捕获异常。  </p>
<p>本规则是 ID_diamondInheritance 的特化。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;&#125;;</span><br><span class="line">class B: public A &#123;&#125;;</span><br><span class="line">class C: public A &#123;&#125;;</span><br><span class="line">class D: public B, public C &#123;&#125;;  // Non-compliant</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        throw D();</span><br><span class="line">    &#125;</span><br><span class="line">    catch (A&amp;) &#123;  // Cannot catch derived objects</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中基类 A 在派生类 D 中会有多个实例，在这种情况下无法通过基类 A 捕获派生类的对象。  </p>
<p>应将 A 设为虚基类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;&#125;;</span><br><span class="line">class B: virtual public A &#123;&#125;;</span><br><span class="line">class C: virtual public A &#123;&#125;;</span><br><span class="line">class D: public B, public C &#123;&#125;;  // Compliant</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="相关-121"><a href="#相关-121" class="headerlink" title="相关"></a>相关</h4><p>ID_diamondInheritance<br><br/></p>
<h4 id="依据-113"><a href="#依据-113" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 14882:2003 10.1(4 5 6)<br>ISO/IEC 14882:2011 10.1(4 5 6 7)<br><br/><br><br/></p>
<h3 id="▌R7-17-通过引用捕获异常"><a href="#▌R7-17-通过引用捕获异常" class="headerlink" title="▌R7.17 通过引用捕获异常"></a><span id="catch_value">▌R7.17 通过引用捕获异常</span></h3><p>ID_catch_value&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: exception warning</p>
<hr/>

<p>通过值捕获异常可能会导致“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Object_slicing">对象切片</a>”，通过指针捕获异常会增加内存管理成本，通过引用捕获异常才是最合理的方式。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    ....</span><br><span class="line">&#125; catch (Exception e) &#123;   // Non-compliant</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中 Exception 是异常类，用传值的方式捕获异常是不符合要求的。  </p>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    ....</span><br><span class="line">&#125; catch (Exception&amp; e) &#123;   // Compliant</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过指针捕获异常也是不符合要求的，参见 ID_throwPointer。<br><br/><br><br/></p>
<h4 id="相关-122"><a href="#相关-122" class="headerlink" title="相关"></a>相关</h4><p>ID_catch_slicing<br>ID_throwPointer<br><br/></p>
<h4 id="参考-180"><a href="#参考-180" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines E.15<br>C++ Core Guidelines ES.63<br>MISRA C++ 2008 15-3-5<br>SEI CERT ERR61-CPP<br><br/><br><br/></p>
<h3 id="▌R7-18-捕获异常时不应产生对象切片问题"><a href="#▌R7-18-捕获异常时不应产生对象切片问题" class="headerlink" title="▌R7.18 捕获异常时不应产生对象切片问题"></a><span id="catch_slicing">▌R7.18 捕获异常时不应产生对象切片问题</span></h3><p>ID_catch_slicing&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: exception warning</p>
<hr/>

<p>通过值捕获多态类的异常对象会使其多态性失效，使异常被错误处理。  </p>
<p>本规则是 ID_catch_value 与 ID_objectSlicing 的特化。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">struct Exception &#123;</span><br><span class="line">    virtual const char* what() const &#123; return nullptr; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct Error: public Exception &#123;</span><br><span class="line">    const char* what() const override &#123; return &quot;error&quot;; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void foo() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        throw Error();</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Exception e) &#123;   // Non-compliant, use reference instead</span><br><span class="line">        log(e.what());      // Only returns nullptr</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中抛出的是派生类对象，但 what 函数只能返回 nullptr。<br><br/><br><br/></p>
<h4 id="相关-123"><a href="#相关-123" class="headerlink" title="相关"></a>相关</h4><p>ID_catch_value<br>ID_objectSlicing<br><br/></p>
<h4 id="参考-181"><a href="#参考-181" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines C.145<br>C++ Core Guidelines ES.63<br><br/><br><br/></p>
<h3 id="▌R7-19-捕获异常后不应直接再次抛出异常"><a href="#▌R7-19-捕获异常后不应直接再次抛出异常" class="headerlink" title="▌R7.19 捕获异常后不应直接再次抛出异常"></a><span id="catch_justrethrow">▌R7.19 捕获异常后不应直接再次抛出异常</span></h3><p>ID_catch_justRethrow&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: exception warning</p>
<hr/>

<p>捕获异常后将其直接再次抛出是没有意义的，还会造成不必要的开销。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void foo() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        bar();</span><br><span class="line">    &#125;</span><br><span class="line">    catch (...) &#123;</span><br><span class="line">        throw;      // Non-compliant</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中的 catch 子句是没有意义的，应将其去掉或对异常进行有效处理。<br><br/><br><br/><br><br/></p>
<h3 id="▌R7-20-重新抛出异常时应使用空-throw-表达式（throw-）"><a href="#▌R7-20-重新抛出异常时应使用空-throw-表达式（throw-）" class="headerlink" title="▌R7.20 重新抛出异常时应使用空 throw 表达式（throw;）"></a><span id="improperrethrow">▌R7.20 重新抛出异常时应使用空 throw 表达式（throw;）</span></h3><p>ID_improperRethrow&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: exception warning</p>
<hr/>

<p>重新抛出异常时应使用空 throw 表达式，避免异常对象的精度损失和不必要的复制开销。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Base &#123;&#125;;</span><br><span class="line">class Derive: public Base &#123;&#125;;</span><br><span class="line"></span><br><span class="line">void foo() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        throw Derive();</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Base&amp; e) &#123;</span><br><span class="line">        throw e;        // Non-compliant, use ‘throw;’ instead</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void bar() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        foo();</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Derive&amp; e) &#123;   // Cannot catch Derive</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，例中 foo 函数虽然捕获的是 Derive 对象，但 throw e; 抛出的是 Base 对象，这也是一种“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Object_slicing">对象切片</a>”问题，造成了对象类型的“精度损失”。将 throw e; 改为 throw; 可解决这种问题。<br><br/><br><br/></p>
<h4 id="依据-114"><a href="#依据-114" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 14882:2003 15.1(6)<br>ISO/IEC 14882:2011 15.1(8)<br><br/><br><br/></p>
<h3 id="▌R7-21-不应在-catch-子句外使用空-throw-表达式（throw-）"><a href="#▌R7-21-不应在-catch-子句外使用空-throw-表达式（throw-）" class="headerlink" title="▌R7.21 不应在 catch 子句外使用空 throw 表达式（throw;）"></a><span id="rethrowoutofcatch">▌R7.21 不应在 catch 子句外使用空 throw 表达式（throw;）</span></h3><p>ID_rethrowOutOfCatch&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: exception warning</p>
<hr/>

<p>空 throw 表达式用于重新抛出当前捕获的异常，用在 catch 子句外是危险的，增大了流程控制的复杂性。  </p>
<p>如果当前没有异常被捕获，空 throw 表达式会引发 std::terminate 函数的执行，导致程序异常终止。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void foo() &#123;</span><br><span class="line">    throw;     // Non-compliant</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void bar() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        throw;   // Non-compliant</span><br><span class="line">    &#125;</span><br><span class="line">    catch (...) &#123;   // Cannot catch ‘throw;’</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="依据-115"><a href="#依据-115" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 14882:2003 15.1(6 8)<br>ISO/IEC 14882:2003 15.3(9)-implementation<br>ISO/IEC 14882:2011 15.1(8 9)<br>ISO/IEC 14882:2011 15.3(9)-implementation<br><br/></p>
<h4 id="参考-182"><a href="#参考-182" class="headerlink" title="参考"></a>参考</h4><p>MISRA C++ 2008 15-1-3<br><br/><br><br/></p>
<h3 id="▌R7-22-不应抛出指针"><a href="#▌R7-22-不应抛出指针" class="headerlink" title="▌R7.22 不应抛出指针"></a><span id="throwpointer">▌R7.22 不应抛出指针</span></h3><p>ID_throwPointer&emsp;&emsp;&emsp;&emsp;&nbsp;:bulb: exception suggestion</p>
<hr/>

<p>抛出指针会增加不必要的内存管理成本，也容易造成意料之外的错误。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class E &#123;&#125; e;</span><br><span class="line"></span><br><span class="line">void foo() &#123;</span><br><span class="line">    if (cond) &#123;</span><br><span class="line">        throw &amp;e;   // Non-compliant</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        throw new E;   // Non-compliant</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void bar() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        foo();</span><br><span class="line">    &#125; catch (E* p) &#123;   // ‘p’ should be deleted or not??</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中对捕获的异常指针不论释放还是不释放都有问题，改为抛出对象的方式可有效避免这种问题。<br><br/><br><br/></p>
<h4 id="参考-183"><a href="#参考-183" class="headerlink" title="参考"></a>参考</h4><p>MISRA C++ 2008 15-0-2<br><br/><br><br/></p>
<h3 id="▌R7-23-不应抛出-NULL"><a href="#▌R7-23-不应抛出-NULL" class="headerlink" title="▌R7.23 不应抛出 NULL"></a><span id="thrownull">▌R7.23 不应抛出 NULL</span></h3><p>ID_throwNULL&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: exception warning</p>
<hr/>

<p>虽然 NULL 表示空指针，但在相当一部分实现中 throw NULL 相当于 throw 0，无法区分指针与整数。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void foo() &#123;</span><br><span class="line">    throw NULL;  // Non-compliant</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void bar() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        foo();</span><br><span class="line">    &#125; catch (int) &#123;  // Which handler?</span><br><span class="line">        ....</span><br><span class="line">    &#125; catch (int*) &#123;</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中 throw NULL 意在抛出空指针，然而会被 catch(int) 子句捕获。<br><br/><br><br/></p>
<h4 id="相关-124"><a href="#相关-124" class="headerlink" title="相关"></a>相关</h4><p>ID_deprecatedNULL<br>ID_throwNonExceptionType<br>ID_throwPointer<br><br/></p>
<h4 id="依据-116"><a href="#依据-116" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 14882:2003 C.2.2.3(1)-implementation<br>ISO/IEC 14882:2011 C.3.2.4(1)-implementation<br>ISO/IEC 14882:2017 C.5.2.7(1)-implementation<br><br/></p>
<h4 id="参考-184"><a href="#参考-184" class="headerlink" title="参考"></a>参考</h4><p>CWE-351<br>MISRA C++ 2008 15-1-2<br><br/><br><br/></p>
<h3 id="▌R7-24-不应抛出-nullptr"><a href="#▌R7-24-不应抛出-nullptr" class="headerlink" title="▌R7.24 不应抛出 nullptr"></a><span id="thrownullptr">▌R7.24 不应抛出 nullptr</span></h3><p>ID_throwNullptr&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: exception warning</p>
<hr/>

<p>nullptr 可被所有接受指针的 catch 子句捕获，使异常处理失去针对性。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void foo() &#123;</span><br><span class="line">    throw nullptr;  // Non-compliant</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void bar() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        foo();</span><br><span class="line">    &#125; catch (int*) &#123;  // Which handler?</span><br><span class="line">        ....</span><br><span class="line">    &#125; catch (char*) &#123;</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="相关-125"><a href="#相关-125" class="headerlink" title="相关"></a>相关</h4><p>ID_throwPointer<br><br/></p>
<h4 id="参考-185"><a href="#参考-185" class="headerlink" title="参考"></a>参考</h4><p>MISRA C++ 2008 15-0-2<br><br/><br><br/></p>
<h3 id="▌R7-25-不应在模块之间传播异常"><a href="#▌R7-25-不应在模块之间传播异常" class="headerlink" title="▌R7.25 不应在模块之间传播异常"></a><span id="crossmoduleexception">▌R7.25 不应在模块之间传播异常</span></h3><p>ID_crossModuleException&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: exception warning</p>
<hr/>

<p>异常的传播机制依赖编译器的具体实现，在不同编译器产生的模块间传播异常会造成运行时错误。  </p>
<p>除非模块均由同一编译器的同一版本生成，否则模块供外部使用的接口不应抛出异常。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// a.dll</span><br><span class="line">void foo() &#123;</span><br><span class="line">    throw Exception();   // Non-compliant</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// b.exe</span><br><span class="line">int main() try &#123;</span><br><span class="line">    foo();</span><br><span class="line">&#125; catch (Exception&amp;) &#123;   // May not catch</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设例中 a.dll 和 b.exe 由不同的编译器生成，异常的抛出机制和捕获机制可能并不匹配，进而导致冲突。<br><br/><br><br/></p>
<h4 id="相关-126"><a href="#相关-126" class="headerlink" title="相关"></a>相关</h4><p>ID_ABIConflict<br><br/></p>
<h4 id="参考-186"><a href="#参考-186" class="headerlink" title="参考"></a>参考</h4><p>SEI CERT ERR59-CPP<br><br/><br><br/></p>
<h3 id="▌R7-26-禁用动态异常说明"><a href="#▌R7-26-禁用动态异常说明" class="headerlink" title="▌R7.26 禁用动态异常说明"></a><span id="forbidthrowspecification">▌R7.26 禁用动态异常说明</span></h3><p>ID_forbidThrowSpecification&emsp;&emsp;&emsp;&emsp;&nbsp;:no_entry: exception warning</p>
<hr/>

<p>用 throw 关键字声明的“<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/except_spec">动态异常说明（dynamic exception specification）</a>”已过时，应使用 noexcept 关键字完成异常说明。  </p>
<p>动态异常说明将所有可能抛出的异常详细列出，尤其是牵扯到外部不可控代码时，会大幅增加异常管理成本，而且各编译器相关实现并未统一，现已从 C++17 标准中移出。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int foo() throw(Exception);   // Non-compliant</span><br></pre></td></tr></table></figure>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int foo() noexcept(false);   // Compliant</span><br></pre></td></tr></table></figure>
<p>例外：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int bar() throw();   // Let it go?</span><br></pre></td></tr></table></figure>
<p>throw() 与 noexcept 等价，C++17 保留了 throw()，但不建议继续使用，审计工具不妨通过配置决定是否放过这种方式。<br><br/><br><br/></p>
<h4 id="配置-19"><a href="#配置-19" class="headerlink" title="配置"></a>配置</h4><p>forbidEmptyThrowSpecification：是否放过空 throw 异常说明<br><br/></p>
<h4 id="依据-117"><a href="#依据-117" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 14882:2011 D.4-deprecated<br>ISO/IEC 14882:2017 D.3-deprecated<br><br/></p>
<h4 id="参考-187"><a href="#参考-187" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines E.12<br>C++ Core Guidelines E.30<br><br/><br><br/></p>
<h3 id="▌R7-27-禁用-C-异常"><a href="#▌R7-27-禁用-C-异常" class="headerlink" title="▌R7.27 禁用 C++ 异常"></a><span id="forbidexception">▌R7.27 禁用 C++ 异常</span></h3><p>ID_forbidException&emsp;&emsp;&emsp;&emsp;&nbsp;:no_entry: exception warning</p>
<hr/>

<p>本规则适用如下场景，可酌情选取。  </p>
<ol>
<li>对时空性能有严格要求的项目  </li>
<li>代码所属框架不支持异常处理  </li>
<li>与 C 或其他语言兼容的接口实现  </li>
<li>项目没有依照异常安全的理念实施  </li>
</ol>
<p>利用返回值或错误码的错误处理方式要求检查可能产生错误的每一个步骤，有些出错情况可能被遗漏，C++ 的异常机制可大幅简化这种繁琐的方式，使代码更专注于事务或算法的实现，而且 C++ 异常是不可被忽略的，然而 C++ 的异常机制是需要一定开销的，对代码的设计与实现也有更严格的要求。  </p>
<p>如果异常情况频繁出现，其成本是不可被忽视的，不适用于具有高性能要求的实时软件系统。如果代码所属项目没有依照异常安全的理念实施，使用异常反而会造成更多问题，可参见 ID_exceptionUnsafe 的进一步讨论。<br><br/><br><br/></p>
<h4 id="相关-127"><a href="#相关-127" class="headerlink" title="相关"></a>相关</h4><p>ID_exceptionUnsafe<br><br/></p>
<h4 id="参考-188"><a href="#参考-188" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines E.6<br>Google C++ Style Guide.Other C++ Features.Exceptions<br><br/><br><br/></p>
<h2 id="8-Function"><a href="#8-Function" class="headerlink" title="8. Function"></a><span id="function">8. Function</span></h2><h3 id="▌R8-1-main-函数的返回类型只应为-int"><a href="#▌R8-1-main-函数的返回类型只应为-int" class="headerlink" title="▌R8.1 main 函数的返回类型只应为 int"></a><span id="mainreturnsnonint">▌R8.1 main 函数的返回类型只应为 int</span></h3><p>ID_mainReturnsNonInt&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: function warning</p>
<hr/>

<p>main 函数的返回值可作为整个进程执行情况的总结，按惯例返回 0 或 EXIT_SUCCESS 表示执行成功，非 0 或 EXIT_FAILURE 表示执行失败，main 函数的返回值会作为标准 exit 函数的参数。  </p>
<p>应采用标准明确支持的方式：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int main(void) &#123; .... &#125;                     // Compliant</span><br><span class="line">int main(int argc, char *argv[]) &#123; .... &#125;   // Compliant</span><br></pre></td></tr></table></figure>
<p>如果将返回值设为 void 或其他非 int 类型，会导致未定义、未声明或由实现定义的行为。  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void main() &#123; .... &#125;   // Non-compliant</span><br><span class="line">bool main() &#123; .... &#125;   // Non-compliant</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="依据-118"><a href="#依据-118" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 5.1.2.2.1(1)-implementation<br>ISO/IEC 9899:1999 5.1.2.2.3(1)-unspecified<br>ISO/IEC 9899:2011 5.1.2.2.1(1)-implementation<br>ISO/IEC 9899:2011 5.1.2.2.3(1)-unspecified<br>ISO/IEC 14882:2003 3.6.1(2)-implementation<br>ISO/IEC 14882:2011 3.6.1(2)-implementation<br><br/></p>
<h4 id="参考-189"><a href="#参考-189" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines F.46<br><br/><br><br/></p>
<h3 id="▌R8-2-main-函数不应被调用、重载或被-inline、static-等关键字限定"><a href="#▌R8-2-main-函数不应被调用、重载或被-inline、static-等关键字限定" class="headerlink" title="▌R8.2 main 函数不应被调用、重载或被 inline、static 等关键字限定"></a><span id="illformedmain">▌R8.2 main 函数不应被调用、重载或被 inline、static 等关键字限定</span></h3><p>ID_illFormedMain&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: function warning</p>
<hr/>

<p>main 函数作为程序的入口是一种特殊的函数，其链接性由实现定义，不应被调用、重载或被任何函数限定符修饰。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int main();   // The main function does not need to be declared</span><br><span class="line"></span><br><span class="line">int foo() &#123;</span><br><span class="line">    return main();   // Non-compliant</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(const char* p) &#123;   // Non-compliant</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline int main() &#123;   // Non-compliant</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="依据-119"><a href="#依据-119" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 6.7.4(4)<br>ISO/IEC 9899:2011 6.7.4(4)<br>ISO/IEC 14882:2003 3.6.1(2 3)-implementation<br>ISO/IEC 14882:2011 3.6.1(2 3)-implementation<br>ISO/IEC 14882:2017 6.6.1(2 3)-implementation<br><br/><br><br/></p>
<h3 id="▌R8-3-在头文件中不应实现函数或定义对象"><a href="#▌R8-3-在头文件中不应实现函数或定义对象" class="headerlink" title="▌R8.3 在头文件中不应实现函数或定义对象"></a><span id="definedinheader">▌R8.3 在头文件中不应实现函数或定义对象</span></h3><p>ID_definedInHeader&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: function warning</p>
<hr/>

<p>头文件中的函数或对象会被引入不同的翻译单元（translate-unit）造成编译冲突。  </p>
<p>常量对象和内联、模板函数可不受本规则约束，静态对象和静态函数也不受本规则约束，但受规则 ID_staticInHeader 限制。  </p>
<p>头文件是项目文档的重要组成部分，有必要保持头文件简洁清晰，头文件的主要内容应是类型或接口的声明。除非函数很简短，否则不建议在头文件中内联实现，大段的函数实现会影响头文件的可读性。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// In a header</span><br><span class="line">int a[] = &#123;1, 2, 3&#125;;   // Non-compliant</span><br><span class="line"></span><br><span class="line">int foo() &#123;    // Non-compliant</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于较为复杂的模板函数，应将其实现与声明分离，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// In a header</span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">struct A &#123;</span><br><span class="line">    T foo(T&amp;);   // Declaration</span><br><span class="line">&#125;;</span><br><span class="line">#include &quot;A.imp&quot;</span><br><span class="line"></span><br><span class="line">// In A.imp</span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">T A&lt;T&gt;::foo(T&amp; p) &#123;   // Implementation</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将模板函数的实现移入 A.imp 文件中，再由主头文件包含即可，A.imp 文件称为模板实现文件。<br><br/><br><br/></p>
<h4 id="参考-190"><a href="#参考-190" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines SF.2<br><br/><br><br/></p>
<h3 id="▌R8-4-函数的参数名称在声明处和实现处应保持一致"><a href="#▌R8-4-函数的参数名称在声明处和实现处应保持一致" class="headerlink" title="▌R8.4 函数的参数名称在声明处和实现处应保持一致"></a><span id="inconsistentparamname">▌R8.4 函数的参数名称在声明处和实现处应保持一致</span></h3><p>ID_inconsistentParamName&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: function warning</p>
<hr/>

<p>参数名称在声明处和实现处不一致会误导函数的使用者，而且很可能是实现错误。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int foo(int a, int b);    // Declaration</span><br><span class="line"></span><br><span class="line">int foo(int b, int a) &#123;   // Non-compliant, which is which??</span><br><span class="line">    return a &gt; b? 1: -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中参数 a 和 b 在声明处和实现处的顺序是颠倒的，令人非常困惑。<br><br/><br><br/></p>
<h4 id="相关-128"><a href="#相关-128" class="headerlink" title="相关"></a>相关</h4><p>ID_inconsistentDeclaration<br><br/></p>
<h4 id="参考-191"><a href="#参考-191" class="headerlink" title="参考"></a>参考</h4><p>MISRA C++ 2008 8-4-2<br><br/><br><br/></p>
<h3 id="▌R8-5-多态类的对象作为参数时不应采用值传递的方式"><a href="#▌R8-5-多态类的对象作为参数时不应采用值传递的方式" class="headerlink" title="▌R8.5 多态类的对象作为参数时不应采用值传递的方式"></a><span id="parammaybeslicing">▌R8.5 多态类的对象作为参数时不应采用值传递的方式</span></h3><p>ID_paramMayBeSlicing&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: function warning</p>
<hr/>

<p>将派生类对象通过传值的方式转换为基类对象后，不再遵循多态机制，易产生意料之外的错误，应采用指针或引用的方式传递多态类对象。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual int fun();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void foo(A);   // Non-compliant</span><br><span class="line"></span><br><span class="line">void bar(A&amp;);  // Compliant</span><br><span class="line">void baz(A*);  // Compliant</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="相关-129"><a href="#相关-129" class="headerlink" title="相关"></a>相关</h4><p>ID_objectSlicing<br><br/></p>
<h4 id="参考-192"><a href="#参考-192" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines C.145<br>C++ Core Guidelines ES.63<br><br/><br><br/></p>
<h3 id="▌R8-6-不应存在未被使用的具名形式参数"><a href="#▌R8-6-不应存在未被使用的具名形式参数" class="headerlink" title="▌R8.6 不应存在未被使用的具名形式参数"></a><span id="paramnotused">▌R8.6 不应存在未被使用的具名形式参数</span></h3><p>ID_paramNotUsed&emsp;&emsp;&emsp;&emsp;&nbsp;:bulb: function suggestion</p>
<hr/>

<p>如果函数的某个参数在函数内没有被用到，意味着函数的功能与设计之间存在差距。  </p>
<p>如果某个参数确实不需要被用到，应尽量从参数列表中将其删除，如果需要遵循某种约定而必须保留参数（如虚函数或回调函数），在 C++ 代码中不妨将参数的名称删掉，在 C 代码中可用 void 转换指明未使用的参数在预期之内，并用注释说明参数未被使用的原因。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int foo(int x) &#123;   // Non-compliant, ‘x’ is not used</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int foo(int x) &#123;   // Compliant in C</span><br><span class="line">    (void)x;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int foo(int) &#123;     // Compliant in C++</span><br><span class="line">    return 0;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="参考-193"><a href="#参考-193" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines F.9<br>MISRA C 2012 2.7<br>MISRA C++ 2008 0-1-11<br><br/><br><br/></p>
<h3 id="▌R8-7-非基本类型的常量参数不应按值传递"><a href="#▌R8-7-非基本类型的常量参数不应按值传递" class="headerlink" title="▌R8.7 非基本类型的常量参数不应按值传递"></a><span id="parampassedbyvalue">▌R8.7 非基本类型的常量参数不应按值传递</span></h3><p>ID_paramPassedByValue&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: function warning</p>
<hr/>

<p>常量参数不可被改变，按值传递产生的复制开销是没有意义的，应使用常量引用传递参数。  </p>
<p>基本类型的参数复制开销可被忽略，故不受本规则限制。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void fun(const string s) &#123;    // Non-compliant</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中 s 为按值传递的常量参数，每当函数被调用时，传入的参数会被复制成一个新的对象，但其值又不能被改变，所以这种复制是没有意义的，利用常量引用可解决这个问题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void fun(const string&amp; s) &#123;   // Compliant</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>改为常量引用后不会产生额外的复制开销。<br><br/><br><br/></p>
<h4 id="参考-194"><a href="#参考-194" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines F.16<br><br/><br><br/></p>
<h3 id="▌R8-8-转发引用只应作为-std-forward-的参数"><a href="#▌R8-8-转发引用只应作为-std-forward-的参数" class="headerlink" title="▌R8.8 转发引用只应作为 std::forward 的参数"></a><span id="illforwardingreference">▌R8.8 转发引用只应作为 std::forward 的参数</span></h3><p>ID_illForwardingReference&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: function warning</p>
<hr/>

<p>不应混淆“<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/reference#Forwarding_references">转发引用（forwarding references）</a>”与右值引用，除作为 std::forward 的参数之外，不应对转发引用再有任何操作。  </p>
<p>转发引用是类型为 T&amp;&amp; 的参数，T 为函数模板类型，无论左值还是右值均可被这种参数接受，而且 const、volatile 等属性也会被忽略，由于含有不确定的状态，所以直接操作转发引用是不妥的，只应通过 std::forward<T> 交由合适的接口处理。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int func();</span><br><span class="line">int func(int&amp;);</span><br><span class="line">int func(const int&amp;);</span><br><span class="line"></span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">int wrapper(T&amp;&amp; arg) &#123;</span><br><span class="line">    return func(arg);   // Non-compliant</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class... V&gt;</span><br><span class="line">int wrapper(V&amp;&amp;... args) &#123;</span><br><span class="line">    return func(args...);   // Non-compliant</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中 arg 和 args 为转发引用及相关参数包，不经 std::forward 的转换直接作为接口的参数无法正确选择重载的接口，应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class T&gt;</span><br><span class="line">int wrapper(T&amp;&amp; arg) &#123;</span><br><span class="line">    return func(forward&lt;T&gt;(arg));   // Compliant</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class... V&gt;</span><br><span class="line">int wrapper(V&amp;&amp;... args) &#123;</span><br><span class="line">    return func(forward&lt;V&gt;(args)...);   // Compliant</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="相关-130"><a href="#相关-130" class="headerlink" title="相关"></a>相关</h4><p>ID_unsuitableForward<br><br/></p>
<h4 id="依据-120"><a href="#依据-120" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 14882:2011 20.2.3(1)<br>ISO/IEC 14882:2017 23.2.5(1)<br><br/></p>
<h4 id="参考-195"><a href="#参考-195" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines F.19<br><br/><br><br/></p>
<h3 id="▌R8-9-局部对象在使用前应被初始化"><a href="#▌R8-9-局部对象在使用前应被初始化" class="headerlink" title="▌R8.9 局部对象在使用前应被初始化"></a><span id="localinitialization">▌R8.9 局部对象在使用前应被初始化</span></h3><p>ID_localInitialization&emsp;&emsp;&emsp;&emsp;&nbsp;:boom: function error</p>
<hr/>

<p>未初始化的局部对象具有不确定的值，读取未初始化的对象会导致标准未定义的行为。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int foo() &#123;</span><br><span class="line">    int a;         // A local object(automatic storage duration)</span><br><span class="line">    if (cond) &#123;</span><br><span class="line">        a = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return a;      // Non-compliant, may be an indeterminate value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中局部对象 a 的初始化依赖某种条件，在条件范围之外读取 a 的值会得到不确定的结果。  </p>
<p>建议对象在声明处初始化，即使不方便在声明处初始化，也应该在声明的附近进行无条件初始化：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int a = 0;    // Good</span><br><span class="line"></span><br><span class="line">int b;</span><br><span class="line">b = 123;      // OK</span><br></pre></td></tr></table></figure>
<p>不建议的模式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int a;</span><br><span class="line">if (x) &#123;</span><br><span class="line">    a = 0;</span><br><span class="line">&#125;</span><br><span class="line">....</span><br><span class="line">if (y) &#123;</span><br><span class="line">    use(a);   // Dangerous</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中 a 的初始化依赖条件 x，并在满足条件 y 时被使用，即使条件 x 和条件 y 有一定相关性可以保证对 a 的使用是正确的，也会造成潜在的维护困难，当条件比较复杂或有变化时极易出错。<br><br/><br><br/></p>
<h4 id="相关-131"><a href="#相关-131" class="headerlink" title="相关"></a>相关</h4><p>ID_illAccess<br><br/></p>
<h4 id="依据-121"><a href="#依据-121" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 6.2.4(5 6)<br>ISO/IEC 9899:2011 6.2.4(6 7)<br>ISO/IEC 9899:2011 6.3.2.1(2)-undefined<br>ISO/IEC 14882:2003 4.1(1)-undefined<br>ISO/IEC 14882:2003 8.5(9)<br>ISO/IEC 14882:2011 4.1(1)-undefined<br>ISO/IEC 14882:2011 8.5(11)<br><br/></p>
<h4 id="参考-196"><a href="#参考-196" class="headerlink" title="参考"></a>参考</h4><p>CWE-457<br>C++ Core Guidelines ES.20<br>MISRA C 2004 9.1<br>MISRA C 2012 9.1<br>MISRA C++ 2008 8-5-1<br><br/><br><br/></p>
<h3 id="▌R8-10-成员须在声明处或构造时初始化"><a href="#▌R8-10-成员须在声明处或构造时初始化" class="headerlink" title="▌R8.10 成员须在声明处或构造时初始化"></a><span id="memberinitialization">▌R8.10 成员须在声明处或构造时初始化</span></h3><p>ID_memberInitialization&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: function warning</p>
<hr/>

<p>成员的声明和使用相距较远，更容易造成未初始化先使用的问题，所以应在声明处或构造函数中初始化所有成员。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct A &#123;</span><br><span class="line">    int x;</span><br><span class="line">    int y = 0;</span><br><span class="line">    int z;</span><br><span class="line"></span><br><span class="line">    A(int i): x(i) &#123;  // Non-compliant, Missing the initialization for ‘z’</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>例中构造函数没有对 z 初始化是不符合要求的，尤其是 public 成员出现这种问题时会造成更大的风险。  </p>
<p>建议所有成员都在声明处初始化：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct A &#123;</span><br><span class="line">    int x = 0;  // Good</span><br><span class="line">    int y = 0;  // Good</span><br><span class="line">    int z = 0;  // Good</span><br><span class="line"></span><br><span class="line">    A(int i): x(i) &#123;  // Compliant</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="参考-197"><a href="#参考-197" class="headerlink" title="参考"></a>参考</h4><p>CWE-908<br>C++ Core Guidelines C.41<br><br/><br><br/></p>
<h3 id="▌R8-11-基类对象构造完毕之前不可调用成员函数"><a href="#▌R8-11-基类对象构造完毕之前不可调用成员函数" class="headerlink" title="▌R8.11 基类对象构造完毕之前不可调用成员函数"></a><span id="illmembercall">▌R8.11 基类对象构造完毕之前不可调用成员函数</span></h3><p>ID_illMemberCall&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: function warning</p>
<hr/>

<p>基类对象未构造完毕时调用成员函数会导致标准未定义的行为。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct A &#123;</span><br><span class="line">    A(int);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct B: A &#123;</span><br><span class="line">    B(): A(member()) &#123;  // Non-compliant, undefined behavior</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int member();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>例中成员函数的返回值作为基类构造函数的参数，而这时基类对象尚未构造，相当于成员函数的调用者没有被初始化，这是一种逻辑错误。<br><br/><br><br/></p>
<h4 id="依据-122"><a href="#依据-122" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 14882:2003 12.6.2(8)-undefined<br>ISO/IEC 14882:2011 12.6.2(13)-undefined<br><br/><br><br/></p>
<h3 id="▌R8-12-在面向构造或析构函数体的-catch-子句中不可访问非静态成员"><a href="#▌R8-12-在面向构造或析构函数体的-catch-子句中不可访问非静态成员" class="headerlink" title="▌R8.12 在面向构造或析构函数体的 catch 子句中不可访问非静态成员"></a><span id="illmemberaccess">▌R8.12 在面向构造或析构函数体的 catch 子句中不可访问非静态成员</span></h3><p>ID_illMemberAccess&emsp;&emsp;&emsp;&emsp;&nbsp;:boom: function error</p>
<hr/>

<p>当流程进入面向构造或析构函数体的 catch 子句时，非静态成员的生命周期已结束，如果继续访问会导致标准未定义的行为。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    int i = 0;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    A() try &#123;   // Function-try-block</span><br><span class="line">        ....</span><br><span class="line">    &#125; catch (...) &#123;</span><br><span class="line">        access(i);    // Non-compliant, ‘i’ may no longer exist </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   ~A() try &#123;</span><br><span class="line">        ....</span><br><span class="line">    &#125; catch (...) &#123;</span><br><span class="line">        access(i);    // Non-compliant, ‘i’ may no longer exist </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>例中 catch 子句均面向函数体，从属于“函数 try 块（function-try-block）”，当流程进入 catch 子句时成员 i 的生命周期已结束，不应被访问。  </p>
<p>应调整实现或将 try-catch 语句移入函数内：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A::A() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        ....</span><br><span class="line">    &#125; catch (...) &#123;</span><br><span class="line">        access(i);   // Compliant</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="依据-123"><a href="#依据-123" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 14882:2003 15.3(10)-undefined<br>ISO/IEC 14882:2011 15.3(10)-undefined<br><br/></p>
<h4 id="参考-198"><a href="#参考-198" class="headerlink" title="参考"></a>参考</h4><p>MISRA C++ 2008 15-3-3<br>SEI CERT ERR53-CPP<br><br/><br><br/></p>
<h3 id="▌R8-13-成员初始化应遵循声明的顺序"><a href="#▌R8-13-成员初始化应遵循声明的顺序" class="headerlink" title="▌R8.13 成员初始化应遵循声明的顺序"></a><span id="disorderedinitialization">▌R8.13 成员初始化应遵循声明的顺序</span></h3><p>ID_disorderedInitialization&emsp;&emsp;&emsp;&emsp;&nbsp;:boom: function error</p>
<hr/>

<p>类成员的初始化顺序是按声明的顺序进行的，初始化前面的成员时不可使用后面成员的值。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct A &#123;</span><br><span class="line">    int* p;</span><br><span class="line">    size_t n;</span><br><span class="line"></span><br><span class="line">    A(size_t s): n(s), p(new int[n])  // Non-compliant</span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>虽然在初始化列表中 n 在 p 的前面，但 p 先于 n 声明，n 仍然在 p 之后被初始化，“p(new int[n])”会造成严重错误。  </p>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct A &#123;</span><br><span class="line">    size_t n;</span><br><span class="line">    int* p;</span><br><span class="line"></span><br><span class="line">    A(size_t s): n(s), p(new int[n])  // Compliant</span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>调整了 n 和 p 的声明顺序，使 n 先于 p 初始化即可。  </p>
<p>如果使用后面成员的地址初始化前面的成员，则不受本规则约束，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct B &#123;</span><br><span class="line">    int*&amp; a;</span><br><span class="line">    int*  b;</span><br><span class="line">    int   c[3];</span><br><span class="line"></span><br><span class="line">    B():</span><br><span class="line">        a(b),  // OK</span><br><span class="line">        b(c)   // OK</span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>例中 a 为引用，b 的地址在初始化之前就确定了，所以“a(b)”没问题；c 为数组，也是一个地址，所以“b(c)”没有问题。<br><br/><br><br/></p>
<h4 id="依据-124"><a href="#依据-124" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 14882:2003 12.6.2(5)<br>ISO/IEC 14882:2011 12.6.2(10)<br><br/></p>
<h4 id="参考-199"><a href="#参考-199" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines C.47<br><br/><br><br/></p>
<h3 id="▌R8-14-在构造函数中不应使用动态类型"><a href="#▌R8-14-在构造函数中不应使用动态类型" class="headerlink" title="▌R8.14 在构造函数中不应使用动态类型"></a><span id="virtualcallinconstructor">▌R8.14 在构造函数中不应使用动态类型</span></h3><p>ID_virtualCallInConstructor&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: function warning</p>
<hr/>

<p>对象的动态类型在其构造过程中不生效。  </p>
<p>执行基类构造函数时，派生类对象尚未构造完毕，基类构造函数不能使用派生类动态类型。  </p>
<p>对于正在构造的对象，不应：  </p>
<ul>
<li>调用派生类重写的虚函数  </li>
<li>通过 typeid 判断对象的动态类型  </li>
<li>通过 dynamic_cast 转换对象的动态类型  </li>
</ul>
<p>注意，如果在构造函数中调用未实现的纯虚函数会导致标准未定义的行为。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">struct A &#123;</span><br><span class="line">    int tag;</span><br><span class="line">    A();</span><br><span class="line">    virtual ~A() = default;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct B: public A &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A::A() &#123;</span><br><span class="line">    if (typeid(*this) == typeid(B)) &#123;   // Non-compliant, always false</span><br><span class="line">        tag = 2;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        tag = 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B b;  // ‘b.tag’ is 1</span><br></pre></td></tr></table></figure>
<p>在基类 A 的构造函数中判断动态类型是无效的。<br><br/><br><br/></p>
<h4 id="依据-125"><a href="#依据-125" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 14882:2003 10.4(6)-undefined<br>ISO/IEC 14882:2011 10.4(6)-undefined<br><br/></p>
<h4 id="参考-200"><a href="#参考-200" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines C.82<br>MISRA C++ 2008 12-1-1<br>Effective C++ item 9<br><br/><br><br/></p>
<h3 id="▌R8-15-在析构函数中不应使用动态类型"><a href="#▌R8-15-在析构函数中不应使用动态类型" class="headerlink" title="▌R8.15 在析构函数中不应使用动态类型"></a><span id="virtualcallindestructor">▌R8.15 在析构函数中不应使用动态类型</span></h3><p>ID_virtualCallInDestructor&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: function warning</p>
<hr/>

<p>对象的动态类型在其析构过程中不生效。  </p>
<p>执行基类析构函数时，属于派生类的成员已被析构，基类析构函数不能使用派生类动态类型。  </p>
<p>对于正在析构的对象，不应：  </p>
<ul>
<li>调用派生类重写的虚函数  </li>
<li>通过 typeid 判断对象的动态类型  </li>
<li>通过 dynamic_cast 转换对象的动态类型  </li>
</ul>
<p>注意，如果在析构函数中调用未实现的纯虚函数会导致标准未定义的行为。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    virtual void clear() &#123;&#125;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">   ~A() &#123; clear(); &#125;   // Non-compliant</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class B: public A &#123;</span><br><span class="line">    int* p = new int[8];</span><br><span class="line">    void clear() override &#123; delete[] p; &#125;   // Invalid</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>虽然派生类 B 重写了 clear 函数，但在基类 A 的析构函数中不生效，相关内存没有被正确释放。  </p>
<p>应将基类的析构函数设为虚函数，在派生类的析构函数中释放资源：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual ~A() = default;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class B: public A &#123;</span><br><span class="line">    int* p = new int[8];</span><br><span class="line">public:</span><br><span class="line">   ~B() override &#123; delete[] p; &#125;   // Compliant</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="依据-126"><a href="#依据-126" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 14882:2003 10.4(6)-undefined<br>ISO/IEC 14882:2011 10.4(6)-undefined<br><br/></p>
<h4 id="参考-201"><a href="#参考-201" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines C.82<br>MISRA C++ 2008 12-1-1<br>Effective C++ item 9<br><br/><br><br/></p>
<h3 id="▌R8-16-在析构函数中避免调用-exit-函数"><a href="#▌R8-16-在析构函数中避免调用-exit-函数" class="headerlink" title="▌R8.16 在析构函数中避免调用 exit 函数"></a><span id="exitcallindestructor">▌R8.16 在析构函数中避免调用 exit 函数</span></h3><p>ID_exitCallInDestructor&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: function warning</p>
<hr/>

<p>程序调用 exit 后，具有静态或线程存储期的对象开始析构，如果这种对象的析构函数再调用 exit 会导致标准未定义的行为，为规避意料之外的错误，应统一要求在析构函数中避免直接或间接地调用 exit。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class T &#123;</span><br><span class="line">    ....</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">   ~T() &#123;</span><br><span class="line">        exit(1);  // Non-compliant</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="依据-127"><a href="#依据-127" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 14882:2003 3.6.1(4)-undefined<br>ISO/IEC 14882:2011 3.6.1(4)-undefined<br><br/><br><br/></p>
<h3 id="▌R8-17-拷贝构造函数应避免实现复制之外的功能"><a href="#▌R8-17-拷贝构造函数应避免实现复制之外的功能" class="headerlink" title="▌R8.17 拷贝构造函数应避免实现复制之外的功能"></a><span id="sideeffectcopyconstructor">▌R8.17 拷贝构造函数应避免实现复制之外的功能</span></h3><p>ID_sideEffectCopyConstructor&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: function warning</p>
<hr/>

<p>拷贝构造函数的执行在某些情况下可被省略，其执行次数可能与预期不符，复制之外的功能也可能无法生效。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    int i;</span><br><span class="line">    static int s;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    A();</span><br><span class="line">    A(const A&amp; rhs) &#123;</span><br><span class="line">        i = rhs.i;     // Compliant</span><br><span class="line">        s++;           // Non-compliant</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>例中拷贝构造函数对静态成员有所读写，这种复制之外的功能是不符合要求的。  </p>
<p>如果按下列方式使用相关类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">A foo();</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    A a = foo();   // Copy elision</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用 foo 函数返回的临时对象构造对象 a，理论上应执行拷贝构造函数，但标准允许编译器将临时对象直接作为对象 a，省略拷贝构造函数的执行以提高效率，这种优化称为“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Copy_elision">copy elision</a>”，复制之外的功能会因此无法生效。在 C++17 之前，是否执行这种优化由实现定义，从 C++17 开始，在某些情况下必须执行这种优化，具体可参见“<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/copy_elision#Mandatory_elision_of_copy.2Fmove_operations">mandatory copy elision</a>”。<br><br/><br><br/></p>
<h4 id="相关-132"><a href="#相关-132" class="headerlink" title="相关"></a>相关</h4><p>ID_sideEffectMoveConstructor<br><br/></p>
<h4 id="依据-128"><a href="#依据-128" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 14882:2003 12.8(15)-implementation<br>ISO/IEC 14882:2011 12.8(31)-implementation<br>ISO/IEC 14882:2017 15.8.3(1)-implementation<br><br/></p>
<h4 id="参考-202"><a href="#参考-202" class="headerlink" title="参考"></a>参考</h4><p>MISRA C++ 2008 12-8-1<br><br/><br><br/></p>
<h3 id="▌R8-18-移动构造函数应避免实现数据移动之外的功能"><a href="#▌R8-18-移动构造函数应避免实现数据移动之外的功能" class="headerlink" title="▌R8.18 移动构造函数应避免实现数据移动之外的功能"></a><span id="sideeffectmoveconstructor">▌R8.18 移动构造函数应避免实现数据移动之外的功能</span></h3><p>ID_sideEffectMoveConstructor&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: function warning</p>
<hr/>

<p>移动构造函数的执行在某些情况下可被省略，其执行次数可能与预期不符，数据移动之外的功能也可能无法生效。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    int* dat;</span><br><span class="line">    static int cnt;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    A();</span><br><span class="line">   ~A();</span><br><span class="line">    A(A&amp;&amp; a) &#123;</span><br><span class="line">        dat = a.dat;      // Compliant</span><br><span class="line">        a.dat = nullptr;  // Compliant</span><br><span class="line">        cnt++;            // Non-compliant</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>例中移动构造函数对静态成员有所读写，这种数据移动之外的功能是不符合要求的。  </p>
<p>如果按下列方式使用相关类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">A foo();</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    A a&#123;foo()&#125;;   // Copy/move elision</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用 foo 函数返回的临时对象构造对象 a，理论上应执行移动构造函数，但标准允许编译器将临时对象直接作为对象 a，移动和拷贝构造函数均可省略以提高效率，这种优化称为“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Copy_elision">copy/move elision</a>”，移动或复制之外的功能会因此无法生效。在 C++17 之前，是否执行这种优化由实现定义，从 C++17 开始，在某些情况下必须执行这种优化，具体可参见“<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/copy_elision#Mandatory_elision_of_copy.2Fmove_operations">mandatory copy elision</a>”。<br><br/><br><br/></p>
<h4 id="相关-133"><a href="#相关-133" class="headerlink" title="相关"></a>相关</h4><p>ID_sideEffectCopyConstructor<br><br/></p>
<h4 id="依据-129"><a href="#依据-129" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 14882:2011 12.8(31)-implementation<br>ISO/IEC 14882:2017 15.8.3(1)-implementation<br><br/><br><br/></p>
<h3 id="▌R8-19-拷贝赋值运算符应处理参数是自身对象时的情况"><a href="#▌R8-19-拷贝赋值运算符应处理参数是自身对象时的情况" class="headerlink" title="▌R8.19 拷贝赋值运算符应处理参数是自身对象时的情况"></a><span id="this_selfjudgement">▌R8.19 拷贝赋值运算符应处理参数是自身对象时的情况</span></h3><p>ID_this_selfJudgement&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: function warning</p>
<hr/>

<p>如果拷贝赋值运算符的参数是自身对象，需防止资源分配和回收方面的冲突。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class A &#123; .... &#125;;</span><br><span class="line"></span><br><span class="line">void foo(A* p, A* q) &#123;</span><br><span class="line">    *p = *q;             // If ‘p’ and ‘q’ point to the same object ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设例中 A 是需要深拷贝的类，其赋值运算符往往需要先释放自身的资源，再复制参数的资源，如果参数就是自身，则需要避免资源被释放，可在赋值运算符中判断 this 与参数地址是否相同：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">A&amp; A::operator = (const A&amp; rhs) &#123;</span><br><span class="line">    if (this != &amp;rhs) &#123;             // Required</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">    return *this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 A 的拷贝构造函数和交换方法齐备，也可按“复制 - 交换”模式实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A&amp; A::operator = (const A&amp; rhs) &#123;</span><br><span class="line">    A tmp(rhs);</span><br><span class="line">    this-&gt;swap(tmp);                // Good</span><br><span class="line">    return *this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>利用创建临时对象并与之交换的方法，也有效规避了冲突，这种方法使各函数更专注于自己的职责，不必重复编写分配和回收相关的代码，建议采用这种方法。<br><br/><br><br/></p>
<h4 id="参考-203"><a href="#参考-203" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines C.62<br><br/><br><br/></p>
<h3 id="▌R8-20-不应存在无效的写入操作"><a href="#▌R8-20-不应存在无效的写入操作" class="headerlink" title="▌R8.20 不应存在无效的写入操作"></a><span id="invalidwrite">▌R8.20 不应存在无效的写入操作</span></h3><p>ID_invalidWrite&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: function warning</p>
<hr/>

<p>内存中的数据写入之后应被读取，如果出现：  </p>
<ul>
<li>写入后未经读取便再次被无条件写入  </li>
<li>写入后未经读取而相关对象的生命周期已结束  </li>
</ul>
<p>这种写入是无效的，出现这种问题往往意味着逻辑错误或功能不完整。  </p>
<p>下列情况可不受本规则约束：  </p>
<ul>
<li>对象初始化时的写入  </li>
<li>有特殊副作用的写入，如对 volatile 型数据的写入等  </li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void foo(int&amp; a, int&amp; b) &#123;</span><br><span class="line">    ....</span><br><span class="line">    a = 123;   // Non-compliant</span><br><span class="line">    a = 456;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中参数 a 被赋值为 123 之后，又被无条件地赋值为 456，显然第一次赋值是没有意义的，很有可能是漏掉了什么。  </p>
<p>又如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int bar() &#123;</span><br><span class="line">    int i = 0;</span><br><span class="line">    ....</span><br><span class="line">    return i++;     // Non-compliant</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中 bar 函数返回局部变量 i 自增前的值，自增运算是没有意义的。  </p>
<p>对象的初始化可不受本规则限制，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int baz() &#123;</span><br><span class="line">    int n = 0;      // OK</span><br><span class="line">    if (cond) &#123;</span><br><span class="line">        n = 123;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        n = 456;</span><br><span class="line">    &#125;</span><br><span class="line">    return n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中局部变量 n 初始化后经由 if-else 分枝，在其两个分枝中都被赋值，也相当于被无条件写入，但在声明处初始化是值得提倡的，故这种情况不受本规则限制。<br><br/><br><br/><br><br/></p>
<h3 id="▌R8-21-不应存在没有副作用的语句"><a href="#▌R8-21-不应存在没有副作用的语句" class="headerlink" title="▌R8.21 不应存在没有副作用的语句"></a><span id="missingsideeffect">▌R8.21 不应存在没有副作用的语句</span></h3><p>ID_missingSideEffect&emsp;&emsp;&emsp;&emsp;&nbsp;:boom: function error</p>
<hr/>

<p>不能对程序状态产生影响的语句称为无“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Side_effect_(computer_science">副作用（side effect）</a>)”的语句，往往属于笔误或调试痕迹，应当修正或去除。  </p>
<p>示例（设 a、b、p 为变量或指针）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a == b;  // Non-compliant</span><br></pre></td></tr></table></figure>
<p>单纯的判等是没有副作用的，很可能是赋值语句的笔误。  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*p++;    // Non-compliant</span><br></pre></td></tr></table></figure>
<p>单纯从某个地址进行读取是没有副作用的，这是一种对运算符优先级理解不当造成的常见错误，应改为 (*p)++;  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;fun;  // Non-compliant</span><br></pre></td></tr></table></figure>
<p>由变量名或无实参列表的函数名作为一个语句是没有副作用的，此语句应改为正确的函数调用。  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+a;      // Non-compliant</span><br></pre></td></tr></table></figure>
<p>正号是没有副作用的，此句很可能应为 ++a;  </p>
<p>如果语句为逻辑与表达式，左子表达式可以作为右子表达式的条件，故左子表达式可以无副作用，而右子表达式一定要有副作用，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p &amp;&amp; p-&gt;fun();  // OK</span><br><span class="line">p &amp;&amp; p-&gt;fun;    // Non-compliant</span><br><span class="line">p-&gt;fun() &amp;&amp; p;  // Non-compliant</span><br></pre></td></tr></table></figure>
<p>如果语句为逻辑或表达式，则要求其左右子表达式均有副作用，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p || p-&gt;fun();  // Non-compliant</span><br><span class="line">p || p-&gt;fun;    // Non-compliant</span><br><span class="line">p-&gt;fun() || p;  // Non-compliant</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="依据-130"><a href="#依据-130" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 5.1.2.3(2)<br>ISO/IEC 9899:2011 5.1.2.3(2)<br>ISO/IEC 14882:2003 1.9(7)<br>ISO/IEC 14882:2011 1.9(12)<br><br/></p>
<h4 id="参考-204"><a href="#参考-204" class="headerlink" title="参考"></a>参考</h4><p>CWE-482<br>CWE-1164<br>MISRA C 2004 14.2<br>MISRA C 2012 2.2<br>MISRA C++ 2008 0-1-9<br><br/><br><br/></p>
<h3 id="▌R8-22-不应存在得不到执行机会的代码"><a href="#▌R8-22-不应存在得不到执行机会的代码" class="headerlink" title="▌R8.22 不应存在得不到执行机会的代码"></a><span id="unreachablecode">▌R8.22 不应存在得不到执行机会的代码</span></h3><p>ID_unreachableCode&emsp;&emsp;&emsp;&emsp;&nbsp;:boom: function error</p>
<hr/>

<p>得不到执行机会的代码是没有意义的，往往意味着逻辑错误。  </p>
<p>这种代码的主要成因如下，括号内为特化规则：  </p>
<ul>
<li>所在函数无法被调用（ID_staticNotUsed、ID_privateNotUsed）  </li>
<li>之前的所有分枝都提前结束了程序的执行  </li>
<li>之前的必经分枝中存在不会结束执行的代码  </li>
<li>所在分枝的条件恒为假（ID_constLogicExpression、ID_invalidCondition、ID_switch_caseOutOfRange）  </li>
<li>所在分枝被其他分枝遮盖（ID_if_identicalCondition、ID_if_hiddenCondition、ID_try_disorderedHandlers、ID_try_disorderedEllipsis）  </li>
<li>流程被不受条件控制的跳转语句跨过（ID_uncondJump）  </li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int fun() &#123;</span><br><span class="line">    if (cond) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    statements    // Non-compliant, unreachable</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中 statements 之前的所有分枝都会结束函数的执行，所以 statements 不会被执行。  </p>
<p>另外，在正式代码中不应存在如下形式的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (false) &#123; .... &#125;      // Non-compliant</span><br><span class="line">while (false) &#123; .... &#125;   // Non-compliant</span><br><span class="line">for (;false;) &#123; .... &#125;   // Non-compliant</span><br></pre></td></tr></table></figure>
<p>也不应该在 return 语句之后存在其他语句，这种代码如果不是被人恶意篡改，就是出于某种目的将本已无效的代码遗留了下来，可参见 ID_constLogicExpression、ID_invalidCondition 的进一步讨论。  </p>
<p>建议时刻保持代码的整洁，并将维护过程中的变动及时地保存在版本管理系统中，这样可以清晰地查看各版本之间的变动，而如果将无效代码与有效代码混在一起，势必造成维护的负担。<br><br/><br><br/></p>
<h4 id="相关-134"><a href="#相关-134" class="headerlink" title="相关"></a>相关</h4><p>ID_staticNotUsed<br>ID_privateNotUsed<br>ID_constLogicExpression<br>ID_invalidCondition<br>ID_switch_caseOutOfRange<br>ID_if_identicalCondition<br>ID_if_hiddenCondition<br>ID_try_disorderedEllipsis<br>ID_try_disorderedHandlers<br>ID_uncondJump<br><br/></p>
<h4 id="参考-205"><a href="#参考-205" class="headerlink" title="参考"></a>参考</h4><p>CWE-561<br>MISRA C 2004 14.1<br>MISRA C 2012 2.1<br>MISRA C++ 2008 0-1-1<br><br/><br><br/></p>
<h3 id="▌R8-23-有返回值的函数其所有分枝都应显式返回"><a href="#▌R8-23-有返回值的函数其所有分枝都应显式返回" class="headerlink" title="▌R8.23 有返回值的函数其所有分枝都应显式返回"></a><span id="notallbranchreturn">▌R8.23 有返回值的函数其所有分枝都应显式返回</span></h3><p>ID_notAllBranchReturn&emsp;&emsp;&emsp;&emsp;&nbsp;:boom: function error</p>
<hr/>

<p>如果有返回值的函数在某个分枝没有使用 return 语句显式返回，会导致标准未定义的行为。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int fun() &#123;</span><br><span class="line">    if (condition1) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (condition2) &#123;</span><br><span class="line">    &#125;                        // Non-compliant, no return value</span><br><span class="line">    else &#123;</span><br><span class="line">        return 3; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当条件符合 condition2 时，fun 函数的调用者将得到一个错误的返回值。  </p>
<p>例外：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">    printf(&quot;Hi~\n&quot;);</span><br><span class="line">&#125;   // Compliant</span><br></pre></td></tr></table></figure>
<p>标准规定未显式返回的 main 函数会返回 0，故 main 函数不受本规则约束。<br><br/><br><br/></p>
<h4 id="依据-131"><a href="#依据-131" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 5.1.2.2.3(1)<br>ISO/IEC 9899:1999 6.9.1(12)-undefined<br>ISO/IEC 9899:2011 5.1.2.2.3(1)<br>ISO/IEC 9899:2011 6.9.1(12)-undefined<br>ISO/IEC 14882:2003 3.6.1(5)<br>ISO/IEC 14882:2003 6.6.3(2)-undefined<br>ISO/IEC 14882:2011 3.6.1(5)<br>ISO/IEC 14882:2011 6.6.3(2)-undefined<br><br/></p>
<h4 id="参考-206"><a href="#参考-206" class="headerlink" title="参考"></a>参考</h4><p>CWE-394<br>MISRA C 2004 16.8<br>MISRA C 2012 17.4<br>MISRA C++ 2008 8-4-3<br><br/><br><br/></p>
<h3 id="▌R8-24-不可返回局部对象的地址或引用"><a href="#▌R8-24-不可返回局部对象的地址或引用" class="headerlink" title="▌R8.24 不可返回局部对象的地址或引用"></a><span id="localaddressflowout">▌R8.24 不可返回局部对象的地址或引用</span></h3><p>ID_localAddressFlowOut&emsp;&emsp;&emsp;&emsp;&nbsp;:boom: function error</p>
<hr/>

<p>局部对象的生命周期结束后，其地址或引用也会失效，如果继续访问会导致标准未定义的行为。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int* foo() &#123;</span><br><span class="line">    int i = 0;    // Local object</span><br><span class="line">    ....</span><br><span class="line">    return &amp;i;    // Non-compliant</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int&amp; bar() &#123;</span><br><span class="line">    int i = 0;    // Local object</span><br><span class="line">    ....</span><br><span class="line">    return i;     // Non-compliant</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int&amp;&amp; baz() &#123;</span><br><span class="line">    int i = 0;    // Local object</span><br><span class="line">    ....</span><br><span class="line">    return std::move(i);    // Non-compliant</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>局部对象的生命周期在函数返回后结束，返回与局部对象相关的指针或引用是不符合要求的。  </p>
<p>注意，除了 return 语句，throw、赋值等表达式也受本规则限制，禁止将内层作用域中的地址向外层作用域传递，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">char* global;</span><br><span class="line"></span><br><span class="line">void fun() &#123;</span><br><span class="line">    char local[] = &quot;....&quot;;</span><br><span class="line">    global = local;          // Non-compliant</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中 local 是局部数组，函数返回后，全局指针会指向无效的内存区域。  </p>
<p>另外，将对象地址传入异步过程时也需要注意对象的生命周期，参见 ID_illLifetime。<br><br/><br><br/></p>
<h4 id="相关-135"><a href="#相关-135" class="headerlink" title="相关"></a>相关</h4><p>ID_tmpAddressFlowOut<br>ID_danglingDeref<br>ID_illLifetime<br><br/></p>
<h4 id="依据-132"><a href="#依据-132" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 6.2.4(2)-undefined<br>ISO/IEC 9899:2011 6.2.4(2)-undefined<br><br/></p>
<h4 id="参考-207"><a href="#参考-207" class="headerlink" title="参考"></a>参考</h4><p>CWE-562<br>C++ Core Guidelines F.43<br>MISRA C 2012 18.6<br>MISRA C++ 2008 7-5-1<br>MISRA C++ 2008 7-5-2<br><br/><br><br/></p>
<h3 id="▌R8-25-不可返回临时对象的地址或引用"><a href="#▌R8-25-不可返回临时对象的地址或引用" class="headerlink" title="▌R8.25 不可返回临时对象的地址或引用"></a><span id="tmpaddressflowout">▌R8.25 不可返回临时对象的地址或引用</span></h3><p>ID_tmpAddressFlowOut&emsp;&emsp;&emsp;&emsp;&nbsp;:boom: function error</p>
<hr/>

<p>临时对象可以通过常量引用或右值引用等方式作为函数的参数，但生命周期结束后，其地址或引用就会失效，如果继续访问会导致标准未定义的行为，对引用型参数取地址应谨慎。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">using S = std::string;</span><br><span class="line"></span><br><span class="line">const S* foo(const S&amp; s) &#123;</span><br><span class="line">    return &amp;s;    // Non-compliant</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    auto* p = foo(&quot;abc&quot;);</span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; &#x27;\n&#x27;;   // Undefined behavior</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中 foo 函数的参数是由字符串常量 “abc” 生成的 string 型临时对象，所在语句执行完毕后生命周期即结束，p 会成为野指针，继续访问会导致标准未定义的行为。  </p>
<p>同理，也应避免对于右值引用型的参数取地址，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">S* bar(S&amp;&amp; s) &#123;</span><br><span class="line">    return &amp;s;   // Non-compliant</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="相关-136"><a href="#相关-136" class="headerlink" title="相关"></a>相关</h4><p>ID_localAddressFlowOut<br>ID_danglingDeref<br>ID_illLifetime<br><br/></p>
<h4 id="依据-133"><a href="#依据-133" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 6.2.4(2)-undefined<br>ISO/IEC 9899:2011 6.2.4(2)-undefined<br><br/></p>
<h4 id="参考-208"><a href="#参考-208" class="headerlink" title="参考"></a>参考</h4><p>MISRA C++ 2008 7-5-3<br><br/><br><br/></p>
<h3 id="▌R8-26-合理设置-lambda-表达式的捕获方式"><a href="#▌R8-26-合理设置-lambda-表达式的捕获方式" class="headerlink" title="▌R8.26 合理设置 lambda 表达式的捕获方式"></a><span id="unsuitablecapture">▌R8.26 合理设置 lambda 表达式的捕获方式</span></h3><p>ID_unsuitableCapture&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: function warning</p>
<hr/>

<p>如果 lambda 表达式只在函数内部使用，可采用捕获引用的方式；如果 lambda 表达式可以超出函数作用域，应采用捕获值的方式。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">auto foo() -&gt; function&lt;int()&gt; &#123;</span><br><span class="line">    int i = 0;</span><br><span class="line">    ....</span><br><span class="line">    return [&amp;]() &#123; return ++i; &#125;;  // Non-compliant</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中的 lambda 表达式引用了局部变量 i，但返回后 i 的地址不再有效，会导致标准未定义的行为。  </p>
<p>另外，要注意解引用指针造成的间接引用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    int i = 0;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    auto bar() &#123;</span><br><span class="line">        return [=]() &#123; return i; &#125;;  // Bad</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>例中的 lambda 表达式通过值捕获变量，this 指针也被捕获，成员变量 i 是通过 this 指针的隐式解引用获取到的，如果 lambda 表达式在 this 指针的生命周期之外执行，就会造成错误。  </p>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auto A::bar() &#123;</span><br><span class="line">    return [*this]() &#123; return i; &#125;;  // OK</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果需要捕获 this 指针，则应显式捕获所有相关变量，避免使用“[=]”。<br><br/><br><br/></p>
<h4 id="相关-137"><a href="#相关-137" class="headerlink" title="相关"></a>相关</h4><p>ID_localAddressFlowOut<br><br/></p>
<h4 id="依据-134"><a href="#依据-134" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 14882:2011 5.1.2<br>ISO/IEC 14882:2017 8.1.5.2<br><br/></p>
<h4 id="参考-209"><a href="#参考-209" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines F.52<br>C++ Core Guidelines F.53<br>C++ Core Guidelines F.54<br><br/><br><br/></p>
<h3 id="▌R8-27-函数返回值不应为右值引用"><a href="#▌R8-27-函数返回值不应为右值引用" class="headerlink" title="▌R8.27 函数返回值不应为右值引用"></a><span id="returnrvaluereference">▌R8.27 函数返回值不应为右值引用</span></h3><p>ID_returnRValueReference&emsp;&emsp;&emsp;&emsp;&nbsp;:bulb: function suggestion</p>
<hr/>

<p>函数返回右值引用的实际价值有限，且易产生错误。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class A &#123; .... &#125;;</span><br><span class="line"></span><br><span class="line">A&amp;&amp; foo() &#123;         // Non-compliant</span><br><span class="line">    return A();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void bar() &#123;</span><br><span class="line">    A&amp;&amp; a = foo();</span><br><span class="line">    access(a);      // Undefined behavior, ‘a’ refers to an invalid object</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中 foo 函数返回类型为右值引用，这种情况下返回临时对象一定是错误的，临时对象在返回前析构，返回的是无效引用。  </p>
<p>也不应返回局部对象的右值引用，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A&amp;&amp; baz() &#123;         // Non-compliant</span><br><span class="line">    A a;</span><br><span class="line">    ....</span><br><span class="line">    return std::move(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和返回临时对象一样，对象 a 在函数返回前析构，返回的也是无效引用。  </p>
<p>应直接返回对象，而不是对象的右值引用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">A foo() &#123;           // Compliant</span><br><span class="line">    return A();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A baz() &#123;           // Compliant</span><br><span class="line">    A a;</span><br><span class="line">    ....</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于函数引用的参数，或函数作用域之外的对象，如果通过 move 返回右值引用，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A&amp;&amp; baz(A&amp; a) &#123;     // Non-compliant</span><br><span class="line">    access(a);</span><br><span class="line">    return std::move(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种情况在运行机制上可能没有问题，但满足的实际需求较为有限，而且相当于将 access(a) 和 move(a) 两种事务合在一个函数中，在某种程度上违反了“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Single-responsibility_principle">单一职责原则</a>”。  </p>
<p>综上所述，应统一要求函数不应返回右值引用。<br><br/><br><br/></p>
<h4 id="相关-138"><a href="#相关-138" class="headerlink" title="相关"></a>相关</h4><p>ID_localAddressFlowOut<br><br/></p>
<h4 id="参考-210"><a href="#参考-210" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines F.45<br><br/><br><br/></p>
<h3 id="▌R8-28-函数返回值不应为常量对象"><a href="#▌R8-28-函数返回值不应为常量对象" class="headerlink" title="▌R8.28 函数返回值不应为常量对象"></a><span id="returnconstobject">▌R8.28 函数返回值不应为常量对象</span></h3><p>ID_returnConstObject&emsp;&emsp;&emsp;&emsp;&nbsp;:bulb: function suggestion</p>
<hr/>

<p>函数返回常量对象不利于移动构造或移动赋值等机制，也可能本意是返回引用，但遗漏了引用符号。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const vector&lt;int&gt; fun() &#123;  // Non-compliant</span><br><span class="line">    return &#123; 1, 2, 3 &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; obj(fun());    // Call ‘vector(const vector&amp;)’</span><br></pre></td></tr></table></figure>
<p>fun 返回 const 对象，构造 obj 对象时只能进行深拷贝，无法利用移动构造等特性。  </p>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; fun() &#123;        // Compliant</span><br><span class="line">    return &#123; 1, 2, 3 &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; obj(fun());    // Call ‘vector(vector&amp;&amp;)’, more efficient</span><br></pre></td></tr></table></figure>
<p>这样可以利用移动构造函数提高效率。  </p>
<p>对于遵循 C++11 之前标准的代码，也不应返回常量对象，函数返回的对象本来就需要通过常量引用或传值的方式被后续代码使用，将返回值设为常量的意义不大。<br><br/><br><br/></p>
<h4 id="相关-139"><a href="#相关-139" class="headerlink" title="相关"></a>相关</h4><p>ID_returnSuperfluousConst<br><br/></p>
<h4 id="参考-211"><a href="#参考-211" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines F.20<br><br/><br><br/></p>
<h3 id="▌R8-29-函数返回值不应为基本类型的常量"><a href="#▌R8-29-函数返回值不应为基本类型的常量" class="headerlink" title="▌R8.29 函数返回值不应为基本类型的常量"></a><span id="returnsuperfluousconst">▌R8.29 函数返回值不应为基本类型的常量</span></h3><p>ID_returnSuperfluousConst&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: function warning</p>
<hr/>

<p>基本类型的函数返回值本来就是不可被修改的右值，不应再受 const 关键字限制。  </p>
<p>本规则是 ID_returnConstObject 的特化。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const int* foo();  // Compliant</span><br><span class="line">const int bar();   // Non-compliant, ‘const’ is superfluous</span><br><span class="line"></span><br><span class="line">class A &#123;</span><br><span class="line">    ....</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    int&amp; fun();</span><br><span class="line">    const int fun() const;  // Non-compliant, missing ‘&amp;’</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>出现这种问题说明设计与使用存在一定的偏差，也可能本意是返回引用或指针，而书写时漏掉了相关符号。<br><br/><br><br/></p>
<h4 id="相关-140"><a href="#相关-140" class="headerlink" title="相关"></a>相关</h4><p>ID_returnConstObject<br><br/></p>
<h4 id="依据-135"><a href="#依据-135" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 14882:2003 3.10(5)<br>ISO/IEC 14882:2011 3.10(1)<br><br/><br><br/></p>
<h3 id="▌R8-30-被返回的表达式应与函数的返回类型一致"><a href="#▌R8-30-被返回的表达式应与函数的返回类型一致" class="headerlink" title="▌R8.30 被返回的表达式应与函数的返回类型一致"></a><span id="returnodd">▌R8.30 被返回的表达式应与函数的返回类型一致</span></h3><p>ID_returnOdd&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: function warning</p>
<hr/>

<p>为了提高可读性并规避意料之外的错误，应避免隐式转换被返回的表达式。  </p>
<p>不应出现下列情况：  </p>
<ul>
<li>返回类型为 bool，却返回了非 true 非 false、非 0 非 1 的常量  </li>
<li>返回类型为指针，却返回了非 0、非 NULL、非 nullptr 的常量  </li>
<li>返回类型为整数，却返回了 NULL、true、false 等常量  </li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bool foo() &#123; return NULL; &#125;   // Non-compliant</span><br><span class="line">long bar() &#123; return false; &#125;  // Non-compliant</span><br><span class="line">int* baz() &#123; return &#x27;\0&#x27;; &#125;   // Non-compliant</span><br></pre></td></tr></table></figure>
<p>这种问题可能是在维护过程中产生的，也可能意味着逻辑错误，需谨慎对待。<br><br/><br><br/></p>
<h4 id="参考-212"><a href="#参考-212" class="headerlink" title="参考"></a>参考</h4><p>MISRA C++ 2008 4-10-1<br><br/><br><br/></p>
<h3 id="▌R8-31-被返回的表达式不应为相同的常量"><a href="#▌R8-31-被返回的表达式不应为相同的常量" class="headerlink" title="▌R8.31 被返回的表达式不应为相同的常量"></a><span id="returnsameconst">▌R8.31 被返回的表达式不应为相同的常量</span></h3><p>ID_returnSameConst&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: function warning</p>
<hr/>

<p>被返回的表达式均为相同的常量是没有意义的。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">bool foo(int a) &#123;</span><br><span class="line">    if (a &gt; 100) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    if (a &gt; 50) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;   // Non-compliant, all the values returned are the same</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/><br><br/></p>
<h3 id="▌R8-32-具有-noreturn-属性的函数不应返回"><a href="#▌R8-32-具有-noreturn-属性的函数不应返回" class="headerlink" title="▌R8.32 具有 noreturn 属性的函数不应返回"></a><span id="unsuitablereturn">▌R8.32 具有 noreturn 属性的函数不应返回</span></h3><p>ID_unsuitableReturn&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: function warning</p>
<hr/>

<p>具有 noreturn 属性的函数返回会导致标准未定义的行为。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[[noreturn]] void foo() &#123;  // Use _Noreturn in C</span><br><span class="line">    if (condition) &#123;</span><br><span class="line">        abort();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;       // Non-compliant, the function returns if ‘condition’ is false</span><br></pre></td></tr></table></figure>
<p>noreturn 表示不会返回，编译器可能不会为 foo 函数生成跳转回调用处的指令，一旦 foo 函数返回就会造成严重错误。<br><br/><br><br/></p>
<h4 id="相关-141"><a href="#相关-141" class="headerlink" title="相关"></a>相关</h4><p>ID_unsuitableReturnType<br><br/></p>
<h4 id="依据-136"><a href="#依据-136" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:2011 6.7.4(8 12)-undefined<br>ISO/IEC 14882:2011 7.6.3(2)-undefined<br><br/><br><br/></p>
<h3 id="▌R8-33-具有-noreturn-属性的函数返回类型只应为-void"><a href="#▌R8-33-具有-noreturn-属性的函数返回类型只应为-void" class="headerlink" title="▌R8.33 具有 noreturn 属性的函数返回类型只应为 void"></a><span id="unsuitablereturntype">▌R8.33 具有 noreturn 属性的函数返回类型只应为 void</span></h3><p>ID_unsuitableReturnType&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: function warning</p>
<hr/>

<p>返回类型不是 void 说明函数有返回值，与 noreturn 属性矛盾。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_Noreturn    int foo();     // Non-compliant in C</span><br><span class="line">[[noreturn]] int bar();     // Non-compliant in C++</span><br></pre></td></tr></table></figure>
<p>例中函数的返回类型为 int，与 noreturn 属性矛盾，也会对函数的使用者造成困扰。  </p>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_Noreturn    void foo();    // Compliant in C</span><br><span class="line">[[noreturn]] void bar();    // Compliant in C++</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="相关-142"><a href="#相关-142" class="headerlink" title="相关"></a>相关</h4><p>ID_unsuitableReturn<br><br/></p>
<h4 id="依据-137"><a href="#依据-137" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:2011 6.7.4(8 12)-undefined<br>ISO/IEC 14882:2011 7.6.3(2)-undefined<br><br/><br><br/></p>
<h3 id="▌R8-34-由-atexit、at-quick-exit-指定的处理函数应正常返回"><a href="#▌R8-34-由-atexit、at-quick-exit-指定的处理函数应正常返回" class="headerlink" title="▌R8.34 由 atexit、at_quick_exit 指定的处理函数应正常返回"></a><span id="exithandlernoreturn">▌R8.34 由 atexit、at_quick_exit 指定的处理函数应正常返回</span></h3><p>ID_exitHandlerNoReturn&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: function warning</p>
<hr/>

<p>如果 atexit、at_quick_exit 指定的处理函数未正常返回，会导致标准未定义的行为。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void handler() &#123;</span><br><span class="line">    exit(1);      // Non-compliant</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    atexit(handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中程序在调用 exit 时会执行 handler，而 handler 又调用 exit，在逻辑上形成无限递归，其后果在标准中是未定义的。  </p>
<p>又如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">jmp_buf buf;</span><br><span class="line"></span><br><span class="line">void handler() &#123;</span><br><span class="line">    longjmp(buf, 1);   // Non-compliant</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    atexit(handler);</span><br><span class="line">    if (setjmp(buf) == 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中 main 返回后会调用 handler，而 handler 又调用 longjmp 跳回 main 函数，在逻辑上形成死循环。<br><br/><br><br/></p>
<h4 id="依据-138"><a href="#依据-138" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 7.20.4.3(2 3)-undefined<br>ISO/IEC 9899:2011 7.22.4.4(2 3)-undefined<br><br/></p>
<h4 id="参考-213"><a href="#参考-213" class="headerlink" title="参考"></a>参考</h4><p>SEI CERT ENV32-C<br><br/><br><br/></p>
<h3 id="▌R8-35-函数模板不应被特化"><a href="#▌R8-35-函数模板不应被特化" class="headerlink" title="▌R8.35 函数模板不应被特化"></a><span id="functionspecialization">▌R8.35 函数模板不应被特化</span></h3><p>ID_functionSpecialization&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: function warning</p>
<hr/>

<p>特化的函数模板不参与重载函数的选取，易导致意类之外的错误。  </p>
<p>如果某些特殊情况确实需要特化模板，不妨将函数委托给模板类实现，通过特化模板类实现特殊的需求，参见 ID_narrowCast。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class T&gt;</span><br><span class="line">int foo(T) &#123;         // #1</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">int foo(T*) &#123;        // #2</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;&gt;</span><br><span class="line">int foo&lt;int*&gt;(int*) &#123;   // #3, non-compliant, specialization of #1</span><br><span class="line">    return 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int* p = nullptr;</span><br><span class="line">    cout &lt;&lt; foo(p) &lt;&lt; &#x27;\n&#x27;;   // What is output?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出 1，特化的函数模板不参与重载函数的选取，所以只会在 <code>#1</code> 和 <code>#2</code> 中选取，foo(p) 与 <code>#2</code> 更贴近，而 <code>#3</code> 是 <code>#1</code> 的特化，所以不会选取 <code>#3</code>，这种情况下 <code>#3</code> 是无效的。  </p>
<p>应去除对函数模板的特化，改为普通重载函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int foo(int*) &#123;   // #3, compliant, safe and brief</span><br><span class="line">    return 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样例中 main 函数会输出 2。<br><br/><br><br/></p>
<h4 id="参考-214"><a href="#参考-214" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines T.144<br>MISRA C++ 2008 14-8-1<br><br/><br><br/></p>
<h3 id="▌R8-36-函数的退出点数量应在规定范围之内"><a href="#▌R8-36-函数的退出点数量应在规定范围之内" class="headerlink" title="▌R8.36 函数的退出点数量应在规定范围之内"></a><span id="toomanyexit">▌R8.36 函数的退出点数量应在规定范围之内</span></h3><p>ID_tooManyExit&emsp;&emsp;&emsp;&emsp;&nbsp;:bulb: function suggestion</p>
<hr/>

<p>理想情况下应在函数的结尾设置统一的退出点，使代码具有清晰的静态结构，否则可读性较差，尤其在多个嵌套的作用域中使用 return 等语句，会使代码难以理解。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void foo()</span><br><span class="line">&#123;</span><br><span class="line">    if (a) &#123;</span><br><span class="line">        if (b) &#123;</span><br><span class="line">            return;   // Bad</span><br><span class="line">        &#125;</span><br><span class="line">        ....</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        ....</span><br><span class="line">        return;   // Bad</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中函数的主体逻辑被 return 语句“割裂”，这显然是不利于阅读和维护的。  </p>
<p>然而，严格地要求每个函数只能有一个退出点是不够灵活的，对于 if…else-if、switch-case、catch-handlers 等并列的分枝结构，其末尾的退出点可以算作一个退出点，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    ....</span><br><span class="line">&#125; catch (A&amp;) &#123;</span><br><span class="line">    ....</span><br><span class="line">    return 0;    // Let it go</span><br><span class="line">&#125; catch (B&amp;) &#123;</span><br><span class="line">    ....</span><br><span class="line">    return 1;    // Let it go</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="配置-20"><a href="#配置-20" class="headerlink" title="配置"></a>配置</h4><p>maxExitCount：退出点数量上限，超过则报出<br><br/></p>
<h4 id="相关-143"><a href="#相关-143" class="headerlink" title="相关"></a>相关</h4><p>ID_jumpOutLoop<br><br/></p>
<h4 id="参考-215"><a href="#参考-215" class="headerlink" title="参考"></a>参考</h4><p>MISRA C 2004 14.7<br>MISRA C 2012 15.5<br>MISRA C++ 2008 6-6-5<br><br/><br><br/></p>
<h3 id="▌R8-37-函数的标签数量应在规定范围之内"><a href="#▌R8-37-函数的标签数量应在规定范围之内" class="headerlink" title="▌R8.37 函数的标签数量应在规定范围之内"></a><span id="toomanylabels">▌R8.37 函数的标签数量应在规定范围之内</span></h3><p>ID_tooManyLabels&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: function warning</p>
<hr/>

<p>标签过多意味着函数内部的跳转逻辑过于复杂，违反结构化设计理念，应适当重构。  </p>
<p>对于 C 代码，建议一个函数只用一个标签作为函数统一出口，对于 C++ 代码，不建议使用标签。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void foo()</span><br><span class="line">&#123;</span><br><span class="line">L0:</span><br><span class="line">    ....</span><br><span class="line">L1:</span><br><span class="line">    ....   // Lots of labels require lots of gotos</span><br><span class="line">    ....   // Lots of gotos make functions terrible</span><br><span class="line">L100:</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="配置-21"><a href="#配置-21" class="headerlink" title="配置"></a>配置</h4><p>maxLabelCount：标签数量上限，超过则报出<br><br/><br><br/></p>
<h3 id="▌R8-38-函数的行数应在规定范围之内"><a href="#▌R8-38-函数的行数应在规定范围之内" class="headerlink" title="▌R8.38 函数的行数应在规定范围之内"></a><span id="toomanylines">▌R8.38 函数的行数应在规定范围之内</span></h3><p>ID_tooManyLines&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: function warning</p>
<hr/>

<p>函数体过大违反模块化编程理念，使人难以阅读，更不便于维护，应适当重构。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    // ... 3000 lines ...</span><br><span class="line">    // Who has the courage to read?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>建议函数体不超过 60 行，以不需要拖拽滚动条就可以在屏幕上完整显示为宜。<br><br/><br><br/></p>
<h4 id="配置-22"><a href="#配置-22" class="headerlink" title="配置"></a>配置</h4><p>maxLineCount：函数行数上限，超过则报出<br><br/></p>
<h4 id="参考-216"><a href="#参考-216" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines F.2<br>C++ Core Guidelines F.3<br><br/><br><br/></p>
<h3 id="▌R8-39-lambda-表达式的行数应在规定范围之内"><a href="#▌R8-39-lambda-表达式的行数应在规定范围之内" class="headerlink" title="▌R8.39 lambda 表达式的行数应在规定范围之内"></a><span id="toomanylambdalines">▌R8.39 lambda 表达式的行数应在规定范围之内</span></h3><p>ID_tooManyLambdaLines&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: function warning</p>
<hr/>

<p>复杂的 lambda 表达式与调用者的代码混在一起是难以阅读的，引入 lambda 表达式的目的应该是“化简”，否则应使用普通函数。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void foo()</span><br><span class="line">&#123;</span><br><span class="line">    auto f0 = []() &#123;</span><br><span class="line">        // ... Many lines ...</span><br><span class="line">    &#125;;</span><br><span class="line">        // ... Many lambdas ...</span><br><span class="line">        // ... Even lambdas nest lambdas ...</span><br><span class="line">    auto f100 = []() &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;;</span><br><span class="line">    // Tut, tut, this is a function, not a namespace,</span><br><span class="line">    // use common functions instead</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>建议 lambda 表达式不超过 5 行，一个函数中不应有多个复杂的 lambda 表达式。<br><br/><br><br/></p>
<h4 id="配置-23"><a href="#配置-23" class="headerlink" title="配置"></a>配置</h4><p>maxLambdaLineCount：lambda 表达式行数上限，超过则报出<br><br/><br><br/></p>
<h3 id="▌R8-40-函数参数的数量应在规定范围之内"><a href="#▌R8-40-函数参数的数量应在规定范围之内" class="headerlink" title="▌R8.40 函数参数的数量应在规定范围之内"></a><span id="toomanyparams">▌R8.40 函数参数的数量应在规定范围之内</span></h3><p>ID_tooManyParams&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: function warning</p>
<hr/>

<p>函数参数过多，意味着：  </p>
<ul>
<li>缺少合理的抽象机制：应将多而零散的参数按其内在联系封装成对象，从而方便地处理其逻辑关系，而不是简单地线性罗列  </li>
<li>违反单一职责原则：参数越多，函数处理的事务自然越多，代码的可维护性自然越差  </li>
</ul>
<p>建议可供外部使用的全局函数、public 或 protected 成员函数的参数不超过 4 个，内部使用的 static 函数、private 成员函数的参数不超过 8 个。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void foo(A a, B b, C c, D d, E e) &#123;   // Bad</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当函数参数过多时，应按参数的逻辑职责进行封装。假设 a 和 b 有直接逻辑关系，c、d、e 有直接逻辑关系，不妨将 a 和 b 封装成一个类，c、d、e 封装成一个类，在类的成员函数中实现相关功能，可更为清晰直观地保证逻辑关系的正确性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class X &#123;</span><br><span class="line">    ....    // Members and methods for ‘a’, ‘b’ ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Y &#123;</span><br><span class="line">    ....    // Members and methods for ‘c’, ‘d’, ‘e’ ... </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void foo(X x, Y y) &#123;   // Good</span><br><span class="line">    x.methods();</span><br><span class="line">    y.methods();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="配置-24"><a href="#配置-24" class="headerlink" title="配置"></a>配置</h4><p>maxParamCount：函数参数数量上限，超过则报出<br>maxInnerFunParamCount：static 函数或 private 成员函数参数数量上限，超过则报出<br><br/></p>
<h4 id="参考-217"><a href="#参考-217" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines F.2<br>C++ Core Guidelines I.23<br><br/><br><br/></p>
<h3 id="▌R8-41-不应定义过于复杂的内联函数"><a href="#▌R8-41-不应定义过于复杂的内联函数" class="headerlink" title="▌R8.41 不应定义过于复杂的内联函数"></a><span id="complexinlinefunction">▌R8.41 不应定义过于复杂的内联函数</span></h3><p>ID_complexInlineFunction&emsp;&emsp;&emsp;&emsp;&nbsp;:bulb: function suggestion</p>
<hr/>

<p>是否对函数进行内联优化由实现定义，当函数执行的开销远大于调用的开销时，将函数定义为内联函数是没有意义的。  </p>
<p>不适合将函数定义为内联函数的情况：  </p>
<ul>
<li>语句数量超过指定限制  </li>
<li>存在循环或异常处理语句  </li>
<li>存在 switch 分枝语句  </li>
<li>函数存在递归实现  </li>
</ul>
<p>建议内联函数的实现不要超过 3 个语句。<br><br/><br><br/></p>
<h4 id="配置-25"><a href="#配置-25" class="headerlink" title="配置"></a>配置</h4><p>maxInlineStatementsCount：内联函数语句数量上限，超过则报出<br><br/></p>
<h4 id="依据-139"><a href="#依据-139" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 6.7.4(5)-implementation<br>ISO/IEC 9899:2011 6.7.4(6)-implementation<br>ISO/IEC 14882:2003 7.1.2(2)-implementation<br>ISO/IEC 14882:2011 7.1.2(2)-implementation<br><br/></p>
<h4 id="参考-218"><a href="#参考-218" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines F.5<br><br/><br><br/></p>
<h3 id="▌R8-42-避免函数调用自身"><a href="#▌R8-42-避免函数调用自身" class="headerlink" title="▌R8.42 避免函数调用自身"></a><span id="recursion">▌R8.42 避免函数调用自身</span></h3><p>ID_recursion&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: function warning</p>
<hr/>

<p>函数直接或间接调用自身可实现递归算法，但调用栈的消耗情况不够直观，易导致栈溢出等错误。  </p>
<p>应使用复杂度更易控制的方法代替函数调用自身这种实现方式，对于难以代替的特殊算法，应做到资源消耗可控。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">size_t foo(size_t n) &#123;</span><br><span class="line">    return n + foo(n - 1);  // Non-compliant</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中 foo 函数无条件地调用自身是一种逻辑错误，导致无限的递归调用。  </p>
<p>又如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">size_t bar(size_t n) &#123;</span><br><span class="line">    if (n &gt; 1) &#123;</span><br><span class="line">        return n + bar(n - 1);  // Non-compliant</span><br><span class="line">    &#125;</span><br><span class="line">    return n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中 bar 函数设置了递归条件，但仍是不可取的，当参数 n 较大时仍然可以造成栈溢出错误。<br><br/><br><br/></p>
<h4 id="参考-219"><a href="#参考-219" class="headerlink" title="参考"></a>参考</h4><p>MISRA C 2012 17.2<br>MISRA C++ 2008 7-5-4<br><br/><br><br/></p>
<h3 id="▌R8-43-作用域及类型嵌套不应过深"><a href="#▌R8-43-作用域及类型嵌套不应过深" class="headerlink" title="▌R8.43 作用域及类型嵌套不应过深"></a><span id="nestedtoodeep">▌R8.43 作用域及类型嵌套不应过深</span></h3><p>ID_nestedTooDeep&emsp;&emsp;&emsp;&emsp;&nbsp;:bulb: function suggestion</p>
<hr/>

<p>作用域及类型嵌套过深会造成阅读和维护困难。  </p>
<p>建议：  </p>
<ul>
<li>函数作用域嵌套不超过 7 层  </li>
<li>内联函数作用域嵌套不超过 2 层  </li>
<li>lambda 表达式内作用域嵌套不超过 5 层  </li>
<li>类、结构体嵌套不超过 3 层  </li>
<li>命名空间嵌套不超过 4 层  </li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (cond0)</span><br><span class="line">    if (cond1)</span><br><span class="line">        .... nested 10 layers ....</span><br><span class="line">                if (cond10)  // Terrible</span><br><span class="line">                    ....   </span><br></pre></td></tr></table></figure>
<p>审计工具不妨通过配置决定嵌套层数是否合规。<br><br/><br><br/></p>
<h4 id="配置-26"><a href="#配置-26" class="headerlink" title="配置"></a>配置</h4><p>maxFunctionNestedDepth：函数作用域最大嵌套层数，超过则报出<br>maxInlineFunctionNestedDepth：内联函数作用域最大嵌套层数，超过则报出<br>maxLambdaNestedDepth：函数作用域最大嵌套层数，超过则报出<br>maxTypeNestedDepth：类型最大嵌套层数，超过则报出<br>maxNamespaceNestedDepth：命名空间最大嵌套层数，超过则报出<br><br/><br><br/></p>
<h3 id="▌R8-44-汇编代码不应与普通代码混合"><a href="#▌R8-44-汇编代码不应与普通代码混合" class="headerlink" title="▌R8.44 汇编代码不应与普通代码混合"></a><span id="mixedasm">▌R8.44 汇编代码不应与普通代码混合</span></h3><p>ID_mixedAsm&emsp;&emsp;&emsp;&emsp;&nbsp;:bulb: function suggestion</p>
<hr/>

<p>汇编代码的格式由实现定义，不具备可移植性，且可读性较差，故不应与普通代码混合。  </p>
<p>如果条件允许，应使用汇编语言实现独立的库，再由 C/C++ 代码调用。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int avg(int a, int b) &#123;</span><br><span class="line">    int sum;               </span><br><span class="line">    __asm &#123;                // Non-compliant</span><br><span class="line">        mov eax, a</span><br><span class="line">        mov ebx, b</span><br><span class="line">        lea eax, [eax + ebx]</span><br><span class="line">        mov sum, eax</span><br><span class="line">    &#125;</span><br><span class="line">    return sum / 2;        // Non-compliant</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中 avg 函数同时含有汇编代码和 C 代码是不符合要求的，至少应将汇编代码单独隔离成一个函数，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int add(int a, int b) &#123;</span><br><span class="line">    __asm &#123;                // Compliant</span><br><span class="line">        mov eax, a</span><br><span class="line">        mov ebx, b</span><br><span class="line">        lea eax, [eax + ebx]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int avg(int a, int b) &#123;</span><br><span class="line">    int sum = add(a, b);   // Compliant</span><br><span class="line">    return sum / 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="依据-140"><a href="#依据-140" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 J.5.10-implementation<br>ISO/IEC 9899:2011 J.5.10-implementation<br>ISO/IEC 14882:2003 7.4(1)-implementation<br>ISO/IEC 14882:2011 7.4(1)-implementation<br><br/></p>
<h4 id="参考-220"><a href="#参考-220" class="headerlink" title="参考"></a>参考</h4><p>MISRA C 2004 2.1<br>MISRA C 2012 Dir 4.3<br>MISRA C++ 2008 7-4-3<br><br/><br><br/></p>
<h3 id="▌R8-45-避免重复的函数实现"><a href="#▌R8-45-避免重复的函数实现" class="headerlink" title="▌R8.45 避免重复的函数实现"></a><span id="functionrepetition">▌R8.45 避免重复的函数实现</span></h3><p>ID_functionRepetition&emsp;&emsp;&emsp;&emsp;&nbsp;:bulb: function suggestion</p>
<hr/>

<p>重复的或过于相似的代码不利于维护。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">struct A &#123;</span><br><span class="line">    int a[10];</span><br><span class="line">    ....</span><br><span class="line">    int* foo() &#123;     // Non-compliant, almost identical to ‘foo() const’</span><br><span class="line">        int* p = a;</span><br><span class="line">        for (int i = 1; i != 10; i++) &#123;</span><br><span class="line">            if (a[i] &gt; *p) &#123;</span><br><span class="line">                p = &amp;a[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return p;</span><br><span class="line">    &#125;</span><br><span class="line">    const int* foo() const &#123;     // Non-compliant, almost identical to ‘foo()’</span><br><span class="line">        const int* p = a;</span><br><span class="line">        for (int i = 1; i != 10; i++) &#123;</span><br><span class="line">            if (a[i] &gt; *p) &#123;</span><br><span class="line">                p = &amp;a[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>例中 foo() 返回数组中最大元素的地址，代码与 foo() const 几乎完全相同，当需求有变化时，需要同时修改两个函数，极易造成意料之外的差异，显然是不利于维护的。  </p>
<p>本例可通过模板和自动类型推理将公有代码抽取出来：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class T&gt;</span><br><span class="line">auto* foo_impl(T* t) &#123;   // The common function extracted</span><br><span class="line">    auto* p = t-&gt;a;</span><br><span class="line">    for (auto i = 1; i != 10; i++) &#123;</span><br><span class="line">        if (t-&gt;a[i] &gt; *p) &#123;</span><br><span class="line">            p = &amp;t-&gt;a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct A &#123;</span><br><span class="line">    ....</span><br><span class="line">    int* foo() &#123;</span><br><span class="line">        return foo_impl(this);   // Compliant</span><br><span class="line">    &#125;</span><br><span class="line">    const int* foo() const &#123;</span><br><span class="line">        return foo_impl(this);   // Compliant</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这样，foo() 与 foo() const 的代码便得到了简化，虽然简化后仍然是相同的，但仅为接口调用，可以接受。<br><br/><br><br/></p>
<h4 id="配置-27"><a href="#配置-27" class="headerlink" title="配置"></a>配置</h4><p>tokenCountThreshold：符号数量阈值，小于此阈值的函数不参与比较<br>repetitionRateThreshold：函数相似度阈值，超过则报出<br><br/></p>
<h4 id="参考-221"><a href="#参考-221" class="headerlink" title="参考"></a>参考</h4><p>CWE-1041<br>C++ Core Guidelines ES.3<br><br/><br><br/></p>
<h2 id="9-Control"><a href="#9-Control" class="headerlink" title="9. Control"></a><span id="control">9. Control</span></h2><h3 id="9-1-If"><a href="#9-1-If" class="headerlink" title="9.1 If"></a><span id="control.if">9.1 If</span></h3><h3 id="▌R9-1-1-if-语句不应被分号隔断"><a href="#▌R9-1-1-if-语句不应被分号隔断" class="headerlink" title="▌R9.1.1 if 语句不应被分号隔断"></a><span id="if_semicolon">▌R9.1.1 if 语句不应被分号隔断</span></h3><p>ID_if_semicolon&emsp;&emsp;&emsp;&emsp;&nbsp;:boom: control error</p>
<hr/>

<p>if 语句不应被分号隔断。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (condition);  // Non-compliant, see the semicolon</span><br><span class="line">&#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个分号使整个 if 语句失效，这可能是笔误，也可能是需求变化不再需要条件判断了，在维护过程中加入了分号，形成了令人费解的残留代码，也不能排除是有人恶意篡改了代码，应立即修正。<br><br/><br><br/></p>
<h4 id="参考-222"><a href="#参考-222" class="headerlink" title="参考"></a>参考</h4><p>CWE-670<br><br/><br><br/></p>
<h3 id="▌R9-1-2-在-if…else-if-分枝中不应有重复的条件"><a href="#▌R9-1-2-在-if…else-if-分枝中不应有重复的条件" class="headerlink" title="▌R9.1.2 在 if…else-if 分枝中不应有重复的条件"></a><span id="if_identicalcondition">▌R9.1.2 在 if…else-if 分枝中不应有重复的条件</span></h3><p>ID_if_identicalCondition&emsp;&emsp;&emsp;&emsp;&nbsp;:boom: control error</p>
<hr/>

<p>if…else-if 分枝的条件不应有重复，否则相同条件排在前面的分枝会得以执行，而排在后面的分枝得不到执行机会。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if (condition1) &#123;</span><br><span class="line">    branch1</span><br><span class="line">&#125;</span><br><span class="line">else if (condition2) &#123;</span><br><span class="line">    branch2</span><br><span class="line">&#125;</span><br><span class="line">else if (condition1) &#123;  // Non-compliant, see the previous ‘condition1’</span><br><span class="line">    branch3</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">    branch4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中 branch1 和 branch3 的条件是相同的，所以 branch3 不会被执行。  </p>
<p>此问题为常见笔误，多数由复制粘贴造成，也可能是维护代码时对之前的逻辑不够了解造成的错误。<br><br/><br><br/></p>
<h4 id="相关-144"><a href="#相关-144" class="headerlink" title="相关"></a>相关</h4><p>ID_if_hiddenCondition<br><br/></p>
<h4 id="参考-223"><a href="#参考-223" class="headerlink" title="参考"></a>参考</h4><p>CWE-561<br>CWE-670<br><br/><br><br/></p>
<h3 id="▌R9-1-3-在-if…else-if-分枝中不应有被遮盖的条件"><a href="#▌R9-1-3-在-if…else-if-分枝中不应有被遮盖的条件" class="headerlink" title="▌R9.1.3 在 if…else-if 分枝中不应有被遮盖的条件"></a><span id="if_hiddencondition">▌R9.1.3 在 if…else-if 分枝中不应有被遮盖的条件</span></h3><p>ID_if_hiddenCondition&emsp;&emsp;&emsp;&emsp;&nbsp;:boom: control error</p>
<hr/>

<p>if…else-if 分枝中，如果前面的条件被满足，后面的分枝就不会被执行，所以如果前面的条件是后面条件的一部分，或者前面的条件包含后面的条件，即使后面的条件可以被满足，其分枝也得不到执行机会。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if (condition1) &#123;</span><br><span class="line">    branch1</span><br><span class="line">&#125;</span><br><span class="line">else if (condition2) &#123;</span><br><span class="line">    branch2</span><br><span class="line">&#125;</span><br><span class="line">else if (condition1 &amp;&amp; condition3) &#123;  // Non-compliant, see the previous ‘condition1’</span><br><span class="line">    branch3</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">    branch4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 condition1 为 true，branch1 将得以执行，branch3 不会被执行，如果 condition1 为 false，branch3 还是不会被执行，称 branch3 被 condition1 遮盖了，branch3 永远不会得到执行机会。  </p>
<p>如果前面的条件包含后面的条件，同样也会遮盖后面的条件，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if (condition1 || condition2) &#123;</span><br><span class="line">    branch1</span><br><span class="line">&#125;</span><br><span class="line">else if (condition2) &#123;  // Non-compliant, see the previous ‘condition2’</span><br><span class="line">    branch2</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">    branch3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同理，branch2 永远也不会被执行。<br><br/><br><br/></p>
<h4 id="相关-145"><a href="#相关-145" class="headerlink" title="相关"></a>相关</h4><p>ID_if_identicalCondition<br><br/></p>
<h4 id="参考-224"><a href="#参考-224" class="headerlink" title="参考"></a>参考</h4><p>CWE-561<br>CWE-670<br><br/><br><br/></p>
<h3 id="▌R9-1-4-if-分枝和-else-分枝的代码不应完全相同"><a href="#▌R9-1-4-if-分枝和-else-分枝的代码不应完全相同" class="headerlink" title="▌R9.1.4 if 分枝和 else 分枝的代码不应完全相同"></a><span id="if_identicalblock">▌R9.1.4 if 分枝和 else 分枝的代码不应完全相同</span></h3><p>ID_if_identicalBlock&emsp;&emsp;&emsp;&emsp;&nbsp;:boom: control error</p>
<hr/>

<p>if 分枝和 else 分枝完全相同会使条件判断失去意义，往往是由复制粘贴造成的错误。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (condition) &#123;</span><br><span class="line">    branch</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">    branch  // Non-compliant</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中 branch 表示完全相同的代码，需修正本应存在的差异，或去掉 if-else 结构。<br><br/><br><br/></p>
<h4 id="相关-146"><a href="#相关-146" class="headerlink" title="相关"></a>相关</h4><p>ID_if_identicalElseIfBlock<br>ID_if_identicalImplicitElseBlock<br><br/></p>
<h4 id="参考-225"><a href="#参考-225" class="headerlink" title="参考"></a>参考</h4><p>CWE-670<br><br/><br><br/></p>
<h3 id="▌R9-1-5-if…else-if-各分枝的代码不应完全相同"><a href="#▌R9-1-5-if…else-if-各分枝的代码不应完全相同" class="headerlink" title="▌R9.1.5 if…else-if 各分枝的代码不应完全相同"></a><span id="if_identicalelseifblock">▌R9.1.5 if…else-if 各分枝的代码不应完全相同</span></h3><p>ID_if_identicalElseIfBlock&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: control warning</p>
<hr/>

<p>内容完全相同的分枝是没有意义的，也可能是由复制粘贴造成的错误。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if (condition1) &#123;</span><br><span class="line">    branch1</span><br><span class="line">&#125;</span><br><span class="line">else if (condition2) &#123;</span><br><span class="line">    branch2</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">    branch1  // Non-compliant</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中 condition1 对应分枝和 else 分枝的内容完全相同，应该合并成一个分枝，或修正本应存在的差异：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (condition2) &#123;</span><br><span class="line">    branch2</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">    branch1  // Compliant</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例外：<br>如果分枝内容较少，为了使代码更清晰可以接受适当的重复，但如果分枝内容很多就不应重复了，审计工具不妨指定一个数量限制，当重复分枝的符号数量超过这个限制时算作违规，否则放过。<br><br/><br><br/></p>
<h4 id="配置-28"><a href="#配置-28" class="headerlink" title="配置"></a>配置</h4><p>blockTokenCountThreshold：分枝符号数量阈值，不检查符号数量小于该值的分枝<br><br/></p>
<h4 id="相关-147"><a href="#相关-147" class="headerlink" title="相关"></a>相关</h4><p>ID_if_identicalBlock<br><br/></p>
<h4 id="参考-226"><a href="#参考-226" class="headerlink" title="参考"></a>参考</h4><p>CWE-670<br><br/><br><br/></p>
<h3 id="▌R9-1-6-if-分枝和隐含的-else-分枝代码不应完全相同"><a href="#▌R9-1-6-if-分枝和隐含的-else-分枝代码不应完全相同" class="headerlink" title="▌R9.1.6 if 分枝和隐含的 else 分枝代码不应完全相同"></a><span id="if_identicalimplicitelseblock">▌R9.1.6 if 分枝和隐含的 else 分枝代码不应完全相同</span></h3><p>ID_if_identicalImplicitElseBlock&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: control warning</p>
<hr/>

<p>带有 return、throw 或 break 等子句的 if 语句，其同一作用域的后续代码相当于它的 else 分枝，显然这种隐含的 else 分枝与 if 分枝完全相同是没有意义的，很可能是由复制粘贴造成的错误。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (condition) &#123;</span><br><span class="line">    statements</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line">statements  // Non-compliant</span><br><span class="line">return;</span><br></pre></td></tr></table></figure>
<p>例中 if 语句之内的 statements 以及 return 语句和 if 语句之外的语句完全相同，这种情况下 if 语句的条件判断是没有意义的，需修正本应存在的差异，或去掉 if 语句。<br><br/><br><br/></p>
<h4 id="相关-148"><a href="#相关-148" class="headerlink" title="相关"></a>相关</h4><p>ID_if_identicalElseIfBlock<br>ID_if_identicalSucceedingBlock<br><br/></p>
<h4 id="参考-227"><a href="#参考-227" class="headerlink" title="参考"></a>参考</h4><p>CWE-670<br><br/><br><br/></p>
<h3 id="▌R9-1-7-没有-else-子句的-if-语句与其后续代码相同是可疑的"><a href="#▌R9-1-7-没有-else-子句的-if-语句与其后续代码相同是可疑的" class="headerlink" title="▌R9.1.7 没有 else 子句的 if 语句与其后续代码相同是可疑的"></a><span id="if_identicalsucceedingblock">▌R9.1.7 没有 else 子句的 if 语句与其后续代码相同是可疑的</span></h3><p>ID_if_identicalSucceedingBlock&emsp;&emsp;&emsp;&emsp;&nbsp;:question: control suspicious</p>
<hr/>

<p>if 语句与其同一作用域的后续代码完全相同是可疑的，可能是由复制粘贴造成的错误。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (condition) &#123;</span><br><span class="line">    a = SOME_VALUE;</span><br><span class="line">&#125;</span><br><span class="line">a = SOME_VALUE;  // Rather suspicious</span><br></pre></td></tr></table></figure>
<p>例中对变量 a 的赋值是没有意义的。<br><br/><br><br/></p>
<h4 id="相关-149"><a href="#相关-149" class="headerlink" title="相关"></a>相关</h4><p>ID_if_identicalImplicitElseBlock<br><br/></p>
<h4 id="参考-228"><a href="#参考-228" class="headerlink" title="参考"></a>参考</h4><p>CWE-670<br><br/><br><br/></p>
<h3 id="▌R9-1-8-if-分枝和-else-分枝的起止语句不应相同"><a href="#▌R9-1-8-if-分枝和-else-分枝的起止语句不应相同" class="headerlink" title="▌R9.1.8 if 分枝和 else 分枝的起止语句不应相同"></a><span id="if_commonstatements">▌R9.1.8 if 分枝和 else 分枝的起止语句不应相同</span></h3><p>ID_if_commonStatements&emsp;&emsp;&emsp;&emsp;&nbsp;:bulb: control suggestion</p>
<hr/>

<p>如果 if 分枝和 else 分枝的起止语句相同，应将其从分枝结构中提取出来，否则重复的代码不利于阅读和维护。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if (condition) &#123;</span><br><span class="line">    foo();</span><br><span class="line">    ....</span><br><span class="line">    bar();</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">    foo();</span><br><span class="line">    ....</span><br><span class="line">    bar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>if 与 else 分枝的开头和结尾相同，应提取出来：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">foo();</span><br><span class="line">if (condition) &#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line">bar();</span><br></pre></td></tr></table></figure>
<p>当条件分枝中的所有语句都相同时，本规则特化为 ID_if_identicalBlock，这种情况往往意味着错误。<br><br/><br><br/></p>
<h4 id="相关-150"><a href="#相关-150" class="headerlink" title="相关"></a>相关</h4><p>ID_if_identicalBlock<br><br/></p>
<h4 id="参考-229"><a href="#参考-229" class="headerlink" title="参考"></a>参考</h4><p>CWE-670<br>C++ Core Guidelines ES.3<br><br/><br><br/></p>
<h3 id="▌R9-1-9-if-语句作用域的范围不应有误"><a href="#▌R9-1-9-if-语句作用域的范围不应有误" class="headerlink" title="▌R9.1.9 if 语句作用域的范围不应有误"></a><span id="if_scope">▌R9.1.9 if 语句作用域的范围不应有误</span></h3><p>ID_if_scope&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: control warning</p>
<hr/>

<p>if 语句作用域的范围不应有误。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (condition)</span><br><span class="line">    statement1; statement2;  // Non-compliant</span><br><span class="line"></span><br><span class="line">if (condition)</span><br><span class="line">    statement1;</span><br><span class="line">    statement2;  // Non-compliant</span><br></pre></td></tr></table></figure>
<p>例中 statement2 不在 if 语句的作用域中，但看起来又和 if 语句相关，这种问题多数是由错误的宏展开或无效的缩进造成的。  </p>
<p>为了避免这种问题，if 语句应使用大括号括起来：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (condition) &#123;</span><br><span class="line">    statement1; statement2;  // Compliant</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="相关-151"><a href="#相关-151" class="headerlink" title="相关"></a>相关</h4><p>ID_if_brace<br><br/></p>
<h4 id="参考-230"><a href="#参考-230" class="headerlink" title="参考"></a>参考</h4><p>CWE-483<br><br/><br><br/></p>
<h3 id="▌R9-1-10-如果-if-关键字前面是右大括号，if-关键字应另起一行"><a href="#▌R9-1-10-如果-if-关键字前面是右大括号，if-关键字应另起一行" class="headerlink" title="▌R9.1.10 如果 if 关键字前面是右大括号，if 关键字应另起一行"></a><span id="if_maybeelseif">▌R9.1.10 如果 if 关键字前面是右大括号，if 关键字应另起一行</span></h3><p>ID_if_mayBeElseIf&emsp;&emsp;&emsp;&emsp;&nbsp;:question: control suspicious</p>
<hr/>

<p>当 if 关键字前面是右大括号，且 if 关键字与该大括号在同一行时，属于不良换行方式，易造成 else 等关键字的遗漏。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (condition1) &#123;</span><br><span class="line">    ....</span><br><span class="line">&#125; if (condition2) &#123;  // Rather suspicious, should it be ‘else if’??</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种情况很可能是漏掉了 else 关键字，即使没有被漏掉，也应该让 if 关键字另起一行，否则这种换行习惯会增加遗漏 else 关键字的风险，而且可读性较差。<br><br/><br><br/><br><br/></p>
<h3 id="▌R9-1-11-if-语句的条件不应为赋值表达式"><a href="#▌R9-1-11-if-语句的条件不应为赋值表达式" class="headerlink" title="▌R9.1.11 if 语句的条件不应为赋值表达式"></a><span id="if_assignment">▌R9.1.11 if 语句的条件不应为赋值表达式</span></h3><p>ID_if_assignment&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: control warning</p>
<hr/>

<p>虽然语言允许在 if 语句的条件中赋值，但 = 和 == 极易混淆，建议所有产生 bool 型结果的表达式，都不要包含赋值运算符。  </p>
<p>本规则是 ID_assignmentAsSubExpression 的特化。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void foo(HRESULT r) &#123;</span><br><span class="line">    if (r = S_OK) &#123;     // Non-compliant</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中 S_OK 为常量，在条件中用常量对变量赋值是没有逻辑意义的，如果条件中等号右侧为常量，基本可以判定是 == 被误写成了 =。  </p>
<p>又如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (r = fun()) &#123;   // Non-compliant</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中 fun 为函数，这也是一种公认的不良风格，应将赋值表达式拆分出来，或者在 C++ 代码中改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (auto r = fun()) &#123;   // Compliant</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将赋值表达式加上括号表示有意为之，是一种惯用写法，但并不值得提倡，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if ((r = fun())) &#123;   // Let it go?</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>审计工具不妨通过配置决定是否放过这种情况。<br><br/><br><br/></p>
<h4 id="配置-29"><a href="#配置-29" class="headerlink" title="配置"></a>配置</h4><p>allowEnclosedAssignment：是否放过括号括起来的赋值表达式<br><br/></p>
<h4 id="相关-152"><a href="#相关-152" class="headerlink" title="相关"></a>相关</h4><p>ID_assignmentAsSubExpression<br><br/></p>
<h4 id="参考-231"><a href="#参考-231" class="headerlink" title="参考"></a>参考</h4><p>CWE-480<br>CWE-481<br>CWE-783<br><br/><br><br/></p>
<h3 id="▌R9-1-12-if-语句不应为空"><a href="#▌R9-1-12-if-语句不应为空" class="headerlink" title="▌R9.1.12 if 语句不应为空"></a><span id="if_emptyblock">▌R9.1.12 if 语句不应为空</span></h3><p>ID_if_emptyBlock&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: control warning</p>
<hr/>

<p>空的 if 语句或 else 子句无实际意义，往往是残留代码或功能未实现。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (cond);     // Non-compliant</span><br><span class="line">if (cond) &#123;&#125;   // Non-compliant</span><br></pre></td></tr></table></figure>
<p>如果 if 语句没有 else 分枝，且其分枝内容为空，这样的 if 语句无任何意义，即使其条件有副作用，也不应继续保留该 if 结构。  </p>
<p>又如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (cond) &#123;    // Non-compliant, empty</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    ....       // Nonempty statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (!cond) &#123;   // Compliant</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者添加注释说明为何为空：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (cond) &#123;  </span><br><span class="line">    ;          // Compliant if reasonable comments are provided</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="参考-232"><a href="#参考-232" class="headerlink" title="参考"></a>参考</h4><p>CWE-1071<br><br/><br><br/></p>
<h3 id="▌R9-1-13-if…else-if-分枝数量应在规定范围之内"><a href="#▌R9-1-13-if…else-if-分枝数量应在规定范围之内" class="headerlink" title="▌R9.1.13 if…else-if 分枝数量应在规定范围之内"></a><span id="if_toomanyelseif">▌R9.1.13 if…else-if 分枝数量应在规定范围之内</span></h3><p>ID_if_tooManyElseIf&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: control warning</p>
<hr/>

<p>if…else-if 分枝过多不利于阅读和维护，而且执行时需逐一判断各分枝的条件，效率较低，建议改为遵循某种算法的索引结构。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if (rabbit) &#123;</span><br><span class="line">&#125;</span><br><span class="line">else if (hamster) &#123;</span><br><span class="line">&#125;</span><br><span class="line">// ... 3000 branches ...</span><br><span class="line">// Computers have the courage to execute,</span><br><span class="line">// but do you have the courage to read?</span><br><span class="line">else &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>建议 if…else-if 分枝数量不超过 5 个。<br><br/><br><br/></p>
<h4 id="配置-30"><a href="#配置-30" class="headerlink" title="配置"></a>配置</h4><p>maxElseIfCount：分枝数量上限，超过则报出<br><br/><br><br/></p>
<h3 id="▌R9-1-14-if-分枝中的语句应该用大括号括起来"><a href="#▌R9-1-14-if-分枝中的语句应该用大括号括起来" class="headerlink" title="▌R9.1.14 if 分枝中的语句应该用大括号括起来"></a><span id="if_brace">▌R9.1.14 if 分枝中的语句应该用大括号括起来</span></h3><p>ID_if_brace&emsp;&emsp;&emsp;&emsp;&nbsp;:bulb: control suggestion</p>
<hr/>

<p>组成 if 分枝的语句应为大括号括起来的复合语句，即使该复合语句只包含一条语句。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (cond1)           // Non-compliant</span><br><span class="line">    if (cond2)       // Non-compliant</span><br><span class="line">        action1();</span><br><span class="line">else                 // Non-compliant</span><br><span class="line">    action2();</span><br></pre></td></tr></table></figure>
<p>根据缩进，这段代码想表达的逻辑应是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (cond1) &#123;</span><br><span class="line">    if (cond2) &#123;</span><br><span class="line">        action1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    action2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但 C/C++ 规定 else 子句与最近的 if 子句配对，所以实际逻辑是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (cond1) &#123;</span><br><span class="line">    if (cond2) &#123;</span><br><span class="line">        action1();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        action2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这显然是与预期不符的。  </p>
<p>又如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (cond)      // Non-compliant</span><br><span class="line">    y = 2;</span><br><span class="line">else           // Non-compliant</span><br><span class="line">    x = 3;</span><br><span class="line">    y = 1;</span><br></pre></td></tr></table></figure>
<p>例中 y = 1; 看起来应该是 else 分枝的一部分，但它实际上并不在 else 的作用范围之内，所以用大括号括起来可避免此类问题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (cond) &#123;    // Compliant</span><br><span class="line">    y = 2;</span><br><span class="line">&#125; else &#123;       // Compliant</span><br><span class="line">    x = 3;</span><br><span class="line">    y = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例外：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (cond1) &#123;</span><br><span class="line">    ....</span><br><span class="line">&#125; else if (cond2) &#123;   // Compliant</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接与 if 语句相连的 else 子句不受本规则约束。<br><br/><br><br/></p>
<h4 id="相关-153"><a href="#相关-153" class="headerlink" title="相关"></a>相关</h4><p>ID_do_brace<br>ID_for_brace<br>ID_while_brace<br>ID_switch_brace<br><br/></p>
<h4 id="参考-233"><a href="#参考-233" class="headerlink" title="参考"></a>参考</h4><p>MISRA C 2004 14.9<br>MISRA C 2012 15.6<br>MISRA C++ 2008 6-4-1<br><br/><br><br/></p>
<h3 id="▌R9-1-15-所有-if…else-if-分枝都应以-else-子句结束"><a href="#▌R9-1-15-所有-if…else-if-分枝都应以-else-子句结束" class="headerlink" title="▌R9.1.15 所有 if…else-if 分枝都应以 else 子句结束"></a><span id="if_missingendingelse">▌R9.1.15 所有 if…else-if 分枝都应以 else 子句结束</span></h3><p>ID_if_missingEndingElse&emsp;&emsp;&emsp;&emsp;&nbsp;:bulb: control suggestion</p>
<hr/>

<p>所有 if…else-if 分枝都以 else 子句结束是“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Defensive_programming">防御性编程</a>”思想的良好体现。  </p>
<p>单独的一个 if 分枝不要求接有 else 子句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (x &gt; 0) &#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>存在多个 if…else-if 分枝时，要求接有 else 子句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if (x &gt; 0) &#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line">else if (y &lt; 0)&#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">    // Comment is the minimum requirement,</span><br><span class="line">    // if here is unreachable logically,</span><br><span class="line">    // it&#x27;s better to log or throw an exception</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="相关-154"><a href="#相关-154" class="headerlink" title="相关"></a>相关</h4><p>ID_switch_missingDefault<br><br/></p>
<h4 id="参考-234"><a href="#参考-234" class="headerlink" title="参考"></a>参考</h4><p>MISRA C 2012 15.7<br>MISRA C++ 2008 6-4-2<br><br/><br><br/></p>
<h3 id="9-2-For"><a href="#9-2-For" class="headerlink" title="9.2 For"></a><span id="control.for">9.2 For</span></h3><h3 id="▌R9-2-1-for-语句不应被分号隔断"><a href="#▌R9-2-1-for-语句不应被分号隔断" class="headerlink" title="▌R9.2.1 for 语句不应被分号隔断"></a><span id="for_semicolon">▌R9.2.1 for 语句不应被分号隔断</span></h3><p>ID_for_semicolon&emsp;&emsp;&emsp;&emsp;&nbsp;:boom: control error</p>
<hr/>

<p>for 语句不应被分号隔断。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (....);  // Non-compliant, see the semicolon</span><br><span class="line">&#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分号使循环失效，这可能是笔误，也可能是有人恶意篡改了代码，应立即修正。<br><br/><br><br/></p>
<h4 id="相关-155"><a href="#相关-155" class="headerlink" title="相关"></a>相关</h4><p>ID_do_brace<br>ID_if_brace<br>ID_switch_brace<br>ID_while_brace<br><br/></p>
<h4 id="参考-235"><a href="#参考-235" class="headerlink" title="参考"></a>参考</h4><p>CWE-670<br><br/><br><br/></p>
<h3 id="▌R9-2-2-for-语句中不应存在无条件的跳转语句"><a href="#▌R9-2-2-for-语句中不应存在无条件的跳转语句" class="headerlink" title="▌R9.2.2 for 语句中不应存在无条件的跳转语句"></a><span id="for_uncondbroken">▌R9.2.2 for 语句中不应存在无条件的跳转语句</span></h3><p>ID_for_uncondBroken&emsp;&emsp;&emsp;&emsp;&nbsp;:boom: control error</p>
<hr/>

<p>无条件的 return、throw 或 break 语句会使循环失效，无条件的 continue 语句会使其后面的代码失效，如果其后没有代码时，该 continue 语句是没有意义的。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (....) &#123;</span><br><span class="line">    if (cond)</span><br><span class="line">        foo();</span><br><span class="line">        break;  // Non-compliant</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种问题多数由错误的缩进或混乱的逻辑造成。<br><br/><br><br/></p>
<h4 id="相关-156"><a href="#相关-156" class="headerlink" title="相关"></a>相关</h4><p>ID_uncondJump<br>ID_while_uncondBroken<br><br/></p>
<h4 id="参考-236"><a href="#参考-236" class="headerlink" title="参考"></a>参考</h4><p>CWE-670<br><br/><br><br/></p>
<h3 id="▌R9-2-3-for-语句作用域的范围不应有误"><a href="#▌R9-2-3-for-语句作用域的范围不应有误" class="headerlink" title="▌R9.2.3 for 语句作用域的范围不应有误"></a><span id="for_scope">▌R9.2.3 for 语句作用域的范围不应有误</span></h3><p>ID_for_scope&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: control warning</p>
<hr/>

<p>for 语句作用域的范围不应有误。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (....)</span><br><span class="line">    statement1; statement2;  // Non-compliant</span><br><span class="line"></span><br><span class="line">for (....)</span><br><span class="line">    statement1;</span><br><span class="line">    statement2;  // Non-compliant</span><br></pre></td></tr></table></figure>
<p>例中 statement2 不在 for 循环的作用域中，但看起来又和 for 循环相关，这种问题多数是由宏展开或无效的缩进造成的。为了避免这种问题，for 语句应使用大括号括起来。<br><br/><br><br/></p>
<h4 id="相关-157"><a href="#相关-157" class="headerlink" title="相关"></a>相关</h4><p>ID_for_brace<br><br/></p>
<h4 id="参考-237"><a href="#参考-237" class="headerlink" title="参考"></a>参考</h4><p>CWE-483<br><br/><br><br/></p>
<h3 id="▌R9-2-4-for-语句没有明确的循环变量时应改用-while-语句"><a href="#▌R9-2-4-for-语句没有明确的循环变量时应改用-while-语句" class="headerlink" title="▌R9.2.4 for 语句没有明确的循环变量时应改用 while 语句"></a><span id="for_simplification">▌R9.2.4 for 语句没有明确的循环变量时应改用 while 语句</span></h3><p>ID_for_simplification&emsp;&emsp;&emsp;&emsp;&nbsp;:bulb: control suggestion</p>
<hr/>

<p>for 语句一般用于实现具有明确循环次数和循环变量的迭代算法，循环变量即控制循环次数的变量。for 语句小括号内的三个表达式应分别专注于循环变量的初始化、循环条件的判断、循环变量的增减，这样可以使循环具有清晰的静态结构，便于阅读，利于维护。  </p>
<p>如果没有明确的循环变量，则应改用 while 循环，避免误导维护者。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int n = 0;</span><br><span class="line">for (; condition(); n++) &#123;   // Non-compliant, ‘n’ is not a loop variable</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中 n 不是循环变量，它可以记录循环次数，但与循环条件无关，应改为 while 循环：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int n = 0;</span><br><span class="line">while (condition()) &#123;   // Compliant</span><br><span class="line">    ....</span><br><span class="line">    n++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 for 语句的第 1 个和第 3 个表达式为空，则更应改为 while 循环，使代码更简洁，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for (; condition(); ) &#123;   // Non-compliant</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (;;) &#123;   // Non-compliant</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">while (condition()) &#123;   // Compliant</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">while (true) &#123;   // Compliant</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="参考-238"><a href="#参考-238" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines ES.73<br><br/><br><br/></p>
<h3 id="▌R9-2-5-for-循环体不应为空"><a href="#▌R9-2-5-for-循环体不应为空" class="headerlink" title="▌R9.2.5 for 循环体不应为空"></a><span id="for_emptyblock">▌R9.2.5 for 循环体不应为空</span></h3><p>ID_for_emptyBlock&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: control warning</p>
<hr/>

<p>空的 for 循环结构不清晰，可读性较差。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int foo(int n) &#123;</span><br><span class="line">    int s = 0;</span><br><span class="line">    for (int i = 1; i &lt;= n; s += i++);   // Non-compliant</span><br><span class="line">    return s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>for 语句小括号内的三个表达式应分别专注于循环变量的初始化、循环条件的判断、循环变量的增减，循环体应专注于迭代算法的实现，使程序具有清晰的静态结构，便于阅读，利于维护。  </p>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int foo(int n) &#123;</span><br><span class="line">    int s = 0;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;   // Compliant</span><br><span class="line">        s += i;</span><br><span class="line">    &#125;</span><br><span class="line">    return s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外，在 C++ 代码中，如果只通过 for 语句遍历容器，而不对元素进行操作是没有意义的，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void bar(vector&lt;int&gt;&amp; v) &#123;</span><br><span class="line">    for (auto i: v);         // Non-compliant</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种代码多为残留代码或功能未实现，应当及时去除或补全功能。<br><br/><br><br/></p>
<h4 id="参考-239"><a href="#参考-239" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines ES.85<br><br/><br><br/></p>
<h3 id="▌R9-2-6-for-循环变量不应为浮点型"><a href="#▌R9-2-6-for-循环变量不应为浮点型" class="headerlink" title="▌R9.2.6 for 循环变量不应为浮点型"></a><span id="for_floatcounter">▌R9.2.6 for 循环变量不应为浮点型</span></h3><p>ID_for_floatCounter&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: control warning</p>
<hr/>

<p>用于控制循环次数的变量称为“循环变量”，这种变量不应采用浮点类型，否则循环的次数难以控制。  </p>
<p>由于浮点型变量的不精确性使浮点型变量不适用于控制循环次数，参见 ID_illFloatComparison。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">size_t n = 0;</span><br><span class="line">for (float f = 0.f; f &lt; 1.f; f += 0.001f) &#123;  // Non-compliant</span><br><span class="line">    ....</span><br><span class="line">    n++;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; n &lt;&lt; &#x27;\n&#x27;;  // Not 1000</span><br></pre></td></tr></table></figure>
<p>本例按常识应循环 1000 次，然而由于 f 无法精确表示 0.001，导致实际循环次数与预期产生偏差。  </p>
<p>可变通地建立整型循环变量与浮点数的关系：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (size_t n = 0; n &lt; 1000; n++) &#123;  // Compliant</span><br><span class="line">    float f = n * 0.001f;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样循环的次数便与预期相符。<br><br/><br><br/></p>
<h4 id="相关-158"><a href="#相关-158" class="headerlink" title="相关"></a>相关</h4><p>ID_illFloatComparison<br><br/></p>
<h4 id="参考-240"><a href="#参考-240" class="headerlink" title="参考"></a>参考</h4><p>MISRA C 2004 13.4<br>MISRA C 2012 14.1<br>MISRA C++ 2008 6-5-1<br><br/><br><br/></p>
<h3 id="▌R9-2-7-for-循环变量不应在循环体内被改变"><a href="#▌R9-2-7-for-循环变量不应在循环体内被改变" class="headerlink" title="▌R9.2.7 for 循环变量不应在循环体内被改变"></a><span id="for_counterchangedinbody">▌R9.2.7 for 循环变量不应在循环体内被改变</span></h3><p>ID_for_counterChangedInBody&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: control warning</p>
<hr/>

<p>用于控制循环次数的变量称为“循环变量”，为了使代码具有清晰的静态结构，循环变量只应在 for 语句的第 3 个表达式中被改变。   </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; 8; i++) &#123;</span><br><span class="line">    ....</span><br><span class="line">    if (cond) &#123;</span><br><span class="line">        ++i;      // Non-compliant</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中循环变量 i 在多处被改变，循环的执行次数和结束条件变得难以理解，易错且不利于维护。<br><br/><br><br/></p>
<h4 id="参考-241"><a href="#参考-241" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines ES.86<br>MISRA C 2004 13.6<br>MISRA C++ 2008 6-5-3<br><br/><br><br/></p>
<h3 id="▌R9-2-8-嵌套的-for-语句不应使用相同的循环变量"><a href="#▌R9-2-8-嵌套的-for-语句不应使用相同的循环变量" class="headerlink" title="▌R9.2.8 嵌套的 for 语句不应使用相同的循环变量"></a><span id="for_counternested">▌R9.2.8 嵌套的 for 语句不应使用相同的循环变量</span></h3><p>ID_for_counterNested&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: control warning</p>
<hr/>

<p>同一个循环变量在内外层 for 循环中均被修改，使循环次数难以控制，是过于复杂的循环逻辑，也可能是某种错误。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">    for (; i &lt; 10; i++) &#123;         // Non-compliant</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="相关-159"><a href="#相关-159" class="headerlink" title="相关"></a>相关</h4><p>ID_for_counterChangedInBody<br><br/><br><br/></p>
<h3 id="▌R9-2-9-for-循环体应该用大括号括起来"><a href="#▌R9-2-9-for-循环体应该用大括号括起来" class="headerlink" title="▌R9.2.9 for 循环体应该用大括号括起来"></a><span id="for_brace">▌R9.2.9 for 循环体应该用大括号括起来</span></h3><p>ID_for_brace&emsp;&emsp;&emsp;&emsp;&nbsp;:bulb: control suggestion</p>
<hr/>

<p>for 循环体应为大括号括起来的复合语句，即使该复合语句只包含一条语句。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a = 0;</span><br><span class="line">for (int i = 0; i &lt; 10; i++)  // Non-compliant</span><br><span class="line">    a += i;</span><br></pre></td></tr></table></figure>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int a = 0;</span><br><span class="line">for (int i = 0; i &lt; 10; i++) &#123;  // Compliant</span><br><span class="line">    a += i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="参考-242"><a href="#参考-242" class="headerlink" title="参考"></a>参考</h4><p>MISRA C 2004 14.8<br>MISRA C 2012 15.6<br>MISRA C++ 2008 6-3-1<br><br/><br><br/></p>
<h3 id="9-3-While"><a href="#9-3-While" class="headerlink" title="9.3 While"></a><span id="control.while">9.3 While</span></h3><h3 id="▌R9-3-1-while-语句不应被分号隔断"><a href="#▌R9-3-1-while-语句不应被分号隔断" class="headerlink" title="▌R9.3.1 while 语句不应被分号隔断"></a><span id="while_semicolon">▌R9.3.1 while 语句不应被分号隔断</span></h3><p>ID_while_semicolon&emsp;&emsp;&emsp;&emsp;&nbsp;:boom: control error</p>
<hr/>

<p>while 语句不应被分号隔断。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while (condition);  // Non-compliant, see the semicolon</span><br><span class="line">&#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分号使循环失效，有造成死循环的危险。<br><br/><br><br/></p>
<h4 id="参考-243"><a href="#参考-243" class="headerlink" title="参考"></a>参考</h4><p>CWE-670<br><br/><br><br/></p>
<h3 id="▌R9-3-2-while-语句中不应存在无条件的跳转语句"><a href="#▌R9-3-2-while-语句中不应存在无条件的跳转语句" class="headerlink" title="▌R9.3.2 while 语句中不应存在无条件的跳转语句"></a><span id="while_uncondbroken">▌R9.3.2 while 语句中不应存在无条件的跳转语句</span></h3><p>ID_while_uncondBroken&emsp;&emsp;&emsp;&emsp;&nbsp;:boom: control error</p>
<hr/>

<p>不受条件限制的 return、throw 或 break 语句会使循环失效，不受条件限制的 continue 语句会使其后面的代码失效，如果其后没有代码，该 continue 语句是没有意义的。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">while (condition) &#123;</span><br><span class="line">    ....</span><br><span class="line">    return;     // Non-compliant</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">while (condition) &#123;</span><br><span class="line">    ....</span><br><span class="line">    break;      // Non-compliant, becomes an if-statement</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">while (condition) &#123;</span><br><span class="line">    ....</span><br><span class="line">    continue;   // Non-compliant, meaningless continue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种问题多数由错误的缩进或混乱的逻辑造成。<br><br/><br><br/></p>
<h4 id="相关-160"><a href="#相关-160" class="headerlink" title="相关"></a>相关</h4><p>ID_uncondJump<br>ID_for_uncondBroken<br><br/></p>
<h4 id="参考-244"><a href="#参考-244" class="headerlink" title="参考"></a>参考</h4><p>CWE-670<br><br/><br><br/></p>
<h3 id="▌R9-3-3-while-语句的条件不应为赋值表达式"><a href="#▌R9-3-3-while-语句的条件不应为赋值表达式" class="headerlink" title="▌R9.3.3 while 语句的条件不应为赋值表达式"></a><span id="while_assignment">▌R9.3.3 while 语句的条件不应为赋值表达式</span></h3><p>ID_while_assignment&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: control warning</p>
<hr/>

<p>虽然语言允许在 while 语句的条件中赋值，但 = 和 == 极易混淆，建议所有产生 bool 型结果的表达式，都不要包含赋值运算符。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while (x = 123)  // Non-compliant</span><br><span class="line">&#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="相关-161"><a href="#相关-161" class="headerlink" title="相关"></a>相关</h4><p>ID_if_assignment<br><br/></p>
<h4 id="参考-245"><a href="#参考-245" class="headerlink" title="参考"></a>参考</h4><p>CWE-480<br>CWE-783<br><br/><br><br/></p>
<h3 id="▌R9-3-4-while-语句作用域的范围不应有误"><a href="#▌R9-3-4-while-语句作用域的范围不应有误" class="headerlink" title="▌R9.3.4 while 语句作用域的范围不应有误"></a><span id="while_scope">▌R9.3.4 while 语句作用域的范围不应有误</span></h3><p>ID_while_scope&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: control warning</p>
<hr/>

<p>while 语句作用域的范围不应有误。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">while (condition)</span><br><span class="line">    statement1; statement2;  // Non-compliant</span><br><span class="line"></span><br><span class="line">while (condition)</span><br><span class="line">    statement1;</span><br><span class="line">    statement2;  // Non-compliant</span><br></pre></td></tr></table></figure>
<p>例中 statement2 不在 while 循环的作用域中，但看起来又和 while 循环相关，这种问题多数是由宏展开或无效的缩进造成的。<br>为了避免这种问题，while 语句应使用大括号括起来。<br><br/><br><br/></p>
<h4 id="相关-162"><a href="#相关-162" class="headerlink" title="相关"></a>相关</h4><p>ID_while_brace<br><br/></p>
<h4 id="参考-246"><a href="#参考-246" class="headerlink" title="参考"></a>参考</h4><p>CWE-483<br><br/><br><br/></p>
<h3 id="▌R9-3-5-while-循环体不应为空"><a href="#▌R9-3-5-while-循环体不应为空" class="headerlink" title="▌R9.3.5 while 循环体不应为空"></a><span id="while_emptyblock">▌R9.3.5 while 循环体不应为空</span></h3><p>ID_while_emptyBlock&emsp;&emsp;&emsp;&emsp;&nbsp;:bulb: control suggestion</p>
<hr/>

<p>空的 while 循环将功能全部压缩到了条件表达式中，各子句的职责划分不明确，可读性较差。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while (flg.test_and_set());     // Non-compliant</span><br><span class="line">i = (i * j) % n;                // The indent is odd here</span><br><span class="line">flg.clear();</span><br></pre></td></tr></table></figure>
<p>示例代码循环检测并设置某标志位，这些功能被压缩到了循环条件中，而且容易使人误以为下一行代码也与循环有关。  </p>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">while (true) &#123;                  // Compliant</span><br><span class="line">    if (!flg.test_and_set()) &#123;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">i = (i * j) % n;</span><br><span class="line">flg.clear();</span><br></pre></td></tr></table></figure>
<p>循环体的内容才是循环主体功能的体现，不应为空。<br><br/><br><br/></p>
<h4 id="参考-247"><a href="#参考-247" class="headerlink" title="参考"></a>参考</h4><p>CWE-1071<br>C++ Core Guidelines ES.85<br><br/><br><br/></p>
<h3 id="▌R9-3-6-while-循环体应该用大括号括起来"><a href="#▌R9-3-6-while-循环体应该用大括号括起来" class="headerlink" title="▌R9.3.6 while 循环体应该用大括号括起来"></a><span id="while_brace">▌R9.3.6 while 循环体应该用大括号括起来</span></h3><p>ID_while_brace&emsp;&emsp;&emsp;&emsp;&nbsp;:bulb: control suggestion</p>
<hr/>

<p>while 循环体应为大括号括起来的复合语句，即使该复合语句只包含一条语句。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">while (condition)   // Non-compliant</span><br><span class="line">    statement;</span><br><span class="line"></span><br><span class="line">while (condition)   // Non-compliant</span><br><span class="line">    statement1;</span><br><span class="line">    statement2;</span><br></pre></td></tr></table></figure>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">while (condition) &#123;   // Compliant</span><br><span class="line">    statement;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">while (condition) &#123;   // Compliant</span><br><span class="line">    statement1;</span><br><span class="line">    statement2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="相关-163"><a href="#相关-163" class="headerlink" title="相关"></a>相关</h4><p>ID_do_brace<br>ID_for_brace<br>ID_if_brace<br>ID_switch_brace<br>ID_switch_onlyDefault<br>ID_switch_onlyOneCase<br><br/></p>
<h4 id="参考-248"><a href="#参考-248" class="headerlink" title="参考"></a>参考</h4><p>MISRA C 2004 14.8<br>MISRA C 2012 15.6<br>MISRA C++ 2008 6-3-1<br><br/><br><br/></p>
<h3 id="9-4-Do"><a href="#9-4-Do" class="headerlink" title="9.4 Do"></a><span id="control.do">9.4 Do</span></h3><h3 id="▌R9-4-1-注意-do-while-0-中可疑的-continue-语句"><a href="#▌R9-4-1-注意-do-while-0-中可疑的-continue-语句" class="headerlink" title="▌R9.4.1 注意 do-while(0) 中可疑的 continue 语句"></a><span id="do_suspiciouscontinue">▌R9.4.1 注意 do-while(0) 中可疑的 continue 语句</span></h3><p>ID_do_suspiciousContinue&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: control warning</p>
<hr/>

<p>continue 语句和 break 语句在语义上是不同的，但在 do-while(0) 中的功效是一样的。  </p>
<p>在 do-while(0) 的循环体中如果既有 break 语句又有 continue 语句，continue 语句被误用的可能性较大。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int foo() &#123;</span><br><span class="line">    do &#123;</span><br><span class="line">        ....</span><br><span class="line">        if (cond1) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        ....</span><br><span class="line">        if (cond2) &#123;</span><br><span class="line">            continue;   // Rather suspicious</span><br><span class="line">        &#125;</span><br><span class="line">        ....</span><br><span class="line">    &#125; while (0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>建议在 do-while(0) 中只使用 break 语句，不使用 continue 语句。<br><br/><br><br/></p>
<h4 id="参考-249"><a href="#参考-249" class="headerlink" title="参考"></a>参考</h4><p>CWE-670<br><br/><br><br/></p>
<h3 id="▌R9-4-2-do-while-循环体不应为空"><a href="#▌R9-4-2-do-while-循环体不应为空" class="headerlink" title="▌R9.4.2 do-while 循环体不应为空"></a><span id="do_emptyblock">▌R9.4.2 do-while 循环体不应为空</span></h3><p>ID_do_emptyBlock&emsp;&emsp;&emsp;&emsp;&nbsp;:bulb: control suggestion</p>
<hr/>

<p>空的 do-while 循环将功能全部压缩到了条件表达式中，各子句的职责划分不明确，可读性较差。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void foo(char* d, const char* s) &#123;</span><br><span class="line">    do &#123;&#125; while (*d++ = *s++);       // Non-compliant</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例代码将循环的条件和循环产生的副作用叠加在了一起，易使人误解。<br><br/><br><br/></p>
<h4 id="相关-164"><a href="#相关-164" class="headerlink" title="相关"></a>相关</h4><p>ID_while_emptyBlock<br><br/></p>
<h4 id="参考-250"><a href="#参考-250" class="headerlink" title="参考"></a>参考</h4><p>CWE-1071<br>C++ Core Guidelines ES.85<br><br/><br><br/></p>
<h3 id="▌R9-4-3-do-while-循环体应该用大括号括起来"><a href="#▌R9-4-3-do-while-循环体应该用大括号括起来" class="headerlink" title="▌R9.4.3 do-while 循环体应该用大括号括起来"></a><span id="do_brace">▌R9.4.3 do-while 循环体应该用大括号括起来</span></h3><p>ID_do_brace&emsp;&emsp;&emsp;&emsp;&nbsp;:bulb: control suggestion</p>
<hr/>

<p>do-while 循环体应为大括号括起来的复合语句，即使该复合语句只包含一条语句。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">do              // Non-compliant</span><br><span class="line">    if (cond)</span><br><span class="line">        break;</span><br><span class="line">    while (*p++ = *q++);</span><br><span class="line">while (true);</span><br></pre></td></tr></table></figure>
<p>例中 while 关键字与 do 关键字产生了错误的对应关系，导致最后一个 while 形成了死循环，应改为：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">do &#123;              // Compliant</span><br><span class="line">    if (cond) &#123;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    while (*p++ = *q++);</span><br><span class="line">&#125;</span><br><span class="line">while (true);</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="相关-165"><a href="#相关-165" class="headerlink" title="相关"></a>相关</h4><p>ID_for_brace<br>ID_if_brace<br>ID_switch_brace<br>ID_while_brace<br><br/></p>
<h4 id="参考-251"><a href="#参考-251" class="headerlink" title="参考"></a>参考</h4><p>MISRA C 2004 14.9<br>MISRA C 2012 15.6<br>MISRA C++ 2008 6-3-1<br><br/><br><br/></p>
<h3 id="▌R9-4-4-不建议使用-do-语句"><a href="#▌R9-4-4-不建议使用-do-语句" class="headerlink" title="▌R9.4.4 不建议使用 do 语句"></a><span id="do_deprecated">▌R9.4.4 不建议使用 do 语句</span></h3><p>ID_do_deprecated&emsp;&emsp;&emsp;&emsp;&nbsp;:bulb: control suggestion</p>
<hr/>

<p>do 语句的终止条件在末尾，且第一次执行时不检查终止条件，易被误用。  </p>
<p>do 语句可用于循环，也可用于定义由 break 等语句跳出的作用域，糅合了循环和流程跳转，使代码变得复杂，不利于阅读和维护，建议将复杂的 do 语句抽取成函数，使代码的静态结构更加清晰。  </p>
<p>宏定义中的 do-while(0) 可不受本规则限制。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void foo(int n) &#123;</span><br><span class="line">    do &#123;</span><br><span class="line">        if (n &lt; 0) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        ....</span><br><span class="line">        if (n &gt; 0) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        ....</span><br><span class="line">    &#125; while (condition);   // Too complex</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="参考-252"><a href="#参考-252" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines ES.75<br><br/><br><br/></p>
<h3 id="9-5-Switch"><a href="#9-5-Switch" class="headerlink" title="9.5 Switch"></a><span id="control.switch">9.5 Switch</span></h3><h3 id="▌R9-5-1-switch-语句不应被分号隔断"><a href="#▌R9-5-1-switch-语句不应被分号隔断" class="headerlink" title="▌R9.5.1 switch 语句不应被分号隔断"></a><span id="switch_semicolon">▌R9.5.1 switch 语句不应被分号隔断</span></h3><p>ID_switch_semicolon&emsp;&emsp;&emsp;&emsp;&nbsp;:boom: control error</p>
<hr/>

<p>switch 语句不应被分号隔断。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">switch (v);  // Non-compliant</span><br></pre></td></tr></table></figure>
<p>这种无意义的 switch 语句应及时去除或补全代码。<br><br/><br><br/></p>
<h4 id="参考-253"><a href="#参考-253" class="headerlink" title="参考"></a>参考</h4><p>CWE-670<br><br/><br><br/></p>
<h3 id="▌R9-5-2-switch-语句不应为空"><a href="#▌R9-5-2-switch-语句不应为空" class="headerlink" title="▌R9.5.2 switch 语句不应为空"></a><span id="switch_emptyblock">▌R9.5.2 switch 语句不应为空</span></h3><p>ID_switch_emptyBlock&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: control warning</p>
<hr/>

<p>空的 switch 语句无实际意义，往往是残留代码或功能未实现。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">switch (v) &#123;&#125;  // Non-compliant</span><br></pre></td></tr></table></figure>
<p>这种无意义的 switch 语句应及时去除或补全代码。<br><br/><br><br/></p>
<h4 id="参考-254"><a href="#参考-254" class="headerlink" title="参考"></a>参考</h4><p>CWE-1071<br>MISRA C++ 2008 6-4-8<br><br/><br><br/></p>
<h3 id="▌R9-5-3-case-标签的值不可超出-switch-条件的范围"><a href="#▌R9-5-3-case-标签的值不可超出-switch-条件的范围" class="headerlink" title="▌R9.5.3 case 标签的值不可超出 switch 条件的范围"></a><span id="switch_caseoutofrange">▌R9.5.3 case 标签的值不可超出 switch 条件的范围</span></h3><p>ID_switch_caseOutOfRange&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: control warning</p>
<hr/>

<p>如果 case 标签的值超出了 switch 条件的范围，会导致相应分枝永远不会被执行。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void foo(char c)</span><br><span class="line">&#123;</span><br><span class="line">    switch (c)</span><br><span class="line">    &#123;</span><br><span class="line">    case 100:    // Compliant</span><br><span class="line">        ....</span><br><span class="line">        break;</span><br><span class="line">    case 256:    // Non-compliant, unreachable branch</span><br><span class="line">        ....</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中变量 c 的值不可能为 256，所以 case 256 对应的分枝永远不会被执行。<br><br/><br><br/></p>
<h4 id="相关-166"><a href="#相关-166" class="headerlink" title="相关"></a>相关</h4><p>ID_illComparison<br><br/></p>
<h4 id="参考-255"><a href="#参考-255" class="headerlink" title="参考"></a>参考</h4><p>CWE-561<br><br/><br><br/></p>
<h3 id="▌R9-5-4-switch-语句中任何子句都应从属于某个-case-或-default-分枝"><a href="#▌R9-5-4-switch-语句中任何子句都应从属于某个-case-或-default-分枝" class="headerlink" title="▌R9.5.4 switch 语句中任何子句都应从属于某个 case 或 default 分枝"></a><span id="switch_invalidstatement">▌R9.5.4 switch 语句中任何子句都应从属于某个 case 或 default 分枝</span></h3><p>ID_switch_invalidStatement&emsp;&emsp;&emsp;&emsp;&nbsp;:boom: control error</p>
<hr/>

<p>switch 语句中任何子句都应从属于某个 case 或 default 分枝，否则不会被执行。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">switch (v)</span><br><span class="line">&#123;</span><br><span class="line">    int i;    // Non-compliant</span><br><span class="line">    i = 0;    // Non-compliant</span><br><span class="line">case 1:</span><br><span class="line">    ....</span><br><span class="line">    break;</span><br><span class="line">default:</span><br><span class="line">    bar(i);   // Logic error, ‘i’ is not initialized</span><br><span class="line">    break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中对变量 i 的声明和赋值不从属于任何 case 或 default 分枝，是无效语句。<br><br/><br><br/></p>
<h4 id="参考-256"><a href="#参考-256" class="headerlink" title="参考"></a>参考</h4><p>CWE-561<br>MISRA C 2012 16.1<br>MISRA C++ 2008 6-4-3<br><br/><br><br/></p>
<h3 id="▌R9-5-5-case-和-default-标签应直接从属于-switch-语句"><a href="#▌R9-5-5-case-和-default-标签应直接从属于-switch-语句" class="headerlink" title="▌R9.5.5 case 和 default 标签应直接从属于 switch 语句"></a><span id="switch_badformedcase">▌R9.5.5 case 和 default 标签应直接从属于 switch 语句</span></h3><p>ID_switch_badFormedCase&emsp;&emsp;&emsp;&emsp;&nbsp;:bulb: control suggestion</p>
<hr/>

<p>不直接从属于 switch 语句的 case 或 default 标签用于非结构性跳转，是公认的不良实现。  </p>
<p>关于非结构性跳转的进一步讨论可参见 ID_forbidGoto。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">switch (v)</span><br><span class="line">&#123;</span><br><span class="line">case 1:         // Compliant </span><br><span class="line">    if (cond)</span><br><span class="line">    &#123;</span><br><span class="line">case 2:         // Non-compliant </span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">default:        // Non-compliant </span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中 case 1 直接从属于 switch 语句，而 case 2 和 default 直接从属于 if 语句，当 v 的值不是 1 时，会绕过 if 语句的条件判断，产生非结构性跳转，与 goto 语句的问题一样，很容易导致逻辑混乱且不利于维护。  </p>
<p>虽然有些编程技巧会将 case 置于循环中，如“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Duff&#39;s_device">Duff’s device</a>”等，但当今主流的编程语言均已不再提倡非结构性跳转。<br><br/><br><br/></p>
<h4 id="相关-167"><a href="#相关-167" class="headerlink" title="相关"></a>相关</h4><p>ID_forbidGotoBlocks<br><br/></p>
<h4 id="参考-257"><a href="#参考-257" class="headerlink" title="参考"></a>参考</h4><p>MISRA C 2004 15.1<br>MISRA C 2012 16.2<br>MISRA C++ 2008 6-4-4<br><br/><br><br/></p>
<h3 id="▌R9-5-6-不应存在紧邻-default-标签的空-case-标签"><a href="#▌R9-5-6-不应存在紧邻-default-标签的空-case-标签" class="headerlink" title="▌R9.5.6 不应存在紧邻 default 标签的空 case 标签"></a><span id="switch_uselessfallthrough">▌R9.5.6 不应存在紧邻 default 标签的空 case 标签</span></h3><p>ID_switch_uselessFallThrough&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: control warning</p>
<hr/>

<p>紧邻 default 标签的空 case 标签是没有意义的，应当去除。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">switch (v)</span><br><span class="line">&#123;</span><br><span class="line">case 0:     // Compliant</span><br><span class="line">    ....</span><br><span class="line">    break;</span><br><span class="line"></span><br><span class="line">case 1:     // Non-compliant</span><br><span class="line">default:</span><br><span class="line">case 2:     // Non-compliant</span><br><span class="line">    ....</span><br><span class="line">    break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">switch (v)</span><br><span class="line">&#123;</span><br><span class="line">case 0:     // Compliant</span><br><span class="line">    ....</span><br><span class="line">    break;</span><br><span class="line"></span><br><span class="line">default:    // Compliant</span><br><span class="line">    ....</span><br><span class="line">    break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/><br><br/></p>
<h3 id="▌R9-5-7-不应存在内容完全相同的-case-分枝"><a href="#▌R9-5-7-不应存在内容完全相同的-case-分枝" class="headerlink" title="▌R9.5.7 不应存在内容完全相同的 case 分枝"></a><span id="switch_identicalbranch">▌R9.5.7 不应存在内容完全相同的 case 分枝</span></h3><p>ID_switch_identicalBranch&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: control warning</p>
<hr/>

<p>内容完全相同的分枝应合并为一个分枝，也可能是由复制粘贴造成的错误。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">switch (v)</span><br><span class="line">&#123;</span><br><span class="line">case 1:</span><br><span class="line">    branch1</span><br><span class="line">    break;</span><br><span class="line">case 2:</span><br><span class="line">    branch2</span><br><span class="line">    break;</span><br><span class="line">case 3:</span><br><span class="line">    branch1   // Non-compliant</span><br><span class="line">    break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中 case 3 对应的分枝和 case 1 对应的分枝内容完全相同，应将其合并为一个分枝，或修正本应存在的差异。  </p>
<p>例外：<br>如果分枝内容较少，为了使代码更清晰可以接受适当的重复，但如果分枝内容很多就不应重复了，审计工具不妨指定一个数量限制，当重复分枝的符号数量超过这个限制时算作违规，否则放过。<br><br/><br><br/></p>
<h4 id="配置-31"><a href="#配置-31" class="headerlink" title="配置"></a>配置</h4><p>branchTokenCountThreshold：分枝符号数量阈值，不检查符号数量小于该值的分枝<br><br/></p>
<h4 id="相关-168"><a href="#相关-168" class="headerlink" title="相关"></a>相关</h4><p>ID_if_identicalBlock<br>ID_if_identicalElseIfBlock<br><br/></p>
<h4 id="参考-258"><a href="#参考-258" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines ES.3<br><br/><br><br/></p>
<h3 id="▌R9-5-8-switch-语句的条件不应为-bool-型"><a href="#▌R9-5-8-switch-语句的条件不应为-bool-型" class="headerlink" title="▌R9.5.8 switch 语句的条件不应为 bool 型"></a><span id="switch_bool">▌R9.5.8 switch 语句的条件不应为 bool 型</span></h3><p>ID_switch_bool&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: control warning</p>
<hr/>

<p>如果条件为 bool 型，应改用 if-else 语句使代码的结构更清晰。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void foo(bool b)</span><br><span class="line">&#123;</span><br><span class="line">    switch (b)   // Non-compliant</span><br><span class="line">    &#123;</span><br><span class="line">    case true:</span><br><span class="line">        ....</span><br><span class="line">        break;</span><br><span class="line">    case false:</span><br><span class="line">        ....</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void foo(bool b)</span><br><span class="line">&#123;</span><br><span class="line">    if (b)  // Compliant</span><br><span class="line">    &#123;</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="参考-259"><a href="#参考-259" class="headerlink" title="参考"></a>参考</h4><p>MISRA C 2004 15.4<br>MISRA C 2012 16.7<br>MISRA C++ 2008 6-4-7<br><br/><br><br/></p>
<h3 id="▌R9-5-9-switch-语句不应只包含-default-标签"><a href="#▌R9-5-9-switch-语句不应只包含-default-标签" class="headerlink" title="▌R9.5.9 switch 语句不应只包含 default 标签"></a><span id="switch_onlydefault">▌R9.5.9 switch 语句不应只包含 default 标签</span></h3><p>ID_switch_onlyDefault&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: control warning</p>
<hr/>

<p>只有 default 标签的 switch 语句是没有意义的，起不到分枝选择的作用，往往是残留代码或功能未实现。  </p>
<p>示例： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">switch (v)</span><br><span class="line">&#123;</span><br><span class="line">default:    // Non-compliant</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种空的可以 fallthrough 到 default 标签的空 case 标签也是没有意义的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">switch (v)</span><br><span class="line">&#123;</span><br><span class="line">case 1:     // Non-compliant</span><br><span class="line">case 2:</span><br><span class="line">default:</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="参考-260"><a href="#参考-260" class="headerlink" title="参考"></a>参考</h4><p>MISRA C 2012 16.6<br>MISRA C++ 2008 6-4-8<br><br/><br><br/></p>
<h3 id="▌R9-5-10-switch-语句不应只包含一个-case-标签"><a href="#▌R9-5-10-switch-语句不应只包含一个-case-标签" class="headerlink" title="▌R9.5.10 switch 语句不应只包含一个 case 标签"></a><span id="switch_onlyonecase">▌R9.5.10 switch 语句不应只包含一个 case 标签</span></h3><p>ID_switch_onlyOneCase&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: control warning</p>
<hr/>

<p>只有一个 case 标签的 switch 语句与 if 语句语义相同，但形式上更为复杂，应改为 if 语句。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">switch (v)</span><br><span class="line">&#123;</span><br><span class="line">case 123:    // Non-compliant</span><br><span class="line">    ....</span><br><span class="line">    break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (v == 123)</span><br><span class="line">&#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="参考-261"><a href="#参考-261" class="headerlink" title="参考"></a>参考</h4><p>MISRA C 2012 16.6<br><br/><br><br/></p>
<h3 id="▌R9-5-11-switch-语句分枝数量应在规定范围之内"><a href="#▌R9-5-11-switch-语句分枝数量应在规定范围之内" class="headerlink" title="▌R9.5.11 switch 语句分枝数量应在规定范围之内"></a><span id="switch_toomanycases">▌R9.5.11 switch 语句分枝数量应在规定范围之内</span></h3><p>ID_switch_tooManyCases&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: control warning</p>
<hr/>

<p>switch 语句分枝过多不利于阅读和维护，这种情况下建议将分枝抽取成函数，再按遵循某种算法的索引结构组织在一起。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">switch (v)</span><br><span class="line">&#123;</span><br><span class="line">case 1: .... break;</span><br><span class="line">case 2: .... break;</span><br><span class="line">        ....             // Lots of cases</span><br><span class="line">case 1000: .... break;   // Non-compliant</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>建议 case 数量不超过 10 个。<br><br/><br><br/></p>
<h4 id="配置-32"><a href="#配置-32" class="headerlink" title="配置"></a>配置</h4><p>maxCasesCount：分枝数量上限，超过则报出<br><br/><br><br/></p>
<h3 id="▌R9-5-12-switch-语句应配有-default-分枝"><a href="#▌R9-5-12-switch-语句应配有-default-分枝" class="headerlink" title="▌R9.5.12 switch 语句应配有 default 分枝"></a><span id="switch_missingdefault">▌R9.5.12 switch 语句应配有 default 分枝</span></h3><p>ID_switch_missingDefault&emsp;&emsp;&emsp;&emsp;&nbsp;:bulb: control suggestion</p>
<hr/>

<p>所有 switch 语句都配有 default 分枝是“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Defensive_programming">防御性编程</a>”思想的良好体现。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">switch (v)</span><br><span class="line">&#123;</span><br><span class="line">case 0:</span><br><span class="line">    ....</span><br><span class="line">    break;</span><br><span class="line">case 1:</span><br><span class="line">    ....</span><br><span class="line">    break;</span><br><span class="line">default:</span><br><span class="line">    // Comment is the minimum requirement,</span><br><span class="line">    // if here is unreachable logically,</span><br><span class="line">    // it&#x27;s better to log or throw an exception</span><br><span class="line">    break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例外：<br>当 switch 条件为枚举类型，且 case 标签已对应所有枚举项时，不再要求有 default 分枝。<br><br/><br><br/></p>
<h4 id="相关-169"><a href="#相关-169" class="headerlink" title="相关"></a>相关</h4><p>ID_if_missingEndingElse<br><br/></p>
<h4 id="参考-262"><a href="#参考-262" class="headerlink" title="参考"></a>参考</h4><p>CWE-478<br>MISRA C 2012 16.4<br>MISRA C++ 2008 6-4-6<br><br/><br><br/></p>
<h3 id="▌R9-5-13-switch-语句的每个非空分枝都应该用无条件的-break-或-return-语句终止"><a href="#▌R9-5-13-switch-语句的每个非空分枝都应该用无条件的-break-或-return-语句终止" class="headerlink" title="▌R9.5.13 switch 语句的每个非空分枝都应该用无条件的 break 或 return 语句终止"></a><span id="switch_breakomitted">▌R9.5.13 switch 语句的每个非空分枝都应该用无条件的 break 或 return 语句终止</span></h3><p>ID_switch_breakOmitted&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: control warning</p>
<hr/>

<p>在 switch 语句的分枝中，break 或 return 语句的缺失是导致错误的常见原因。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">switch (a)</span><br><span class="line">&#123;</span><br><span class="line">case 0:</span><br><span class="line">    b = 1;</span><br><span class="line">    break;  // Compliant</span><br><span class="line">case 1:</span><br><span class="line">    b = 2;  // Non-compliant, missing ‘break’</span><br><span class="line">default:</span><br><span class="line">    b = 3;</span><br><span class="line">    break;  // Compliant</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相连的 case 标签不受本规则约束，但最好配有注释：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">switch (c)</span><br><span class="line">&#123;</span><br><span class="line">case 0:     // Compliant</span><br><span class="line">case 1:</span><br><span class="line">    ....</span><br><span class="line">    break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>少数情况下，如果确实不能有 break 或 return 语句，应添加注释说明情况，或在 C++ 代码中用 [[fallthrough]] 注明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">switch (v)</span><br><span class="line">&#123;</span><br><span class="line">case 1:</span><br><span class="line">    do_something();</span><br><span class="line">    [[fallthrough]];   // Compliant, since C++17</span><br><span class="line">default:</span><br><span class="line">    do_something_default();</span><br><span class="line">    break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="依据-141"><a href="#依据-141" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 6.8.4.2(7)<br>ISO/IEC 9899:2011 6.8.4.2(7)<br>ISO/IEC 14882:2003 6.4.2(6)<br>ISO/IEC 14882:2011 6.4.2(6)<br>ISO/IEC 14882:2017 10.6.5(1 2 3)<br><br/></p>
<h4 id="参考-263"><a href="#参考-263" class="headerlink" title="参考"></a>参考</h4><p>CWE-484<br>C++ Core Guidelines ES.78<br>MISRA C 2004 15.2<br>MISRA C 2012 16.3<br>MISRA C++ 2008 6-4-5<br><br/><br><br/></p>
<h3 id="▌R9-5-14-switch-语句应该用大括号括起来"><a href="#▌R9-5-14-switch-语句应该用大括号括起来" class="headerlink" title="▌R9.5.14 switch 语句应该用大括号括起来"></a><span id="switch_brace">▌R9.5.14 switch 语句应该用大括号括起来</span></h3><p>ID_switch_brace&emsp;&emsp;&emsp;&emsp;&nbsp;:bulb: control suggestion</p>
<hr/>

<p>switch 语句应为包含多条语句的复合语句，且用大括号括起来，否则不应选用 switch 语句。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">switch (v)   // Non-compliant</span><br><span class="line">    case 0:</span><br><span class="line">        foo(v);</span><br></pre></td></tr></table></figure>
<p>应改为 if 语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (v == 0) &#123;   // Compliant</span><br><span class="line">    foo(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="相关-170"><a href="#相关-170" class="headerlink" title="相关"></a>相关</h4><p>ID_if_brace<br>ID_switch_onlyDefault<br>ID_switch_onlyOneCase<br><br/></p>
<h4 id="参考-264"><a href="#参考-264" class="headerlink" title="参考"></a>参考</h4><p>MISRA C 2004 14.8<br>MISRA C 2012 15.6<br>MISRA C++ 2008 6-3-1<br><br/><br><br/></p>
<h3 id="▌R9-5-15-switch-语句不应嵌套"><a href="#▌R9-5-15-switch-语句不应嵌套" class="headerlink" title="▌R9.5.15 switch 语句不应嵌套"></a><span id="switch_forbidnest">▌R9.5.15 switch 语句不应嵌套</span></h3><p>ID_switch_forbidNest&emsp;&emsp;&emsp;&emsp;&nbsp;:no_entry: control suggestion</p>
<hr/>

<p>嵌套的 switch 语句使代码显得复杂，不利于阅读和维护。  </p>
<p>不同 switch 语句的分枝交织在一起，较难看出分枝的从属关系，尤其是相关代码行数较多时这种问题会更为明显，应将内嵌的 switch 语句抽取成一个函数，使代码具有更清晰的静态结构。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">switch (u)</span><br><span class="line">&#123;</span><br><span class="line">case 1:</span><br><span class="line">    ....</span><br><span class="line">case 2:</span><br><span class="line">    switch (v)  // Non-compliant</span><br><span class="line">    &#123;</span><br><span class="line">    case 3:     // Confusing</span><br><span class="line">        ....</span><br><span class="line">    case 4:</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">default:</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/><br><br/></p>
<h3 id="9-6-Try-catch"><a href="#9-6-Try-catch" class="headerlink" title="9.6 Try-catch"></a><span id="control.try-catch">9.6 Try-catch</span></h3><h3 id="▌R9-6-1-try-关键字的作用域不应为空"><a href="#▌R9-6-1-try-关键字的作用域不应为空" class="headerlink" title="▌R9.6.1 try 关键字的作用域不应为空"></a><span id="try_emptyblock">▌R9.6.1 try 关键字的作用域不应为空</span></h3><p>ID_try_emptyBlock&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: control warning</p>
<hr/>

<p>try 关键字的作用域，即 try 关键字后的复合语句不应为空，否则无实际意义，往往是残留代码或功能未实现。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">try   // Non-compliant, the compound-statement is empty</span><br><span class="line">&#123;&#125;</span><br><span class="line">catch (Exception&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    handle(e);  // The whole statement is meaningless</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="参考-265"><a href="#参考-265" class="headerlink" title="参考"></a>参考</h4><p>CWE-1071<br><br/><br><br/></p>
<h3 id="▌R9-6-2-catch-子句不应为空"><a href="#▌R9-6-2-catch-子句不应为空" class="headerlink" title="▌R9.6.2 catch 子句不应为空"></a><span id="catch_emptyblock">▌R9.6.2 catch 子句不应为空</span></h3><p>ID_catch_emptyBlock&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: control warning</p>
<hr/>

<p>空的 catch 子句仅捕获异常而未作任何处理，相当于掩盖了异常。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void foo() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">    catch (E&amp;)   // Non-compliant, empty catch-clause</span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>掩盖异常也可能会影响到程序其他方面的正常运行。  </p>
<p>至少应添加日志记录等操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void foo() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">    catch (E&amp;) &#123;</span><br><span class="line">        log(&quot;messages&quot;);   // Compliant</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="参考-266"><a href="#参考-266" class="headerlink" title="参考"></a>参考</h4><p>CWE-391<br>CWE-1069<br>CWE-1071<br><br/><br><br/></p>
<h3 id="▌R9-6-3-不应嵌套-try-catch-语句"><a href="#▌R9-6-3-不应嵌套-try-catch-语句" class="headerlink" title="▌R9.6.3 不应嵌套 try-catch 语句"></a><span id="try_forbidnest">▌R9.6.3 不应嵌套 try-catch 语句</span></h3><p>ID_try_forbidNest&emsp;&emsp;&emsp;&emsp;&nbsp;:no_entry: control suggestion</p>
<hr/>

<p>嵌套的 try-catch 语句使代码显得复杂，不利于阅读和维护。  </p>
<p>在嵌套的 try-catch 语句中较难看出各 catch 子句的从属关系，尤其是相关代码行数较多时这种问题会更为明显，应将内嵌的 try-catch 语句抽取成函数，使代码具有更清晰的静态结构。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    ....</span><br><span class="line">    try &#123;    // Non-compliant</span><br><span class="line">        ....</span><br><span class="line">    &#125; catch (A&amp;) &#123;    // Confusing</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125; catch (B&amp;) &#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="参考-267"><a href="#参考-267" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines E.17<br><br/><br><br/></p>
<h3 id="▌R9-6-4-捕获所有异常的-catch-…-子句应位于最后"><a href="#▌R9-6-4-捕获所有异常的-catch-…-子句应位于最后" class="headerlink" title="▌R9.6.4 捕获所有异常的 catch(…) 子句应位于最后"></a><span id="try_disorderedellipsis">▌R9.6.4 捕获所有异常的 catch(…) 子句应位于最后</span></h3><p>ID_try_disorderedEllipsis&emsp;&emsp;&emsp;&emsp;&nbsp;:boom: control error</p>
<hr/>

<p>如果 catch(…) 子句排在前面，其后面的 catch 子句会失去作用。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    ....</span><br><span class="line">&#125; catch (...) &#123;   // Non-compliant, disordered catch-all handler</span><br><span class="line">    ....</span><br><span class="line">&#125; catch (E&amp;) &#123;   // Unreachable</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    ....</span><br><span class="line">&#125; catch (E&amp;) &#123;</span><br><span class="line">    ....</span><br><span class="line">&#125; catch (...) &#123;   // Compliant</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="相关-171"><a href="#相关-171" class="headerlink" title="相关"></a>相关</h4><p>ID_unreachableCode<br><br/></p>
<h4 id="依据-142"><a href="#依据-142" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 14882:2003 15.3(6)<br>ISO/IEC 14882:2011 15.3(5)<br>ISO/IEC 14882:2011 18.3(5)<br><br/></p>
<h4 id="参考-268"><a href="#参考-268" class="headerlink" title="参考"></a>参考</h4><p>CWE-561<br>C++ Core Guidelines E.31<br>MISRA C++ 2008 15-3-7<br><br/><br><br/></p>
<h3 id="▌R9-6-5-面向派生类的-catch-子句应排在面向基类的-catch-子句之前"><a href="#▌R9-6-5-面向派生类的-catch-子句应排在面向基类的-catch-子句之前" class="headerlink" title="▌R9.6.5 面向派生类的 catch 子句应排在面向基类的 catch 子句之前"></a><span id="try_disorderedhandlers">▌R9.6.5 面向派生类的 catch 子句应排在面向基类的 catch 子句之前</span></h3><p>ID_try_disorderedHandlers&emsp;&emsp;&emsp;&emsp;&nbsp;:boom: control error</p>
<hr/>

<p>以派生类对象为参数的 catch 子句应排在以基类对象为参数的 catch 子句之前，否则后面的 catch 子句会失去作用。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class B &#123;&#125;;</span><br><span class="line">class D: public B &#123;&#125;;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">    ....</span><br><span class="line">&#125; catch (B&amp;) &#123;</span><br><span class="line">    ....</span><br><span class="line">&#125; catch (D&amp;) &#123;  // Non-compliant, unreachable</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中 B 为基类，D 为派生类，D 类异常会被第一个 catch 子句捕获，第二个 catch 子句失去了作用。  </p>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    ....</span><br><span class="line">&#125; catch (D&amp;) &#123;</span><br><span class="line">    ....</span><br><span class="line">&#125; catch (B&amp;) &#123;  // Compliant</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="相关-172"><a href="#相关-172" class="headerlink" title="相关"></a>相关</h4><p>ID_unreachableCode<br><br/></p>
<h4 id="依据-143"><a href="#依据-143" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 14882:2003 15.3<br>ISO/IEC 14882:2011 15.3<br>ISO/IEC 14882:2011 18.3<br><br/></p>
<h4 id="参考-269"><a href="#参考-269" class="headerlink" title="参考"></a>参考</h4><p>CWE-561<br>C++ Core Guidelines E.31<br>MISRA C++ 2008 15-3-6<br>SEI CERT ERR54-CPP<br><br/><br><br/></p>
<h3 id="9-7-Jump"><a href="#9-7-Jump" class="headerlink" title="9.7 Jump"></a><span id="control.jump">9.7 Jump</span></h3><h3 id="▌R9-7-1-禁止-goto-语句向嵌套的或无包含关系的作用域跳转"><a href="#▌R9-7-1-禁止-goto-语句向嵌套的或无包含关系的作用域跳转" class="headerlink" title="▌R9.7.1 禁止 goto 语句向嵌套的或无包含关系的作用域跳转"></a><span id="forbidgotoblocks">▌R9.7.1 禁止 goto 语句向嵌套的或无包含关系的作用域跳转</span></h3><p>ID_forbidGotoBlocks&emsp;&emsp;&emsp;&emsp;&nbsp;:no_entry: control warning</p>
<hr/>

<p>不同的作用域对应不同的条件约束，在不同的作用域间跳转是对约束的破坏，很容易导致逻辑混乱。  </p>
<p>向嵌套的或无包含关系的作用域跳转是不应被允许的，如果是为了结束当前流程而在同层或向外层作用域跳转，则可被本规则允许。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int foo(int a) &#123;</span><br><span class="line">    if (a == 0) &#123;</span><br><span class="line">        goto L;    // Non-compliant, jumps into a block</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; a; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; a; j++) &#123;</span><br><span class="line">L:</span><br><span class="line">            if (cond) &#123;</span><br><span class="line">                goto M;   // Compliant, jumps out of loops</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">M:</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中 goto L 从 if 语句跳入循环语句是应当被禁止的，而 goto M 用于结束循环流程，可以保留。<br><br/><br><br/></p>
<h4 id="相关-173"><a href="#相关-173" class="headerlink" title="相关"></a>相关</h4><p>ID_forbidGotoBack<br>ID_forbidGoto<br><br/></p>
<h4 id="参考-270"><a href="#参考-270" class="headerlink" title="参考"></a>参考</h4><p>MISRA C 2012 15.3<br>MISRA C++ 2008 6-6-1<br><br/><br><br/></p>
<h3 id="▌R9-7-2-禁止-goto-语句向前跳转"><a href="#▌R9-7-2-禁止-goto-语句向前跳转" class="headerlink" title="▌R9.7.2 禁止 goto 语句向前跳转"></a><span id="forbidgotoback">▌R9.7.2 禁止 goto 语句向前跳转</span></h3><p>ID_forbidGotoBack&emsp;&emsp;&emsp;&emsp;&nbsp;:no_entry: control suggestion</p>
<hr/>

<p>向先于当前 goto 语句定义的标签跳转，可读性较差，是公认的不良实现。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int foo() &#123;</span><br><span class="line">    int i = 0, j = 0;</span><br><span class="line">L:</span><br><span class="line">    j += 1;</span><br><span class="line">    i += j;</span><br><span class="line">    if (j &gt; 100) &#123;</span><br><span class="line">        goto M;      // Compliant</span><br><span class="line">    &#125;</span><br><span class="line">    goto L;          // Non-compliant</span><br><span class="line">M:</span><br><span class="line">    return i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中 goto M 向后跳转符合本规则要求，而 goto L 向前跳转不符合要求，应改用循环等结构性语句。<br><br/><br><br/></p>
<h4 id="相关-174"><a href="#相关-174" class="headerlink" title="相关"></a>相关</h4><p>ID_forbidGotoBlocks<br>ID_forbidGoto<br><br/></p>
<h4 id="参考-271"><a href="#参考-271" class="headerlink" title="参考"></a>参考</h4><p>MISRA C 2012 15.2<br>MISRA C++ 2008 6-6-2<br><br/><br><br/></p>
<h3 id="▌R9-7-3-禁用-goto-语句"><a href="#▌R9-7-3-禁用-goto-语句" class="headerlink" title="▌R9.7.3 禁用 goto 语句"></a><span id="forbidgoto">▌R9.7.3 禁用 goto 语句</span></h3><p>ID_forbidGoto&emsp;&emsp;&emsp;&emsp;&nbsp;:no_entry: control suggestion</p>
<hr/>

<p>历史表明，goto 语句会破坏程序的结构性规划，很容易导致逻辑混乱且不利于阅读和维护，在非自动生成的、对可读性有要求的代码中，建议禁用 goto 语句。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if (cond0) &#123;</span><br><span class="line">    goto L;    // Non-compliant</span><br><span class="line">&#125;</span><br><span class="line">....</span><br><span class="line">if (cond1) &#123;</span><br><span class="line">L:</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>语句的排列和作用域的嵌套描述了程序的静态结构，清晰的静态结构使人易于理解程序的行为，而 goto 语句会打破这种结构，无规律的跳转会严重地降低代码可读性，例中 goto L 会绕过第二个 if 语句的条件约束，可读性很差，应被禁止。  </p>
<p>C 语言的流程管理较为简单，goto 语句可提供一定的灵活性，但不应作为常规实现手段，也应受一定的限制，在 C 代码中使用 goto 语句应遵循 ID_forbidGotoBlocks 和 ID_forbidGotoBack 等规则。  </p>
<p>C++ 语言提供了更丰富的流程管理功能，在 C++ 代码中不应再使用 goto 语句。  </p>
<p>下面给出 goto 语句的一种常用模式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void foo(size_t n)</span><br><span class="line">&#123;</span><br><span class="line">    int *a = NULL, *b = NULL, *c = NULL;</span><br><span class="line">    a = (int*)malloc(n);</span><br><span class="line">    if (!a) &#123;</span><br><span class="line">        goto E;</span><br><span class="line">    &#125;</span><br><span class="line">    b = (int*)malloc(n);</span><br><span class="line">    if (!b) &#123;</span><br><span class="line">        goto E;</span><br><span class="line">    &#125;</span><br><span class="line">    c = (int*)malloc(n);    // Multiple resource allocation</span><br><span class="line">    if (!c) &#123;</span><br><span class="line">        goto E;</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">E:                          // Single exit point</span><br><span class="line">    free(a);</span><br><span class="line">    free(b);</span><br><span class="line">    free(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在多次资源分配过程中，如果某次分配失败则需要释放已分配的资源，利用 goto 语句可实现资源的统一释放，在 C 代码中如果不用 goto 语句反而会很繁琐，所以这种模式在 C 代码中可以复用。  </p>
<p>由于 C++ 提供容器、智能指针等更丰富的资源管理手段，所以不建议在 C++ 代码中再使用这种模式，即使标准库没有和相关资源对应的功能，也应该利用“<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/raii">RAII</a>”等机制对其先封装再使用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void foo(size_t n) &#123;</span><br><span class="line">    std::vector&lt;int&gt; a, b, c;   // Safe and brief</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="相关-175"><a href="#相关-175" class="headerlink" title="相关"></a>相关</h4><p>ID_forbidGotoBlocks<br>ID_forbidGotoBack<br><br/></p>
<h4 id="参考-272"><a href="#参考-272" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines ES.76<br>MISRA C 2012 15.1<br><br/><br><br/></p>
<h3 id="▌R9-7-4-禁用-setjmp、longjmp"><a href="#▌R9-7-4-禁用-setjmp、longjmp" class="headerlink" title="▌R9.7.4 禁用 setjmp、longjmp"></a><span id="forbidlongjmp">▌R9.7.4 禁用 setjmp、longjmp</span></h3><p>ID_forbidLongjmp&emsp;&emsp;&emsp;&emsp;&nbsp;:no_entry: control warning</p>
<hr/>

<p>setjmp、longjmp 可以在函数间跳转，进一步破坏了结构化编程理念，非框架代码不应使用。  </p>
<p>setjmp 与 longjmp 由类型为 jmp_buf 的参数关联，只能在同一线程中使用，如果调用 longjmp 时没有对应的 setjmp，或 setjmp 所在函数已经结束执行，会导致标准未定义的行为，而且要注意 setjmp、longjmp 无法与 C++ 对象自动析构等机制兼容，极易造成意料之外的错误。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">jmp_buf buf;</span><br><span class="line"></span><br><span class="line">float div(int a, int b) &#123;</span><br><span class="line">    if (b == 0) &#123;</span><br><span class="line">        longjmp(buf, 1);     // Non-compliant</span><br><span class="line">    &#125;</span><br><span class="line">    return (float)a / b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    if (setjmp(buf) == 0) &#123;          // Non-compliant</span><br><span class="line">        printf(&quot;%f\n&quot;, div(3, 0));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>setjmp 返回 0 表示设置跳转位置成功，之后如果调用 longjmp 会跳回 setjmp 的位置，这时 setjmp 返回非 0 值，这种机制在 C 语言中可以用作异常处理，也可以实现“协程”等概念，但会严重地降低代码可读性，在普通的业务逻辑或算法实现中不应使用。  </p>
<p>另外，函数间跳转与编译器的优化机制有冲突，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">jmp_buf buf;</span><br><span class="line"></span><br><span class="line">void foo() &#123; longjmp(buf, 1); &#125;</span><br><span class="line"></span><br><span class="line">void bar() &#123;</span><br><span class="line">    int i = 1;            // Missing ‘volatile’</span><br><span class="line">    if (!setjmp(buf)) &#123;</span><br><span class="line">        i++;</span><br><span class="line">        foo();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        printf(&quot;%d\n&quot;, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在启用优化时和关闭优化时可能会有不同的输出，启用优化时局部变量 i 可能直接存于寄存器，当通过 longjmp 跳转回 bar 函数时，i++ 的结果会丢失。将局部变量用 volatile 限定可解决这种问题，但很容易遗漏或产生无必要的限定。<br><br/><br><br/></p>
<h4 id="依据-144"><a href="#依据-144" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 7.13.2.1(2)-undefined<br>ISO/IEC 14882:2011 18.10(4)-undefined<br><br/></p>
<h4 id="参考-273"><a href="#参考-273" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines SL.C.1<br>MISRA C 2004 20.7<br>MISRA C 2012 21.4<br>MISRA C++ 2008 17-0-5<br>SEI CERT ERR52-CPP<br><br/><br><br/></p>
<h3 id="▌R9-7-5-不应存在不受条件控制的跳转语句"><a href="#▌R9-7-5-不应存在不受条件控制的跳转语句" class="headerlink" title="▌R9.7.5 不应存在不受条件控制的跳转语句"></a><span id="uncondjump">▌R9.7.5 不应存在不受条件控制的跳转语句</span></h3><p>ID_uncondJump&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: control warning</p>
<hr/>

<p>不受条件控制的跳转语句会剥夺其后续代码的执行机会，往往意味着逻辑错误，也可能是调试或维护痕迹。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void foo() &#123;</span><br><span class="line">    if (cond) &#123;</span><br><span class="line">        goto L;   // Non-compliant, unconditional goto</span><br><span class="line">        bar();    // Unreachable code    </span><br><span class="line">    &#125;</span><br><span class="line">L:</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中 goto 语句相对其同一作用域中的后续代码 bar(); 是不受条件控制的，bar 函数得不到执行机会。<br><br/><br><br/></p>
<h4 id="相关-176"><a href="#相关-176" class="headerlink" title="相关"></a>相关</h4><p>ID_unreachableCode<br><br/><br><br/></p>
<h3 id="▌R9-7-6-不应存在不改变程序流程的跳转语句"><a href="#▌R9-7-6-不应存在不改变程序流程的跳转语句" class="headerlink" title="▌R9.7.6 不应存在不改变程序流程的跳转语句"></a><span id="redundantjump">▌R9.7.6 不应存在不改变程序流程的跳转语句</span></h3><p>ID_redundantJump&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: control warning</p>
<hr/>

<p>不改变程序流程的跳转语句是多余的，往往意味着逻辑错误，也可能是调试或维护痕迹。  </p>
<p>goto、return、break、continue 等跳转语句均受本规则约束。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void foo() &#123;</span><br><span class="line">    goto L;   // Non-compliant, redundant</span><br><span class="line">L:</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void bar() &#123;</span><br><span class="line">    ....</span><br><span class="line">    return;   // Non-compliant, redundant</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void baz() &#123;</span><br><span class="line">    while (cond) &#123;</span><br><span class="line">        ....</span><br><span class="line">        continue;   // Non-compliant, redundant</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/><br><br/></p>
<h3 id="▌R9-7-7-避免使用跳转语句退出循环"><a href="#▌R9-7-7-避免使用跳转语句退出循环" class="headerlink" title="▌R9.7.7 避免使用跳转语句退出循环"></a><span id="jumpoutloop">▌R9.7.7 避免使用跳转语句退出循环</span></h3><p>ID_jumpOutLoop&emsp;&emsp;&emsp;&emsp;&nbsp;:bulb: control suggestion</p>
<hr/>

<p>循环的退出条件应与其控制表达式一致，使代码具有清晰的静态结构，否则可读性较差，尤其在多个嵌套的作用域中使用 break、goto 或 return 等跳转语句，会使代码难以理解。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">while (cond) &#123;</span><br><span class="line">    if (x) &#123;</span><br><span class="line">        if (y) &#123;</span><br><span class="line">            break;   // Bad</span><br><span class="line">        &#125;</span><br><span class="line">        ....</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        ....</span><br><span class="line">        break;   // Bad</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中循环条件散落在循环体内，而且循环的主体逻辑被各种跳转语句“割裂”，是不利于阅读和维护的。<br><br/><br><br/></p>
<h4 id="相关-177"><a href="#相关-177" class="headerlink" title="相关"></a>相关</h4><p>ID_tooManyExit<br><br/></p>
<h4 id="参考-274"><a href="#参考-274" class="headerlink" title="参考"></a>参考</h4><p>MISRA C 2004 14.6<br>MISRA C 2012 15.4<br>MISRA C++ 2008 6-6-4<br><br/><br><br/></p>
<h2 id="10-Expression"><a href="#10-Expression" class="headerlink" title="10. Expression"></a><span id="expression">10. Expression</span></h2><h3 id="10-1-Logic"><a href="#10-1-Logic" class="headerlink" title="10.1 Logic"></a><span id="expression.logic">10.1 Logic</span></h3><h3 id="▌R10-1-1-不应存在无意义的重复子表达式"><a href="#▌R10-1-1-不应存在无意义的重复子表达式" class="headerlink" title="▌R10.1.1 不应存在无意义的重复子表达式"></a><span id="illidentical">▌R10.1.1 不应存在无意义的重复子表达式</span></h3><p>ID_illIdentical&emsp;&emsp;&emsp;&emsp;&nbsp;:boom: expression error</p>
<hr/>

<p>逻辑与、逻辑或、按位与、按位或的子表达式以及三元表达式的两个分枝不应重复，否则相关运算会失去意义。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void foo(int* p, int* q) &#123;</span><br><span class="line">    if (p != NULL &amp;&amp; p != NULL) &#123;   // Non-compliant</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void bar() &#123;</span><br><span class="line">    while (FLAG0 | FLAG1 | FLAG0) &#123;   // Non-compliant</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">char baz(bool x) &#123;</span><br><span class="line">    return x? &#x27;a&#x27;: &#x27;a&#x27;;   // Non-compliant</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中重复的子表达式都是有问题的，这是很常见的错误，多由复制粘贴引起。修正时不应只删去重复项，还要考虑是否漏掉了某些项。  </p>
<p>例外：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void qux(ifstream&amp; f) &#123;</span><br><span class="line">    if (f.get() == &#x27;a&#x27; &amp;&amp; f.get() == &#x27;a&#x27;) &#123;   // Let it go</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具有副作用的逻辑子表达式可不受本规则约束。例中重复的子表达式可以改变文件流的状态，但第二个子表达式可能不会被执行，这种代码即使没有逻辑错误也是不便于维护的，参见 ID_shortCircuitSideEffect。<br><br/><br><br/></p>
<h4 id="参考-275"><a href="#参考-275" class="headerlink" title="参考"></a>参考</h4><p>CWE-682<br><br/><br><br/></p>
<h3 id="▌R10-1-2-逻辑子表达式之间不应存在矛盾"><a href="#▌R10-1-2-逻辑子表达式之间不应存在矛盾" class="headerlink" title="▌R10.1.2 逻辑子表达式之间不应存在矛盾"></a><span id="conflictcondition">▌R10.1.2 逻辑子表达式之间不应存在矛盾</span></h3><p>ID_conflictCondition&emsp;&emsp;&emsp;&emsp;&nbsp;:boom: expression error</p>
<hr/>

<p>相互矛盾的逻辑子表达式会使整个表达式的结果恒为真或恒为假，导致逻辑错误。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a == 1 &amp;&amp; a == 2   // always false</span><br><span class="line">a != 1 || a != 2   // always true</span><br></pre></td></tr></table></figure>
<p>同一变量不可能同时等于不同的值，这种表达式是无效的。  </p>
<p>又如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a &gt; b &amp;&amp; a &lt;= b   // always false</span><br><span class="line">a &gt; b || a &lt;= b   // always true</span><br><span class="line"></span><br><span class="line">a == b &amp;&amp; a != b   // always false</span><br><span class="line">a == b || a != b   // always true</span><br><span class="line"></span><br><span class="line">a &lt; -128 &amp;&amp; a &gt; 127     // always false</span><br><span class="line">a &gt;= -128 || a &lt;= 127   // always true</span><br></pre></td></tr></table></figure>
<p>这种表达式均为常见笔误，应及时修正。<br><br/><br><br/></p>
<h4 id="相关-178"><a href="#相关-178" class="headerlink" title="相关"></a>相关</h4><p>ID_redundantCondition<br>ID_simplifiableCondition<br><br/></p>
<h4 id="参考-276"><a href="#参考-276" class="headerlink" title="参考"></a>参考</h4><p>CWE-570<br>CWE-571<br><br/><br><br/></p>
<h3 id="▌R10-1-3-作为条件的逻辑表达式不应恒为真或恒为假"><a href="#▌R10-1-3-作为条件的逻辑表达式不应恒为真或恒为假" class="headerlink" title="▌R10.1.3 作为条件的逻辑表达式不应恒为真或恒为假"></a><span id="invalidcondition">▌R10.1.3 作为条件的逻辑表达式不应恒为真或恒为假</span></h3><p>ID_invalidCondition&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: expression warning</p>
<hr/>

<p>以恒为真或恒为假的表达式作为条件是没有意义的，属于逻辑错误。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void foo() &#123;</span><br><span class="line">    int i = 1;</span><br><span class="line">    if (i &gt; 0) &#123;   // Non-compliant, always true</span><br><span class="line">        ....       </span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        ....       // Infeasible path</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中变量 i 初始化为 1 后在没有被修改过的情况下，仍对其进行判断是没有意义的，else 分枝的代码得不到执行机会。<br><br/><br><br/></p>
<h4 id="相关-179"><a href="#相关-179" class="headerlink" title="相关"></a>相关</h4><p>ID_constLogicExpression<br><br/></p>
<h4 id="参考-277"><a href="#参考-277" class="headerlink" title="参考"></a>参考</h4><p>CWE-570<br>CWE-571<br>MISRA C 2004 13.7<br>MISRA C 2012 14.3<br>MISRA C++ 2008 0-1-2<br><br/><br><br/></p>
<h3 id="▌R10-1-4-不应存在多余的逻辑子表达式"><a href="#▌R10-1-4-不应存在多余的逻辑子表达式" class="headerlink" title="▌R10.1.4 不应存在多余的逻辑子表达式"></a><span id="redundantcondition">▌R10.1.4 不应存在多余的逻辑子表达式</span></h3><p>ID_redundantCondition&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: expression warning</p>
<hr/>

<p>逻辑或、逻辑与的子表达式有包含关系时，其中的一个表达式是多余的。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a &gt; b &amp;&amp; a != b     // None-compliant, a != b is redundant</span><br><span class="line">a &lt; b || a != b     // None-compliant, a &lt; b is redundant</span><br><span class="line">a &gt;= b &amp;&amp; a == b    // None-compliant, a &gt;= b is redundant</span><br><span class="line">a == b || a &lt;= b    // None-compliant, a == b is redundant</span><br></pre></td></tr></table></figure>
<p>多余的子表达式很可能意味着某种错误，需认真对待。<br><br/><br><br/></p>
<h4 id="相关-180"><a href="#相关-180" class="headerlink" title="相关"></a>相关</h4><p>ID_simplifiableCondition<br>ID_conflictCondition<br><br/><br><br/></p>
<h3 id="▌R10-1-5-逻辑表达式及逻辑子表达式不应为常量"><a href="#▌R10-1-5-逻辑表达式及逻辑子表达式不应为常量" class="headerlink" title="▌R10.1.5 逻辑表达式及逻辑子表达式不应为常量"></a><span id="constlogicexpression">▌R10.1.5 逻辑表达式及逻辑子表达式不应为常量</span></h3><p>ID_constLogicExpression&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: expression warning</p>
<hr/>

<p>不改变程序流程的常量逻辑表达式是没有意义的，而常量逻辑子表达式则是多余的。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if (false) &#123;  // Non-compliant</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">while (false) &#123;  // Non-compliant</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const bool False = false;</span><br><span class="line">if (False &amp;&amp; other_condition) &#123;  // Non-compliant</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种代码往往是调试或维护过程中产生的残留代码，应及时去除。  </p>
<p>例外：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">while (true) &#123;  // Compliant</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">do &#123;</span><br><span class="line">    ....</span><br><span class="line">&#125; while (0);  // Compliant</span><br></pre></td></tr></table></figure>
<p>true 或 1 等常量可作为 while 或 do-while 循环的条件，false 或 0 等常量可作为 do-while 循环的条件。  </p>
<p>由宏定义的常量也不应作为控制语句的条件，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#define M 1</span><br><span class="line"></span><br><span class="line">if (M) &#123;  // Non-compliant</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应采用条件编译的方式，避免占用运行时资源：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#if M  // Compliant</span><br><span class="line">    ....</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>或：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if constexpr (M) &#123;  // Compliant, since C++17</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="参考-278"><a href="#参考-278" class="headerlink" title="参考"></a>参考</h4><p>CWE-570<br>CWE-571<br>MISRA C 2004 13.7<br>MISRA C 2012 14.3<br>MISRA C++ 2008 0-1-2<br><br/><br><br/></p>
<h3 id="▌R10-1-6-逻辑表达式的右子表达式不应有副作用"><a href="#▌R10-1-6-逻辑表达式的右子表达式不应有副作用" class="headerlink" title="▌R10.1.6 逻辑表达式的右子表达式不应有副作用"></a><span id="shortcircuitsideeffect">▌R10.1.6 逻辑表达式的右子表达式不应有副作用</span></h3><p>ID_shortCircuitSideEffect&emsp;&emsp;&emsp;&emsp;&nbsp;:bulb: expression suggestion</p>
<hr/>

<p>逻辑表达式的右子表达式有副作用会使代码变得复杂易错，不利于阅读和维护。  </p>
<p>对于逻辑表达式的求值，标准规定从左至右计算各子表达式的值，当可以确定整个表达式的值时，即使还有未计算的子表达式，也会立即结束求值，这种方法可提高效率，称为“短路规则（short-circuit evaluation）”。  </p>
<p>逻辑表达式的右子表达式受左子表达式影响，可能不会被执行，如果有副作用也可能不会生效。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (a == foo || b == bar++) &#123;  // Non-compliant</span><br><span class="line">    do_something(bar);         // Consider that ‘bar++’ may not be evaluated</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 a == foo 为真，不论 b 是否等于 bar++，整个条件表达式的值一定为真，所以 b == bar++ 不一定会被执行，需要同时考虑 bar++ 执行与未执行的两种状态，很容易产生错误，也不利于阅读和维护。<br><br/><br><br/></p>
<h4 id="依据-145"><a href="#依据-145" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 6.5.13(4)<br>ISO/IEC 9899:1999 6.5.14(4)<br>ISO/IEC 9899:2011 6.5.13(4)<br>ISO/IEC 9899:2011 6.5.14(4)<br><br/></p>
<h4 id="参考-279"><a href="#参考-279" class="headerlink" title="参考"></a>参考</h4><p>MISRA C 2004 12.4<br>MISRA C 2012 13.5<br>MISRA C++ 2008 5-14-1<br><br/><br><br/></p>
<h3 id="▌R10-1-7-化简可被合并的逻辑子表达式"><a href="#▌R10-1-7-化简可被合并的逻辑子表达式" class="headerlink" title="▌R10.1.7 化简可被合并的逻辑子表达式"></a><span id="simplifiablecondition">▌R10.1.7 化简可被合并的逻辑子表达式</span></h3><p>ID_simplifiableCondition&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: expression warning</p>
<hr/>

<p>逻辑或、逻辑与的子表达式可以合并成一个表达式时应尽量合并。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a &lt; b || a &gt; b      // None-compliant, use a != b instead</span><br><span class="line">a &gt; b || a == b     // None-compliant, use a &gt;= b instead</span><br><span class="line">a &lt; b || a == b     // None-compliant, use a &lt;= b instead</span><br><span class="line">a &lt;= b &amp;&amp; a &gt;= b    // None-compliant, use a == b instead</span><br></pre></td></tr></table></figure>
<p>不合理的繁琐写法也可能意味着某种错误，需认真对待。<br><br/><br><br/></p>
<h4 id="相关-181"><a href="#相关-181" class="headerlink" title="相关"></a>相关</h4><p>ID_redundantCondition<br>ID_conflictCondition<br><br/><br><br/></p>
<h3 id="▌R10-1-8-化简可转换为逻辑表达式的三元表达式"><a href="#▌R10-1-8-化简可转换为逻辑表达式的三元表达式" class="headerlink" title="▌R10.1.8 化简可转换为逻辑表达式的三元表达式"></a><span id="simplifiableternary">▌R10.1.8 化简可转换为逻辑表达式的三元表达式</span></h3><p>ID_simplifiableTernary&emsp;&emsp;&emsp;&emsp;&nbsp;:bulb: expression suggestion</p>
<hr/>

<p>当三元表达式的分枝是常量 true 或 false 时应化简为逻辑表达式。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void foo(int a) &#123;</span><br><span class="line">    if (a &gt; 123? true: false) &#123;   // Non-compliant, too verbose</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool bar(int a) &#123;</span><br><span class="line">    return a &gt; 123? baz(): false;   // Non-compliant, verbose</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void foo(int a) &#123;</span><br><span class="line">    if (a &gt; 123) &#123;   // Compliant</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool bar(int a) &#123;</span><br><span class="line">    return a &gt; 123 &amp;&amp; baz();   // Compliant</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/><br><br/></p>
<h3 id="10-2-Evaluation"><a href="#10-2-Evaluation" class="headerlink" title="10.2 Evaluation"></a><span id="expression.evaluation">10.2 Evaluation</span></h3><h3 id="▌R10-2-1-不可依赖不会生效的副作用"><a href="#▌R10-2-1-不可依赖不会生效的副作用" class="headerlink" title="▌R10.2.1 不可依赖不会生效的副作用"></a><span id="unevaluatedsideeffect">▌R10.2.1 不可依赖不会生效的副作用</span></h3><p>ID_unevaluatedSideEffect&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: expression warning</p>
<hr/>

<p>有些运算符只关注类型，其子表达式不会被求值，子表达式的副作用也不会有实际效果。  </p>
<p>这类运算在 C 语言中有：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sizeof、_Alignof、_Generic</span><br></pre></td></tr></table></figure>
<p>在 C++ 语言中有：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sizeof、typeid、noexcept、decltype、declval</span><br></pre></td></tr></table></figure>
<p>这类运算符不宜作用于逻辑、算术、位运算、函数调用等子表达式。  </p>
<p>特殊情况：  </p>
<ul>
<li>在 C 语言中，如果 sizeof 作用于变长数组类型，数组长度表达式会被求值。  </li>
<li>在 C++ 语言中，如果 typeid 作用于返回多态类型的函数调用，该函数也会被执行。  </li>
</ul>
<p>虽然在某些特殊情况下相关子表达式会被求值，但为了避免意料之外的错误，本规则要求这类运算符的子表达式在任何情况下均不可含有任何副作用。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int a = 0;</span><br><span class="line"></span><br><span class="line">int b = sizeof(a++);   // Non-compliant</span><br><span class="line">printf(&quot;%d &quot;, a);</span><br><span class="line"></span><br><span class="line">int c = sizeof(int[a++]);   // Non-compliant, variable length array</span><br><span class="line">printf(&quot;%d\n&quot;, a);</span><br></pre></td></tr></table></figure>
<p>输出 0 1，sizeof(a++) 的副作用不生效，而 sizeof(int[a++]) 的副作用会生效，这往往会使人困惑。<br><br/><br><br/></p>
<h4 id="相关-182"><a href="#相关-182" class="headerlink" title="相关"></a>相关</h4><p>ID_sideEffectAssertion<br><br/></p>
<h4 id="依据-146"><a href="#依据-146" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 6.5.3.4(2)<br>ISO/IEC 9899:2011 6.5.3.4(2)<br>ISO/IEC 14882:2003 5.3.3(1)<br>ISO/IEC 14882:2011 5.3.3(1)<br>ISO/IEC 14882:2017 8.3.3(1)<br><br/></p>
<h4 id="参考-280"><a href="#参考-280" class="headerlink" title="参考"></a>参考</h4><p>MISRA C 2004 12.3<br>MISRA C 2012 13.6<br>MISRA C++ 2008 5-3-4<br>SEI CERT EXP44-C<br>SEI CERT EXP52-CPP<br><br/><br><br/></p>
<h3 id="▌R10-2-2-避免依赖特定的子表达式求值顺序"><a href="#▌R10-2-2-避免依赖特定的子表达式求值顺序" class="headerlink" title="▌R10.2.2 避免依赖特定的子表达式求值顺序"></a><span id="evaluationorderreliance">▌R10.2.2 避免依赖特定的子表达式求值顺序</span></h3><p>ID_evaluationOrderReliance&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: expression warning</p>
<hr/>

<p>不同的求值顺序不应产生不同的结果，否则极易导致意料之外的错误，也会降低代码的可移植性。  </p>
<p>C 标准用“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Sequence_point">序列点（sequence point）</a>”定义求值顺序，序列点前面的表达式先于后面的表达式求值并落实相关副作用，逻辑与、逻辑或、三元、逗号等运算符以及函数调用的左括号与序列点相关，其左子表达式先于右子表达式求值并落实副作用，赋值、算术、位运算等运算符与序列点无关，其左右子表达式的求值顺序是未声明的，函数各参数的求值顺序也是未声明的，C++ 标准与 C 标准大致相同，C++17 明确了赋值、移位等运算符的求值顺序。  </p>
<p>要注意子表达式的副作用在不同求值顺序下的正确性，可参见 ID_confusingAssignment 的进一步说明。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stack s &#123;1, 2, 3&#125;;      // A stack, the top is 1</span><br><span class="line">int pop();              // Pop and return the top element from the stack</span><br><span class="line">int x = pop() - pop();  // Non-compliant</span><br></pre></td></tr></table></figure>
<p>设 pop 函数弹出并返回栈顶元素，减号左右的两个 pop 函数哪个先执行呢？这是标准未声明的，x 的值可以是 1 - 2，也可以是 2 - 1，由编译器决定。  </p>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a = pop();</span><br><span class="line">int b = pop();</span><br><span class="line">x = a - b;      // Compliant, or ‘b - a’, depends on your needs</span><br></pre></td></tr></table></figure>
<p>这样便确定是栈项的第一个元素减第二个元素。  </p>
<p>又如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun(pop(), pop());  // Non-compliant</span><br></pre></td></tr></table></figure>
<p>设 fun 是函数名称或获取函数指针的表达式，标准规定 fun 会先于参数求值，但参数之间的求值顺序是未声明的。  </p>
<p>逻辑与、逻辑或、三元、逗号等表达式可不受本规则限制，但其子表达式需受本规则限制。<br><br/><br><br/></p>
<h4 id="相关-183"><a href="#相关-183" class="headerlink" title="相关"></a>相关</h4><p>ID_confusingAssignment<br><br/></p>
<h4 id="依据-147"><a href="#依据-147" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 5.1.2.3(2)<br>ISO/IEC 9899:1999 Annex C<br>ISO/IEC 9899:2011 5.1.2.3(3)<br>ISO/IEC 9899:2011 Annex C<br><br/></p>
<h4 id="参考-281"><a href="#参考-281" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines ES.43<br>C++ Core Guidelines ES.44<br><br/><br><br/></p>
<h3 id="▌R10-2-3-在表达式中不应多次读写同一对象"><a href="#▌R10-2-3-在表达式中不应多次读写同一对象" class="headerlink" title="▌R10.2.3 在表达式中不应多次读写同一对象"></a><span id="confusingassignment">▌R10.2.3 在表达式中不应多次读写同一对象</span></h3><p>ID_confusingAssignment&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: expression warning</p>
<hr/>

<p>在表达式中多次引用并修改同一对象，很可能会因为非预期的求值顺序而产生错误的结果。  </p>
<p>关于对象的副作用在求值过程中何时生效这一问题，相关标准既复杂又有大量未声明和未定义的情况，故需注意：  </p>
<ol>
<li>写入对象的次数不应超过 1 次  </li>
<li>对象不应既被读取又被写入，除非是为了计算对象的新状态并写入对象  </li>
</ol>
<p>注意，对 volatile 对象的读取相当于更新对象的值，也是一种副作用，故：  </p>
<ol>
<li>volatile 对象在表达式中只应出现 1 次  </li>
<li>volatile 对象不应既被读取又被写入  </li>
</ol>
<p>本规则是 ID_evaluationOrderReliance 的特化。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a = a++;        // Non-compliant</span><br><span class="line">a = ++a;        // Non-compliant</span><br><span class="line"></span><br><span class="line">++b = b;        // Non-compliant</span><br><span class="line">b = a++ + a;    // Non-compliant</span><br><span class="line"></span><br><span class="line">arr[i] = ++i;   // Non-compliant</span><br><span class="line">p-&gt;fun(p++);    // Non-compliant</span><br><span class="line"></span><br><span class="line">fun(a, a++);    // Non-compliant</span><br><span class="line">fun(++a, a++);  // Non-compliant</span><br></pre></td></tr></table></figure>
<p>例中 ++ 泛指写入操作。  </p>
<p>设 a 是值为 0 的整型变量，如下表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = a++;        // Non-compliant</span><br></pre></td></tr></table></figure>
<p>对变量 a 有两次写入，分别是增 1 和赋值为 0（子表达式 a++ 的值为 0），这两次写入的次序在 C 和 C++17 之前的标准中是未声明的，如果先增 1 再赋 0，a 的值最终为 0，如果先赋 0 再增 1，a 的值最终为 1，这种不确定的结果应当避免，C++17 规定了右子表达式的副作用先于赋值生效，所以在 C++17 之后例中表达式是无效的。  </p>
<p>虽然新的标准强化了求值顺序，但这种代码使人费解，很容易造成理解上的偏差，故不应使用。  </p>
<p>如果 a 不是 volatile 变量，应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a++;            // Compliant, or</span><br><span class="line">a += 1;         // Compliant, or</span><br><span class="line">a = a + 1;      // Compliant</span><br></pre></td></tr></table></figure>
<p>如果 a 是 volatile 变量，应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int tmp = a;</span><br><span class="line">a = tmp + 1;    // Compliant</span><br></pre></td></tr></table></figure>
<p>对于逻辑与、逻辑或、三元以及逗号表达式，标准明确规定了子表达式从左至右求值，左子表达式的副作用也会在右子表达式求值前生效，故可不受本规则限制，但其子表达式仍需受本规则限制，进一步可参见“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Sequence_point">序列点（sequence point）</a>”以及“<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/eval_order">求值顺序</a>”等概念。<br><br/><br><br/></p>
<h4 id="相关-184"><a href="#相关-184" class="headerlink" title="相关"></a>相关</h4><p>ID_evaluationOrderReliance<br><br/></p>
<h4 id="依据-148"><a href="#依据-148" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 6.5(2)-undefined<br>ISO/IEC 9899:1999 Annex C<br>ISO/IEC 9899:2011 6.5(2)-undefined<br>ISO/IEC 9899:2011 Annex C<br>ISO/IEC 14882:2003 5(4)-unspecified<br>ISO/IEC 14882:2011 1.9(15)-undefined<br>ISO/IEC 14882:2011 5.17(1)<br>ISO/IEC 14882:2017 8.18(1)<br><br/></p>
<h4 id="参考-282"><a href="#参考-282" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines ES.43<br>MISRA C 2012 13.2<br>MISRA C++ 2008 5-0-1<br>SEI CERT EXP50-CPP<br><br/><br><br/></p>
<h3 id="▌R10-2-4-注意运算符优先级，避免非预期的结果"><a href="#▌R10-2-4-注意运算符优先级，避免非预期的结果" class="headerlink" title="▌R10.2.4 注意运算符优先级，避免非预期的结果"></a><span id="unexpectedprecedence">▌R10.2.4 注意运算符优先级，避免非预期的结果</span></h3><p>ID_unexpectedPrecedence&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: expression warning</p>
<hr/>

<p>对运算符优先级的错误理解是产生逻辑错误的主要原因之一。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int foo(bool cond) &#123;</span><br><span class="line">    return 1 + cond? 2: 3;  // Rather suspicious</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>加号的优先级大于三元运算符，但 cond 是 bool 型变量，所以这种情况十分可疑。  </p>
<p>很可能应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int foo(bool cond) &#123;</span><br><span class="line">    return 1 + (cond? 2: 3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="参考-283"><a href="#参考-283" class="headerlink" title="参考"></a>参考</h4><p>CWE-783<br><br/><br><br/></p>
<h3 id="▌R10-2-5-不在同一数组或对象中的地址不可相减或比较大小"><a href="#▌R10-2-5-不在同一数组或对象中的地址不可相减或比较大小" class="headerlink" title="▌R10.2.5 不在同一数组或对象中的地址不可相减或比较大小"></a><span id="illptrdiff">▌R10.2.5 不在同一数组或对象中的地址不可相减或比较大小</span></h3><p>ID_illPtrDiff&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: expression warning</p>
<hr/>

<p>不在同一数组或对象中的地址之间没有逻辑关系，这种地址相减或比较大小属于逻辑错误，也会导致标准未定义或未声明的行为。  </p>
<p>对于 C++ 语言，即使在同一对象中：  </p>
<ul>
<li>静态成员之间  </li>
<li>静态成员与非静态成员之间  </li>
<li>由 access-specifier 分隔的成员之间  </li>
</ul>
<p>也不应对地址求差值或比较大小。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">bool b;</span><br><span class="line">ptrdiff_t d;</span><br><span class="line"></span><br><span class="line">int i, j;</span><br><span class="line">b = &amp;j &gt; &amp;i;   // Non-compliant, undefined in C, unspecified in C++</span><br><span class="line">d = &amp;j - &amp;i;   // Non-compliant, undefined in C and C++ if overflow</span><br><span class="line"></span><br><span class="line">struct A &#123;</span><br><span class="line">    int i, j;</span><br><span class="line">&#125; a;</span><br><span class="line">b = &amp;a.j &gt; &amp;a.i;   // Compliant, ‘b’ is true</span><br><span class="line">d = &amp;a.j - &amp;a.i;   // Compliant, ‘d’ is 1</span><br><span class="line"></span><br><span class="line">int x[8];</span><br><span class="line">int y[8];</span><br><span class="line">d = &amp;y[1] - &amp;x[0];   // Non-compliant, undefined behavior if overflow</span><br><span class="line">d = &amp;x[1] - &amp;x[0];   // Compliant, ‘d’ is 1</span><br><span class="line"></span><br><span class="line">class B &#123;</span><br><span class="line">    static int i;</span><br><span class="line">    int j;</span><br><span class="line">public:                   // access-specifier</span><br><span class="line">    int k;</span><br><span class="line">    int foo() &#123;</span><br><span class="line">        return &amp;i &lt; &amp;j    // Non-compliant, unspecified</span><br><span class="line">            || &amp;j &lt; &amp;k;   // Non-compliant, unspecified</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>另外，指针与空指针之间也不应相减或比较大小：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int* p = &amp;foo;</span><br><span class="line">bool b = p &lt; NULL;              // Non-compliant</span><br><span class="line">ptrdiff_t d = p - (int*)NULL;   // Non-compliant</span><br></pre></td></tr></table></figure>
<p>指针与空指针比较大小是一种常见笔误，对此本规则特化为 ID_oddPtrZeroComparison。<br><br/><br><br/></p>
<h4 id="相关-185"><a href="#相关-185" class="headerlink" title="相关"></a>相关</h4><p>ID_oddPtrZeroComparison<br><br/></p>
<h4 id="依据-149"><a href="#依据-149" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 6.5.6(9)-undefined<br>ISO/IEC 9899:1999 6.5.8(5)-undefined<br>ISO/IEC 9899:2011 6.5.6(9)-undefined<br>ISO/IEC 9899:2011 6.5.8(5)-undefined<br>ISO/IEC 14882:2003 5.7(6)-undefined<br>ISO/IEC 14882:2003 5.9(2)-unspecified<br>ISO/IEC 14882:2011 5.7(6)-undefined<br>ISO/IEC 14882:2011 5.9(2)-unspecified<br><br/></p>
<h4 id="参考-284"><a href="#参考-284" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines ES.62<br>MISRA C 2004 17.3<br>MISRA C 2012 18.3<br>MISRA C++ 2008 5-0-16<br>MISRA C++ 2008 5-0-17<br>MISRA C++ 2008 5-0-18<br><br/><br><br/></p>
<h3 id="▌R10-2-6-bool-值不应参与位运算、大小比较、数值增减"><a href="#▌R10-2-6-bool-值不应参与位运算、大小比较、数值增减" class="headerlink" title="▌R10.2.6 bool 值不应参与位运算、大小比较、数值增减"></a><span id="illbooloperation">▌R10.2.6 bool 值不应参与位运算、大小比较、数值增减</span></h3><p>ID_illBoolOperation&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: expression warning</p>
<hr/>

<p>bool 值只能为真或假，不具有“大小”等数值意义，bool 值参与位运算、大小比较、数值增减是不合理的。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bool foo(unsigned flags, unsigned flag) &#123;</span><br><span class="line">    return flags &amp; flag != 0;               // Non-compliant</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于 != 的优先级高于 &amp;，所以例中的 return 语句相当于先判断 flag 是否为 0，再将这个 bool 型的结果与 flags 按位与，这是没有意义的。  </p>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bool foo(unsigned flags, unsigned flag) &#123;</span><br><span class="line">    return (flags &amp; flag) != 0;             // Compliant</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="依据-150"><a href="#依据-150" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 14882:2003 5.2.6(1 2)<br>ISO/IEC 14882:2003 5.3.2(1 2)<br>ISO/IEC 14882:2003 D.1-deprecated<br>ISO/IEC 14882:2011 5.2.6(1 2)<br>ISO/IEC 14882:2011 5.3.2(1 2)<br>ISO/IEC 14882:2011 D.1-deprecated<br><br/></p>
<h4 id="参考-285"><a href="#参考-285" class="headerlink" title="参考"></a>参考</h4><p>CWE-682<br>CWE-783<br>CWE-1024<br>CWE-1025<br>MISRA C 2004 12.7<br>MISRA C 2012 10.1<br>MISRA C++ 2008 5-0-21<br><br/><br><br/></p>
<h3 id="▌R10-2-7-不应出现复合赋值的错误形式"><a href="#▌R10-2-7-不应出现复合赋值的错误形式" class="headerlink" title="▌R10.2.7 不应出现复合赋值的错误形式"></a><span id="illformedcompoundassignment">▌R10.2.7 不应出现复合赋值的错误形式</span></h3><p>ID_illFormedCompoundAssignment&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: expression warning</p>
<hr/>

<p>如下形式的复合赋值表达式（设 a 和 x 为变量或表达式）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a -= a - x;</span><br><span class="line">a /= a / x;</span><br><span class="line">a &amp;= a &amp; x;</span><br><span class="line">a |= a | x;</span><br><span class="line">a ^= a ^ x;</span><br></pre></td></tr></table></figure>
<p>均为常见笔误，应将复合赋值改为普通赋值，或去掉重复的子表达式。<br><br/><br><br/></p>
<h4 id="参考-286"><a href="#参考-286" class="headerlink" title="参考"></a>参考</h4><p>CWE-682<br><br/><br><br/></p>
<h3 id="▌R10-2-8-避免出现复合赋值的可疑形式"><a href="#▌R10-2-8-避免出现复合赋值的可疑形式" class="headerlink" title="▌R10.2.8 避免出现复合赋值的可疑形式"></a><span id="suspiciouscompoundassignment">▌R10.2.8 避免出现复合赋值的可疑形式</span></h3><p>ID_suspiciousCompoundAssignment&emsp;&emsp;&emsp;&emsp;&nbsp;:question: expression suspicious</p>
<hr/>

<p>如下形式的复合赋值表达式（设 a 和 x 为变量或表达式）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a += a + x;</span><br><span class="line">a *= a * x;</span><br><span class="line">a %= a % x;</span><br><span class="line">a &lt;&lt;= a &lt;&lt; x;</span><br><span class="line">a &gt;&gt;= a &gt;&gt; x;</span><br></pre></td></tr></table></figure>
<p>均为常见笔误，但在特定需求下也有其逻辑意义，故对这种表达式应给出可疑提醒。即使这类表达式没有逻辑错误，也应该换成普通赋值表达式以便提高可读性。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a += a + x;   // Rather suspicious</span><br></pre></td></tr></table></figure>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = a + x;</span><br><span class="line">a = 2 * a + x;</span><br><span class="line">a = a + (a + x);</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="参考-287"><a href="#参考-287" class="headerlink" title="参考"></a>参考</h4><p>CWE-682<br><br/><br><br/></p>
<h3 id="▌R10-2-9-amp-、-、-、-、-左右子表达式不应相同"><a href="#▌R10-2-9-amp-、-、-、-、-左右子表达式不应相同" class="headerlink" title="▌R10.2.9 &amp;=、|=、-=、/=、%= 左右子表达式不应相同"></a><span id="illselfcompoundassignment">▌R10.2.9 &amp;=、|=、-=、/=、%= 左右子表达式不应相同</span></h3><p>ID_illSelfCompoundAssignment&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: expression warning</p>
<hr/>

<p>&amp;=、|= 左右子表达式如果相同则没有任何效果，-=、/=、%= 左右子表达式相同则结果总为 1 或 0，这种表达式往往意味着笔误或逻辑错误。  </p>
<p>示例（设 a 为变量或表达式）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a &amp;= a;  // Non-compliant, no effect</span><br><span class="line">a |= a;  // Non-compliant, no effect</span><br></pre></td></tr></table></figure>
<p>如果目的是清零或置 1，也不建议使用下列表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a -= a;  // Non-compliant, tedious</span><br><span class="line">a /= a;  // Non-compliant, low efficiency</span><br><span class="line">a %= a;  // Non-compliant, low efficiency</span><br></pre></td></tr></table></figure>
<p>对于高级语言来说，应该直接将变量赋值为 0 或 1，而不是采用更繁琐甚至低效的方式。<br><br/><br><br/></p>
<h4 id="参考-288"><a href="#参考-288" class="headerlink" title="参考"></a>参考</h4><p>CWE-682<br><br/><br><br/></p>
<h3 id="▌R10-2-10-不应将-NULL-当作整数使用"><a href="#▌R10-2-10-不应将-NULL-当作整数使用" class="headerlink" title="▌R10.2.10 不应将 NULL 当作整数使用"></a><span id="oddnullassignment">▌R10.2.10 不应将 NULL 当作整数使用</span></h3><p>ID_oddNullAssignment&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: expression warning</p>
<hr/>

<p>标识符 NULL 由实现定义，在 C++ 语言中往往等同于常量 0，但 NULL 只应该用来表示空指针，否则不利于阅读和维护。  </p>
<p>被当作整数使用的 NULL 也很可能意味着某种错误。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const int i = NULL;        // Non-compliant</span><br><span class="line">const char c = NULL;       // Non-compliant</span><br><span class="line">void foo(bool x = NULL);   // Non-compliant</span><br></pre></td></tr></table></figure>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const int i = 0;           // Compliant</span><br><span class="line">const char c = &#x27;\0&#x27;;       // Compliant</span><br><span class="line">void foo(bool x = false);  // Compliant</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="依据-151"><a href="#依据-151" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 14882:2003 C.2.2.3(1)-implementation<br>ISO/IEC 14882:2011 C.3.2.4(1)-implementation<br>ISO/IEC 14882:2017 C.5.2.7(1)-implementation<br><br/></p>
<h4 id="参考-289"><a href="#参考-289" class="headerlink" title="参考"></a>参考</h4><p>MISRA C++ 2008 4-10-1<br><br/><br><br/></p>
<h3 id="▌R10-2-11-注意赋值运算符与一元运算符的空格方式"><a href="#▌R10-2-11-注意赋值运算符与一元运算符的空格方式" class="headerlink" title="▌R10.2.11 注意赋值运算符与一元运算符的空格方式"></a><span id="stickyassignmentoperator">▌R10.2.11 注意赋值运算符与一元运算符的空格方式</span></h3><p>ID_stickyAssignmentOperator&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: expression warning</p>
<hr/>

<p>如果 = 与 +、-、*、!、&amp;、~ 等一元运算符之间没有空格，而一元运算符与其子表达式之间有空格，是一种非常怪异的格式，也可能是 +=、-=、*=、&amp;= 等复合赋值运算符的笔误。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a =+ b;    // Non-compliant</span><br><span class="line">a =- b;    // Non-compliant</span><br><span class="line">a =~ b;    // Non-compliant</span><br><span class="line">a =! b;    // Non-compliant</span><br><span class="line"></span><br><span class="line">a += b;    // Compliant</span><br><span class="line">a = -b;    // Compliant</span><br><span class="line">a = ~b;    // Compliant</span><br><span class="line">a = !b;    // Compliant</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="参考-290"><a href="#参考-290" class="headerlink" title="参考"></a>参考</h4><p>CWE-480<br><br/><br><br/></p>
<h3 id="▌R10-2-12-不可将对象的值赋给具有部分重叠区域的对象"><a href="#▌R10-2-12-不可将对象的值赋给具有部分重叠区域的对象" class="headerlink" title="▌R10.2.12 不可将对象的值赋给具有部分重叠区域的对象"></a><span id="overlappingassignment">▌R10.2.12 不可将对象的值赋给具有部分重叠区域的对象</span></h3><p>ID_overlappingAssignment&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: expression warning</p>
<hr/>

<p>如果两个对象的存储区域有部分重叠，将其中一个对象的值赋给另一个对象会导致标准未定义的行为。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">union U &#123;</span><br><span class="line">    int16_t x;</span><br><span class="line">    int16_t y;</span><br><span class="line">    int64_t z;</span><br><span class="line">&#125; u;</span><br><span class="line"></span><br><span class="line">u.x = u.y;   // Compliant</span><br><span class="line">u.z = u.x;   // Non-compliant</span><br></pre></td></tr></table></figure>
<p>例中 x 和 y 的存储区域完全重叠且类型相同，可以相互赋值；x 和 z 有部分重叠，不可相互赋值。<br><br/><br><br/></p>
<h4 id="依据-152"><a href="#依据-152" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 6.5.16.1(3)-undefined<br>ISO/IEC 9899:2011 6.5.16.1(3)-undefined<br>ISO/IEC 14882:2003 5.17(8)-undefined<br>ISO/IEC 14882:2011 5.17(8)-undefined<br><br/></p>
<h4 id="参考-291"><a href="#参考-291" class="headerlink" title="参考"></a>参考</h4><p>MISRA C 2012 19.1<br>MISRA C++ 2008 0-2-1<br><br/><br><br/></p>
<h3 id="▌R10-2-13-赋值运算符左右子表达式不应相同"><a href="#▌R10-2-13-赋值运算符左右子表达式不应相同" class="headerlink" title="▌R10.2.13 赋值运算符左右子表达式不应相同"></a><span id="selfassignment">▌R10.2.13 赋值运算符左右子表达式不应相同</span></h3><p>ID_selfAssignment&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: expression warning</p>
<hr/>

<p>赋值运算符左右子表达式相同是没有逻辑意义的，往往是笔误或残留代码。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = a;       // Non-compliant</span><br><span class="line">a = b = a;   // Non-compliant</span><br></pre></td></tr></table></figure>
<p>也可能是对语言特性不了解所致，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    int a;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    A(int a) &#123;</span><br><span class="line">        a = a;   // Non-compliant, ‘a’ is not the member</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>例中构造函数对成员 a 的赋值是无效的，应改为 this-&gt;a = a;  </p>
<p>有时这种代码被用来消除编译警告，编译器可能会报出没有被用到的参数，将参数赋值给自身可去除警告，但这并不是一种好方法，引入了没有实际意义的代码，改进方法可参见 ID_paramNotUsed。  </p>
<p>有时为了设置调试断点，但又找不到合适的位置，可以增加这种代码作为断点，但这种非正式的代码是不应被保留的。<br><br/><br><br/></p>
<h4 id="参考-292"><a href="#参考-292" class="headerlink" title="参考"></a>参考</h4><p>CWE-682<br><br/><br><br/></p>
<h3 id="▌R10-2-14-除法和求余运算符左右子表达式不应相同"><a href="#▌R10-2-14-除法和求余运算符左右子表达式不应相同" class="headerlink" title="▌R10.2.14 除法和求余运算符左右子表达式不应相同"></a><span id="selfdivision">▌R10.2.14 除法和求余运算符左右子表达式不应相同</span></h3><p>ID_selfDivision&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: expression warning</p>
<hr/>

<p>除法或求余运算符左右子表达式相同，结果总为 1 或 0 以及产生除零异常，往往是某种笔误。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int foo(int* p) &#123;</span><br><span class="line">    return p[0] % p[0];  // Non-compliant</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="参考-293"><a href="#参考-293" class="headerlink" title="参考"></a>参考</h4><p>CWE-682<br><br/><br><br/></p>
<h3 id="▌R10-2-15-减法运算符左右子表达式不应相同"><a href="#▌R10-2-15-减法运算符左右子表达式不应相同" class="headerlink" title="▌R10.2.15 减法运算符左右子表达式不应相同"></a><span id="selfsubtraction">▌R10.2.15 减法运算符左右子表达式不应相同</span></h3><p>ID_selfSubtraction&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: expression warning</p>
<hr/>

<p>与自身做减法，结果总为 0，往往是某种笔误。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int *p0, *p1;</span><br><span class="line">....</span><br><span class="line">ptrdiff_t d = p0 - p0;  // Non-compliant</span><br></pre></td></tr></table></figure>
<p>例中减法表达式是没有意义的，很可能是 p1 被误写成了 p0。<br><br/><br><br/></p>
<h4 id="参考-294"><a href="#参考-294" class="headerlink" title="参考"></a>参考</h4><p>CWE-682<br><br/><br><br/></p>
<h3 id="▌R10-2-16-异或运算符左右子表达式不应相同"><a href="#▌R10-2-16-异或运算符左右子表达式不应相同" class="headerlink" title="▌R10.2.16 异或运算符左右子表达式不应相同"></a><span id="selfexclusiveor">▌R10.2.16 异或运算符左右子表达式不应相同</span></h3><p>ID_selfExclusiveOr&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: expression warning</p>
<hr/>

<p>与自身异或的结果总为 0，而且也可能意味着某种错误。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a ^= a;      // Non-compliant</span><br><span class="line">a = a ^ a;   // Non-compliant</span><br></pre></td></tr></table></figure>
<p>这种代码可能是为了对变量清零，也可能是笔误，即使没有逻辑错误，也应将变量直接赋值为 0 以提高可读性。<br><br/><br><br/></p>
<h4 id="参考-295"><a href="#参考-295" class="headerlink" title="参考"></a>参考</h4><p>CWE-682<br><br/><br><br/></p>
<h3 id="▌R10-2-17-负号不应作用于无符号整数"><a href="#▌R10-2-17-负号不应作用于无符号整数" class="headerlink" title="▌R10.2.17 负号不应作用于无符号整数"></a><span id="minusonunsigned">▌R10.2.17 负号不应作用于无符号整数</span></h3><p>ID_minusOnUnsigned&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: expression warning</p>
<hr/>

<p>负号作用于 unsigned int、unsigned long、unsigned long long 等无符号整型表达式的结果仍为无符号整数，易产生意料之外的错误。  </p>
<p>当 int 类型的取值范围可以包含 unsigned char、unsigned short 等“较小”无符号整型的取值范围时，较小的无符号整型可以被提升为 int 类型，负号作用于这种类型的表达式可以得到有符号的结果，但会降低可移植性。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">unsigned int x = 1;</span><br><span class="line">signed long long y = -x;        // Non-compliant, ‘y’ equals UINT_MAX, not -1</span><br><span class="line">unsigned long long z = -1ULL;   // Non-compliant, use ULLONG_MAX instead</span><br></pre></td></tr></table></figure>
<p>例中 y 的值预期为 -1，但实际值是无符号整数的最大值；-1ULL 这种常量是令人困惑的，应使用 ULLONG_MAX 代替。<br><br/><br><br/></p>
<h4 id="配置-33"><a href="#配置-33" class="headerlink" title="配置"></a>配置</h4><p>allowSmallUnsignedTypes：是否允许负号作用于 unsigned char、unsigned short 等无符号整型表达式<br><br/></p>
<h4 id="依据-153"><a href="#依据-153" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 6.5.3.3(3)<br>ISO/IEC 9899:2011 6.5.3.3(3)<br><br/></p>
<h4 id="参考-296"><a href="#参考-296" class="headerlink" title="参考"></a>参考</h4><p>MISRA C 2004 12.9<br>MISRA C 2012 10.1<br>MISRA C++ 2008 5-3-2<br><br/><br><br/></p>
<h3 id="▌R10-2-18-不应重复使用一元运算符"><a href="#▌R10-2-18-不应重复使用一元运算符" class="headerlink" title="▌R10.2.18 不应重复使用一元运算符"></a><span id="repeatedunaryoperators">▌R10.2.18 不应重复使用一元运算符</span></h3><p>ID_repeatedUnaryOperators&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: expression warning</p>
<hr/>

<p>重复的一元运算符没有意义，为常见笔误。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int a = 1;</span><br><span class="line">int b = ~~a;    // Non-compliant</span><br><span class="line">int c = -+a;    // Non-compliant</span><br><span class="line">int d = - -a;   // Non-compliant</span><br></pre></td></tr></table></figure>
<p>例外：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool e = !!a;   // Let it go</span><br></pre></td></tr></table></figure>
<p>两个连续的 ! 是 bool 转换的惯用方法，可不受本规则约束。<br><br/><br><br/><br><br/></p>
<h3 id="▌R10-2-19-运算结果不应溢出"><a href="#▌R10-2-19-运算结果不应溢出" class="headerlink" title="▌R10.2.19 运算结果不应溢出"></a><span id="evaloverflow">▌R10.2.19 运算结果不应溢出</span></h3><p>ID_evalOverflow&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: expression warning</p>
<hr/>

<p>溢出即运算结果超出了对应类型的取值范围，使相关数据无法被完整存储，造成数据丢失。  </p>
<p>有符号整型和浮点型溢出会导致标准未定义的行为。无符号整数的运算结果是数学上的结果与无符号整型最大值求模的结果，标准认为这是一种算法特性，规定无符号整型不存在溢出，然而实践表明，运算结果超出取值范围往往意味着错误。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int32_t mul(int32_t a, int32_t b)</span><br><span class="line">&#123;</span><br><span class="line">    return a * b;   // May overflow or underflow</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中 32 位整数相乘可能产生溢出，使函数返回错误结果。  </p>
<p>应对溢出作出判断：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int32_t mul(int32_t a, int32_t b)</span><br><span class="line">&#123;</span><br><span class="line">    int64_t r = static_cast&lt;int64_t&gt;(a) * b;</span><br><span class="line">    if (r &gt; INT32_MAX) &#123;</span><br><span class="line">        throw Overflow();</span><br><span class="line">    &#125;</span><br><span class="line">    if (r &lt; INT32_MIN) &#123;</span><br><span class="line">        throw Underflow();</span><br><span class="line">    &#125;</span><br><span class="line">    return static_cast&lt;int32_t&gt;(r);   // Safe result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 INT32_MAX 和 INT32_MIN 分别为 32 位整数的最大值与最小值。<br><br/><br><br/></p>
<h4 id="依据-154"><a href="#依据-154" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 6.2.5(9)<br>ISO/IEC 9899:1999 6.5(5)-undefined<br>ISO/IEC 9899:2011 6.2.5(9)<br>ISO/IEC 9899:2011 6.5(5)-undefined<br>ISO/IEC 14882:2003 5(5)-undefined<br>ISO/IEC 14882:2011 5(4)-undefined<br><br/></p>
<h4 id="参考-297"><a href="#参考-297" class="headerlink" title="参考"></a>参考</h4><p>CWE-190<br>C++ Core Guidelines ES.103<br>C++ Core Guidelines ES.104<br><br/><br><br/></p>
<h3 id="▌R10-2-20-位运算符不应作用于有符号整数"><a href="#▌R10-2-20-位运算符不应作用于有符号整数" class="headerlink" title="▌R10.2.20 位运算符不应作用于有符号整数"></a><span id="bitwiseoperonsigned">▌R10.2.20 位运算符不应作用于有符号整数</span></h3><p>ID_bitwiseOperOnSigned&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: expression warning</p>
<hr/>

<p>符号位在位运算方面没有逻辑意义，对负数进行位运算往往意味着逻辑错误。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int foo(signed s, unsigned u) &#123;</span><br><span class="line">    return s &amp; u;                 // Non-compliant</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int bar(signed s, unsigned u) &#123;</span><br><span class="line">    if (s &lt; 0) &#123;</span><br><span class="line">        int a = s &lt;&lt; u;           // Non-compliant, undefined in C and C++11</span><br><span class="line">        int b = s &gt;&gt; u;           // Non-compliant, implementation-defined</span><br><span class="line">        return a + b;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中 s 为有符号整数，其符号位对位运算没有意义，对负数左移会导致标准未定义的行为，对负数右移则由实现定义。<br><br/><br><br/></p>
<h4 id="依据-155"><a href="#依据-155" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 6.5.7(3)-undefined<br>ISO/IEC 9899:2011 6.5.7(3)-undefined<br>ISO/IEC 14882:2003 5.8(2)<br>ISO/IEC 14882:2003 5.8(3)-implementation<br>ISO/IEC 14882:2011 5.8(2)-undefined<br>ISO/IEC 14882:2011 5.8(3)-implementation<br><br/></p>
<h4 id="参考-298"><a href="#参考-298" class="headerlink" title="参考"></a>参考</h4><p>CWE-682<br>C++ Core Guidelines ES.101<br>MISRA C 2004 12.7<br>MISRA C 2012 10.1<br>MISRA C++ 2008 5-0-21<br><br/><br><br/></p>
<h3 id="▌R10-2-21-移位数量不应超过相关类型比特位的数量"><a href="#▌R10-2-21-移位数量不应超过相关类型比特位的数量" class="headerlink" title="▌R10.2.21 移位数量不应超过相关类型比特位的数量"></a><span id="illshiftcount">▌R10.2.21 移位数量不应超过相关类型比特位的数量</span></h3><p>ID_illShiftCount&emsp;&emsp;&emsp;&emsp;&nbsp;:boom: expression error</p>
<hr/>

<p>如果移位数量为负数、大于或等于相关类型比特位的数量，会导致标准未定义的行为。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">uint32_t foo(uint16_t a) &#123;</span><br><span class="line">    return a &lt;&lt; 16;         // Non-compliant, unportable</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint64_t bar(uint32_t b) &#123;</span><br><span class="line">    return b &lt;&lt; 32;         // Non-compliant, undefined behavior</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中变量 a 为 16 位整数，是否会被提升为 32 位整型由实现定义，参见“<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/c/language/conversion#Integer_promotions">类型提升</a>”；变量 b 为 32 位整数，将其左移 32 位并不能得到 64 位整数，反而会导致标准未定义的行为。  </p>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">uint32_t foo(uint16_t a) &#123;</span><br><span class="line">    return uint32_t(a) &lt;&lt; 16;   // Compliant</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint64_t bar(uint32_t b) &#123;</span><br><span class="line">    return uint64_t(b) &lt;&lt; 32;   // Compliant</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="依据-156"><a href="#依据-156" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 6.5.7(3)-undefined<br>ISO/IEC 9899:2011 6.5.7(3)-undefined<br>ISO/IEC 14882:2003 5.8(1)-undefined<br>ISO/IEC 14882:2011 5.8(1)-undefined<br>ISO/IEC 14882:2017 8.8(1)-undefined<br><br/></p>
<h4 id="参考-299"><a href="#参考-299" class="headerlink" title="参考"></a>参考</h4><p>MISRA C 2012 12.2<br>MISRA C++ 2008 5-8-1<br><br/><br><br/></p>
<h3 id="▌R10-2-22-按位取反需避免由类型提升产生的多余数据"><a href="#▌R10-2-22-按位取反需避免由类型提升产生的多余数据" class="headerlink" title="▌R10.2.22 按位取反需避免由类型提升产生的多余数据"></a><span id="suspiciouspromotion">▌R10.2.22 按位取反需避免由类型提升产生的多余数据</span></h3><p>ID_suspiciousPromotion&emsp;&emsp;&emsp;&emsp;&nbsp;:question: expression suspicious</p>
<hr/>

<p>8 位或 16 位整数按位取反时会被提升为 int 等类型，可能会产生非预期的多余数据。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uint8_t a = 0xCD;</span><br><span class="line">uint8_t b = (~a) &gt;&gt; 4;   // Rather suspicious, ‘b’ is 0xF3 </span><br></pre></td></tr></table></figure>
<p>经“<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/c/language/conversion#Integer_promotions">类型提升</a>”，例中 ~a 在 16 位环境中为 0xFF32，在 32 位环境中为 0xFFFFFF32，高位的数据很可能是多余的。  </p>
<p>应在取反后立即转为目标类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uint8_t a = 0xCD;</span><br><span class="line">uint8_t b = uint8_t(~a) &gt;&gt; 4;   // OK, ‘b’ is 0x03</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="参考-300"><a href="#参考-300" class="headerlink" title="参考"></a>参考</h4><p>MISRA C++ 2008 5-0-10<br><br/><br><br/></p>
<h3 id="▌R10-2-23-逗号表达式的子表达式应具有必要的副作用"><a href="#▌R10-2-23-逗号表达式的子表达式应具有必要的副作用" class="headerlink" title="▌R10.2.23 逗号表达式的子表达式应具有必要的副作用"></a><span id="invalidcommasubexpression">▌R10.2.23 逗号表达式的子表达式应具有必要的副作用</span></h3><p>ID_invalidCommaSubExpression&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: expression warning</p>
<hr/>

<p>缺少必要副作用的逗号子表达式没有意义，往往意味着逻辑错误。  </p>
<p>设逗号表达式中逗号运算符的子表达式个数为 n（n &gt;= 2），如果最后一个子表达式的值可影响程序状态，前 n - 1 个子表达式应具备副作用，否则所有子表达式都应具备副作用。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void foo(int&amp; a, int&amp; b) &#123;</span><br><span class="line">    a, b = 0, 1;             // Non-compliant</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中逗号表达式有 3 个子表达式，只有第 2 个子表达式有效，第 1 和第 3 个没有意义。  </p>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void foo(int&amp; a, int&amp; b) &#123;</span><br><span class="line">    a = 0, b = 1;            // Compliant, but bad</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本规则集合不建议使用逗号表达式，将逗号表达式拆分成合理的语句是更好的选择，如：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void foo(int&amp; a, int&amp; b) &#123;</span><br><span class="line">    a = 0;</span><br><span class="line">    b = 1;                   // Compliant, good</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="相关-186"><a href="#相关-186" class="headerlink" title="相关"></a>相关</h4><p>ID_forbidCommaExpression<br><br/><br><br/></p>
<h3 id="10-3-Comparison"><a href="#10-3-Comparison" class="headerlink" title="10.3 Comparison"></a><span id="expression.comparison">10.3 Comparison</span></h3><h3 id="▌R10-3-1-参与比较的对象之间应具备合理的大小关系"><a href="#▌R10-3-1-参与比较的对象之间应具备合理的大小关系" class="headerlink" title="▌R10.3.1 参与比较的对象之间应具备合理的大小关系"></a><span id="illcomparison">▌R10.3.1 参与比较的对象之间应具备合理的大小关系</span></h3><p>ID_illComparison&emsp;&emsp;&emsp;&emsp;&nbsp;:boom: expression error</p>
<hr/>

<p>对象与超出其类型取值范围的值比较，或与取值范围的边界进行无意义的比较属于逻辑错误。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void foo(string&amp; txt, string&amp; sub) &#123;</span><br><span class="line">    size_t n = txt.find(sub);</span><br><span class="line">    if (n &gt;= 0) &#123;               // Non-compliant, always true</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中 n 为无符号变量，一定大于或等于 0，n &gt;= 0 是无意义的比较，也是一种常见笔误。  </p>
<p>又如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void bar(uint16_t x) &#123;</span><br><span class="line">    if (x == -1) &#123;      // Non-compliant, always false</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中 x 为 16 位无符号变量，其取值范围为 [0, 65535]，x == -1 恒为假。由于“<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/c/language/conversion#Integer_promotions">类型提升</a>”，x 可以被转为 int 型再与 -1 比较，x 恒为正数而 -1 为负数，故不可能相等。  </p>
<p>对于有符号字符型变量，与其比较的数值不在 [-128, 127] 范围内时，也是无效的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CodePage encodingDetect(const char* src) &#123;</span><br><span class="line">    char b0 = src[0];</span><br><span class="line">    char b1 = src[1];</span><br><span class="line">    char b2 = src[2];</span><br><span class="line">    if (b0 == 0xef &amp;&amp; b1 == 0xbb &amp;&amp; b2 == 0xbf) &#123;   // Non-compliant, always false</span><br><span class="line">        return cpUtf8;</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即使例中 b0 的二进制绝对值确实为 0xef，但由于类型提升，b0 转为 int 型后为负数，0xef 为正数，比较的结果恒为假。char 型变量是否有符号由实现定义，可参见 ID_plainNumericChar 的进一步说明，将 b0 等变量设为 unsigned char 可解决这个问题。<br><br/><br><br/></p>
<h4 id="相关-187"><a href="#相关-187" class="headerlink" title="相关"></a>相关</h4><p>ID_switch_caseOutOfRange<br><br/></p>
<h4 id="参考-301"><a href="#参考-301" class="headerlink" title="参考"></a>参考</h4><p>CWE-697<br>CWE-1024<br>CWE-1025<br><br/><br><br/></p>
<h3 id="▌R10-3-2-不应使用-或-判断浮点数是否相等"><a href="#▌R10-3-2-不应使用-或-判断浮点数是否相等" class="headerlink" title="▌R10.3.2 不应使用 == 或 != 判断浮点数是否相等"></a><span id="illfloatcomparison">▌R10.3.2 不应使用 == 或 != 判断浮点数是否相等</span></h3><p>ID_illFloatComparison&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: expression warning</p>
<hr/>

<p>一般来说，除了可以记作 a * 2<sup>n</sup>（a、n 为整数）的浮点数值可以被精确存储之外，其他均为近似值。用 == 或 != 判断浮点数（float、double、long double）是否相等往往得不到预期的结果。  </p>
<p>如 0、1、2、3、1.5、1.25、… 可以被精确存储，而除此之外绝大部分数值如 0.1、0.2、0.3、… 只能存储其近似值。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">float f = 1;</span><br><span class="line">f /= 10;</span><br><span class="line">if (f == 0.1) &#123;     // Non-compliant, do not use ‘==’ or ‘!=’</span><br><span class="line">    cout &lt;&lt; &quot;OK&quot;;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    cout &lt;&lt; &quot;Oops&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出 Oops，这是因为 f == 0.1 在运算时将变量和常量转为 double 型，而转换过程中生成了两个不同的对 0.1 的近似值（如 0.10000000149011611938 和 0.10000000000000000555），其结果自然为 false。<br>这非常容易造成意料之外的混乱，所以判断浮点数是否相等不应直接使用 == 或 != 运算符，即使浮点数可以被精确存储。  </p>
<p>解决方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bool feq(float a, float b, float e = 0.0001f) &#123;</span><br><span class="line">    return fabs(a - b) &lt; e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>利用 feq 函数判断浮点数是否相等，如果两个浮点数的差值非常小则可以认为相等，其中 fabs 为计算浮点数差值绝对值的函数，如果差值绝对值小于 e 则认为相等，否则不等。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (feq(f, 0.1)) &#123;   // Compliant</span><br><span class="line">    cout &lt;&lt; &quot;OK&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="参考-302"><a href="#参考-302" class="headerlink" title="参考"></a>参考</h4><p>CWE-1025<br>MISRA C 2004 13.3<br>MISRA C++ 2008 6-2-2<br><br/><br><br/></p>
<h3 id="▌R10-3-3-指针不应与字符串常量直接比较"><a href="#▌R10-3-3-指针不应与字符串常量直接比较" class="headerlink" title="▌R10.3.3 指针不应与字符串常量直接比较"></a><span id="illptrstrcomparison">▌R10.3.3 指针不应与字符串常量直接比较</span></h3><p>ID_illPtrStrComparison&emsp;&emsp;&emsp;&emsp;&nbsp;:boom: expression error</p>
<hr/>

<p>直接比较指针和字符串常量的结果往往总是 false，应改用字符串比较函数。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bool is_name(const char* p) &#123;</span><br><span class="line">    return p == &quot;bar&quot;;          // Non-compliant</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果例中 is_name 函数只接受常量字符串作为参数，该函数在某些环境中也可能正常工作，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (is_name(&quot;foo&quot;)) &#123;   // May be false</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line">if (is_name(&quot;bar&quot;)) &#123;   // May be true</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然而相同的字符串常量是否一定拥有相同的地址呢？对这个问题不同的编译器有不同的实现，有可移植性要求的代码要规避这种问题，而且这种问题极易导致错误，一般的程序都应该避免这种问题。  </p>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bool is_name(const char* p) &#123;</span><br><span class="line">    return !strcmp(p, &quot;bar&quot;);   // Compliant</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="依据-157"><a href="#依据-157" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 6.4.5(6)-unspecified<br>ISO/IEC 9899:2011 6.4.5(7)-unspecified<br>ISO/IEC 14882:2003 2.13.4(2)-implementation<br>ISO/IEC 14882:2011 2.14.5(12)-implementation<br>ISO/IEC 14882:2017 5.13.5(16)-unspecified<br><br/></p>
<h4 id="参考-303"><a href="#参考-303" class="headerlink" title="参考"></a>参考</h4><p>CWE-595<br>CWE-697<br>CWE-1024<br>CWE-1025<br><br/><br><br/></p>
<h3 id="▌R10-3-4-不应比较非同类枚举值"><a href="#▌R10-3-4-不应比较非同类枚举值" class="headerlink" title="▌R10.3.4 不应比较非同类枚举值"></a><span id="differentenumcomparison">▌R10.3.4 不应比较非同类枚举值</span></h3><p>ID_differentEnumComparison&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: expression warning</p>
<hr/>

<p>比较非同类枚举值相当于比较不同类别的事物，没有逻辑意义，往往是设计缺陷或逻辑错误。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">enum Fruit &#123; apple, orange, banana &#125;;</span><br><span class="line">enum Pet &#123; hamster, chipmunk, chinchilla &#125;;</span><br><span class="line"></span><br><span class="line">void foo(Fruit f) &#123;</span><br><span class="line">    if (f == hamster) &#123;  // Non-compliant</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void bar(Pet p) &#123;</span><br><span class="line">    switch (p) &#123;</span><br><span class="line">    case apple:     // Non-compliant</span><br><span class="line">        ....</span><br><span class="line">        break;</span><br><span class="line">    case chipmunk:  // Compliant</span><br><span class="line">        ....</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/><br><br/></p>
<h3 id="▌R10-3-5-比较运算符左右子表达式不应相同"><a href="#▌R10-3-5-比较运算符左右子表达式不应相同" class="headerlink" title="▌R10.3.5 比较运算符左右子表达式不应相同"></a><span id="selfcomparison">▌R10.3.5 比较运算符左右子表达式不应相同</span></h3><p>ID_selfComparison&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: expression warning</p>
<hr/>

<p>与自身的比较是没意义的，往往是某种笔误。  </p>
<p>示例（设 a 为变量或表达式）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a == a   // Non-compliant</span><br><span class="line">a != a   // Non-compliant</span><br><span class="line">a &gt; a    // Non-compliant</span><br><span class="line">a &gt;= a   // Non-compliant</span><br><span class="line">a &lt; a    // Non-compliant</span><br><span class="line">a &lt;= a   // Non-compliant</span><br></pre></td></tr></table></figure>
<p>例外：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void foo(float a) &#123;</span><br><span class="line">    if (a != a) &#123;     // Let it go</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当 a != a 为真时表示 a 为无效值“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/NaN">NaN</a>”，这是判断浮点数是否有效的惯用方法，可不受本规则约束。<br><br/><br><br/></p>
<h4 id="参考-304"><a href="#参考-304" class="headerlink" title="参考"></a>参考</h4><p>CWE-1025<br><br/><br><br/></p>
<h3 id="▌R10-3-6-比较运算不可作为另一个比较运算的直接子表达式"><a href="#▌R10-3-6-比较运算不可作为另一个比较运算的直接子表达式" class="headerlink" title="▌R10.3.6 比较运算不可作为另一个比较运算的直接子表达式"></a><span id="successivecomparison">▌R10.3.6 比较运算不可作为另一个比较运算的直接子表达式</span></h3><p>ID_successiveComparison&emsp;&emsp;&emsp;&emsp;&nbsp;:boom: expression error</p>
<hr/>

<p>在 C/C++ 语言中，连续的比较运算是没有意义的，本规则是 ID_illBoolOperation 的特化。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bool foo(int a, int b, int c) &#123;</span><br><span class="line">    return a &gt;= b &gt;= c;           // Non-compliant, logic error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中 a &gt;= b 的结果为 bool 型，bool 型数据是没有大小概念的，这个结果再与 c 比较大小是没有意义的。  </p>
<p>例外：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a &gt; b == true        // Compliant, but odd</span><br><span class="line">a != b != true       // Compliant, but odd</span><br><span class="line">(a &gt; b) == (c &gt; d)   // Compliant, but complex</span><br></pre></td></tr></table></figure>
<p>如果是判断两个 bool 表达式是否相等，可不受本规则约束，但这种复杂的形式并不值得提倡。<br><br/><br><br/></p>
<h4 id="相关-188"><a href="#相关-188" class="headerlink" title="相关"></a>相关</h4><p>ID_illBoolOperation<br><br/></p>
<h4 id="参考-305"><a href="#参考-305" class="headerlink" title="参考"></a>参考</h4><p>CWE-697<br>CWE-1024<br>CWE-1025<br><br/><br><br/></p>
<h3 id="10-4-Call"><a href="#10-4-Call" class="headerlink" title="10.4 Call"></a><span id="expression.call">10.4 Call</span></h3><h3 id="▌R10-4-1-不应忽略重要的返回值"><a href="#▌R10-4-1-不应忽略重要的返回值" class="headerlink" title="▌R10.4.1 不应忽略重要的返回值"></a><span id="returnvalueignored">▌R10.4.1 不应忽略重要的返回值</span></h3><p>ID_returnValueIgnored&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: expression warning</p>
<hr/>

<p>与状态判断、信息获取、资源分配有关的返回值不应被忽略。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void bar(string&amp; s) &#123;</span><br><span class="line">    s.empty();          // Non-compliant</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中 empty 函数返回字符串是否为空，如果忽略返回值会使函数调用失去意义。  </p>
<p>C++17 nodiscard 属性表示返回值具有重要意义，标准库中以及由用户标注的具有 nodiscard 属性的返回值不应被忽略，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[[nodiscard]] int fun();   // Or use __attribute__((warn_unused_result)) in GCC</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    fun();           // Non-compliant</span><br><span class="line">    int r = fun();   // Compliant, ‘r’ should be used in subsequent code   </span><br><span class="line">    ....</span><br><span class="line">    (void)fun();     // Let it go?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经 void 转换的函数调用可以认为是有意放弃返回值，审计工具不妨通过配置决定是否放过这种情况。<br><br/><br><br/></p>
<h4 id="配置-34"><a href="#配置-34" class="headerlink" title="配置"></a>配置</h4><p>allowVoidCastedDiscard：是否允许通过 void 转换忽略返回值<br><br/></p>
<h4 id="依据-158"><a href="#依据-158" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 14882:2017 10.6.7<br><br/></p>
<h4 id="参考-306"><a href="#参考-306" class="headerlink" title="参考"></a>参考</h4><p>MISRA C 2012 17.7<br>MISRA C++ 2008 0-1-7<br><br/><br><br/></p>
<h3 id="▌R10-4-2-不可臆断返回值的意义"><a href="#▌R10-4-2-不可臆断返回值的意义" class="headerlink" title="▌R10.4.2 不可臆断返回值的意义"></a><span id="wronguseofreturnvalue">▌R10.4.2 不可臆断返回值的意义</span></h3><p>ID_wrongUseOfReturnValue&emsp;&emsp;&emsp;&emsp;&nbsp;:boom: expression error</p>
<hr/>

<p>应遵循接口文档使用接口，不可臆断返回值的意义，否则造成逻辑错误。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void foo(const string&amp; s) &#123;</span><br><span class="line">    if (s.find(&quot;bar&quot;)) &#123;      // Non-compliant</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中 find 函数返回 “bar” 在 s 中的位置，当 s 中不存在 “bar” 时返回 string::npos，将 find 函数的返回值转为 bool 型是没有逻辑意义的。  </p>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void foo(const string&amp; s) &#123;</span><br><span class="line">    if (s.find(&quot;bar&quot;) != string::npos) &#123;   // Compliant</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>想当然地认为返回 0 表示失败或不存在，非 0 表示成功或存在，是造成错误的常见原因。  </p>
<p>又如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bool gt(const char* a, const char* b) &#123;</span><br><span class="line">    return strcmp(a, b) == 1;             // Non-compliant</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>strcmp 函数的返回值可以是等于、大于或小于 0 的任意整数，分别对应字符串的等于、大于或小于关系，认为其只能返回 0、1 或 -1 是一种常见的误解。  </p>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bool gt(const char* a, const char* b) &#123;</span><br><span class="line">    return strcmp(a, b) &gt; 0;              // Compliant</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>strcmp、wcscmp 以及 memcmp 等函数不应与 0 之外的任何值比较。  </p>
<p>下列函数的返回值不应与 0 比较，也不应转为 bool 型：  </p>
<ul>
<li>open、create 等 Linux 系统调用，失败时返回负数，成功时返回非负数  </li>
<li>CreateFile、CreateNamedPipe 等 Windows API，失败时返回 INVALID_HANDLE_VALUE，而不是 0  </li>
<li>HRESULT 型 Windows API 返回值，负数表示失败、非负数表示成功  </li>
</ul>
<p>另外，有相当一部分函数成功时返回 0，失败时返回非 0，如 access、chmod、rename 等 Linux 系统调用，不可将其返回值当作 bool 型使用。<br><br/><br><br/></p>
<h4 id="依据-159"><a href="#依据-159" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 7.21.4<br>ISO/IEC 9899:2011 7.24.4<br><br/></p>
<h4 id="参考-307"><a href="#参考-307" class="headerlink" title="参考"></a>参考</h4><p>CWE-253<br><br/><br><br/></p>
<h3 id="▌R10-4-3-避免对象切片"><a href="#▌R10-4-3-避免对象切片" class="headerlink" title="▌R10.4.3 避免对象切片"></a><span id="objectslicing">▌R10.4.3 避免对象切片</span></h3><p>ID_objectSlicing&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: expression warning</p>
<hr/>

<p>将派生类对象复制为基类对象的行为称为“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Object_slicing">对象切片（object slicing）</a>”，基类对象不再持有派生类的属性，不再遵循多态机制，意味着某种精度上的损失，往往会造成意料之外的错误。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct A &#123; .... &#125;;</span><br><span class="line">struct B: A &#123; .... &#125;;</span><br><span class="line"></span><br><span class="line">void foo(A);</span><br><span class="line"></span><br><span class="line">A a;</span><br><span class="line">B b;</span><br><span class="line"></span><br><span class="line">a = b;    // Slicing</span><br><span class="line">foo(b);   // Slicing</span><br><span class="line"></span><br><span class="line">vector&lt;A&gt; v&#123;b&#125;;   // Slicing</span><br><span class="line">v.push_back(b);   // Slicing</span><br></pre></td></tr></table></figure>
<p>尤其是函数传参或容器收纳对象时发生切片，会引起相当大的困惑，明明传入的是派生类对象，但虚函数都不生效了，所以要求多态性的接口或容器均应使用指针或引用。  </p>
<p>在少数情况下，对象切片可能也有其逻辑意义，但不建议“隐式切片”，应定义特定名称的函数标明这是一种特殊处理，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A a;</span><br><span class="line">B b;</span><br><span class="line"></span><br><span class="line">a = b;                   // Bad, implicit slicing</span><br><span class="line">a = to_base_object(b);   // OK</span><br></pre></td></tr></table></figure>
<p>其中 to_base_object 是一个返回基类对象的函数，表示有意为之。<br><br/><br><br/></p>
<h4 id="相关-189"><a href="#相关-189" class="headerlink" title="相关"></a>相关</h4><p>ID_paramMayBeSlicing<br><br/></p>
<h4 id="参考-308"><a href="#参考-308" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines ES.63<br>C++ Core Guidelines C.145<br>SEI CERT OOP51-CPP<br><br/><br><br/></p>
<h3 id="▌R10-4-4-避免显式调用析构函数"><a href="#▌R10-4-4-避免显式调用析构函数" class="headerlink" title="▌R10.4.4 避免显式调用析构函数"></a><span id="explicitdtorcall">▌R10.4.4 避免显式调用析构函数</span></h3><p>ID_explicitDtorCall&emsp;&emsp;&emsp;&emsp;&nbsp;:bulb: expression suggestion</p>
<hr/>

<p>显式调用析构函数会提前结束对象的生命周期，之后对该对象的任何访问都会导致标准未定义的行为。  </p>
<p>对于在栈上定义的对象，流程离开相关作用域时会再次自动调用其析构函数；对于动态创建的对象，用 delete 回收时也会调用其析构函数，使对象在生命周期之外被访问，导致标准未定义的行为。   </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    int* p = new int[123];</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">   ~A() &#123;</span><br><span class="line">        delete[] p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void foo() &#123;</span><br><span class="line">    A a;</span><br><span class="line">    a.~A();   // Non-compliant, explicitly call the destructor</span><br><span class="line">&#125;             // ~A() twice called, crash...</span><br></pre></td></tr></table></figure>
<p>例中对象 a 的析构函数被显式调用，foo 返回前会再次调用析构函数，造成内存被重复释放。应去掉显式调用，由类提供提前释放资源的方法，并保证资源不会被重复释放。  </p>
<p>例外：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">char* p = new char[sizeof(Type)];</span><br><span class="line">Type* q = new (p) Type;</span><br><span class="line">....</span><br><span class="line">q-&gt;~Type();   // Compliant, used with replacement new</span><br><span class="line">delete[] p;</span><br></pre></td></tr></table></figure>
<p>与 replacement new 配合的显式析构是实现容器或内存池的常规手段，可不受本规则约束。<br><br/><br><br/></p>
<h4 id="相关-190"><a href="#相关-190" class="headerlink" title="相关"></a>相关</h4><p>ID_missingResetNull<br><br/></p>
<h4 id="依据-160"><a href="#依据-160" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 14882:2003 12.4(14)-undefined<br>ISO/IEC 14882:2011 12.4(15)-undefined<br><br/><br><br/></p>
<h3 id="▌R10-4-5-不应将非-POD-对象传入可变参数列表"><a href="#▌R10-4-5-不应将非-POD-对象传入可变参数列表" class="headerlink" title="▌R10.4.5 不应将非 POD 对象传入可变参数列表"></a><span id="nonpodvariadicargument">▌R10.4.5 不应将非 POD 对象传入可变参数列表</span></h3><p>ID_nonPODVariadicArgument&emsp;&emsp;&emsp;&emsp;&nbsp;:boom: expression error</p>
<hr/>

<p>如果将非“<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/named_req/PODType">POD</a>”对象传入可变参数列表，程序的行为在 C++03 中是未定义的，在 C++11 中是部分由实现定义的。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void foo(int n, ...) &#123;</span><br><span class="line">    va_list ap;</span><br><span class="line">    ....</span><br><span class="line">    string s = va_arg(ap, string);   // Undefined behavior</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void bar(string&amp; s) &#123;</span><br><span class="line">    foo(1, s);          // Non-compliant</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中 string 类对象不是 POD 对象，其拷贝构造和析构过程难以与可变参数列表机制兼容，通过 va_arg 难以获取正确的对象。  </p>
<p>又如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct A &#123;</span><br><span class="line">    string s;</span><br><span class="line">    operator const char*() const &#123;</span><br><span class="line">        return s.c_str();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void foo(const A&amp; a) &#123;</span><br><span class="line">    printf(&quot;%s\n&quot;, a);   // Non-compliant</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即使对象有转为 const char* 的方法，在可变参数列表中也是无效的，printf 无法正确获取字符串地址，造成内存访问错误。  </p>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void foo(const A&amp; a) &#123;</span><br><span class="line">    printf(&quot;%s\n&quot;, static_cast&lt;const char*&gt;(a));   // Compliant</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="相关-191"><a href="#相关-191" class="headerlink" title="相关"></a>相关</h4><p>ID_badVaArgType<br><br/></p>
<h4 id="依据-161"><a href="#依据-161" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 14882:2003 5.2.2(7)-undefined<br>ISO/IEC 14882:2011 5.2.2(7)-implementation<br><br/></p>
<h4 id="参考-309"><a href="#参考-309" class="headerlink" title="参考"></a>参考</h4><p>CWE-686<br><br/><br><br/></p>
<h3 id="▌R10-4-6-C-格式化字符串需要的参数个数与实际传入的参数个数应一致"><a href="#▌R10-4-6-C-格式化字符串需要的参数个数与实际传入的参数个数应一致" class="headerlink" title="▌R10.4.6 C 格式化字符串需要的参数个数与实际传入的参数个数应一致"></a><span id="inconsistentformatargnum">▌R10.4.6 C 格式化字符串需要的参数个数与实际传入的参数个数应一致</span></h3><p>ID_inconsistentFormatArgNum&emsp;&emsp;&emsp;&emsp;&nbsp;:boom: expression error</p>
<hr/>

<p>如果 C 格式化占位符的数量大于参数的数量，会导致标准未定义的行为，反之多余的参数会失去意义，往往意味着逻辑错误。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void foo(int type, const char* msg) &#123;</span><br><span class="line">    printf(&quot;Error (type %d): %s\n&quot;, type);  // Non-compliant, undefined behavior</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中格式化字符串需要两个参数，但只传入了一个，往往会引发运行时堆栈错误。  </p>
<p>由于可变参数列表自身的局限，很难在编译时发现这种问题，有些编译器会检查 printf、sprintf 等标准函数，但无法检查自定义函数，建议在 C++ 代码中禁用可变参数列表和 C 风格的格式化函数。<br><br/><br><br/></p>
<h4 id="相关-192"><a href="#相关-192" class="headerlink" title="相关"></a>相关</h4><p>ID_inconsistentFormatArgType<br>ID_forbidCStringFormat<br><br/></p>
<h4 id="依据-162"><a href="#依据-162" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 7.19.6.1(2)-undefined<br>ISO/IEC 9899:2011 7.21.6.1(2)-undefined<br><br/></p>
<h4 id="参考-310"><a href="#参考-310" class="headerlink" title="参考"></a>参考</h4><p>SEI CERT FIO47-C<br><br/><br><br/></p>
<h3 id="▌R10-4-7-C-格式化占位符与其对应参数的类型应一致"><a href="#▌R10-4-7-C-格式化占位符与其对应参数的类型应一致" class="headerlink" title="▌R10.4.7 C 格式化占位符与其对应参数的类型应一致"></a><span id="inconsistentformatargtype">▌R10.4.7 C 格式化占位符与其对应参数的类型应一致</span></h3><p>ID_inconsistentFormatArgType&emsp;&emsp;&emsp;&emsp;&nbsp;:boom: expression error</p>
<hr/>

<p>C 格式化占位符与其对应参数的类型应一致，否则导致标准未定义的行为。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">size_t n;</span><br><span class="line">ptrdiff_t d;</span><br><span class="line">....</span><br><span class="line">printf(&quot;%u&quot;, n);    // Non-compliant</span><br><span class="line">printf(&quot;%d&quot;, d);    // Non-compliant</span><br><span class="line">printf(&quot;%lu&quot;, n);   // Non-compliant</span><br><span class="line">printf(&quot;%lld&quot;, d);  // Non-compliant</span><br></pre></td></tr></table></figure>
<p>size_t、ptrdiff_t 等类型是由实现定义的，标准没有规定其是否一定对应 unsigned、long 或 long long 等类型，而 %u、%d、%lu、%lld 只对应 unsigned、int、unsigned long、long long 等类型，所以示例代码都是不合理的。  </p>
<p>应使 n 对应 %zu，d 对应 %td： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;%zu&quot;, n);   // Compliant</span><br><span class="line">printf(&quot;%td&quot;, d);   // Compliant</span><br></pre></td></tr></table></figure>
<p>对于 stdint.h 中定义的类型，应使用 inttypes.h 中定义的占位符：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int32_t i;</span><br><span class="line">uint64_t u;</span><br><span class="line">....</span><br><span class="line">printf(&quot;%d&quot;, i);    // Unportable</span><br><span class="line">printf(&quot;%lu&quot;, u);   // Unportable</span><br><span class="line"></span><br><span class="line">printf(&quot;%&quot; PRId32, i);   // OK</span><br><span class="line">printf(&quot;%&quot; PRIu64, u);   // OK</span><br></pre></td></tr></table></figure>
<p>int32_t、uint64_t 并不一定对应 int、unsigned long，不应将 %d、%lu 等占位符在代码中写死，PRId32 和 PRIu64 是 inttypes.h 中定义的宏，可解决移植相关的问题。  </p>
<p>又如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void foo(const string&amp; msg) &#123;</span><br><span class="line">    printf(&quot;%s\n&quot;, msg);        // Non-compliant</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中 %s 要求对应 char* 型指针，但 msg 是 string 型对象，造成栈读取错误，应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void foo(const string&amp; msg) &#123;</span><br><span class="line">    printf(&quot;%s\n&quot;, msg.c_str());   // Compliant</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于可变参数列表自身的局限，很难在编译时发现这种问题，有些编译器会检查 printf、sprintf 等标准函数，但无法检查自定义函数，建议在 C++ 代码中禁用可变参数列表和 C 风格的格式化函数。<br><br/><br><br/></p>
<h4 id="相关-193"><a href="#相关-193" class="headerlink" title="相关"></a>相关</h4><p>ID_nonPODVariadicArgument<br>ID_inconsistentFormatArgNum<br>ID_forbidCStringFormat<br><br/></p>
<h4 id="依据-163"><a href="#依据-163" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 7.19.6.1(9)-undefined<br>ISO/IEC 9899:2011 7.21.6.1(9)-undefined<br><br/></p>
<h4 id="参考-311"><a href="#参考-311" class="headerlink" title="参考"></a>参考</h4><p>CWE-686<br>SEI CERT FIO47-C<br><br/><br><br/></p>
<h3 id="▌R10-4-8-在-C-代码中禁用-C-字符串格式化方法"><a href="#▌R10-4-8-在-C-代码中禁用-C-字符串格式化方法" class="headerlink" title="▌R10.4.8 在 C++ 代码中禁用 C 字符串格式化方法"></a><span id="forbidcstringformat">▌R10.4.8 在 C++ 代码中禁用 C 字符串格式化方法</span></h3><p>ID_forbidCStringFormat&emsp;&emsp;&emsp;&emsp;&nbsp;:no_entry: expression suggestion</p>
<hr/>

<p>C 字符串格式化方法的主要问题有：  </p>
<ul>
<li>需要手工维护参数与格式化占位符的对应关系  </li>
<li>在编译期难以保证安全性，增加测试成本  </li>
<li>与 C++ 的强类型理念不符，不在 C++ 标准之内  </li>
<li>只接受基本类型的参数，不利于数据的对象化管理  </li>
</ul>
<p>故在 C++ 代码中禁用下列函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">printf、fprintf、sprintf、snprintf、</span><br><span class="line">wprintf、fwprintf、swprintf、</span><br><span class="line">vprintf、vfprintf、vsprintf、vsnprintf、</span><br><span class="line">vwprintf、vfwprintf、vswprintf</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef int32_t mytype;</span><br><span class="line"></span><br><span class="line">struct T &#123;</span><br><span class="line">    mytype a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void foo(const T* p) &#123;</span><br><span class="line">    printf(&quot;%d&quot;, p-&gt;a);   // Non-compliant, unportable</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 C 字符串格式化方法中，不同类型的参数依赖不同的格式化占位符，参数的类型与个数必须和占位符严格对应，否则就会导致未定义的行为，当参数较多时极易出错，单纯地要求开发者小心谨慎是不可靠的，改用更安全的方法才是明智的选择。  </p>
<p>在 C++ 代码中利用标准流可避免这些问题，而且 C++ 标准流具备可扩展性，符合面向对象的编程理念：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std::ostream&amp; operator &lt;&lt; (std::ostream&amp; os, const T&amp; t) &#123;</span><br><span class="line">    return os &lt;&lt; t.a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void foo(const T* p) &#123;</span><br><span class="line">    std::cout &lt;&lt; *p;     // Compliant, safe and brief</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当参数较多时，标准流的方式在形态上可能较为“松散”，在可读性上可能不如 printf 函数，而且重载 &lt;&lt;、&gt;&gt; 运算符的方式也会产生同步问题和额外的性能开销，对此 C++20 的“<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/utility/format/format">std::format</a>”提供了更多的格式化方法。也可参见 ID_forbidVariadicFunction 的示例，用“<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/parameter_pack">模板参数包</a>”等更安全的方法实现 printf 函数的功能。<br><br/><br><br/></p>
<h4 id="相关-194"><a href="#相关-194" class="headerlink" title="相关"></a>相关</h4><p>ID_forbidVariadicFunction<br><br/></p>
<h4 id="依据-164"><a href="#依据-164" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 7.19.6.1(2)-undefined<br>ISO/IEC 9899:1999 7.19.6.1(9)-undefined<br>ISO/IEC 9899:2011 7.21.6.1(2)-undefined<br>ISO/IEC 9899:2011 7.21.6.1(9)-undefined<br><br/></p>
<h4 id="参考-312"><a href="#参考-312" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines SL.io.3<br><br/><br><br/></p>
<h3 id="▌R10-4-9-禁用-atof、atoi、atol-以及-atoll-等函数"><a href="#▌R10-4-9-禁用-atof、atoi、atol-以及-atoll-等函数" class="headerlink" title="▌R10.4.9 禁用 atof、atoi、atol 以及 atoll 等函数"></a><span id="forbidatox">▌R10.4.9 禁用 atof、atoi、atol 以及 atoll 等函数</span></h3><p>ID_forbidAtox&emsp;&emsp;&emsp;&emsp;&nbsp;:no_entry: expression warning</p>
<hr/>

<p>当字符串无法被正确转为数值时，stdlib.h 或 cstdlib 中的 atof、atoi、atol 以及 atoll 等函数会导致标准未定义的行为。  </p>
<p>对于 C 语言应改用 strtof、strtol 等函数，对于 C++ 语言应改用标准流转换的方式。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; atoi(&quot;abcdefg&quot;) &lt;&lt; &#x27;\n&#x27;;        // Non-compliant</span><br><span class="line">cout &lt;&lt; atoi(&quot;100000000000&quot;) &lt;&lt; &#x27;\n&#x27;;   // Non-compliant</span><br></pre></td></tr></table></figure>
<p>例中字符串“abcdefg”不表示数字，字符串“100000000000”超出了正常 int 型变量的范围，这些情况会导致标准未定义的行为。  </p>
<p>更严重的问题是无法通过这种函数判断转换是否成功，这种不确定性也意味着代码在实现上存在缺陷。  </p>
<p>C++ 标准流转换示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int foo(const char* s) &#123;</span><br><span class="line">    int v = 0;</span><br><span class="line">    stringstream ss(s);</span><br><span class="line">    ss &gt;&gt; v;</span><br><span class="line">    if (ss.fail()) &#123;              // Or use ‘!ss.eof() || ss.fail()’</span><br><span class="line">        throw some_exception();</span><br><span class="line">    &#125;</span><br><span class="line">    return v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本例通过 ss.fail() 判断字符串前面的字符是否可以转为 int 型变量，也可通过 !ss.eof() || ss.fail() 判断字符串整体是否可以转为 int 型变量。<br><br/><br><br/></p>
<h4 id="依据-165"><a href="#依据-165" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 7.20.1(1)-undefined<br>ISO/IEC 9899:2011 7.22.1(1)-undefined<br><br/></p>
<h4 id="参考-313"><a href="#参考-313" class="headerlink" title="参考"></a>参考</h4><p>MISRA C 2004 20.10<br>MISRA C 2012 21.7<br>MISRA C++ 2008 18-0-2<br><br/><br><br/></p>
<h3 id="▌R10-4-10-避免使用由实现定义的库函数"><a href="#▌R10-4-10-避免使用由实现定义的库函数" class="headerlink" title="▌R10.4.10 避免使用由实现定义的库函数"></a><span id="implementationdefinedfunction">▌R10.4.10 避免使用由实现定义的库函数</span></h3><p>ID_implementationDefinedFunction&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: expression warning</p>
<hr/>

<p>由实现定义的（implementation-defined）库函数会增加移植或兼容等方面的成本。  </p>
<p>如：  </p>
<ul>
<li>cstdlib、stdlib.h 中的 abort、exit、_Exit、quick_exit、getenv、system 等函数  </li>
<li>ctime、time.h 中的 clock 等函数  </li>
<li>csignal、signal.h 中的 signal 等函数  </li>
</ul>
<p>这些函数的行为取决于编译器、库或环境的生产厂家，同一个函数不同的厂家会有不同的实现，故称这种函数的行为是“由实现定义”的。有高可靠性要求的软件系统应避免使用这种函数，否则需明确各种实现上的具体差异，增加了移植、发布以及兼容性等多方面的成本。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line"></span><br><span class="line">void foo() &#123;</span><br><span class="line">    abort();   // Non-compliant</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用 abort 函数会终止进程，但打开的流是否会被关闭，缓冲区内的数据是否会写入文件，临时文件是否会被清理则由实现定义。<br><br/><br><br/></p>
<h4 id="依据-166"><a href="#依据-166" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:2011 7.14.1.1(3)-implementation<br>ISO/IEC 9899:2011 7.22.4.1(2)-implementation<br>ISO/IEC 9899:2011 7.22.4.4(5)-implementation<br>ISO/IEC 9899:2011 7.22.4.5(2)-implementation<br>ISO/IEC 9899:2011 7.22.4.6(2)-implementation<br>ISO/IEC 9899:2011 7.22.4.7(4)-implementation<br>ISO/IEC 9899:2011 7.22.4.8(3)-implementation<br>ISO/IEC 9899:2011 7.27.2.1(3)-implementation<br><br/></p>
<h4 id="参考-314"><a href="#参考-314" class="headerlink" title="参考"></a>参考</h4><p>CWE-474<br>CWE-589<br>MISRA C 2004 20.8<br>MISRA C 2004 20.11<br>MISRA C 2004 20.12<br>MISRA C 2012 21.5<br>MISRA C 2012 21.8<br>MISRA C 2012 21.10<br>MISRA C++ 2008 18-0-3<br>MISRA C++ 2008 18-0-4<br>MISRA C++ 2008 18-7-1<br><br/><br><br/></p>
<h3 id="▌R10-4-11-合理使用-std-move"><a href="#▌R10-4-11-合理使用-std-move" class="headerlink" title="▌R10.4.11 合理使用 std::move"></a><span id="unsuitablemove">▌R10.4.11 合理使用 std::move</span></h3><p>ID_unsuitableMove&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: expression warning</p>
<hr/>

<p>std::move 的参数应为左值，返回值应直接作为接口的参数，除此之外的使用方式价值有限，且易产生错误。  </p>
<p>std::move 将左值转为右值，意在宣告对象的数据将被转移到其他对象，应由合适的接口完成数据转移。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string foo();</span><br><span class="line">string s = move(foo());  // Non-compliant</span><br></pre></td></tr></table></figure>
<p>例中 foo 函数返回的是右值，如果再调用 std::move 是多余的，应将 std::move 去掉。  </p>
<p>又如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string a(&quot;....&quot;);</span><br><span class="line">string&amp;&amp; b = move(a);  // Non-compliant</span><br><span class="line">string c(b);           // Not move construction</span><br></pre></td></tr></table></figure>
<p>例中 b 是具有名称的右值引用，其实是左值，c 仍是拷贝构造。  </p>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string a(&quot;....&quot;);</span><br><span class="line">string c(move(a));  // Compliant</span><br></pre></td></tr></table></figure>
<p>这样构造 c 时会自动选取移动构造函数，避免了复制。  </p>
<p>又如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string foo() &#123;</span><br><span class="line">    string s(&quot;....&quot;);</span><br><span class="line">    ....</span><br><span class="line">    return move(s);  // Non-compliant</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中 foo 函数返回对象，编译器会进行“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Copy_elision#Return_value_optimization">RVO（Return Value Optimization）</a>”优化，显式调用 move 是多余的，而且会干扰优化，不应出现 return std::move(….) 这种代码。  </p>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string foo() &#123;</span><br><span class="line">    string s(&quot;....&quot;);</span><br><span class="line">    ....</span><br><span class="line">    return s;  // Compliant</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="依据-167"><a href="#依据-167" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 14882:2011 20.2.3(6)<br>ISO/IEC 14882:2017 23.2.5(5)<br><br/></p>
<h4 id="参考-315"><a href="#参考-315" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines ES.56<br>C++ Core Guidelines F.18<br>C++ Core Guidelines F.48<br><br/><br><br/></p>
<h3 id="▌R10-4-12-合理使用-std-forward"><a href="#▌R10-4-12-合理使用-std-forward" class="headerlink" title="▌R10.4.12 合理使用 std::forward"></a><span id="unsuitableforward">▌R10.4.12 合理使用 std::forward</span></h3><p>ID_unsuitableForward&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: expression warning</p>
<hr/>

<p>std::forward 的参数应为“<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/reference#Forwarding_references">转发引用（forwarding references）</a>”，返回值应直接作为接口的参数，除此之外的使用方式价值有限，且易产生错误。  </p>
<p>转发引用是类型为 T&amp;&amp; 的参数，T 为函数模板类型，无论左值还是右值均可被这种参数接受，而且 const、volatile 等属性也会被忽略，这种参数应通过 std::forward<T> 交由合适的接口处理。  </p>
<p>关于转发引用，可参见 ID_illForwardingReference 的进一步说明。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">struct A &#123; .... &#125;;</span><br><span class="line"></span><br><span class="line">void foo(A&amp;);        // #1</span><br><span class="line">void foo(const A&amp;);  // #2</span><br><span class="line">void foo(A&amp;&amp;);       // #3</span><br><span class="line"></span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">void bar(T&amp;&amp; x) &#123;        // Forwarding reference</span><br><span class="line">    foo(forward&lt;T&gt;(x));  // Compliant</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void baz(const A&amp; a) &#123;</span><br><span class="line">    A b(a);</span><br><span class="line">    bar(b);    // Calls #1</span><br><span class="line"></span><br><span class="line">    bar(a);    // Calls #2</span><br><span class="line"></span><br><span class="line">    bar(A());  // Calls #3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中 bar 接口的参数为转发引用，在 baz 函数中，bar 接口将左值、常量引用和临时对象分别转发给对应的 foo 接口，这种模式称为“完美转发”，std::forward 应在这种模式内使用。  </p>
<p>下面给出几种错误示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void bar(A&amp;&amp; x) &#123;</span><br><span class="line">    foo(forward&lt;A&gt;(x));  // Non-compliant, ‘x’ is not a forwarding reference</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">struct X &#123;</span><br><span class="line">    void bar(T&amp;&amp; x) &#123;</span><br><span class="line">        foo(forward&lt;T&gt;(x));  // Non-compliant, ‘x’ is not a forwarding reference</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意，转发引用的类型只能是函数模板类型，非模板和类模板不构成转发引用。  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class T&gt;</span><br><span class="line">void bar(T&amp;&amp; x) &#123;</span><br><span class="line">    T y = forward&lt;T&gt;(x);  // Non-compliant, ‘y’ is always an lvalue</span><br><span class="line">    foo(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">void bar(T&amp;&amp; x) &#123;</span><br><span class="line">    foo(forward&lt;T&amp;&gt;(x));  // Non-compliant, use ‘forward&lt;T&gt;(x)’</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>forward 的返回值应直接作为接口的参数，且只应使用 forward<T>。<br><br/><br><br/></p>
<h4 id="相关-195"><a href="#相关-195" class="headerlink" title="相关"></a>相关</h4><p>ID_illForwardingReference<br><br/></p>
<h4 id="依据-168"><a href="#依据-168" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 14882:2011 20.2.3(1)<br>ISO/IEC 14882:2017 23.2.5(1)<br><br/></p>
<h4 id="参考-316"><a href="#参考-316" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines F.19<br><br/><br><br/></p>
<h3 id="10-5-Sizeof"><a href="#10-5-Sizeof" class="headerlink" title="10.5 Sizeof"></a><span id="expression.sizeof">10.5 Sizeof</span></h3><h3 id="▌R10-5-1-sizeof-不应作用于数组参数"><a href="#▌R10-5-1-sizeof-不应作用于数组参数" class="headerlink" title="▌R10.5.1 sizeof 不应作用于数组参数"></a><span id="sizeof_arrayparameter">▌R10.5.1 sizeof 不应作用于数组参数</span></h3><p>ID_sizeof_arrayParameter&emsp;&emsp;&emsp;&emsp;&nbsp;:boom: expression error</p>
<hr/>

<p>当函数的形式参数为数组时，实际上是一个指针，对这种参数使用 sizeof 无法获取到数组大小，往往意味着错误。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void fun(char arr[32]) &#123;</span><br><span class="line">    memset(arr, 0, sizeof(arr));  // Non-compliant</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中参数 arr 是一个指针，而不是一个真实的数组。  </p>
<p>在 C++ 代码中，如果有必要将参数设为数组，建议使用引用的方式，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void fun(char (&amp;arr)[32]) &#123;</span><br><span class="line">    memset(arr, 0, sizeof(arr));  // Compliant</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样 sizeof(arr) 的结果就会和预期一致。<br><br/><br><br/></p>
<h4 id="依据-169"><a href="#依据-169" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 6.7.5.3(7)<br>ISO/IEC 9899:2011 6.7.6.3(7)<br><br/></p>
<h4 id="参考-317"><a href="#参考-317" class="headerlink" title="参考"></a>参考</h4><p>CWE-467<br><br/><br><br/></p>
<h3 id="▌R10-5-2-sizeof-不应作用于逻辑表达式"><a href="#▌R10-5-2-sizeof-不应作用于逻辑表达式" class="headerlink" title="▌R10.5.2 sizeof 不应作用于逻辑表达式"></a><span id="sizeof_oddexpression">▌R10.5.2 sizeof 不应作用于逻辑表达式</span></h3><p>ID_sizeof_oddExpression&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: expression warning</p>
<hr/>

<p>sizeof 作用于 &lt;、&gt;、&lt;=、&gt;=、==、!=、&amp;&amp;、|| 等逻辑表达式为常见笔误，逻辑运算符往往应该移出 sizeof 表达式。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (sizeof(a == x)) &#123;  // Non-compliant, may be sizeof(a) == x</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line">if (sizeof(a &gt;= x)) &#123;  // Non-compliant, may be sizeof(a) &gt;= x</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/><br><br/></p>
<h3 id="▌R10-5-3-sizeof-作用于指针是可疑的"><a href="#▌R10-5-3-sizeof-作用于指针是可疑的" class="headerlink" title="▌R10.5.3 sizeof 作用于指针是可疑的"></a><span id="sizeof_pointer">▌R10.5.3 sizeof 作用于指针是可疑的</span></h3><p>ID_sizeof_pointer&emsp;&emsp;&emsp;&emsp;&nbsp;:question: expression suspicious</p>
<hr/>

<p>sizeof 作用于指针的结果是指针的大小，而不是指针指向内容的大小，sizeof 作用于指针很容易造成错误。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void foo(int* p) &#123;</span><br><span class="line">    memset(p, 0, sizeof(p));   // Logic error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void foo(int* p, int n) &#123;</span><br><span class="line">    memset(p, 0, n * sizeof(*p));   // OK</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中参数 n 是数组元素的个数。<br><br/><br><br/></p>
<h4 id="相关-196"><a href="#相关-196" class="headerlink" title="相关"></a>相关</h4><p>ID_sizeof_pointerDivision<br><br/></p>
<h4 id="参考-318"><a href="#参考-318" class="headerlink" title="参考"></a>参考</h4><p>CWE-467<br><br/><br><br/></p>
<h3 id="▌R10-5-4-被除数不应是作用于指针的-sizeof-表达式"><a href="#▌R10-5-4-被除数不应是作用于指针的-sizeof-表达式" class="headerlink" title="▌R10.5.4 被除数不应是作用于指针的 sizeof 表达式"></a><span id="sizeof_pointerdivision">▌R10.5.4 被除数不应是作用于指针的 sizeof 表达式</span></h3><p>ID_sizeof_pointerDivision&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: expression warning</p>
<hr/>

<p>形如 sizeof(p) / n 的表达式往往意在获取数组元素的个数，如果 p 是指针，sizeof(p) 是指针大小而不是数组大小，结果很可能是错误的。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void foo(T* p) &#123;</span><br><span class="line">    size_t n = sizeof(p[0]);</span><br><span class="line">    qsort(p, sizeof(p) / n, n, cmp);  // Non-compliant, logic error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中 sizeof(p) / n 并不能获取 p 所指数组中元素的个数。  </p>
<p>本规则是 ID_sizeof_pointer 的特化，sizeof 作用于指针是可疑的，再作为被除数就更加可疑了。<br><br/><br><br/></p>
<h4 id="相关-197"><a href="#相关-197" class="headerlink" title="相关"></a>相关</h4><p>ID_sizeof_pointer<br><br/></p>
<h4 id="参考-319"><a href="#参考-319" class="headerlink" title="参考"></a>参考</h4><p>CWE-467<br><br/><br><br/></p>
<h3 id="▌R10-5-5-指针加减偏移量时计入-sizeof-是可疑的"><a href="#▌R10-5-5-指针加减偏移量时计入-sizeof-是可疑的" class="headerlink" title="▌R10.5.5 指针加减偏移量时计入 sizeof 是可疑的"></a><span id="sizeof_suspiciousadd">▌R10.5.5 指针加减偏移量时计入 sizeof 是可疑的</span></h3><p>ID_sizeof_suspiciousAdd&emsp;&emsp;&emsp;&emsp;&nbsp;:question: expression suspicious</p>
<hr/>

<p>指针加减偏移量时会自动计入指针指向类型的大小，如果再计入 sizeof 的值，很可能是某种错误。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int foo(int* p, int i) &#123;</span><br><span class="line">    return *(p + i * sizeof(int));   // Rather suspicious</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 foo 函数是为了获取指针 p 之后第 i 个整数的值，那么这种实现是错误的，应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int foo(int* p, int i) &#123;</span><br><span class="line">    return *(p + i);       // Right</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="依据-170"><a href="#依据-170" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 6.5.6(8)<br>ISO/IEC 9899:2011 6.5.6(8)<br><br/></p>
<h4 id="参考-320"><a href="#参考-320" class="headerlink" title="参考"></a>参考</h4><p>CWE-468<br><br/><br><br/></p>
<h3 id="▌R10-5-6-sizeof-表达式的结果不应与-0-或负数比较"><a href="#▌R10-5-6-sizeof-表达式的结果不应与-0-或负数比较" class="headerlink" title="▌R10.5.6 sizeof 表达式的结果不应与 0 或负数比较"></a><span id="sizeof_zerocomparison">▌R10.5.6 sizeof 表达式的结果不应与 0 或负数比较</span></h3><p>ID_sizeof_zeroComparison&emsp;&emsp;&emsp;&emsp;&nbsp;:boom: expression error</p>
<hr/>

<p>将 sizeof 表达式的结果与 0 或负数比较往往意味着逻辑错误。  </p>
<p>标准规定，如果 sizeof 作用于完整类型结果一定大于 0，如果作用于不完整的类型则无法通过编译。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void foo(int* p) &#123;</span><br><span class="line">    if (sizeof(p)) &#123;  // Non-compliant, always true</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，在某些 C 环境中，sizeof 作用于空结构体或联合体结果可能是 0，但这属于未定义的行为，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">struct A &#123;&#125; a;</span><br><span class="line">printf(&quot;%zu\n&quot;, sizeof(a));  // What is output?</span><br></pre></td></tr></table></figure>
<p>空结构体或联合体在 C 标准中属于非法类型，示例代码可能会输出 0，也可能不会通过编译。<br><br/><br><br/></p>
<h4 id="依据-171"><a href="#依据-171" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 6.7.2.1(7)-undefined<br>ISO/IEC 9899:2011 6.7.2.1(8)-undefined<br>ISO/IEC 14882:2003 5.3.3(1 6)<br>ISO/IEC 14882:2003 9(3)<br>ISO/IEC 14882:2011 5.3.3(1 6)<br>ISO/IEC 14882:2011 9(3)<br>ISO/IEC 14882:2017 8.3.3(1 6)<br>ISO/IEC 14882:2017 12(4)<br><br/></p>
<h4 id="参考-321"><a href="#参考-321" class="headerlink" title="参考"></a>参考</h4><p>CWE-1025<br><br/><br><br/></p>
<h3 id="▌R10-5-7-sizeof-不应再作用于-sizeof-表达式"><a href="#▌R10-5-7-sizeof-不应再作用于-sizeof-表达式" class="headerlink" title="▌R10.5.7 sizeof 不应再作用于 sizeof 表达式"></a><span id="sizeof_sizeof">▌R10.5.7 sizeof 不应再作用于 sizeof 表达式</span></h3><p>ID_sizeof_sizeof&emsp;&emsp;&emsp;&emsp;&nbsp;:boom: expression error</p>
<hr/>

<p>sizeof(sizeof(…)) 等价于 sizeof(size_t)，在实际应用中没有任何必要写成连续 sizeof 的形式，往往意味着逻辑错误，多数由复制粘贴或错误的宏展开导致。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void foo() &#123;</span><br><span class="line">    T* p = (T*)malloc(sizeof(T));</span><br><span class="line">    p-&gt;nLength = sizeof(sizeof(T));  // Non-compliant, copy-paste error</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="依据-172"><a href="#依据-172" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 6.5.3.4(4)<br>ISO/IEC 9899:2011 6.5.3.4(5)<br>ISO/IEC 14882:2003 5.3.3(6)<br>ISO/IEC 14882:2011 5.3.3(6)<br>ISO/IEC 14882:2017 8.3.3(6)<br><br/></p>
<h4 id="参考-322"><a href="#参考-322" class="headerlink" title="参考"></a>参考</h4><p>CWE-682<br><br/><br><br/></p>
<h3 id="▌R10-5-8-C-代码中-sizeof-不应作用于-NULL"><a href="#▌R10-5-8-C-代码中-sizeof-不应作用于-NULL" class="headerlink" title="▌R10.5.8 C++ 代码中 sizeof 不应作用于 NULL"></a><span id="sizeof_null">▌R10.5.8 C++ 代码中 sizeof 不应作用于 NULL</span></h3><p>ID_sizeof_NULL&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: expression warning</p>
<hr/>

<p>标识符 NULL 由实现定义，在 C++ 语言中往往等同于常量 0，sizeof(NULL) 的结果很可能与预期不符。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">size_t n = sizeof(NULL);   // Non-compliant</span><br></pre></td></tr></table></figure>
<p>不同的编译器对示例代码有不同的处理，有些会把 NULL 当作指针，有些会当作常量 0。  </p>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">size_t n = sizeof(nullptr);   // Compliant</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="相关-198"><a href="#相关-198" class="headerlink" title="相关"></a>相关</h4><p>ID_deprecatedNULL<br><br/></p>
<h4 id="依据-173"><a href="#依据-173" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 14882:2003 C.2.2.3(1)-implementation<br>ISO/IEC 14882:2011 C.3.2.4(1)-implementation<br>ISO/IEC 14882:2017 C.5.2.7(1)-implementation<br><br/></p>
<h4 id="参考-323"><a href="#参考-323" class="headerlink" title="参考"></a>参考</h4><p>CWE-351<br><br/><br><br/></p>
<h3 id="▌R10-5-9-sizeof-不可作用于-void"><a href="#▌R10-5-9-sizeof-不可作用于-void" class="headerlink" title="▌R10.5.9 sizeof 不可作用于 void"></a><span id="sizeof_void">▌R10.5.9 sizeof 不可作用于 void</span></h3><p>ID_sizeof_void&emsp;&emsp;&emsp;&emsp;&nbsp;:boom: expression error</p>
<hr/>

<p>void 表示不存在的类型，也是不完整的类型，sizeof 作用于 void 是没意义的，属于语言运用错误，也可能是 sizeof(void*) 的笔误。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">size_t a = sizeof(void);   // Non-compliant</span><br><span class="line">size_t b = sizeof(void*);  // Compliant</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="依据-174"><a href="#依据-174" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 6.2.5(19)<br>ISO/IEC 9899:1999 6.3.2.2(1)<br>ISO/IEC 9899:2011 6.2.5(19)<br>ISO/IEC 9899:2011 6.3.2.2(1)<br><br/><br><br/></p>
<h3 id="10-6-Assertion"><a href="#10-6-Assertion" class="headerlink" title="10.6 Assertion"></a><span id="expression.assertion">10.6 Assertion</span></h3><h3 id="▌R10-6-1-断言中的表达式不应恒为真"><a href="#▌R10-6-1-断言中的表达式不应恒为真" class="headerlink" title="▌R10.6.1 断言中的表达式不应恒为真"></a><span id="badassertion">▌R10.6.1 断言中的表达式不应恒为真</span></h3><p>ID_badAssertion&emsp;&emsp;&emsp;&emsp;&nbsp;:boom: expression error</p>
<hr/>

<p>恒为真的断言是没有意义的。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void foo(int a[]) &#123;</span><br><span class="line">    assert(sizeof(a));        // Non-compliant</span><br><span class="line">    assert(&quot;some comments&quot;);  // Non-compliant</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也不建议使用恒为假的断言表示异常，在 C++ 代码中应改用异常处理的方式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void bar(int x) &#123;</span><br><span class="line">    if (x &lt; 0) &#123;</span><br><span class="line">        assert(0);  // Bad, use exceptions instead</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="依据-175"><a href="#依据-175" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 7.2<br>ISO/IEC 9899:2011 7.2<br><br/><br><br/></p>
<h3 id="▌R10-6-2-断言中的表达式不应有副作用"><a href="#▌R10-6-2-断言中的表达式不应有副作用" class="headerlink" title="▌R10.6.2 断言中的表达式不应有副作用"></a><span id="sideeffectassertion">▌R10.6.2 断言中的表达式不应有副作用</span></h3><p>ID_sideEffectAssertion&emsp;&emsp;&emsp;&emsp;&nbsp;:boom: expression error</p>
<hr/>

<p>断言中的表达式如果有副作用，不能保证在所有编译设置下都有效。  </p>
<p>如标准断言 assert 会受宏 NDEBUG 的影响，当该宏被定义时 assert 中的表达式不会被执行。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void foo(int* p) &#123;</span><br><span class="line">    assert(++(*p) &gt; 0);  // Non-compliant</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>表达式的副作用均应在 assert 之前完成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void foo(int* p) &#123;</span><br><span class="line">    ++(*p);</span><br><span class="line">    assert(*p &gt; 0);      // Compliant</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="相关-199"><a href="#相关-199" class="headerlink" title="相关"></a>相关</h4><p>ID_macro_sideEffectArgs<br>ID_unevaluatedSideEffect<br><br/></p>
<h4 id="依据-176"><a href="#依据-176" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 7.2<br>ISO/IEC 9899:2011 7.2<br><br/></p>
<h4 id="参考-324"><a href="#参考-324" class="headerlink" title="参考"></a>参考</h4><p>SEI CERT PRE31-C<br><br/><br><br/></p>
<h3 id="▌R10-6-3-断言中的表达式不应过于复杂"><a href="#▌R10-6-3-断言中的表达式不应过于复杂" class="headerlink" title="▌R10.6.3 断言中的表达式不应过于复杂"></a><span id="complexassertion">▌R10.6.3 断言中的表达式不应过于复杂</span></h3><p>ID_complexAssertion&emsp;&emsp;&emsp;&emsp;&nbsp;:bulb: expression suggestion</p>
<hr/>

<p>断言中的表达式不应过于复杂，否则不易定位具体是哪一项不符合断言，不利于调试。  </p>
<p>对于“逻辑与”表达式应将各子表达式分成多个断言。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void foo(int a, int b, int c) &#123;</span><br><span class="line">    assert(a != 0 &amp;&amp; b &gt; 10 &amp;&amp; c == b + 1);  // Bad</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void foo(int a, int b, int c) &#123;</span><br><span class="line">    assert(a != 0);</span><br><span class="line">    assert(b &gt; 10);</span><br><span class="line">    assert(c == b + 1);  // Good</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本着使代码便于调试的理念展开工作，可有效降低测试及维护成本。<br><br/><br><br/></p>
<h4 id="配置-35"><a href="#配置-35" class="headerlink" title="配置"></a>配置</h4><p>maxLogicOperatorCount：断言表达式中“逻辑与”运算符的最大数量，超过则报出<br><br/><br><br/></p>
<h3 id="10-7-Complexity"><a href="#10-7-Complexity" class="headerlink" title="10.7 Complexity"></a><span id="expression.complexity">10.7 Complexity</span></h3><h3 id="▌R10-7-1-表达式不应过于复杂"><a href="#▌R10-7-1-表达式不应过于复杂" class="headerlink" title="▌R10.7.1 表达式不应过于复杂"></a><span id="complexexpression">▌R10.7.1 表达式不应过于复杂</span></h3><p>ID_complexExpression&emsp;&emsp;&emsp;&emsp;&nbsp;:bulb: expression suggestion</p>
<hr/>

<p>复杂的表达式不利于阅读与调试，易包含潜在的错误，应适当拆分。  </p>
<p>下列情况可判定为复杂表达式：  </p>
<ul>
<li>运算符过多  </li>
<li>有副作用的子表达式过多  </li>
<li>优先级括号嵌套层次过深  </li>
<li>函数调用或数组索引嵌套层次过深  </li>
<li>三元表达式嵌套层次过深  </li>
</ul>
<p>审计工具不妨通过配置判断表达式是否合规。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">f(g(h(i(....)));           // Non-compliant</span><br><span class="line">    </span><br><span class="line">a || b || c || .... || z;  // Non-compliant</span><br><span class="line"></span><br><span class="line">++++++n;                   // Non-compliant</span><br><span class="line"></span><br><span class="line">x ? y ? z ? .... : ....;   // Non-compliant</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="配置-36"><a href="#配置-36" class="headerlink" title="配置"></a>配置</h4><p>maxOperatorCount：运算符最大数量，超过则报出<br>maxSideEffectPoints：具有副作用的子表达式最大数量，超过则报出<br>maxParenthesesLevel：优先级括号嵌套最大层数，超过则报出<br>maxPostfixLevel：函数调用、数组索引嵌套最大层数，超过则报出<br>maxTernaryLevel：三元表达式嵌套最大层数，超过则报出<br><br/></p>
<h4 id="参考-325"><a href="#参考-325" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines ES.40<br><br/><br><br/></p>
<h3 id="10-8-Other"><a href="#10-8-Other" class="headerlink" title="10.8 Other"></a><span id="expression.other">10.8 Other</span></h3><h3 id="▌R10-8-1-不应访问填充数据"><a href="#▌R10-8-1-不应访问填充数据" class="headerlink" title="▌R10.8.1 不应访问填充数据"></a><span id="accesspaddingdata">▌R10.8.1 不应访问填充数据</span></h3><p>ID_accessPaddingData&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: expression warning</p>
<hr/>

<p>内存中各对象之间可能存在填充数据，这种数据只为实现“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Data_structure_alignment">内存对齐</a>”而无数值意义，而且填充数据的值是标准未声明的。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct A &#123;</span><br><span class="line">    char a;</span><br><span class="line">    long b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void foo(A* x, A* y) &#123;</span><br><span class="line">    if (memcmp(x, y, sizeof(*x)) == 0) &#123;  // Non-compliant</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果按常见的 4 或 8 字节对齐，A 的成员 a 和 b 之间会存在填充数据，填充数据参与比较将得到错误的结果。  </p>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void foo(A* x, A* y) &#123;</span><br><span class="line">    if (x-&gt;a == y-&gt;a &amp;&amp; x-&gt;b == y-&gt;b) &#123;  // Compliant</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即使成员之间没有填充数据也不应使用 memcmp 等函数比较，应实现类型明确的比较接口以供调用，否则很容易产生错误。<br><br/><br><br/></p>
<h4 id="相关-200"><a href="#相关-200" class="headerlink" title="相关"></a>相关</h4><p>ID_ignorePaddingData<br><br/></p>
<h4 id="依据-177"><a href="#依据-177" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 6.2.6.2(5)-unspecified<br>ISO/IEC 9899:2011 6.2.6.2(5)-unspecified<br><br/><br><br/></p>
<h3 id="▌R10-8-2-new-表达式只可用于赋值或当作参数"><a href="#▌R10-8-2-new-表达式只可用于赋值或当作参数" class="headerlink" title="▌R10.8.2 new 表达式只可用于赋值或当作参数"></a><span id="oddnew">▌R10.8.2 new 表达式只可用于赋值或当作参数</span></h3><p>ID_oddNew&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: expression warning</p>
<hr/>

<p>new 表达式只应作为“=”的直接右子表达式，或直接作为参数，其他形式均有问题。  </p>
<p>本规则对 replacement new 不作要求。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int i = *new int(10);         // Non-compliant, memory leak</span><br><span class="line"></span><br><span class="line">int&amp; j = *new int(10);        // Non-compliant</span><br><span class="line">delete &amp;j;                    // Very odd</span><br><span class="line"></span><br><span class="line">char* p = new char[10] + 5;   // Non-compliant</span><br><span class="line">delete[] p - 5;               // Very odd</span><br><span class="line"></span><br><span class="line">if (new int[10]) &#123;            // Non-compliant, memory leak</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种问题多数是由笔误或错误的宏展开造成的。<br><br/><br><br/></p>
<h4 id="相关-201"><a href="#相关-201" class="headerlink" title="相关"></a>相关</h4><p>ID_multiAllocation<br><br/><br><br/></p>
<h3 id="▌R10-8-3-数组下标应为整型表达式"><a href="#▌R10-8-3-数组下标应为整型表达式" class="headerlink" title="▌R10.8.3 数组下标应为整型表达式"></a><span id="oddsubscripting">▌R10.8.3 数组下标应为整型表达式</span></h3><p>ID_oddSubscripting&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: expression warning</p>
<hr/>

<p>C/C++ 语言规定，数组下标可以在中括号的右侧也可以在左侧，然而这只是一种理论上的设计，在实际代码中应采用约定俗成的方式，即数组的名称在中括号的左侧，下标在中括号的右侧。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void fun() &#123;</span><br><span class="line">    int a[5] = &#123;1, 2, 3, 4&#125;;</span><br><span class="line">    4[a] = 5;                       // Non-compliant, use a[4] instead</span><br><span class="line">    for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">        cout &lt;&lt; i + 1[a] &lt;&lt; &#x27;\n&#x27;;   // Non-compliant, may be a[i + 1]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于 a[4] 相当于 *(a+4)，所以与其等价的 *(4+a) 也应该可以解释为 4[a]，但下标在左侧的写法容易造成运算符优先级相关的问题，将下标写在右侧才是符合惯例的方式。<br><br/><br><br/></p>
<h4 id="依据-178"><a href="#依据-178" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 6.5.2.1(2)<br>ISO/IEC 9899:2011 6.5.2.1(2)<br>ISO/IEC 14882:2003 8.3.4(6)<br>ISO/IEC 14882:2011 8.3.4(6)<br><br/><br><br/></p>
<h3 id="▌R10-8-4-禁用逗号表达式"><a href="#▌R10-8-4-禁用逗号表达式" class="headerlink" title="▌R10.8.4 禁用逗号表达式"></a><span id="forbidcommaexpression">▌R10.8.4 禁用逗号表达式</span></h3><p>ID_forbidCommaExpression&emsp;&emsp;&emsp;&emsp;&nbsp;:no_entry: expression suggestion</p>
<hr/>

<p>逗号表达式将多个语句合成一个表达式，不利于阅读且易形成笔误。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fun1(), fun2();                     // Non-compliant, bad</span><br><span class="line">cond? foo(), bar(): baz(), qux();   // Non-compliant, very bad</span><br></pre></td></tr></table></figure>
<p>逗号表达式会使代码的静态结构含混不明，总有更合理的方法替代逗号表达式： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fun1();</span><br><span class="line">fun2();      // Compliant</span><br><span class="line"></span><br><span class="line">if (cond) &#123;</span><br><span class="line">    foo();</span><br><span class="line">    bar();   // Compliant</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    baz();</span><br><span class="line">    qux();   // Compliant</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>逗号表达式也易被误用，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = b++, b * 2;      // Non-compliant</span><br><span class="line">x, y, z = 1, 2, 3;   // Non-compliant</span><br><span class="line">delete p, q;         // Non-compliant</span><br><span class="line">foo((a, b), c);      // Non-compliant</span><br><span class="line">return i, j, k;      // Non-compliant</span><br></pre></td></tr></table></figure>
<p>又如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (a = 0, b = 0; a &lt; 100; a++, b++)  &#123;   // Let it go?</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 for 语句的第 1 个和第 3 个表达式中使用逗号表达式为惯用方式，但这种方式并不值得提倡，审计工具不妨通过配置决定是否放过这种方式。<br><br/><br><br/></p>
<h4 id="配置-37"><a href="#配置-37" class="headerlink" title="配置"></a>配置</h4><p>allowCommaExpressionInForIteration：是否放过 for 语句中的逗号表达式<br><br/></p>
<h4 id="参考-326"><a href="#参考-326" class="headerlink" title="参考"></a>参考</h4><p>MISRA C 2004 12.10<br>MISRA C 2012 12.3<br>MISRA C++ 2008 5-18-1<br><br/><br><br/></p>
<h2 id="11-Literal"><a href="#11-Literal" class="headerlink" title="11. Literal"></a><span id="literal">11. Literal</span></h2><h3 id="▌R11-1-转义字符的反斜杠不可误写成斜杠"><a href="#▌R11-1-转义字符的反斜杠不可误写成斜杠" class="headerlink" title="▌R11.1 转义字符的反斜杠不可误写成斜杠"></a><span id="literal_suspiciouschar">▌R11.1 转义字符的反斜杠不可误写成斜杠</span></h3><p>ID_literal_suspiciousChar&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: literal warning</p>
<hr/>

<p>将转义字符的反斜杠误写成斜杠是常见笔误，但仍可通过编译，造成不易察觉的问题。  </p>
<p>本规则是 ID_literal_multicharacter 的特化。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char a = &#x27;/t&#x27;;   // Non-compliant</span><br><span class="line">char b = &#x27;\t&#x27;;   // Compliant</span><br></pre></td></tr></table></figure>
<p>例中 ‘/t’ 是错误的，但可以作为“多字符常量”通过编译，值由实现定义。  </p>
<p>又如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const char* p = strchr(str, &#x27;/t&#x27;);   // Non-compliant</span><br></pre></td></tr></table></figure>
<p>在某些环境中执行结果和下列代码一样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const char* p = strchr(str, &#x27;/&#x27;);</span><br></pre></td></tr></table></figure>
<p>字符 t 将被忽略，造成逻辑错误，’/t’ 应改为 ‘\t’。<br><br/><br><br/></p>
<h4 id="相关-202"><a href="#相关-202" class="headerlink" title="相关"></a>相关</h4><p>ID_literal_multicharacter<br><br/></p>
<h4 id="依据-179"><a href="#依据-179" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 6.4.4.4(10)-implementation<br>ISO/IEC 9899:2011 6.4.4.4(10)-implementation<br>ISO/IEC 14882:2011 2.13.2(1)-implementation<br>ISO/IEC 14882:2011 2.14.3(1)-implementation<br>ISO/IEC 14882:2017 5.13.3(2)-implementation<br><br/><br><br/></p>
<h3 id="▌R11-2-在字符常量中用转义字符表示制表符和控制字符"><a href="#▌R11-2-在字符常量中用转义字符表示制表符和控制字符" class="headerlink" title="▌R11.2 在字符常量中用转义字符表示制表符和控制字符"></a><span id="literal_hardcodechar">▌R11.2 在字符常量中用转义字符表示制表符和控制字符</span></h3><p>ID_literal_hardCodeChar&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: literal warning</p>
<hr/>

<p>未经转义的制表符和控制字符不利于阅读和维护。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char c = &#x27;	&#x27;;  // Non-compliant</span><br></pre></td></tr></table></figure>
<p>例中字符常量为制表符，易被误解为空格，在终端上复制粘贴后也可能变成数目不确定的空格，成为 multi-character 常量，导致意料之外的错误。  </p>
<p>故应使用转义字符：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char c = &#x27;\t&#x27;;  // Compliant</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="相关-203"><a href="#相关-203" class="headerlink" title="相关"></a>相关</h4><p>ID_literal_hardCodeString<br><br/><br><br/></p>
<h3 id="▌R11-3-在字符串常量中用转义字符表示制表符和控制字符"><a href="#▌R11-3-在字符串常量中用转义字符表示制表符和控制字符" class="headerlink" title="▌R11.3 在字符串常量中用转义字符表示制表符和控制字符"></a><span id="literal_hardcodestring">▌R11.3 在字符串常量中用转义字符表示制表符和控制字符</span></h3><p>ID_literal_hardCodeString&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: literal warning</p>
<hr/>

<p>未经转义的制表符和控制字符不利于阅读和维护。  </p>
<p>C++ 原始字符串（raw string）不受本规则限制，但不建议在原始字符串中使用制表符和换行符之外的控制字符。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const char* s = &quot;	&quot;;  // Non-compliant</span><br></pre></td></tr></table></figure>
<p>例中字符串包含制表符，易被误解为空格，在终端上复制粘贴后也可能变成数目不确定的空格，导致与预期不符的结果。  </p>
<p>故应使用转义字符：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const char* s = &quot;\t&quot;;  // Compliant</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="相关-204"><a href="#相关-204" class="headerlink" title="相关"></a>相关</h4><p>ID_literal_hardCodeChar<br><br/><br><br/></p>
<h3 id="▌R11-4-不应使用非标准转义字符"><a href="#▌R11-4-不应使用非标准转义字符" class="headerlink" title="▌R11.4 不应使用非标准转义字符"></a><span id="literal_nonstandardesc">▌R11.4 不应使用非标准转义字符</span></h3><p>ID_literal_nonStandardEsc&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: literal warning</p>
<hr/>

<p>非标准转义字符没有可移植性，也可能是忘了将反斜杠转义。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string path(&quot;C:\Files\x.cpp&quot;);   // Non-compliant</span><br></pre></td></tr></table></figure>
<p>例中 \F 不是标准转义字符，\x 也不符合 16 进制转义字符的格式，这显然是路径中的反斜杠忘了转义。  </p>
<p>附 C/C++ 标准转义字符：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x27;\a&#x27;          // Alert</span><br><span class="line">&#x27;\b&#x27;          // Backspace</span><br><span class="line">&#x27;\f&#x27;          // Formfeed page break</span><br><span class="line">&#x27;\n&#x27;          // New line</span><br><span class="line">&#x27;\r&#x27;          // Carriage return</span><br><span class="line">&#x27;\t&#x27;          // Horizontal tab</span><br><span class="line">&#x27;\v&#x27;          // Vertical tab</span><br><span class="line">&#x27;\\&#x27;          // Backslash</span><br><span class="line">&#x27;\?&#x27;          // Question mark</span><br><span class="line">&#x27;\&#x27;&#x27;          // Single quotation mark</span><br><span class="line">&#x27;\&quot;&#x27;          // Double quotation mark</span><br><span class="line">&#x27;\0&#x27;          // Null character</span><br><span class="line">&#x27;\ddd&#x27;        // Any character, ‘d’ is an octal number</span><br><span class="line">&#x27;\xhh&#x27;        // Any character, ‘h’ is a hex number</span><br><span class="line">&#x27;\uhhhh&#x27;      // Universal character name, ‘h’ is a hex number</span><br><span class="line">&#x27;\Uhhhhhhhh&#x27;  // Universal character name, ‘h’ is a hex number</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="依据-180"><a href="#依据-180" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 6.4.4.4<br>ISO/IEC 9899:2011 6.4.4.4<br>ISO/IEC 14882:2003 2.13.2(3)-undefined<br>ISO/IEC 14882:2011 2.14.3(3)-implementation<br>ISO/IEC 14882:2017 5.13.3(7)-implementation<br><br/></p>
<h4 id="参考-327"><a href="#参考-327" class="headerlink" title="参考"></a>参考</h4><p>MISRA C 2004 4.1<br>MISRA C++ 2008 2-13-1<br><br/><br><br/></p>
<h3 id="▌R11-5-不应连接不同前缀的字符串常量"><a href="#▌R11-5-不应连接不同前缀的字符串常量" class="headerlink" title="▌R11.5 不应连接不同前缀的字符串常量"></a><span id="literal_hybridconcat">▌R11.5 不应连接不同前缀的字符串常量</span></h3><p>ID_literal_hybridConcat&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: literal warning</p>
<hr/>

<p>连接不同前缀的字符串常量会导致标准未定义或由实现定义的行为。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef wchar_t S[];</span><br><span class="line"></span><br><span class="line">S a = L&quot;123&quot; U&quot;456&quot;;   // Non-compliant</span><br><span class="line">S b = L&quot;123&quot; u&quot;456&quot;;   // Non-compliant</span><br></pre></td></tr></table></figure>
<p>C++03 规定宽字符串与窄字符串连接会导致未定义的行为；C++11 规定如果一个字符串有前缀另一个没有，结果以有前缀的为准，其他情况由实现定义或无法通过编译，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">S x = L&quot;123&quot; &quot;456&quot;;    // Undefined in C++03, a wide string in C++11</span><br><span class="line">S y = L&quot;123&quot; U&quot;456&quot;;   // Implementation defined in C++11</span><br><span class="line">S z = L&quot;123&quot; u8&quot;456&quot;;  // Ill-formed in C++11</span><br></pre></td></tr></table></figure>
<p>C99 规定宽字符串与窄字符串连接的结果为宽字符串，C11 规定不同前缀的宽字符串连接结果由实现定义，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">S u = L&quot;123&quot; &quot;456&quot;;    // A wide string in C99</span><br><span class="line">S v = L&quot;123&quot; U&quot;456&quot;;   // Implementation defined in C11</span><br></pre></td></tr></table></figure>
<p>为了提高可读性和可移植性，字符串前缀应保持一致：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">S r = &quot;123&quot; L&quot;456&quot;;    // Bad</span><br><span class="line">S s = L&quot;123&quot; L&quot;456&quot;;   // Good</span><br><span class="line">S t = L&quot;123&quot; &quot;456&quot;;    // Let it go?</span><br></pre></td></tr></table></figure>
<p>对于有前缀和无前缀的字符串连接，在新的语言标准中均已有定义，审计工具不妨通过配置决定是否放过这种连接。<br><br/><br><br/></p>
<h4 id="配置-38"><a href="#配置-38" class="headerlink" title="配置"></a>配置</h4><p>allowPrefixedConcatUnprefixed：是否允许有前缀和无前缀的字符串连接<br><br/></p>
<h4 id="依据-181"><a href="#依据-181" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 6.4.5(4)<br>ISO/IEC 9899:2011 6.4.5(5)-implementation<br>ISO/IEC 14882:2003 2.13.4(3)-undefined<br>ISO/IEC 14882:2011 2.14.5(13)-implementation<br><br/></p>
<h4 id="参考-328"><a href="#参考-328" class="headerlink" title="参考"></a>参考</h4><p>MISRA C++ 2008 2-13-5<br><br/><br><br/></p>
<h3 id="▌R11-6-字符串常量中不应存在拼写错误"><a href="#▌R11-6-字符串常量中不应存在拼写错误" class="headerlink" title="▌R11.6 字符串常量中不应存在拼写错误"></a><span id="literal_misspelling">▌R11.6 字符串常量中不应存在拼写错误</span></h3><p>ID_literal_misspelling&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: literal warning</p>
<hr/>

<p>如果含有拼写错误的常量字符串对用户可见，也可以认为是产品的一种 bug，会对用户造成困扰，故应认真对待。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void showMessage(int err) &#123;</span><br><span class="line">    if (err) &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Error\n&quot;;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Successfull\n&quot;;  // Non-compliant</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中“Successfull”存在拼写错误，应改为“Successful”。<br><br/><br><br/></p>
<h4 id="相关-205"><a href="#相关-205" class="headerlink" title="相关"></a>相关</h4><p>ID_misspelling<br><br/><br><br/></p>
<h3 id="▌R11-7-常量后缀由应由大写字母组成"><a href="#▌R11-7-常量后缀由应由大写字母组成" class="headerlink" title="▌R11.7 常量后缀由应由大写字母组成"></a><span id="literal_confusingsuffix">▌R11.7 常量后缀由应由大写字母组成</span></h3><p>ID_literal_confusingSuffix&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: literal warning</p>
<hr/>

<p>小写字母“l”极易与数字“1”混淆，为了提高可读性，常量后缀均应由大写字母组成。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">long long a = 100ll;    // Non-compliant, may be misread as 10011</span><br><span class="line">long double b = 100.l;  // Non-compliant, may be misread as 100.1</span><br></pre></td></tr></table></figure>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">long long a = 100LL;    // Compliant</span><br><span class="line">long double b = 100.L;  // Compliant</span><br></pre></td></tr></table></figure>
<p>后缀大小写混用的情况会使人更加困惑：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">long long c = 100lL;            // Non-compliant, very bad</span><br><span class="line">unsigned long long d = 100lLU;  // Non-compliant, very bad</span><br></pre></td></tr></table></figure>
<p>其中，小写的 l 和大写的 L 混在了一起，应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">long long c = 100LL;            // Compliant</span><br><span class="line">unsigned long long d = 100LLU;  // Compliant</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="配置-39"><a href="#配置-39" class="headerlink" title="配置"></a>配置</h4><p>allSuffixCharMustBeUpperCase：要求后缀中所有字符均为大写，或只要求小写字符“l”不得用于后缀<br><br/></p>
<h4 id="参考-329"><a href="#参考-329" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines NL.19<br>MISRA C 2012 7.3<br>MISRA C++ 2008 2-13-4<br><br/><br><br/></p>
<h3 id="▌R11-8-禁用-8-进制常量"><a href="#▌R11-8-禁用-8-进制常量" class="headerlink" title="▌R11.8 禁用 8 进制常量"></a><span id="literal_forbidoct">▌R11.8 禁用 8 进制常量</span></h3><p>ID_literal_forbidOct&emsp;&emsp;&emsp;&emsp;&nbsp;:no_entry: literal suggestion</p>
<hr/>

<p>8 进制不像 10 进制那样符合人们的常规思维，也不像 2 进制或 16 进制那样便于展示数据的存储格式，而且 C/C++ 语言中 8 进制表示法只是在数字前置 0，与十进制过于相似，易被误用。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const int K_0 = 5592;</span><br><span class="line">const int K_1 = 0631;  // Non-compliant</span><br><span class="line">const int K_2 = 3817;</span><br><span class="line">const int K_3 = 4257;</span><br></pre></td></tr></table></figure>
<p>为了格式上的对齐，错误地在 10 进制数前写 0 是常见笔误，例中 k_1 的实际值为 409。<br><br/><br><br/></p>
<h4 id="参考-330"><a href="#参考-330" class="headerlink" title="参考"></a>参考</h4><p>MISRA C 2004 7.1<br>MISRA C 2012 7.1<br>MISRA C++ 2008 2-13-2<br><br/><br><br/></p>
<h3 id="▌R11-9-不应使用非标准常量后缀"><a href="#▌R11-9-不应使用非标准常量后缀" class="headerlink" title="▌R11.9 不应使用非标准常量后缀"></a><span id="literal_nonstandardsuffix">▌R11.9 不应使用非标准常量后缀</span></h3><p>ID_literal_nonStandardSuffix&emsp;&emsp;&emsp;&emsp;&nbsp;:bulb: literal suggestion</p>
<hr/>

<p>整数常量后缀应为 L、LL、UL、ULL，浮点数常量的后缀应为 L、f 或 F，非标准后缀不具备可移植性。  </p>
<p>在 C++ 代码中，用户自定义后缀不受本规则限制。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unsigned int a = 100ui32;  // Non-compliant, not common between compilers</span><br><span class="line">long long b = 100i64;      // Non-compliant</span><br></pre></td></tr></table></figure>
<p>例中 ui32、i64 为 MSVC 编译器特有的后缀，应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unsigned int a = 100U;  // Compliant</span><br><span class="line">long long b = 100LL;    // Compliant</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="相关-206"><a href="#相关-206" class="headerlink" title="相关"></a>相关</h4><p>ID_literal_confusingSuffix<br><br/></p>
<h4 id="依据-182"><a href="#依据-182" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 6.4.4.1(5)<br>ISO/IEC 9899:1999 6.4.4.2(4)<br>ISO/IEC 9899:2011 6.4.4.1(5)<br>ISO/IEC 9899:2011 6.4.4.2(4)<br>ISO/IEC 14882:2003 2.14.2(2)<br>ISO/IEC 14882:2003 2.14.4(1)<br>ISO/IEC 14882:2011 2.14.2(2)<br>ISO/IEC 14882:2011 2.14.4(1)<br>ISO/IEC 14882:2017 5.13.2(2)<br>ISO/IEC 14882:2017 5.13.4(1)<br><br/><br><br/></p>
<h3 id="▌R11-10-小心遗漏逗号导致的非预期字符串连接"><a href="#▌R11-10-小心遗漏逗号导致的非预期字符串连接" class="headerlink" title="▌R11.10 小心遗漏逗号导致的非预期字符串连接"></a><span id="literal_oddconcat">▌R11.10 小心遗漏逗号导致的非预期字符串连接</span></h3><p>ID_literal_oddConcat&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: literal warning</p>
<hr/>

<p>注意可能导致非预期结果的字符串连接，尤其在初始化列表中，小心逗号被遗漏。  </p>
<p>字符串连接的适用场景：  </p>
<ul>
<li>字符串过长不便于显示时可将字符串拆成多个子串分行书写  </li>
<li>宏和字符串连接在一起完成一些更灵活的操作  </li>
</ul>
<p>除此之外不应将一个字符串拆成多个子串。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string strs[] = &#123;</span><br><span class="line">    &quot;123&quot;, &quot;456&quot;, &quot;789&quot;,</span><br><span class="line">    &quot;123&quot;, &quot;456&quot;, &quot;789&quot;   // Rather suspicious, missing a comma?</span><br><span class="line">    &quot;123&quot;, &quot;456&quot;, &quot;789&quot;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>例中初始化列表第 2 行的 “789” 与第 3 行的 “123” 中间没有逗号，会连接成 “789123”，显然是不符合预期的，这种问题属于常见笔误。  </p>
<p>又如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void foo(const char*);</span><br><span class="line">void foo(const char*, const char*);</span><br><span class="line"></span><br><span class="line">void bar() &#123;</span><br><span class="line">    foo(&quot;abc&quot; &quot;123&quot;);  // Rather suspicious, which ‘foo’ is right?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/><br><br/></p>
<h3 id="▌R11-11-不应存在-magic-number"><a href="#▌R11-11-不应存在-magic-number" class="headerlink" title="▌R11.11 不应存在 magic number"></a><span id="literal_magicnumber">▌R11.11 不应存在 magic number</span></h3><p>ID_literal_magicNumber&emsp;&emsp;&emsp;&emsp;&nbsp;:bulb: literal suggestion</p>
<hr/>

<p>直接出现在代码中的字面数值称为 magic number，使人难以理解其含义，不利于阅读和维护，应改用具有适当名称的常量或枚举项。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">double foo(double b) &#123;</span><br><span class="line">    double a = b * 1.618034;   // Non-compliant, 1.618034 is a magic number</span><br><span class="line">    return a * (a + b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double bar(double a) &#123;</span><br><span class="line">    double b = a * 0.618034;   // Non-compliant, 0.618034 is a magic number</span><br><span class="line">    return a * (a + b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中 1.618034 不能表示其含义，而且当这种 magic number 散落在代码的各个角落时，不便于统一管理，造成维护上的困难。  </p>
<p>应改为具有名称的常量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const double goldenRatio = 1.618034;   // Compliant</span><br><span class="line"></span><br><span class="line">double foo(double b) &#123;</span><br><span class="line">    double a = b * goldenRatio;   // Compliant</span><br><span class="line">    return a * (a + b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double bar(double a) &#123;</span><br><span class="line">    double b = a * (goldenRatio - 1);   // Compliant</span><br><span class="line">    return a * (a + b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>常量初始化表达式中的字面数值，以及表示序号起始或简单状态的 0、1 等小字面数值可不受本规则约束。<br><br/><br><br/></p>
<h4 id="相关-207"><a href="#相关-207" class="headerlink" title="相关"></a>相关</h4><p>ID_literal_magicString<br><br/></p>
<h4 id="参考-331"><a href="#参考-331" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines ES.45<br><br/><br><br/></p>
<h3 id="▌R11-12-不应存在-magic-string"><a href="#▌R11-12-不应存在-magic-string" class="headerlink" title="▌R11.12 不应存在 magic string"></a><span id="literal_magicstring">▌R11.12 不应存在 magic string</span></h3><p>ID_literal_magicString&emsp;&emsp;&emsp;&emsp;&nbsp;:bulb: literal suggestion</p>
<hr/>

<p>直接出现在代码中的字面常量字符串称为 magic string，不利于阅读和维护，应改用具有适当名称的常量。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void foo(const string&amp; url)</span><br><span class="line">&#123;</span><br><span class="line">    if (url == &quot;https://foo.net&quot;) &#123;  // Non-compliant</span><br><span class="line">        bar(&quot;https://foo.net&quot;);      // Non-compliant</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当这种常量字符串散落在代码的各个角落时，不便于统一管理，造成维护上的困难。  </p>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const char myUrl[] = &quot;https://foo.net&quot;;  // Compliant</span><br><span class="line"></span><br><span class="line">void foo(const string&amp; url)</span><br><span class="line">&#123;</span><br><span class="line">    if (url == myUrl) &#123;  // Compliant</span><br><span class="line">        bar(myUrl);      // Compliant</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>常量初始化表达式中的常量字符串可不受本规则约束。<br><br/><br><br/></p>
<h4 id="相关-208"><a href="#相关-208" class="headerlink" title="相关"></a>相关</h4><p>ID_literal_magicNumber<br><br/></p>
<h4 id="参考-332"><a href="#参考-332" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines ES.45<br><br/><br><br/></p>
<h3 id="▌R11-13-不应使用多字符常量"><a href="#▌R11-13-不应使用多字符常量" class="headerlink" title="▌R11.13 不应使用多字符常量"></a><span id="literal_multicharacter">▌R11.13 不应使用多字符常量</span></h3><p>ID_literal_multicharacter&emsp;&emsp;&emsp;&emsp;&nbsp;:bulb: literal suggestion</p>
<hr/>

<p>“多字符常量（multi-character literal）”指单引号之间有多个字符或非基本字符的常量，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x27;abc&#x27;  // has type int and implementation-defined value</span><br><span class="line">&#x27;中&#x27;   // has type int and implementation-defined value</span><br><span class="line">L&#x27;文&#x27;  // has type wchar_t and implementation-defined value</span><br></pre></td></tr></table></figure>
<p>这种常量的值是由实现定义的，而且在形式上与字符或字符串常量非常相似，易被误用，故建议禁用。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void foo(int x) &#123;</span><br><span class="line">    if (x == &#x27;tcp&#x27;) &#123;  // Non-compliant</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">    else if (x == &#x27;udp&#x27;) &#123;  // Non-compliant</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中 ‘tcp’、’udp’ 为多字符常量，在 C 代码中应改用 enum，在 C++ 代码中应改用 enum class 实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">enum class PROT &#123; tcp, udp &#125;;</span><br><span class="line"></span><br><span class="line">void foo(PROT x) &#123;</span><br><span class="line">    if (x == PROT::tcp) &#123;  // Compliant</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">    else if (x == PROT::udp) &#123;  // Compliant</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="相关-209"><a href="#相关-209" class="headerlink" title="相关"></a>相关</h4><p>ID_literal_suspiciousChar<br><br/></p>
<h4 id="依据-183"><a href="#依据-183" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 6.4.4.4(10)-implementation<br>ISO/IEC 9899:2011 6.4.4.4(10)-implementation<br>ISO/IEC 14882:2011 2.13.2(1)-implementation<br>ISO/IEC 14882:2011 2.14.3(1)-implementation<br>ISO/IEC 14882:2017 5.13.3(2)-implementation<br><br/><br><br/></p>
<h2 id="12-Cast"><a href="#12-Cast" class="headerlink" title="12. Cast"></a><span id="cast">12. Cast</span></h2><h3 id="▌R12-1-避免类型转换造成数据丢失"><a href="#▌R12-1-避免类型转换造成数据丢失" class="headerlink" title="▌R12.1 避免类型转换造成数据丢失"></a><span id="narrowcast">▌R12.1 避免类型转换造成数据丢失</span></h3><p>ID_narrowCast&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: cast warning</p>
<hr/>

<p>应避免取值范围大的类型向取值范围小的类型隐式转换，相关显式转换也应在合理的条件下完成。  </p>
<p>如果对象的值在新类型取值范围内，但无法用新类型精确表示，转换由实现定义；如果对象的值超出了新类型的取值范围，会导致数据丢失以及由实现定义或未定义的行为。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int i;</span><br><span class="line">double d;</span><br><span class="line">....</span><br><span class="line">short s = i;  // Non-compliant, may cause data loss</span><br><span class="line">long l = d;   // Non-compliant, may cause undefined behavior</span><br><span class="line">float f = d;  // Non-compliant, may cause undefined behavior</span><br></pre></td></tr></table></figure>
<p>将整数类型转为取值范围更小的整数类型会造成数据丢失，将浮点类型转为整数类型或取值范围更小的浮点类型，则可导致由实现定义或未定义的行为，所以应在转换前判断是否可以安全转换，或实现特定的转换逻辑。  </p>
<p>下面给出判断转换是否安全的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class To, class From&gt;</span><br><span class="line">struct Checker &#123;</span><br><span class="line">    static To cast(From x) &#123;</span><br><span class="line">        auto y = static_cast&lt;To&gt;(x);</span><br><span class="line">        auto z = static_cast&lt;From&gt;(y);</span><br><span class="line">        return x == z? y: throw DataLoss();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;class To, class From&gt;</span><br><span class="line">To checked_cast(From x) &#123;</span><br><span class="line">    return Checker&lt;To, From&gt;::cast(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数 checked_cast 委托类 Checker 将源类型转为目标类型，再将目标类型转回源类型，如果经两次转换得到的值与转换前的值不符，说明转换存在数据丢失，抛出异常。  </p>
<p>浮点型转换可能导致未定义的行为，所以应在转换之前判断取值范围，可通过特化 Checker 实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">template &lt;&gt; struct Checker&lt;long, double&gt; &#123;</span><br><span class="line">    static bool check(double x) &#123;</span><br><span class="line">        return !isgreater(x, LONG_MAX) &amp;&amp; !isless(x, LONG_MIN);</span><br><span class="line">    &#125;</span><br><span class="line">    static long cast(double x) &#123;</span><br><span class="line">        return check(x)? static_cast&lt;long&gt;(x): throw DataLoss();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;&gt; struct Checker&lt;float, double&gt; &#123;</span><br><span class="line">    static bool check(double x) &#123;</span><br><span class="line">        return !isgreater(fabs(x), FLT_MAX) &amp;&amp; !isless(fabs(x), FLT_MIN);</span><br><span class="line">    &#125;</span><br><span class="line">    static float cast(double x) &#123;</span><br><span class="line">        return check(x)? static_cast&lt;float&gt;(x): throw DataLoss();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这样当 double 对象的值超出 long 或 float 对象的取值范围时会抛出异常。另外，浮点类型转整数类型时小数部分如何取舍、负数是否可以转为无符号数等问题均可以根据实际需求通过特化 Checker 来实现。  </p>
<p>函数 checked_cast 的用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int i;</span><br><span class="line">double d;</span><br><span class="line">....</span><br><span class="line">short s = checked_cast&lt;short&gt;(i);  // Compliant</span><br><span class="line">long l = checked_cast&lt;long&gt;(d);    // Compliant</span><br><span class="line">float f = checked_cast&lt;float&gt;(d);  // Compliant</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="依据-184"><a href="#依据-184" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 6.3.1.4(1)-undefined<br>ISO/IEC 9899:1999 6.3.1.5(2)-undefined<br>ISO/IEC 9899:2011 6.3.1.4(1)-undefined<br>ISO/IEC 9899:2011 6.3.1.5(1)-undefined<br>ISO/IEC 14882:2003 4.8(1)-undefined<br>ISO/IEC 14882:2003 4.9(1)-undefined<br>ISO/IEC 14882:2011 4.8(1)-undefined<br>ISO/IEC 14882:2011 4.9(1 2)-undefined<br><br/></p>
<h4 id="参考-333"><a href="#参考-333" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines ES.46<br>MISRA C 2012 10.3<br>MISRA C 2012 10.5<br>MISRA C++ 2008 5-0-5<br>MISRA C++ 2008 5-0-6<br>SEI CERT FLP34-C<br><br/><br><br/></p>
<h3 id="▌R12-2-避免数据丢失造成类型转换失效"><a href="#▌R12-2-避免数据丢失造成类型转换失效" class="headerlink" title="▌R12.2 避免数据丢失造成类型转换失效"></a><span id="invalidpromotion">▌R12.2 避免数据丢失造成类型转换失效</span></h3><p>ID_invalidPromotion&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: cast warning</p>
<hr/>

<p>下列表达式的类型不应被隐式或显式地转为取值范围更大的类型：  </p>
<ul>
<li>二元算术表达式  </li>
<li>以二元算术表达式为分枝的三元表达式  </li>
</ul>
<p>这种表达式的溢出或精度损失会发生在类型转换之前，使类型转换失效。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void foo(int32_t a, int32_t b)</span><br><span class="line">&#123;</span><br><span class="line">    int64_t i = a * b;            // Non-compliant</span><br><span class="line">    int64_t j = int64_t(a + b);   // Non-compliant</span><br><span class="line"></span><br><span class="line">    double x = a / b;             // Non-compliant</span><br><span class="line">    double y = double(a / b);     // Non-compliant</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中表达式 a * b、a + b 的类型为 32 位整型，如果溢出则无法正确转为 64 位整型；a / b 的结果仍是整数，小数部分将丢失。  </p>
<p>应将操作数转为目标类型，使算术表达式与被赋值的对象具有相同的类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void foo(int32_t a, int32_t b)</span><br><span class="line">&#123;</span><br><span class="line">    int64_t i = int64_t(a) * b;   // Compliant</span><br><span class="line">    int64_t j = a + int64_t(b);   // Compliant</span><br><span class="line"></span><br><span class="line">    double x = double(a) / b;     // Compliant</span><br><span class="line">    double y = a / double(b);     // Compliant</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样便可避免类型转换失效。<br><br/><br><br/></p>
<h4 id="相关-210"><a href="#相关-210" class="headerlink" title="相关"></a>相关</h4><p>ID_evalOverflow<br><br/></p>
<h4 id="参考-334"><a href="#参考-334" class="headerlink" title="参考"></a>参考</h4><p>MISRA C 2012 10.6<br>MISRA C 2012 10.7<br>MISRA C 2012 10.8<br>MISRA C++ 2008 5-0-3<br>MISRA C++ 2008 5-0-7<br>MISRA C++ 2008 5-0-8<br><br/><br><br/></p>
<h3 id="▌R12-3-避免有符号整型与无符号整型相互转换"><a href="#▌R12-3-避免有符号整型与无符号整型相互转换" class="headerlink" title="▌R12.3 避免有符号整型与无符号整型相互转换"></a><span id="signchangecast">▌R12.3 避免有符号整型与无符号整型相互转换</span></h3><p>ID_signChangeCast&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: cast warning</p>
<hr/>

<p>有符号整型与无符号整型相互转换易导致意料之外的错误。  </p>
<p>整型转换规则：  </p>
<ul>
<li>如果向布尔型以外的其他整数类型转换，且值在新类型取值范围内，值不变  </li>
<li>否则，如果新类型为无符号整型，将值不断加减 M + 1 直至进入新类型取值范围，M 为新类型最大值  </li>
<li>否则，如果新类型为有符号整型，相关转换由实现定义  </li>
</ul>
<p>负数转为无符号整数往往会得到意料之外的结果，无符号整数转为有符号整数也可能导致移植相关的问题，所以应避免有符号整型与无符号整型之间的隐式转换，相关显式转换也应在合理的条件下完成。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">signed s = -1;</span><br><span class="line">unsigned u = 1;</span><br><span class="line">printf(&quot;%d\n&quot;, s &lt; u);   // Non-compliant</span><br></pre></td></tr></table></figure>
<p>例中有符号整数 s 的值为 -1，无符号整数 u 的值为 1，s 理应小于 u，但由于“<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/c/language/conversion#Integer_promotions">类型提升</a>”，s 会被转为无符号整数，值为无符号整数的最大值，s &lt; u 的实际结果为 0。<br><br/><br><br/></p>
<h4 id="依据-185"><a href="#依据-185" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 6.3.1.3<br>ISO/IEC 9899:2011 6.3.1.3<br><br/></p>
<h4 id="参考-335"><a href="#参考-335" class="headerlink" title="参考"></a>参考</h4><p>MISRA C++ 2008 5-0-4<br>SEI CERT INT02-C<br><br/><br><br/></p>
<h3 id="▌R12-4-避免与-void-相互转换"><a href="#▌R12-4-避免与-void-相互转换" class="headerlink" title="▌R12.4 避免与 void* 相互转换"></a><span id="voidcast">▌R12.4 避免与 void* 相互转换</span></h3><p>ID_voidCast&emsp;&emsp;&emsp;&emsp;&nbsp;:bulb: cast suggestion</p>
<hr/>

<p>与 void* 相互转换会打破类型限制，是不安全的类型转换。  </p>
<p>C 语言的某些传统接口会使用 void*，可不受本规则限制，但在 C++ 代码中应避与 void* 相互转换。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct A &#123; .... &#125;;</span><br><span class="line"></span><br><span class="line">void foo(void* v) &#123;</span><br><span class="line">    A* a = (A*)v;     // Non-compliant</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中参数 v 可以随意接受非 A 对象的指针，进而导致标准未定义的行为，代码的正确性单方面依赖开发者是不可靠的。<br><br/><br><br/></p>
<h4 id="相关-211"><a href="#相关-211" class="headerlink" title="相关"></a>相关</h4><p>ID_forbidMemberVoidPtr<br>ID_forbidFunctionVoidPtr<br><br/></p>
<h4 id="依据-186"><a href="#依据-186" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 14882:2003 5.2.10(7)-unspecified<br>ISO/IEC 14882:2011 5.2.10(7)-unspecified<br><br/></p>
<h4 id="参考-336"><a href="#参考-336" class="headerlink" title="参考"></a>参考</h4><p>MISRA C 2012 11.5<br>MISRA C 2012 11.6<br>MISRA C++ 2008 5-2-8<br><br/><br><br/></p>
<h3 id="▌R12-5-避免向下类型转换"><a href="#▌R12-5-避免向下类型转换" class="headerlink" title="▌R12.5 避免向下类型转换"></a><span id="downcast">▌R12.5 避免向下类型转换</span></h3><p>ID_downCast&emsp;&emsp;&emsp;&emsp;&nbsp;:bulb: cast suggestion</p>
<hr/>

<p>从基类到派生类的向下类型转换往往意味着现有接口已经不能满足需求，故应避免这种转换。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class A &#123; .... &#125;;</span><br><span class="line"></span><br><span class="line">class B: public A &#123;</span><br><span class="line">public:</span><br><span class="line">    void bar();   // A new function</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void foo(A* a) &#123;</span><br><span class="line">    if (B* p = dynamic_cast&lt;B*&gt;(a)) &#123;   // Bad, down cast</span><br><span class="line">        p-&gt;bar();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中 foo 接口对基类参数进行向下类型转换是不利于维护的，当这种特殊处理较多时，应利用多态方法合理重构。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    ....</span><br><span class="line">public:</span><br><span class="line">    virtual void bar();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class B: public A &#123;</span><br><span class="line">public:</span><br><span class="line">    void bar() override;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void foo(A* a) &#123;</span><br><span class="line">    if (a) &#123;</span><br><span class="line">        a-&gt;bar();   // Good</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="相关-212"><a href="#相关-212" class="headerlink" title="相关"></a>相关</h4><p>ID_nonDynamicDownCast<br>ID_narrowCast<br><br/></p>
<h4 id="参考-337"><a href="#参考-337" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines ES.48<br><br/><br><br/></p>
<h3 id="▌R12-6-指针与整数不应相互转换"><a href="#▌R12-6-指针与整数不应相互转换" class="headerlink" title="▌R12.6 指针与整数不应相互转换"></a><span id="ptrintcast">▌R12.6 指针与整数不应相互转换</span></h3><p>ID_ptrIntCast&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: cast warning</p>
<hr/>

<p>指针与整数相互转换容易造成地址不完整、寻址错误、降低可移植性等多种问题。  </p>
<p>指针与整数的转换由实现定义，整数的符号和取值范围可能与指针有冲突，错误的值转为指针也会导致标准未定义的行为。在某些平台上指针与 size_t 可以安全转换，但不具备可移植性，审计工具不妨通过配置决定是否放过这种转换。C 标准规定指针可以转为 intptr_t 或 uintptr_t，但也声明了这些类型不是编译器必须实现的类型。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void foo(int* p) &#123;</span><br><span class="line">    vector&lt;int&gt; v;</span><br><span class="line">    v.emplace_back((int)p);  // Non-compliant</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中将指针转为 int 是不符合要求的，指针的值可能会超过 int 的范围。<br><br/><br><br/></p>
<h4 id="配置-40"><a href="#配置-40" class="headerlink" title="配置"></a>配置</h4><p>allowPointerToSizeType：是否放过指针与 size_t 的转换<br><br/></p>
<h4 id="相关-213"><a href="#相关-213" class="headerlink" title="相关"></a>相关</h4><p>ID_fixedAddrToPointer<br><br/></p>
<h4 id="依据-187"><a href="#依据-187" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 6.3.2.3(5)-implementation<br>ISO/IEC 9899:1999 7.18.1.4(1)<br>ISO/IEC 9899:2011 6.3.2.3(5)-implementation<br>ISO/IEC 9899:2011 7.20.1.4(1)<br>ISO/IEC 14882:2003 5.2.10(4 5)-implementation<br>ISO/IEC 14882:2011 3.7.4.3(1)<br>ISO/IEC 14882:2011 5.2.10(4 5)-implementation<br><br/></p>
<h4 id="参考-338"><a href="#参考-338" class="headerlink" title="参考"></a>参考</h4><p>MISRA C 2004 11.3<br>MISRA C 2012 11.4<br>MISRA C++ 2008 5-2-9<br>SEI CERT INT36-C<br><br/><br><br/></p>
<h3 id="▌R12-7-类型转换不应去掉-const、volatile-等属性"><a href="#▌R12-7-类型转换不应去掉-const、volatile-等属性" class="headerlink" title="▌R12.7 类型转换不应去掉 const、volatile 等属性"></a><span id="qualifiercastedaway">▌R12.7 类型转换不应去掉 const、volatile 等属性</span></h3><p>ID_qualifierCastedAway&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: cast warning</p>
<hr/>

<p>去掉 const、volatile 等属性会使相关机制失去意义，往往意味着设计上的缺陷，也会导致标准未定义的行为。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const int c = 1;</span><br><span class="line">volatile int v = 2;</span><br><span class="line"></span><br><span class="line">*(int*)&amp;c = 3;   // Non-compliant, undefined behavior</span><br><span class="line">*(int*)&amp;v = 4;   // Non-compliant, undefined behavior</span><br></pre></td></tr></table></figure>
<p>通过去掉 const 或 volatile 的转换修改相关对象会导致标准未定义的行为。  </p>
<p>又如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct A &#123;</span><br><span class="line">    void foo() const &#123;</span><br><span class="line">        const_cast&lt;A*&gt;(this)-&gt;n++;   // Non-compliant</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    int n = 0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>例中 foo 为常量成员函数，用 const_cast 去掉 this 指针的 const 限定是不符合要求的。  </p>
<p>如果成员的改变只起辅助作用而不影响对象状态，可将成员设为 mutable，否则应重新设计类，如： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct A &#123;</span><br><span class="line">    void foo() const &#123;</span><br><span class="line">        n++;             // OK</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    mutable int n = 0;   // Can be modified by const member functions</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="依据-188"><a href="#依据-188" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 6.7.3(5)-undefined<br>ISO/IEC 9899:2011 6.7.3(6)-undefined<br>ISO/IEC 14882:2003 7.1.5.1(4 7)-undefined<br>ISO/IEC 14882:2011 7.1.6.1(4 6)-undefined<br><br/></p>
<h4 id="参考-339"><a href="#参考-339" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines Type.3<br>MISRA C 2004 11.5<br>MISRA C 2012 11.8<br>MISRA C++ 2008 5-2-5<br>SEI CERT EXP32-C<br>SEI CERT EXP55-CPP<br><br/><br><br/></p>
<h3 id="▌R12-8-不应转换无继承关系的指针或引用"><a href="#▌R12-8-不应转换无继承关系的指针或引用" class="headerlink" title="▌R12.8 不应转换无继承关系的指针或引用"></a><span id="castnoinheritance">▌R12.8 不应转换无继承关系的指针或引用</span></h3><p>ID_castNoInheritance&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: cast warning</p>
<hr/>

<p>无继承关系的指针或引用之间没有逻辑关系，转换意味着设计缺陷或逻辑错误。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">float f = 0;</span><br><span class="line">int* p = (int*)&amp;f;  // Non-compliant</span><br><span class="line">(*p)++;             // Undefined behavior</span><br></pre></td></tr></table></figure>
<p>基本类型之间没有继承关系，float* 转为 int* 属于逻辑错误，导致标准未定义的行为。  </p>
<p>有时为了考察对象内部结构，需要将对象指针转为 unsigned char* 等类型，但这种转换脱离了类型的保护，也会降低代码的可移植性，审计工具不妨通过配置决定是否放过这种转换。  </p>
<p>又如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class A &#123; .... &#125;;</span><br><span class="line">class B &#123; .... &#125;;</span><br><span class="line">class C: public A, public B &#123; .... &#125;;</span><br><span class="line"></span><br><span class="line">A* a = new C;</span><br><span class="line"></span><br><span class="line">B* b0 = (B*)a;                    // Non-compliant</span><br><span class="line">B* b1 = reinterpret_cast&lt;B*&gt;(a);  // Non-compliant</span><br><span class="line"></span><br><span class="line">B* b2 = static_cast&lt;B*&gt;(a);       // Compliant, compile-time protected</span><br><span class="line">B* b3 = dynamic_cast&lt;B*&gt;(a);      // Compliant, run-time protected</span><br></pre></td></tr></table></figure>
<p>例中 A 与 B 没有继承关系，C 从 A 和 B 继承，指针 a 为 A 类型但实际指向 C 的实例，这种情况下将 a 直接强制转为 B 类型的指针将得到错误的结果，这种问题在实际代码中也很常见。  </p>
<p>本规则限制无继承关系的 C 风格类型转换以及 reinterpret_cast 转换，不限制 static_cast 和 dynamic_cast 转换，示例中的 static_cast 转换将得到编译错误从而锁定问题，如果 A 和 B 是多态类型，用 dynamic_cast 会得到正确的结果。  </p>
<p>例外：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class V &#123; .... &#125;;</span><br><span class="line"></span><br><span class="line">class U &#123;</span><br><span class="line">    ....</span><br><span class="line">public:</span><br><span class="line">    operator V*();   // Conversion operator</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">U* u = new U;</span><br><span class="line"></span><br><span class="line">V* v0 = (V*)u;                     // Compliant, but bad</span><br><span class="line">V* v1 = reinterpret_cast&lt;V*&gt;(u);   // Still non-compliant</span><br></pre></td></tr></table></figure>
<p>例中 U 和 V 是无继承关系的类，但 U 实现了向 V 的转换运算符，U 和 V 之间存在逻辑关系，这时的 C 风格类型转换可不受本规则限制，但不符合规则 ID_forbidCStyleCast，这种情况仍然不能使用 reinterpret_cast，参见 ID_unsuitableReinterpretCast。<br><br/><br><br/></p>
<h4 id="配置-41"><a href="#配置-41" class="headerlink" title="配置"></a>配置</h4><p>allowWeakerCast：是否放过与 unsigned char* 的转换<br><br/></p>
<h4 id="相关-214"><a href="#相关-214" class="headerlink" title="相关"></a>相关</h4><p>ID_stricterAlignedCast<br>ID_castNonPublicInheritance<br><br/></p>
<h4 id="依据-189"><a href="#依据-189" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 6.5(7)-undefined<br>ISO/IEC 9899:2011 6.5(7)-undefined<br>ISO/IEC 14882:2003 3.10(15)-undefined<br>ISO/IEC 14882:2003 4.1(1)-undefined<br>ISO/IEC 14882:2011 3.10(10)-undefined<br>ISO/IEC 14882:2011 4.1(1)-undefined<br><br/></p>
<h4 id="参考-340"><a href="#参考-340" class="headerlink" title="参考"></a>参考</h4><p>MISRA C 2012 11.3<br>MISRA C++ 2008 5-2-7<br>SEI CERT EXP39-C<br><br/><br><br/></p>
<h3 id="▌R12-9-不应转换无-public-继承关系的指针或引用"><a href="#▌R12-9-不应转换无-public-继承关系的指针或引用" class="headerlink" title="▌R12.9 不应转换无 public 继承关系的指针或引用"></a><span id="castnonpublicinheritance">▌R12.9 不应转换无 public 继承关系的指针或引用</span></h3><p>ID_castNonPublicInheritance&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: cast warning</p>
<hr/>

<p>public 继承表示派生类是基类的某种扩展，而非 public 继承往往表示派生类是基类的某种例外，基类的方法不再适用于派生类的对象。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class A &#123; .... &#125;;</span><br><span class="line">class B: private A &#123; .... &#125;;</span><br><span class="line"></span><br><span class="line">void bar(A* a);</span><br><span class="line"></span><br><span class="line">void foo(B* b) &#123;</span><br><span class="line">    bar((A*)b);    // Non-compliant</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中派生类 B 是对基类 A 的改造，再用 A 类方法处理 B 类对象是有问题的。<br><br/><br><br/></p>
<h4 id="相关-215"><a href="#相关-215" class="headerlink" title="相关"></a>相关</h4><p>ID_castNoInheritance<br><br/></p>
<h4 id="依据-190"><a href="#依据-190" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 14882:2003 4.10(3)<br>ISO/IEC 14882:2011 4.10(3)<br><br/><br><br/></p>
<h3 id="▌R12-10-非-POD-类的指针与基本类型的指针不应相互转换"><a href="#▌R12-10-非-POD-类的指针与基本类型的指针不应相互转换" class="headerlink" title="▌R12.10 非 POD 类的指针与基本类型的指针不应相互转换"></a><span id="nonpodbinarycast">▌R12.10 非 POD 类的指针与基本类型的指针不应相互转换</span></h3><p>ID_nonPODBinaryCast&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: cast warning</p>
<hr/>

<p>非“<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/named_req/PODType">POD</a>”对象相关数据之间存在特殊的内在关系，尤其是虚函数表指针、虚基类表指针这种由实现定义的运行时数据，不应当作普通二进制数据处理，非 POD 对象的指针也不应与 void*、unsigned char* 等基本类型的指针相互转换。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    ....</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    virtual ~A() = 0;</span><br><span class="line"></span><br><span class="line">    void save() const &#123;</span><br><span class="line">        FILE* fp = fopen(&quot;dat&quot;, &quot;wb&quot;);</span><br><span class="line">        fwrite(this, sizeof(A), 1, fp);   // Non-compliant</span><br><span class="line">        fclose(fp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void load() &#123;</span><br><span class="line">        FILE* fp = fopen(&quot;dat&quot;, &quot;rb&quot;);</span><br><span class="line">        fread(this, sizeof(A), 1, fp);    // Non-compliant</span><br><span class="line">        fclose(fp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>例中 A 是多态类型，save 函数将对象写入文件，fwrite 的第一个参数 this 被隐式转为 void*，不符合本规则要求。对象的虚表指针等数据一并被写入文件，但虚表指针是运行时数据不应被保存，load 函数从文件中读取对象便破坏了运行时数据。<br><br/><br><br/></p>
<h4 id="相关-216"><a href="#相关-216" class="headerlink" title="相关"></a>相关</h4><p>ID_nonPODFilling<br><br/></p>
<h4 id="参考-341"><a href="#参考-341" class="headerlink" title="参考"></a>参考</h4><p>CWE-843<br><br/><br><br/></p>
<h3 id="▌R12-11-不同的字符串类型之间不可直接转换"><a href="#▌R12-11-不同的字符串类型之间不可直接转换" class="headerlink" title="▌R12.11 不同的字符串类型之间不可直接转换"></a><span id="charwcharcast">▌R12.11 不同的字符串类型之间不可直接转换</span></h3><p>ID_charWCharCast&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: cast warning</p>
<hr/>

<p>char* 和 wchar_t* 直接转换并不进行字符集转换，属于语言运用错误，char*、wchar_t*、char16_t* 以及 char32_t* 之间均不可直接转换。  </p>
<p>本规则是 ID_castNoInheritance 的特化。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wchar_t* to_unicode(char* str) &#123;</span><br><span class="line">    return (wchar_t*)str;          // Remarkably brave, but totally wrong</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例代码显然是错误的，应改用 iconv、MultiByteToWideChar 等字符集编码转换函数。  </p>
<p>由于 unsigned char* 一般针对二进制数据，unsigned char* 与其他字符串类型之间的转换可不受本规则约束，但 char* 不应作为二进制数据的类型，参见 ID_plainBinaryChar。<br><br/><br><br/></p>
<h4 id="相关-217"><a href="#相关-217" class="headerlink" title="相关"></a>相关</h4><p>ID_castNoInheritance<br>ID_plainBinaryChar<br><br/></p>
<h4 id="参考-342"><a href="#参考-342" class="headerlink" title="参考"></a>参考</h4><p>CWE-704<br>SEI CERT STR38-C<br><br/><br><br/></p>
<h3 id="▌R12-12-避免向对齐要求更严格的指针转换"><a href="#▌R12-12-避免向对齐要求更严格的指针转换" class="headerlink" title="▌R12.12 避免向对齐要求更严格的指针转换"></a><span id="stricteralignedcast">▌R12.12 避免向对齐要求更严格的指针转换</span></h3><p>ID_stricterAlignedCast&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: cast warning</p>
<hr/>

<p>访问不符合对齐要求的数据会导致标准未定义的行为。  </p>
<p>对象的存储地址与其占用空间的长度相关，如变量的地址往往是其长度的整数倍，这种机制称为“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Data_structure_alignment">内存对齐</a>”，可提高处理器访问数据的效率，如果对象的地址不符合这种要求，访问对象的效率就会降低，在某些平台上甚至会崩溃，详见“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Bus_error#Unaligned_access">unaligned access</a>”。  </p>
<p>每种对象类型都有一个“<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/c/language/object#Alignment">对齐要求（alignment requirement）</a>”，一般来说占用空间越大的类型，对齐要求越严格，如 char 对象可以存储在任意地址，而 int 对象的地址只应是 sizeof(int) 的整数倍，所以解引用由 char 指针转换成的 int 指针很可能会造成“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Bus_error#Unaligned_access">unaligned access</a>”。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void foo(unsigned char* p) &#123;</span><br><span class="line">    char c = *(char*)p;            // Compliant</span><br><span class="line">    long n = *(long*)(p + 1);      // Non-compliant</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>二进制数据转向结构化数据时，这种问题较为常见，例中 p + 1 与 long 型变量的对齐要求不同，不应直接转换。  </p>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void foo(unsigned char* p) &#123;</span><br><span class="line">    char c = *(char*)p;            // Compliant</span><br><span class="line">    long n;</span><br><span class="line">    memcpy(&amp;n, p + 1, sizeof(n));  // Compliant</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用 memcpy 等函数将低对齐要求的数据复制到高对齐要求的对象中，是避免相关问题的通用模式。<br><br/><br><br/></p>
<h4 id="相关-218"><a href="#相关-218" class="headerlink" title="相关"></a>相关</h4><p>ID_castNoInheritance<br><br/></p>
<h4 id="依据-191"><a href="#依据-191" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 6.3.2.3(7)-undefined<br>ISO/IEC 9899:2011 6.3.2.3(7)-undefined<br><br/></p>
<h4 id="参考-343"><a href="#参考-343" class="headerlink" title="参考"></a>参考</h4><p>SEI CERT EXP36-C<br><br/><br><br/></p>
<h3 id="▌R12-13-避免转换指向数组的指针"><a href="#▌R12-13-避免转换指向数组的指针" class="headerlink" title="▌R12.13 避免转换指向数组的指针"></a><span id="arraypointercast">▌R12.13 避免转换指向数组的指针</span></h3><p>ID_arrayPointerCast&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: cast warning</p>
<hr/>

<p>指针的逻辑大小与类型相关，转换指向数组的指针极易造成元素定位、空间计算等方面的错误。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct A &#123; int x; &#125;;</span><br><span class="line">struct B: A &#123; int y; &#125;;</span><br><span class="line"></span><br><span class="line">void foo(A* p, int n) &#123;</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        p[i].x = 1; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void bar() &#123;</span><br><span class="line">    B arr[100];</span><br><span class="line">    foo(arr, 100);   // Non-compliant</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中派生类对象的数组被转换成了基类指针，foo 函数中对数组元素的定位将是错误的。  </p>
<p>另外，在回收动态分配的数组时，如果指针的类型与实际元素的类型不一致，会导致标准未定义的行为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A* p = new B[100];   // Non-compliant</span><br><span class="line">delete[] p;          // Undefined behavior</span><br></pre></td></tr></table></figure>
<p>这是一个危险的问题，本规则针对所有数组相关的隐式和显式类型转换。<br><br/><br><br/></p>
<h4 id="依据-192"><a href="#依据-192" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 14882:2003 5.3.5(3)-undefined<br>ISO/IEC 14882:2011 5.3.5(3)-undefined<br><br/></p>
<h4 id="参考-344"><a href="#参考-344" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines C.152<br><br/><br><br/></p>
<h3 id="▌R12-14-避免转换函数指针"><a href="#▌R12-14-避免转换函数指针" class="headerlink" title="▌R12.14 避免转换函数指针"></a><span id="functionpointercast">▌R12.14 避免转换函数指针</span></h3><p>ID_functionPointerCast&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: cast warning</p>
<hr/>

<p>函数指针和不兼容的类型转换会导致标准未定义的行为。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void foo();</span><br><span class="line">typedef void (*fnp_t)(int);</span><br><span class="line"></span><br><span class="line">void* p0 = (void*)&amp;foo;    // Non-compliant</span><br><span class="line">fnp_t p1 = (fnp_t)&amp;foo;    // Non-compliant</span><br><span class="line"></span><br><span class="line">p1(123);                   // Undefined behavior</span><br></pre></td></tr></table></figure>
<p>例外：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fnp_t p = NULL;            // Compliant</span><br><span class="line"></span><br><span class="line">(void)p;                   // Let it go</span><br><span class="line">p = (fnp_t)dlsym(h, &quot;f&quot;);  // Let it go</span><br></pre></td></tr></table></figure>
<p>对函数指针进行 void 转换，或 dlsym、GetProcAddress 等动态导入函数的系统接口可不受本规则约束。<br><br/><br><br/></p>
<h4 id="依据-193"><a href="#依据-193" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 6.3.2.3(6 7 8)-undefined<br>ISO/IEC 9899:1999 6.5.2.2(9)-undefined<br>ISO/IEC 9899:2011 6.3.2.3(6 7 8)-undefined<br>ISO/IEC 9899:2011 6.5.2.2(9)-undefined<br>ISO/IEC 14882:2003 5.2.10(6)-undefined<br>ISO/IEC 14882:2011 5.2.10(6)-undefined<br>ISO/IEC 14882:2011 5.2.10(8)-implementation<br><br/></p>
<h4 id="参考-345"><a href="#参考-345" class="headerlink" title="参考"></a>参考</h4><p>MISRA C 2004 11.1<br>MISRA C 2012 11.1<br>MISRA C++ 2008 5-2-6<br><br/><br><br/></p>
<h3 id="▌R12-15-向下动态类型转换应使用-dynamic-cast"><a href="#▌R12-15-向下动态类型转换应使用-dynamic-cast" class="headerlink" title="▌R12.15 向下动态类型转换应使用 dynamic_cast"></a><span id="nondynamicdowncast">▌R12.15 向下动态类型转换应使用 dynamic_cast</span></h3><p>ID_nonDynamicDownCast&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: cast warning</p>
<hr/>

<p>向下动态类型转换应使用 dynamic_cast 以保证安全性。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class A &#123; .... &#125;;</span><br><span class="line">class B: public A &#123; .... &#125;;   // A and B are polymorphic classes</span><br><span class="line"></span><br><span class="line">void foo(A* a)</span><br><span class="line">&#123;</span><br><span class="line">    B* b0 = (B*)a;                     // Non-compliant</span><br><span class="line">    B* b1 = static_cast&lt;B*&gt;(a);        // Non-compliant</span><br><span class="line">    B* b2 = reinterpret_cast&lt;B*&gt;(a);   // Non-compliant</span><br><span class="line">    B* b3 = dynamic_cast&lt;B*&gt;(a);       // Compliant</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 a 实际指向的不是 B 类对象，使用 dynamic_cast 会得到一个空值便于进一步处理，其他方式的转换会得到无法判断对错的结果。  </p>
<p>注意，虚基类指针只能通过 dynamic_cast 转换为派生类指针，否则导致标准未定义的行为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class A &#123; .... &#125;;</span><br><span class="line">class B: virtual A &#123; .... &#125;;</span><br><span class="line">class C: virtual A &#123; .... &#125;;</span><br><span class="line">class D: B, C &#123; .... &#125;;</span><br><span class="line"></span><br><span class="line">void foo(A* a) &#123;</span><br><span class="line">    D* d0 = (D*)a;                 // Undefined behavior</span><br><span class="line">    D* d1 = dynamic_cast&lt;D*&gt;(a);   // Right</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应尽量减少向下类型转换，参见 ID_downCast。<br><br/><br><br/></p>
<h4 id="相关-219"><a href="#相关-219" class="headerlink" title="相关"></a>相关</h4><p>ID_downCast<br><br/></p>
<h4 id="依据-194"><a href="#依据-194" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 14882:2003 5.2.7<br>ISO/IEC 14882:2003 5.2.9(5 8)-undefined<br>ISO/IEC 14882:2011 5.2.7<br>ISO/IEC 14882:2011 5.2.9(11 12)-undefined<br><br/></p>
<h4 id="参考-346"><a href="#参考-346" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines Type.2<br>MISRA C++ 2008 5-2-2<br><br/><br><br/></p>
<h3 id="▌R12-16-对-new-表达式不应进行类型转换"><a href="#▌R12-16-对-new-表达式不应进行类型转换" class="headerlink" title="▌R12.16 对 new 表达式不应进行类型转换"></a><span id="oddnewcast">▌R12.16 对 new 表达式不应进行类型转换</span></h3><p>ID_oddNewCast&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: cast warning</p>
<hr/>

<p>new 表达式本身是类型明确的，转换 new 表达式的类型也容易造成分配、访问或回收相关的错误。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int* p = (int*)new char[123];  // Non-compliant</span><br><span class="line">....</span><br><span class="line">delete[] p;  // What will happen?</span><br></pre></td></tr></table></figure>
<p>例中 char 数组被转为 int 数组，由于元素个数不兼容也会导致内存访问与回收的错误。<br><br/><br><br/></p>
<h4 id="相关-220"><a href="#相关-220" class="headerlink" title="相关"></a>相关</h4><p>ID_arrayPointerCast<br><br/><br><br/></p>
<h3 id="▌R12-17-不应存在多余的类型转换"><a href="#▌R12-17-不应存在多余的类型转换" class="headerlink" title="▌R12.17 不应存在多余的类型转换"></a><span id="redundantcast">▌R12.17 不应存在多余的类型转换</span></h3><p>ID_redundantCast&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: cast warning</p>
<hr/>

<p>多余的类型转换是没有意义的，往往意味着某种错误。  </p>
<p>不应出现下列情况：  </p>
<ul>
<li>原类型与转换后的类型完全相同  </li>
<li>非 void 转换的结果没有被读取  </li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">float foo(int x) &#123;</span><br><span class="line">    return (int)x;   // Non-compliant</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">float bar(int y) &#123;</span><br><span class="line">    (float)y;        // Non-compliant</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中参数 x 转换后的类型与转换前完全相同，参数 y 转换后没有被读取，均不符合要求。  </p>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">float foo(int x) &#123;</span><br><span class="line">    return (float)x;   // Compliant</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">float bar(int y) &#123;</span><br><span class="line">    return (float)y;   // Compliant</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可用 void 转换表示有意放弃读取，但对无返回值的函数不应再使用 void 转换，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">char foo();</span><br><span class="line">void bar();</span><br><span class="line"></span><br><span class="line">void baz(int x) &#123;</span><br><span class="line">    (void)x;        // Compliant</span><br><span class="line">    (void)foo();    // Compliant</span><br><span class="line">    (void)bar();    // Non-compliant, ‘(void)’ is redundant</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="参考-347"><a href="#参考-347" class="headerlink" title="参考"></a>参考</h4><p>CWE-704<br><br/><br><br/></p>
<h3 id="▌R12-18-可用其他方式完成的转换不应使用-reinterpret-cast"><a href="#▌R12-18-可用其他方式完成的转换不应使用-reinterpret-cast" class="headerlink" title="▌R12.18 可用其他方式完成的转换不应使用 reinterpret_cast"></a><span id="unsuitablereinterpretcast">▌R12.18 可用其他方式完成的转换不应使用 reinterpret_cast</span></h3><p>ID_unsuitableReinterpretCast&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: cast warning</p>
<hr/>

<p>reinterpret_cast 将地址强行按另一种类型解释，不考虑转换需要的逻辑，可用 static_cast、dynamic_cast 完成的转换不应使用 reinterpret_cast。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct A &#123; int a = 1; &#125;;</span><br><span class="line">struct B &#123; int b = 2; &#125;;</span><br><span class="line">struct C: A, B &#123;&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    C c;</span><br><span class="line">    cout &lt;&lt; static_cast&lt;B*&gt;(&amp;c)-&gt;b &lt;&lt; &#x27; &#x27;;</span><br><span class="line">    cout &lt;&lt; reinterpret_cast&lt;B*&gt;(&amp;c)-&gt;b &lt;&lt; &#x27;\n&#x27;;  // Non-compliant, what is output?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出 2 1，如果想将派生类对象的地址 &amp;c 转为基类指针，应使用 static_cast 进行正确的偏移转换，使用 reinterpret_cast 不会进行偏移转换，得到的成员 b 不是真实的成员 b。<br><br/><br><br/></p>
<h4 id="相关-221"><a href="#相关-221" class="headerlink" title="相关"></a>相关</h4><p>ID_voidCast<br><br/></p>
<h4 id="依据-195"><a href="#依据-195" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 14882:2003 5.2.10(7)-unspecified<br>ISO/IEC 14882:2011 5.2.10(7)-unspecified<br><br/></p>
<h4 id="参考-348"><a href="#参考-348" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines Type.1<br><br/><br><br/></p>
<h3 id="▌R12-19-合理使用-reinterpret-cast"><a href="#▌R12-19-合理使用-reinterpret-cast" class="headerlink" title="▌R12.19 合理使用 reinterpret_cast"></a><span id="forbidreinterpretcast">▌R12.19 合理使用 reinterpret_cast</span></h3><p>ID_forbidReinterpretCast&emsp;&emsp;&emsp;&emsp;&nbsp;:no_entry: cast suggestion</p>
<hr/>

<p>reinterpret_cast 是一种不安全的类型转换，如果必须使用需提供合理的注释说明。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class MyData &#123; .... &#125;;</span><br><span class="line"></span><br><span class="line">void foo(const char* path) &#123;</span><br><span class="line">    unsigned char* p = read_from_file(path);</span><br><span class="line">    MyData* dat = reinterpret_cast&lt;MyData*&gt;(p);  // Bad</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设例中 read_from_file 读取并返回文件的二进制数据，用 reinterpret_cast 将二进制数据直接转为对象是不安全的，妥善的做法是根据文件数据将对象的成员逐一构造出来，可参见 ID_stricterAlignedCast 介绍的方法，这样也可以及时发现并处理问题。  </p>
<p>又如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ext_type* ext_interface();   // External interface</span><br><span class="line"></span><br><span class="line">void foo() &#123;</span><br><span class="line">    auto* raw = ext_interface();</span><br><span class="line">    auto* dat = reinterpret_cast&lt;MyType*&gt;(raw);   // OK</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中 ext_interface 是不受控制的外部接口，它的返回类型不完整或不可用，甚至返回的地址也不遵循 C++ 内存模型，需要将其“重解释”为另一种类型才能探究其内部结构和数据，MyType 是为了解决这个问题而自定义的类型，这种情况可以使用 reinterpret_cast 完成这种非常规转换，但需注明这种情况产生的原因。<br><br/><br><br/></p>
<h4 id="相关-222"><a href="#相关-222" class="headerlink" title="相关"></a>相关</h4><p>ID_forbidCStyleCast<br>ID_stricterAlignedCast<br><br/></p>
<h4 id="参考-349"><a href="#参考-349" class="headerlink" title="参考"></a>参考</h4><p>CWE-843<br>C++ Core Guidelines Pro.safety<br><br/><br><br/></p>
<h3 id="▌R12-20-在-C-代码中禁用-C-风格类型转换"><a href="#▌R12-20-在-C-代码中禁用-C-风格类型转换" class="headerlink" title="▌R12.20 在 C++ 代码中禁用 C 风格类型转换"></a><span id="forbidcstylecast">▌R12.20 在 C++ 代码中禁用 C 风格类型转换</span></h3><p>ID_forbidCStyleCast&emsp;&emsp;&emsp;&emsp;&nbsp;:no_entry: cast suggestion</p>
<hr/>

<p>C 风格类型转换易造成数据丢失或逻辑错误，在 C++ 代码中应使用 static_cast、dynamic_cast 等方法代替 C 风格类型转换。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class A &#123; .... &#125;;</span><br><span class="line">class B &#123; .... &#125;;</span><br><span class="line"></span><br><span class="line">void foo(A* a) &#123;</span><br><span class="line">    B* b = (B*)a;  // Non-compliant, an error value with no logical meaning</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void bar(A* a) &#123;</span><br><span class="line">    B* b = dynamic_cast&lt;B*&gt;(a);  // Compliant, prevent errors at compile time</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中 A 和 B 是两种不相关的类型，用 C 语言的转换方式是可以转换成功的，但并没有逻辑意义，在 C++ 代码中应使用 static_cast 或 dynamic_cast 等方法在编译时或运行时保障转换的有效性。<br><br/><br><br/></p>
<h4 id="参考-350"><a href="#参考-350" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines ES.49<br>MISRA C++ 2008 5-2-4<br><br/><br><br/></p>
<h2 id="13-Buffer"><a href="#13-Buffer" class="headerlink" title="13. Buffer"></a><span id="buffer">13. Buffer</span></h2><h3 id="▌R13-1-避免缓冲区溢出"><a href="#▌R13-1-避免缓冲区溢出" class="headerlink" title="▌R13.1 避免缓冲区溢出"></a><span id="bufferoverflow">▌R13.1 避免缓冲区溢出</span></h3><p>ID_bufferOverflow&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: buffer warning</p>
<hr/>

<p>“缓冲区（buffer）”的本意是指内存等高速设备上的区域，程序在这种区域内接收或处理数据，之后再一并输出到网络或磁盘等低速环境，起到提高效率的作用，故称缓冲区。连续的内存区域均可称为缓冲区，在 C/C++ 语言中对应数组等结构。  </p>
<p>缓冲区之外可能是程序的其他数据，也可能是函数返回地址、资源分配信息等重要数据，对缓冲区的越界读写往往意味着逻辑错误，而且会使程序遭到破坏。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void foo(const char* s) &#123;</span><br><span class="line">    char buf[100];</span><br><span class="line">    strcpy(buf, s);   // Non-compliant</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    foo(userInput());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中 userInput 函数返回用户输入的字符串，其长度不确定，而缓冲区 buf 的长度为 100 字节，如果用户输入超过这个长度就会使程序遭到破坏，这种问题称为“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Buffer_overflow">缓冲区溢出（buffer overflow）</a>”，也是程序遭受攻击的常见原因。  </p>
<p>缓冲区溢出可造成严重危害，如：  </p>
<ul>
<li>破坏堆栈或段结构，扰乱程序执行  </li>
<li>改写关键信息，篡改程序行为  </li>
<li>注入并运行恶意代码  </li>
<li>攻击高权限进程获取非法权限  </li>
</ul>
<p>所以将读写限定在缓冲区边界之内是十分重要的，示例代码应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void foo(const char* s) &#123;</span><br><span class="line">    char buf[100] = &quot;&quot;;</span><br><span class="line">    strncpy(buf, s, sizeof(buf) - 1);   // Compliant</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>strncpy 与 strcpy 不同，当源字符串长度超过指定限制时会结束复制，但要注意 strncpy 对空字符的处理。<br><br/><br><br/></p>
<h4 id="相关-223"><a href="#相关-223" class="headerlink" title="相关"></a>相关</h4><p>ID_arrayIndexOverflow<br>ID_unsafeStringFunction<br><br/></p>
<h4 id="参考-351"><a href="#参考-351" class="headerlink" title="参考"></a>参考</h4><p>CWE-119<br>CWE-125<br>CWE-787<br>CWE-788<br><br/><br><br/></p>
<h3 id="▌R13-2-数组下标不可越界"><a href="#▌R13-2-数组下标不可越界" class="headerlink" title="▌R13.2 数组下标不可越界"></a><span id="arrayindexoverflow">▌R13.2 数组下标不可越界</span></h3><p>ID_arrayIndexOverflow&emsp;&emsp;&emsp;&emsp;&nbsp;:boom: buffer error</p>
<hr/>

<p>数组下标超过数组大小范围会导致标准未定义的行为。  </p>
<p>设数组元素个数为 N，p 为指向数组第一个元素的指针，i 为整数，标准规定：  </p>
<ul>
<li>当 i &gt;= 0 且 i &lt; N 时，p + i 的结果不会溢出  </li>
<li>当 i 等于 N 时，p + i 的结果不会溢出，但不可对其解引用  </li>
<li>当 i &lt; 0 或 i &gt; N 时，p + i 的结果可能会溢出  </li>
<li>使数组下标超出 [0, N] 的运算可能会使指针值溢出，导致未定义的行为  </li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int a[10];</span><br><span class="line">int *p, *e;</span><br><span class="line"></span><br><span class="line">p = a + 0;    // Compliant</span><br><span class="line">p = a + 5;    // Compliant</span><br><span class="line">e = a + 10;   // Compliant, won&#x27;t overflow</span><br><span class="line"></span><br><span class="line">p = a - 1;    // Non-compliant, the array subscript is -1, which exceeds [0, N]</span><br><span class="line">e = a + 11;   // Non-compliant, the array subscript is 11, which exceeds [0, N]</span><br><span class="line"></span><br><span class="line">--p;          // Non-compliant, may overflow</span><br><span class="line">e++;          // Non-compliant, may overflow</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="相关-224"><a href="#相关-224" class="headerlink" title="相关"></a>相关</h4><p>ID_bufferOverflow<br><br/></p>
<h4 id="依据-196"><a href="#依据-196" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 6.5.6(8)-undefined<br>ISO/IEC 9899:2011 6.5.6(8)-undefined<br>ISO/IEC 14882:2003 5.7(5)-undefined<br>ISO/IEC 14882:2011 5.7(5)-undefined<br><br/></p>
<h4 id="参考-352"><a href="#参考-352" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines ES.103<br>SEI CERT ARR30-C<br><br/><br><br/></p>
<h3 id="▌R13-3-为缓冲区分配足够的空间"><a href="#▌R13-3-为缓冲区分配足够的空间" class="headerlink" title="▌R13.3 为缓冲区分配足够的空间"></a><span id="insufficientbuffer">▌R13.3 为缓冲区分配足够的空间</span></h3><p>ID_insufficientBuffer&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: buffer warning</p>
<hr/>

<p>为缓冲区分配足够的空间，避免溢出等问题。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void foo(const char* s) &#123;</span><br><span class="line">    char* p = (char*)malloc(strlen(s));  // Non-compliant, should be ‘strlen(s) + 1’</span><br><span class="line">    strcpy(p, s);</span><br><span class="line">    printf(&quot;%s\n&quot;, p);  // Out of bounds, undefined behavior</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>字符串以空字符结尾，在分配字符串空间时不可漏掉空字符的空间。  </p>
<p>又如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void bar() &#123;</span><br><span class="line">    int* p = (int*)malloc(123);  // Non-compliant</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中 bar 函数为 int 型数组分配了 123 个字节的空间，而 123 不能被 sizeof(int) 整除，最后一个元素会越界。虽然 malloc 函数返回已对齐的地址，但这种代码往往意味着 sizeof 因子的缺失。  </p>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void bar() &#123;</span><br><span class="line">    int* p = (int*)malloc(123 * sizeof(int));  // Compliant</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="相关-225"><a href="#相关-225" class="headerlink" title="相关"></a>相关</h4><p>ID_bufferOverflow<br><br/></p>
<h4 id="参考-353"><a href="#参考-353" class="headerlink" title="参考"></a>参考</h4><p>CWE-131<br>CWE-135<br><br/><br><br/></p>
<h3 id="▌R13-4-memset-等函数不应作用于非-POD-对象"><a href="#▌R13-4-memset-等函数不应作用于非-POD-对象" class="headerlink" title="▌R13.4 memset 等函数不应作用于非 POD 对象"></a><span id="nonpodfilling">▌R13.4 memset 等函数不应作用于非 POD 对象</span></h3><p>ID_nonPODFilling&emsp;&emsp;&emsp;&emsp;&nbsp;:boom: buffer error</p>
<hr/>

<p>memset、memcpy、memmove 等具有填充功能的函数不应作用于非“<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/named_req/PODType">POD</a>”对象，否则会破坏其数据的内在关系。  </p>
<p>本规则是 ID_nonPODBinaryCast 的特化。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    ....</span><br><span class="line">public:</span><br><span class="line">    virtual ~A();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void foo(A&amp; a) &#123;</span><br><span class="line">    memset(&amp;a, 0, sizeof(a));   // Non-compliant, the ‘vfptr’ is corrupted</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中 memset 填充非 POD 对象，其虚函数表指针会被破坏，造成严重的运行时错误。<br><br/><br><br/></p>
<h4 id="相关-226"><a href="#相关-226" class="headerlink" title="相关"></a>相关</h4><p>ID_nonPODBinaryCast<br><br/></p>
<h4 id="参考-354"><a href="#参考-354" class="headerlink" title="参考"></a>参考</h4><p>CWE-463<br>C++ Core Guidelines SL.con.4<br>C++ Core Guidelines C.90<br><br/><br><br/></p>
<h3 id="▌R13-5-memset-等函数长度相关的参数不应有误"><a href="#▌R13-5-memset-等函数长度相关的参数不应有误" class="headerlink" title="▌R13.5 memset 等函数长度相关的参数不应有误"></a><span id="badlength">▌R13.5 memset 等函数长度相关的参数不应有误</span></h3><p>ID_badLength&emsp;&emsp;&emsp;&emsp;&nbsp;:boom: buffer error</p>
<hr/>

<p>对于 memset、memcpy、memmove、memcmp 及同类函数，表示长度的参数不应存在常见笔误。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char buf[1024];</span><br><span class="line">memset(buf, 1024, 0);  // Non-compliant</span><br></pre></td></tr></table></figure>
<p>长度和填充值参数被写反是常见笔误，应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">memset(buf, 0, 1024);  // Compliant</span><br></pre></td></tr></table></figure>
<p>又如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int arr[1024];</span><br><span class="line">memset(buf, 0, 1024);  // Rather suspicious</span><br><span class="line">memset(buf, 1, 123);   // Non-compliant</span><br></pre></td></tr></table></figure>
<p>memset 等函数的长度单位为字节，不应遗漏 sizeof 因子，应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">memset(buf, 0, 1024 * sizeof(int));  // Compliant</span><br><span class="line">memset(buf, 1, 123 * sizeof(int));   // Compliant</span><br></pre></td></tr></table></figure>
<p>又如（设 p 为对象指针）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">memset(p, 0, sizeof(p));   // Non-compliant</span><br></pre></td></tr></table></figure>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">memset(p, 0, sizeof(*p));  // Compliant</span><br></pre></td></tr></table></figure>
<p>sizeof 作用于指针并不能获取到对象的大小，可参见 ID_sizeof_pointer 的进一步讨论。  </p>
<p>又如（设 a、b 是对象）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">memset(&amp;a, 0, sizeof(&amp;a));   // Non-compliant</span><br><span class="line">memcpy(&amp;a, &amp;b, sizeof(&amp;a));  // Non-compliant</span><br></pre></td></tr></table></figure>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">memset(&amp;a, 0, sizeof(a));    // Compliant</span><br><span class="line">memcpy(&amp;a, &amp;b, sizeof(a));   // Compliant</span><br></pre></td></tr></table></figure>
<p>这是常见的复制粘贴错误。  </p>
<p>又如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (memcmp(&amp;a, &amp;b, sizeof(a) != 0)) &#123;  // Non-compliant</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>长度参数不应为比较表达式，应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (memcmp(&amp;a, &amp;b, sizeof(a)) != 0) &#123;  // Compliant</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>括号的错误嵌套也是常见的笔误。<br><br/><br><br/></p>
<h4 id="参考-355"><a href="#参考-355" class="headerlink" title="参考"></a>参考</h4><p>CWE-130<br>CWE-805<br><br/><br><br/></p>
<h3 id="▌R13-6-memset-等函数填充值相关的参数不应有误"><a href="#▌R13-6-memset-等函数填充值相关的参数不应有误" class="headerlink" title="▌R13.6 memset 等函数填充值相关的参数不应有误"></a><span id="valueoverflow">▌R13.6 memset 等函数填充值相关的参数不应有误</span></h3><p>ID_valueOverflow&emsp;&emsp;&emsp;&emsp;&nbsp;:boom: buffer error</p>
<hr/>

<p>memset、memset_s 等函数的填充值参数会被转为 unsigned char 型，所以填充值不应超出 unsigned char 的取值范围。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char buf[32];</span><br><span class="line">memset(buf, 1024, 32);  // Non-compliant</span><br></pre></td></tr></table></figure>
<p>例中填充值为 1024，超出了 unsigned char 的范围，在实际代码中也可能是长度参数与填充值参数被写反了。<br><br/><br><br/></p>
<h4 id="依据-197"><a href="#依据-197" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 7.21.6.1(2)<br>ISO/IEC 9899:2011 7.24.6.1(2)<br>ISO/IEC 9899:2011 K.3.7.4.1(4)<br><br/></p>
<h4 id="参考-356"><a href="#参考-356" class="headerlink" title="参考"></a>参考</h4><p>CWE-130<br><br/><br><br/></p>
<h2 id="14-Pointer"><a href="#14-Pointer" class="headerlink" title="14. Pointer"></a><span id="pointer">14. Pointer</span></h2><h3 id="▌R14-1-避免空指针解引用"><a href="#▌R14-1-避免空指针解引用" class="headerlink" title="▌R14.1 避免空指针解引用"></a><span id="nullderefinscp">▌R14.1 避免空指针解引用</span></h3><p>ID_nullDerefInScp&emsp;&emsp;&emsp;&emsp;&nbsp;:boom: pointer error</p>
<hr/>

<p>通过指针的值访问相应地址中的数据称为“解引用（dereference）”，空指针是没有指向任何数据的指针，空指针解引用是一种逻辑错误，会导致标准未定义的行为。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int foo(int i) &#123;</span><br><span class="line">    int* p = NULL;</span><br><span class="line">    if (cond) &#123;</span><br><span class="line">        p = &amp;i;</span><br><span class="line">    &#125;</span><br><span class="line">    return *p;    // Non-compliant</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中指针 p 为空的状态可以到达解引用处，往往会引发“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Segmentation_fault">段错误</a>”而导致崩溃。  </p>
<p>例外：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct T &#123;</span><br><span class="line">    int foo() &#123; return 0; &#125;</span><br><span class="line">    static int bar() &#123; return 1; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">T* p = nullptr;</span><br><span class="line">int b = p-&gt;bar();   // Compliant, but bad, use ‘T::bar()’ instead</span><br><span class="line">int c = p-&gt;foo();   // Non-compliant, even if it may not crash</span><br></pre></td></tr></table></figure>
<p>在 C++ 代码中通过指针访问静态成员不算作解引用，可不受本规则约束，但这种风格易引起维护者的疑虑而增加维护成本。  </p>
<p>注意，非静态成员函数是对象数据的访问方法，即使非静态成员函数没有实际地访问对象数据，也不应通过空指针调用非静态成员函数，否则仍属于逻辑错误，而且如果调用的是虚函数或虚基类的成员函数也会造成崩溃。<br><br/><br><br/></p>
<h4 id="依据-198"><a href="#依据-198" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 6.3.2.1(1)-undefined<br>ISO/IEC 9899:1999 6.5.3.2(4)-undefined<br>ISO/IEC 9899:2011 6.3.2.1(1)-undefined<br>ISO/IEC 9899:2011 6.5.3.2(4)-undefined<br>ISO/IEC 14882:2003 8.3.2(4)-undefined<br>ISO/IEC 14882:2011 8.3.2(5)-undefined<br><br/></p>
<h4 id="参考-357"><a href="#参考-357" class="headerlink" title="参考"></a>参考</h4><p>CWE-476<br>C++ Core Guidelines ES.65<br><br/><br><br/></p>
<h3 id="▌R14-2-注意逻辑表达式内的空指针解引用"><a href="#▌R14-2-注意逻辑表达式内的空指针解引用" class="headerlink" title="▌R14.2 注意逻辑表达式内的空指针解引用"></a><span id="nullderefinexp">▌R14.2 注意逻辑表达式内的空指针解引用</span></h3><p>ID_nullDerefInExp&emsp;&emsp;&emsp;&emsp;&nbsp;:boom: pointer error</p>
<hr/>

<p>在逻辑表达式中，需注意逻辑关系以及运算符优先级，不可出现空指针解引用等问题。  </p>
<p>示例（设 foo、bar 是指针 p 所指对象的非静态成员函数）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p || p-&gt;foo();  // Non-compliant</span><br></pre></td></tr></table></figure>
<p>当 p 为空时执行“||”的右子表达式，恰好使空指针被解引用。  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p &amp;&amp; p-&gt;foo() || p-&gt;bar();  // Non-compliant</span><br></pre></td></tr></table></figure>
<p>“&amp;&amp;”的优先级高于“||”，由“||”的左子表达式可知 p 可能为空，而右子表达式却没有限制，导致空指针被解引用。  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;foo() &amp;&amp; p;  // Non-compliant</span><br></pre></td></tr></table></figure>
<p>这是颠倒了对指针的判断和解引用次序，属于语言运用错误。<br><br/><br><br/></p>
<h4 id="依据-199"><a href="#依据-199" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 6.3.2.1(1)-undefined<br>ISO/IEC 9899:1999 6.5.3.2(4)-undefined<br>ISO/IEC 9899:2011 6.3.2.1(1)-undefined<br>ISO/IEC 9899:2011 6.5.3.2(4)-undefined<br>ISO/IEC 14882:2003 8.3.2(4)-undefined<br>ISO/IEC 14882:2011 8.3.2(5)-undefined<br><br/></p>
<h4 id="参考-358"><a href="#参考-358" class="headerlink" title="参考"></a>参考</h4><p>CWE-476<br>CWE-783<br>C++ Core Guidelines ES.65<br><br/><br><br/></p>
<h3 id="▌R14-3-不可解引用未初始化的指针"><a href="#▌R14-3-不可解引用未初始化的指针" class="headerlink" title="▌R14.3 不可解引用未初始化的指针"></a><span id="wildptrderef">▌R14.3 不可解引用未初始化的指针</span></h3><p>ID_wildPtrDeref&emsp;&emsp;&emsp;&emsp;&nbsp;:boom: pointer error</p>
<hr/>

<p>未初始化的指针具有不确定的值，对其解引用会导致标准未定义的行为，往往会造成严重错误。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int foo() &#123;</span><br><span class="line">    int* p;      // Uninitialized</span><br><span class="line">    return *p;   // Non-compliant</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中指针 p 定义后未被初始化，可能指向不可访问的空间，也可能指向已分配的空间，对其读写可能会导致崩溃，也可能会扰乱程序的行为，造成难以排查的错误。<br><br/><br><br/></p>
<h4 id="相关-227"><a href="#相关-227" class="headerlink" title="相关"></a>相关</h4><p>ID_illAccess<br>ID_localInitialization<br><br/></p>
<h4 id="依据-200"><a href="#依据-200" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 6.5.3.2(4)-undefined<br>ISO/IEC 9899:2011 6.5.3.2(4)-undefined<br><br/></p>
<h4 id="参考-359"><a href="#参考-359" class="headerlink" title="参考"></a>参考</h4><p>CWE-824<br>C++ Core Guidelines ES.65<br><br/><br><br/></p>
<h3 id="▌R14-4-不可解引用已被释放的指针"><a href="#▌R14-4-不可解引用已被释放的指针" class="headerlink" title="▌R14.4 不可解引用已被释放的指针"></a><span id="danglingderef">▌R14.4 不可解引用已被释放的指针</span></h3><p>ID_danglingDeref&emsp;&emsp;&emsp;&emsp;&nbsp;:boom: pointer error</p>
<hr/>

<p>已被释放的指针指向失效的内存空间，对其解引用会导致标准未定义的行为，往往会造成严重错误。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int foo() &#123;</span><br><span class="line">    int* p = new int[100];</span><br><span class="line">    if (cond) &#123;</span><br><span class="line">        ....</span><br><span class="line">        delete[] p;</span><br><span class="line">    &#125;</span><br><span class="line">    return p[0];  // Non-compliant, ‘p’ may be deallocated</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本来指针 p 指向有效的内存空间，但由于某种原因相关内存被释放，p 的值不变但已无效，这种情况被形象地称为“指针悬挂”，未经初始化的指针和这种被悬挂的指针统称“野指针”，均指向无效地址不可被解引用。  </p>
<p>应关注对象的生命周期，避免内层作用域中的地址向外层传递，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int foo(int i) &#123;</span><br><span class="line">    int* p = &amp;i;</span><br><span class="line">    if (cond) &#123;</span><br><span class="line">        int j = 0;</span><br><span class="line">        ....</span><br><span class="line">        p = &amp;j;   // Bad practice</span><br><span class="line">    &#125;</span><br><span class="line">    return *p;    // Non-compliant, ‘p’ may be deallocated</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中局部变量 j 的地址被传给了外层作域中的指针 p，j 的生命周期结束后，p 会成为野指针。  </p>
<p>另外，在 C++ 代码中，应避免持有可被自动销毁的对象地址，如容器中对象的地址、智能指针所指对象的地址等：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int bar(vector&lt;int&gt;&amp; v) &#123;</span><br><span class="line">    int* p = &amp;v.front();    // Bad practice</span><br><span class="line">    v.push_back(1);</span><br><span class="line">    return *p;              // ‘p’ may be invalid</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中指针 p 记录了 vector 容器中对象的地址，根据 vector 容器持有对象的策略，随着元素的增加原有对象的地址可能不再有效。  </p>
<p>又如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int baz() &#123;</span><br><span class="line">    auto u = make_unique&lt;int&gt;();</span><br><span class="line">    auto p = u.get();            // Bad practice</span><br><span class="line">    u = make_unique&lt;int&gt;();</span><br><span class="line">    return *p;                   // ‘p’ is invalid</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中指针 p 记录了 unique_ptr 所指对象的地址，当 unique_ptr 指向新的对象时，原对象的地址不再有效。<br><br/><br><br/></p>
<h4 id="相关-228"><a href="#相关-228" class="headerlink" title="相关"></a>相关</h4><p>ID_illAccess<br>ID_localAddressFlowOut<br>ID_illLifetime<br><br/></p>
<h4 id="依据-201"><a href="#依据-201" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 6.5.3.2(4)-undefined<br>ISO/IEC 9899:2011 6.5.3.2(4)-undefined<br><br/></p>
<h4 id="参考-360"><a href="#参考-360" class="headerlink" title="参考"></a>参考</h4><p>CWE-825<br>C++ Core Guidelines ES.65<br>SEI CERT EXP54-CPP<br><br/><br><br/></p>
<h3 id="▌R14-5-避免无效的空指针检查"><a href="#▌R14-5-避免无效的空指针检查" class="headerlink" title="▌R14.5 避免无效的空指针检查"></a><span id="invalidnullcheck">▌R14.5 避免无效的空指针检查</span></h3><p>ID_invalidNullCheck&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: pointer warning</p>
<hr/>

<p>当指针的值一定不为空时，再对其进行检查是没有意义的，往往意味着逻辑错误。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (int* p = new int[100]) &#123;   // Non-compliant</span><br><span class="line">    ....</span><br><span class="line">&#125; else &#123;   // Invalid</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>标准规定默认 new 运算符的返回值不会为空，如果分配失败则抛出异常，所以这种检查和相关错误处理是无效的。  </p>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (int* p = new(std::nothrow) int[100]) &#123;   // Compliant</span><br><span class="line">    ....</span><br><span class="line">&#125; else &#123;   // OK</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>又如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (p) &#123;        // Meaningless</span><br><span class="line">    delete p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于可接受空指针的接口，不必总在调用前判断指针是否为空，否则会使代码变得繁琐。delete 关键字或 free 函数可以作用于空指针，调用之前的检查是没有意义的。<br><br/><br><br/></p>
<h4 id="相关-229"><a href="#相关-229" class="headerlink" title="相关"></a>相关</h4><p>ID_repeatedNullCheck<br><br/></p>
<h4 id="依据-202"><a href="#依据-202" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 14882:2003 18.4<br>ISO/IEC 14882:2011 18.6<br><br/><br><br/></p>
<h3 id="▌R14-6-不应重复检查指针是否为空"><a href="#▌R14-6-不应重复检查指针是否为空" class="headerlink" title="▌R14.6 不应重复检查指针是否为空"></a><span id="repeatednullcheck">▌R14.6 不应重复检查指针是否为空</span></h3><p>ID_repeatedNullCheck&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: pointer warning</p>
<hr/>

<p>重复的空指针检查是不必要的，使代码显得繁琐，且干扰编译器优化。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void foo(int* p) &#123;</span><br><span class="line">    if (!p) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (p) &#123;   // Non-compliant, ‘p’ is not nullptr</span><br><span class="line">        ....</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        ....   // Unreachable</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="相关-230"><a href="#相关-230" class="headerlink" title="相关"></a>相关</h4><p>ID_invalidNullCheck<br><br/><br><br/></p>
<h3 id="▌R14-7-不应将非零常量值赋值给指针"><a href="#▌R14-7-不应将非零常量值赋值给指针" class="headerlink" title="▌R14.7 不应将非零常量值赋值给指针"></a><span id="fixedaddrtopointer">▌R14.7 不应将非零常量值赋值给指针</span></h3><p>ID_fixedAddrToPointer&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: pointer warning</p>
<hr/>

<p>固定地址是不可移植的，且存在安全隐患。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const void* badAddr = (void*)0xffffffff;  // Non-compliant</span><br></pre></td></tr></table></figure>
<p>示例代码的本意是声明一个表示无效地址的值，但在 64 位系统中这个地址可能是有效的。  </p>
<p>又如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typedef int (*fp_t)(int);</span><br><span class="line">fp_t fp = (fp_t)0x1234abcd;  // Non-compliant</span><br><span class="line">int res = (*fp)(123);        // Unsafe</span><br></pre></td></tr></table></figure>
<p>示例代码假设在特定地址可以找到特定的函数，将该地址赋给一个指针并调用，这种假设是不可移植的，也可能本身就是错误的，会导致崩溃，而且函数地址往往也属于敏感信息，不应被写入代码，否则一旦泄露，攻击者可以更改预期地址上的数据，导致恶意代码被执行。  </p>
<p>某些框架或系统会以 -1 表示无效地址，但不具备通用性，审计工具不妨通过配置决定是否放过。  </p>
<p>例外：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define DEVICE_BASE ((volatile Dev*)0x1234)</span><br><span class="line"></span><br><span class="line">volatile Dev* p = DEVICE_BASE;  // Let it go if the address is right</span><br></pre></td></tr></table></figure>
<p>如果固定地址受环境支持，如固定的设备地址，可不受本规则约束，但应通过接口获取地址，避免将常量地址写死在代码中。<br><br/><br><br/></p>
<h4 id="配置-42"><a href="#配置-42" class="headerlink" title="配置"></a>配置</h4><p>allowMinusOneAsPointerValue：是否允许 -1 作为指针的值<br><br/></p>
<h4 id="相关-231"><a href="#相关-231" class="headerlink" title="相关"></a>相关</h4><p>ID_addressExposure<br>ID_plainSensitiveInfo<br>ID_ptrIntCast<br><br/></p>
<h4 id="参考-361"><a href="#参考-361" class="headerlink" title="参考"></a>参考</h4><p>CWE-587<br><br/><br><br/></p>
<h3 id="▌R14-8-不应使用常量-0-表示空指针"><a href="#▌R14-8-不应使用常量-0-表示空指针" class="headerlink" title="▌R14.8 不应使用常量 0 表示空指针"></a><span id="zeroasptrvalue">▌R14.8 不应使用常量 0 表示空指针</span></h3><p>ID_zeroAsPtrValue&emsp;&emsp;&emsp;&emsp;&nbsp;:bulb: pointer suggestion</p>
<hr/>

<p>在 C 代码中应使用 NULL 表示空指针，在 C++ 代码中应使用 nullptr 表示空指针。  </p>
<p>标准允许 0、’\0’、false、1 - 1 等值为 0 的常量表达式作为空指针常量，但易与非指针混淆，不利于阅读和维护。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int* p;</span><br><span class="line">void foo(int*);</span><br><span class="line"></span><br><span class="line">p = 0;   // Non-compliant</span><br><span class="line">foo(0);  // Non-compliant</span><br></pre></td></tr></table></figure>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p = NULL;      // Compliant in C</span><br><span class="line">foo(nullptr);  // Compliant in C++</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="相关-232"><a href="#相关-232" class="headerlink" title="相关"></a>相关</h4><p>ID_oddPtrBoolAssignment<br>ID_oddPtrCharAssignment<br>ID_oddPtrBoolComparison<br>ID_oddPtrCharComparison<br><br/></p>
<h4 id="依据-203"><a href="#依据-203" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 6.3.2.3(3)<br>ISO/IEC 9899:2011 6.3.2.3(3)<br>ISO/IEC 14882:2003 4.10(1)<br>ISO/IEC 14882:2011 4.10(1)<br><br/></p>
<h4 id="参考-362"><a href="#参考-362" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines ES.47<br>MISRA C 2012 11.9<br>MISRA C++ 2008 4-10-2<br><br/><br><br/></p>
<h3 id="▌R14-9-不应使用-false-对指针赋值"><a href="#▌R14-9-不应使用-false-对指针赋值" class="headerlink" title="▌R14.9 不应使用 false 对指针赋值"></a><span id="oddptrboolassignment">▌R14.9 不应使用 false 对指针赋值</span></h3><p>ID_oddPtrBoolAssignment&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: pointer warning</p>
<hr/>

<p>用 false 对指针赋值是非常怪异的，会误导维护者，而且也很可能是逻辑错误。  </p>
<p>本规则是 ID_zeroAsPtrValue 的特化。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void foo(bool* p) &#123;</span><br><span class="line">    p = false;        // Non-compliant</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void foo(bool* p) &#123;</span><br><span class="line">    *p = false;       // Compliant</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="相关-233"><a href="#相关-233" class="headerlink" title="相关"></a>相关</h4><p>ID_zeroAsPtrValue<br><br/></p>
<h4 id="参考-363"><a href="#参考-363" class="headerlink" title="参考"></a>参考</h4><p>CWE-351<br><br/><br><br/></p>
<h3 id="▌R14-10-不应使用-‘-0’-等字符常量对指针赋值"><a href="#▌R14-10-不应使用-‘-0’-等字符常量对指针赋值" class="headerlink" title="▌R14.10 不应使用 ‘\0’ 等字符常量对指针赋值"></a><span id="oddptrcharassignment">▌R14.10 不应使用 ‘\0’ 等字符常量对指针赋值</span></h3><p>ID_oddPtrCharAssignment&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: pointer warning</p>
<hr/>

<p>用 ‘\0’、L’\0’、u’\0’、U’\0’ 等字符常量对指针赋值是非常怪异的，往往意味着逻辑错误。  </p>
<p>本规则是 ID_zeroAsPtrValue 的特化。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void set_terminate(char* p) &#123;</span><br><span class="line">    p = &#x27;\0&#x27;;                   // Non-compliant</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void set_terminate(char* p) &#123;</span><br><span class="line">    *p = &#x27;\0&#x27;;                  // Compliant</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="相关-234"><a href="#相关-234" class="headerlink" title="相关"></a>相关</h4><p>ID_zeroAsPtrValue<br><br/></p>
<h4 id="参考-364"><a href="#参考-364" class="headerlink" title="参考"></a>参考</h4><p>CWE-351<br><br/><br><br/></p>
<h3 id="▌R14-11-指针不应与-false-比较大小"><a href="#▌R14-11-指针不应与-false-比较大小" class="headerlink" title="▌R14.11 指针不应与 false 比较大小"></a><span id="oddptrboolcomparison">▌R14.11 指针不应与 false 比较大小</span></h3><p>ID_oddPtrBoolComparison&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: pointer warning</p>
<hr/>

<p>指针与 false 比较大小是非常怪异的，往往是某种笔误。  </p>
<p>本规则是 ID_zeroAsPtrValue 的特化。  </p>
<p>示例（设 p 为指针）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p == false  // Non-compliant</span><br><span class="line">p != false  // Non-compliant</span><br></pre></td></tr></table></figure>
<p>如果判断指针是否为空，只应将指针与 NULL 或 nullptr 比较，其他常量均不符合要求。<br><br/><br><br/></p>
<h4 id="相关-235"><a href="#相关-235" class="headerlink" title="相关"></a>相关</h4><p>ID_zeroAsPtrValue<br><br/></p>
<h4 id="参考-365"><a href="#参考-365" class="headerlink" title="参考"></a>参考</h4><p>CWE-1025<br><br/><br><br/></p>
<h3 id="▌R14-12-指针不应与-‘-0’-等字符常量比较大小"><a href="#▌R14-12-指针不应与-‘-0’-等字符常量比较大小" class="headerlink" title="▌R14.12 指针不应与 ‘\0’ 等字符常量比较大小"></a><span id="oddptrcharcomparison">▌R14.12 指针不应与 ‘\0’ 等字符常量比较大小</span></h3><p>ID_oddPtrCharComparison&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: pointer warning</p>
<hr/>

<p>指针与 ‘\0’、L’\0’、u’\0’、U’\0’ 等字符常量比较大小是非常怪异的，往往是某种笔误。  </p>
<p>本规则是 ID_zeroAsPtrValue 的特化。  </p>
<p>示例（设 p 为指针）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (p == &#x27;\0&#x27;) &#123;   // Non-compliant</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种情况很有可能是漏写了 * 号：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (*p == &#x27;\0&#x27;) &#123;   // Non-compliant</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>否则只应将指针与 NULL 或 nullptr 比较。<br><br/><br><br/></p>
<h4 id="相关-236"><a href="#相关-236" class="headerlink" title="相关"></a>相关</h4><p>ID_zeroAsPtrValue<br><br/></p>
<h4 id="参考-366"><a href="#参考-366" class="headerlink" title="参考"></a>参考</h4><p>CWE-1025<br><br/><br><br/></p>
<h3 id="▌R14-13-指针与空指针不应比较大小"><a href="#▌R14-13-指针与空指针不应比较大小" class="headerlink" title="▌R14.13 指针与空指针不应比较大小"></a><span id="oddptrzerocomparison">▌R14.13 指针与空指针不应比较大小</span></h3><p>ID_oddPtrZeroComparison&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: pointer warning</p>
<hr/>

<p>指针与空指针比较大小往往意味着逻辑错误，而且只有指向同一数组或对象的指针才能比较大小，否则会导致标准未定义的行为，空指针不指向任何数组或对象，故不应比较指针与空指针的大小。  </p>
<p>指针与空指针之间只应使用 == 或 != 比较，其他比较运算符均不符合要求。  </p>
<p>本规则是 ID_illPtrDiff 的特化。  </p>
<p>示例（设 p 为指针）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">p &lt; NULL       // Non-compliant, may be always false</span><br><span class="line">p &gt;= 0         // Non-compliant, may be always true</span><br><span class="line">p &gt; nullptr    // Non-compliant, use p != nullptr instead</span><br><span class="line">p &lt;= 0         // Non-compliant, use p == 0 instead</span><br><span class="line"></span><br><span class="line">p == NULL      // Compliant</span><br><span class="line">p != nullptr   // Compliant</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="相关-237"><a href="#相关-237" class="headerlink" title="相关"></a>相关</h4><p>ID_illPtrDiff<br><br/></p>
<h4 id="依据-204"><a href="#依据-204" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 6.5.8(5)-undefined<br>ISO/IEC 9899:2011 6.5.8(5)-undefined<br><br/></p>
<h4 id="参考-367"><a href="#参考-367" class="headerlink" title="参考"></a>参考</h4><p>CWE-1025<br><br/><br><br/></p>
<h3 id="▌R14-14-不应判断-this-指针是否为空"><a href="#▌R14-14-不应判断-this-指针是否为空" class="headerlink" title="▌R14.14 不应判断 this 指针是否为空"></a><span id="this_zerocomparison">▌R14.14 不应判断 this 指针是否为空</span></h3><p>ID_this_zeroComparison&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: pointer warning</p>
<hr/>

<p>正常情况下 this 指针不会为空，而且判断 this 指针是否为空会影响编译器对 this 指针的优化，造成难以预料的后果。  </p>
<p>在某些环境中通过空指针调用非静态成员函数时，this 指针可能为空，但这并不符合标准。值得强调的是，任何情况下都不应逃避解引用空指针造成的问题。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct A &#123;</span><br><span class="line">    int x = 0;</span><br><span class="line">    int getX() &#123;</span><br><span class="line">        return this? x: 0;  // Non-compliant</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A* p = foo();</span><br><span class="line">// Suppose an error has occurred and a null pointer is returned</span><br><span class="line">cout &lt;&lt; p-&gt;getX() &lt;&lt; &#x27;\n&#x27;;</span><br></pre></td></tr></table></figure>
<p>假设 foo 函数不应返回空指针，而某个错误导致其返回了空指针，程序本应崩溃，而 getX 函数却逃避了崩溃，这非但不能真正地解决问题，反而使问题难以定位，使程序难以调试，大大降低了可维护性。<br><br/><br><br/></p>
<h4 id="参考-368"><a href="#参考-368" class="headerlink" title="参考"></a>参考</h4><p>CWE-1025<br><br/><br><br/></p>
<h3 id="▌R14-15-析构函数中不可使用-delete-this"><a href="#▌R14-15-析构函数中不可使用-delete-this" class="headerlink" title="▌R14.15 析构函数中不可使用 delete this"></a><span id="this_deleteindestructor">▌R14.15 析构函数中不可使用 delete this</span></h3><p>ID_this_deleteInDestructor&emsp;&emsp;&emsp;&emsp;&nbsp;:boom: pointer error</p>
<hr/>

<p>析构函数中不可使用 delete this，否则造成无限递归。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct A &#123;</span><br><span class="line">    ~A() &#123;</span><br><span class="line">        delete this;  // Non-compliant</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="参考-369"><a href="#参考-369" class="headerlink" title="参考"></a>参考</h4><p>CWE-674<br><br/><br><br/></p>
<h3 id="▌R14-16-禁用-delete-this"><a href="#▌R14-16-禁用-delete-this" class="headerlink" title="▌R14.16 禁用 delete this"></a><span id="this_forbiddeletethis">▌R14.16 禁用 delete this</span></h3><p>ID_this_forbidDeleteThis&emsp;&emsp;&emsp;&emsp;&nbsp;:no_entry: pointer suggestion</p>
<hr/>

<p>使用 delete this 须保证：  </p>
<ul>
<li>对象是用 new 创建的，但不能用 new[] 或 replacement new  </li>
<li>使用 delete this 之后不能再访问相关非静态成员  </li>
<li>不能在析构函数中使用 delete this  </li>
</ul>
<p>由于限制条件易被打破，对框架以及语言工具之外的业务类或算法类代码建议禁用 delete this。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    ....</span><br><span class="line">public:</span><br><span class="line">    void foo() &#123;</span><br><span class="line">        delete this;   // Non-compliant</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">auto* p = new A;</span><br><span class="line">p-&gt;foo();              // Looks innocent</span><br><span class="line"></span><br><span class="line">p = new A[10];</span><br><span class="line">p-&gt;foo();              // Memory is still leaking</span><br></pre></td></tr></table></figure>
<p>如果有必要使用 delete this，应将类的析构函数设为非 public，使对象只能通过 new 创建，并确保执行 delete this 后 this 指针再也不会被访问，而且不能用 new[] 创建数组，否则仍然存在内存泄漏等问题。<br><br/><br><br/><br><br/></p>
<h3 id="▌R14-17-判断-dynamic-cast-转换是否成功"><a href="#▌R14-17-判断-dynamic-cast-转换是否成功" class="headerlink" title="▌R14.17 判断 dynamic_cast 转换是否成功"></a><span id="nullderefdynamiccast">▌R14.17 判断 dynamic_cast 转换是否成功</span></h3><p>ID_nullDerefDynamicCast&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: pointer warning</p>
<hr/>

<p>dynamic_cast 转换指针失败会返回空指针，转换引用失败会抛出异常，如果不作判断则失去了使用 dynamic_cast 的意义。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void foo(A* a) &#123;</span><br><span class="line">    dynamic_cast&lt;B*&gt;(a)-&gt;foo();  // Non-compliant</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void foo(A* a) &#123;</span><br><span class="line">    if (auto* b = dynamic_cast&lt;B*&gt;(a)) &#123;  // Compliant</span><br><span class="line">        b-&gt;foo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 dynamic_cast 会产生一定的开销，如果不对其结果作判断，还不如使用 static_cast 等转换，但本规则集合不建议采用非 dynamic_cast 的动态类型转换，参见 ID_nonDynamicDownCast。<br><br/><br><br/></p>
<h4 id="相关-238"><a href="#相关-238" class="headerlink" title="相关"></a>相关</h4><p>ID_nonDynamicDownCast<br><br/></p>
<h4 id="依据-205"><a href="#依据-205" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 14882:2003 5.2.7(9)<br>ISO/IEC 14882:2011 5.2.7(9)<br><br/></p>
<h4 id="参考-370"><a href="#参考-370" class="headerlink" title="参考"></a>参考</h4><p>CWE-476<br>C++ Core Guidelines C.148<br><br/><br><br/></p>
<h3 id="▌R14-18-指针在释放后应置空"><a href="#▌R14-18-指针在释放后应置空" class="headerlink" title="▌R14.18 指针在释放后应置空"></a><span id="missingresetnull">▌R14.18 指针在释放后应置空</span></h3><p>ID_missingResetNull&emsp;&emsp;&emsp;&emsp;&nbsp;:bulb: pointer suggestion</p>
<hr/>

<p>内存空间被回收后相关指针不再有效，这时应将指针设为空指针，可避免重复释放等问题，如果后续对指针有错误访问，也可使问题立即显现出来，便于修正。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class T &#123;</span><br><span class="line">    int* p = new int[123];</span><br><span class="line">    ....</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">   ~T() &#123;</span><br><span class="line">        dealloc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void dealloc() &#123;</span><br><span class="line">        delete[] p;</span><br><span class="line">        p = nullptr;    // Good</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>例中 dealloc 函数释放指针 p 后将其置为空指针，如果 dealloc 函数被外界反复调用也没有问题。本规则是对“指针悬挂”等问题的有效措施，参见 ID_danglingDeref。<br><br/><br><br/></p>
<h4 id="相关-239"><a href="#相关-239" class="headerlink" title="相关"></a>相关</h4><p>ID_danglingDeref<br>ID_explicitDtorCall<br><br/></p>
<h4 id="参考-371"><a href="#参考-371" class="headerlink" title="参考"></a>参考</h4><p>SEI CERT MEM01-C<br><br/><br><br/></p>
<h2 id="15-Interruption"><a href="#15-Interruption" class="headerlink" title="15. Interruption"></a><span id="interruption">15. Interruption</span></h2><h3 id="▌R15-1-避免由信号处理产生的数据竞争"><a href="#▌R15-1-避免由信号处理产生的数据竞争" class="headerlink" title="▌R15.1 避免由信号处理产生的数据竞争"></a><span id="sig_dataraces">▌R15.1 避免由信号处理产生的数据竞争</span></h3><p>ID_sig_dataRaces&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: interruption warning</p>
<hr/>

<p>异步信号处理函数的调用会随时打断主程序的流程，当处理函数返回后，主程序在被打断的位置继续执行，这种方式称为“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Interrupt">中断（interrupt）</a>”，与执行非并发的线程相似，但没有锁等同步机制，而且信号处理函数本身也可能被中断，所以在信号处理函数中访问共享数据应格外小心。  </p>
<p>异步信号处理函数的安全模式：  </p>
<ul>
<li>调用“<a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man7/signal-safety.7.html">异步信号安全</a>”函数执行清理或结束进程，如 abort、_Exit 等  </li>
<li>对 volatile sig_atomic_t 等类型的共享对象赋值，主程序周期性地检查共享对象并执行相应动作  </li>
<li>利用 sigsetjmp、siglongjmp 等函数使流程跳转到主程序中的预定位置  </li>
<li>通过管道等方式与主程序通信，向管道写入一个字节，主程序监控该管道并执行相应动作  </li>
</ul>
<p>只应选择其中一种方式，且尽量避免访问共享数据，否则对共享数据的错误处理会使程序产生未定义的行为。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">char msg[32];</span><br><span class="line"></span><br><span class="line">void handler(int signum) &#123;</span><br><span class="line">    strcpy(msg, &quot;SIGINT received&quot;);      // Non-compliant</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    signal(SIGINT, handler);</span><br><span class="line">    strcpy(msg, &quot;No signal received&quot;);   // Race condition</span><br><span class="line">    ....</span><br><span class="line">    printf(&quot;%s\n&quot;, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中信号处理函数和主程序均访问了共享数据，handler 中的 strcpy 可以在 main 中的 strcpy 执行之前或中途执行，造成非预期的结果。  </p>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">volatile sig_atomic_t flag = 0;</span><br><span class="line"></span><br><span class="line">void handler(int signum) &#123;</span><br><span class="line">    flag = 1;                // Compliant</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    signal(SIGINT, handler);</span><br><span class="line">    ....</span><br><span class="line">    printf(&quot;%s received\n&quot;, flag? &quot;SIGINT&quot;: &quot;No signal&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用 SIG_ATOMIC_MIN 和 SIG_ATOMIC_MAX 之间的值对 sig_atomic_t 类型的对象赋值可以保证原子性，超出范围的赋值，或赋值之外的操作不能保证原子性，需要避免。<br><br/><br><br/></p>
<h4 id="相关-240"><a href="#相关-240" class="headerlink" title="相关"></a>相关</h4><p>ID_dataRaces<br>ID_sig_nonAsyncSafeCall<br><br/></p>
<h4 id="依据-206"><a href="#依据-206" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 7.14.1.1(5)-undefined<br>ISO/IEC 9899:2011 7.14.1.1(5)-undefined<br>ISO/IEC 14882:2003 1.9(9)-undefined<br>ISO/IEC 14882:2011 1.9(6)-undefined<br><br/></p>
<h4 id="参考-372"><a href="#参考-372" class="headerlink" title="参考"></a>参考</h4><p>SEI CERT SIG31-C<br><br/><br><br/></p>
<h3 id="▌R15-2-处理信号时避免使用非异步信号安全函数"><a href="#▌R15-2-处理信号时避免使用非异步信号安全函数" class="headerlink" title="▌R15.2 处理信号时避免使用非异步信号安全函数"></a><span id="sig_nonasyncsafecall">▌R15.2 处理信号时避免使用非异步信号安全函数</span></h3><p>ID_sig_nonAsyncSafeCall&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: interruption warning</p>
<hr/>

<p>不处理共享数据也不会影响程序状态的函数，以及不会被信号中断的函数称为“<a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man7/signal-safety.7.html">异步信号安全</a>”函数，处理信号时只应使用这种函数。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;signal.h&gt;</span><br><span class="line"></span><br><span class="line">void handler(int signum) &#123;</span><br><span class="line">    printf(&quot;....&quot;);          // Non-compliant</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    signal(SIGINT, handler);</span><br><span class="line">    printf(&quot;....&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>printf 不是异步信号安全函数，例中两个 printf 的输出结果可能会交织在一起，甚至会产生运行时错误。<br><br/><br><br/></p>
<h4 id="相关-241"><a href="#相关-241" class="headerlink" title="相关"></a>相关</h4><p>ID_sig_dataRaces<br>ID_dataRaces<br><br/></p>
<h4 id="依据-207"><a href="#依据-207" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 7.14.1.1(5)-undefined<br>ISO/IEC 9899:2011 7.14.1.1(5)-undefined<br><br/></p>
<h4 id="参考-373"><a href="#参考-373" class="headerlink" title="参考"></a>参考</h4><p>SEI CERT SIG30-C<br><br/><br><br/></p>
<h3 id="▌R15-3-SIGFPE、SIGILL、SIGSEGV-等信号的处理函数不可返回"><a href="#▌R15-3-SIGFPE、SIGILL、SIGSEGV-等信号的处理函数不可返回" class="headerlink" title="▌R15.3 SIGFPE、SIGILL、SIGSEGV 等信号的处理函数不可返回"></a><span id="sig_illreturn">▌R15.3 SIGFPE、SIGILL、SIGSEGV 等信号的处理函数不可返回</span></h3><p>ID_sig_illReturn&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: interruption warning</p>
<hr/>

<p>与计算异常相关的信号由不可恢复的错误引起，相关信号处理函数应终止程序的执行，否则导致标准未定义的行为。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;signal.h&gt;</span><br><span class="line"></span><br><span class="line">void handler(int signum) &#123;</span><br><span class="line">    ....</span><br><span class="line">    return;   // Non-compliant</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    signal(SIGFPE, handler);</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当发生除 0 等计算异常时，程序会收到 SIGFPE 信号，这种信号对应的处理函数应使用 abort、_Exit 等函数终止程序的执行，不可正常返回，否则可能会造成更严重的损失。  </p>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void handler(int signum) &#123;</span><br><span class="line">    ....</span><br><span class="line">    _Exit(1);   // Compliant</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或使用 sigsetjmp 和 siglongjmp 使流程跳转到主程序中的预定位置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">sigjmp_buf buf;</span><br><span class="line"></span><br><span class="line">void handler(int x) &#123;</span><br><span class="line">    siglongjmp(buf, 1);   // Compliant</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    signal(SIGFPE, handler);</span><br><span class="line">    if (sigsetjmp(buf, 1)) &#123;</span><br><span class="line">        ....                   // #1, Normal procedure</span><br><span class="line">        return 0;              // Normal exit</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        ....                   // #2, handle error</span><br><span class="line">        return 1;              // Abnormal exit</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这种模式下，<code>#1</code> 实现程序的功能，如果收到了 SIGFPE 信号，流程就会跳转到 <code>#2</code>。<br><br/><br><br/></p>
<h4 id="依据-208"><a href="#依据-208" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 7.14.1.1(3)-undefined<br>ISO/IEC 9899:2011 7.14.1.1(3)-undefined<br><br/></p>
<h4 id="参考-374"><a href="#参考-374" class="headerlink" title="参考"></a>参考</h4><p>SEI CERT SIG35-C<br><br/><br><br/></p>
<h3 id="▌R15-4-禁用-signal-函数"><a href="#▌R15-4-禁用-signal-函数" class="headerlink" title="▌R15.4 禁用 signal 函数"></a><span id="forbidsignalfunction">▌R15.4 禁用 signal 函数</span></h3><p>ID_forbidSignalFunction&emsp;&emsp;&emsp;&emsp;&nbsp;:no_entry: interruption suggestion</p>
<hr/>

<p>signal 函数具有一定的局限性，且各平台实现差异较大，可用 sigaction 函数代替。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;signal.h&gt;</span><br><span class="line"></span><br><span class="line">void handler(int signum) &#123;     // #1</span><br><span class="line">    signal(signum, handler);   // #2, non-compliant, race condition</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设例中 handler 是某种信号的处理函数。在某些平台上，signal 指定的函数只能被执行一次，所以需要在 handler 中再次调用 signal 指定处理函数，但如果程序在运行到 <code>#1</code> 和 <code>#2</code> 之间时收到同样的信号，会执行不符合预期的默认处理函数，这是一种竞态条件；而在另一些平台上，signal 指定的函数会一直有效，handler 再次调用 signal 是多余的。  </p>
<p>sigaction 函数不存在这些问题，也可提供更多的功能，但要注意该函数尚未在语言标准中定义。<br><br/><br><br/></p>
<h4 id="相关-242"><a href="#相关-242" class="headerlink" title="相关"></a>相关</h4><p>ID_signalInMultiThreading<br>ID_implementationDefinedFunction<br><br/></p>
<h4 id="依据-209"><a href="#依据-209" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 7.14.1.1(3)-implementation<br>ISO/IEC 9899:2011 7.14.1.1(3)-implementation<br>ISO/IEC 9899:2011 7.14.1.1(7)-undefined<br><br/></p>
<h4 id="参考-375"><a href="#参考-375" class="headerlink" title="参考"></a>参考</h4><p>MISRA C 2012 21.5<br>MISRA C++ 2008 18-7-1<br>SEI CERT SIG01-C<br>SEI CERT SIG34-C<br><br/><br><br/></p>
<h2 id="16-Concurrency"><a href="#16-Concurrency" class="headerlink" title="16. Concurrency"></a><span id="concurrency">16. Concurrency</span></h2><h3 id="▌R16-1-访问共享数据应遵循合理的同步机制"><a href="#▌R16-1-访问共享数据应遵循合理的同步机制" class="headerlink" title="▌R16.1 访问共享数据应遵循合理的同步机制"></a><span id="dataraces">▌R16.1 访问共享数据应遵循合理的同步机制</span></h3><p>ID_dataRaces&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: concurrency warning</p>
<hr/>

<p>如果一份数据同时被多个线程、进程或中断处理过程读写，会产生不确定的结果，这种情况称为“<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/memory_model#Threads_and_data_races">数据竞争（data race）</a>”，会导致标准未定义的行为，应落实合理的同步机制来控制访问共享数据的先后顺序。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int foo() &#123;</span><br><span class="line">    static int id = 0;</span><br><span class="line">    return id++;        // Data races in multithreading</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数意在每次被调用都可以返回不同的整数，但如果多个线程同时执行 id++，会使读取、计算、写入等步骤交织在一起，得到错误的结果，这是一种典型的数据竞争。  </p>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int foo() &#123;</span><br><span class="line">    static atomic&lt;int&gt; id(0);</span><br><span class="line">    return id.fetch_add(1);    // OK</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 atomic 是 C++ 标准原子类，fetch_add 将对象持有的整数增 1 并返回之前的值，这个过程不会被多个线程同时执行，只能依次执行，从而保证了返回值的唯一性和正确性。  </p>
<p>对共享数据访问次序的控制称为“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Synchronization_(computer_science">同步（synchronization）</a>)”，可使用锁、条件变量、原子操作等方法实现对线程的同步。与共享数据相关，但未落实同步机制的函数不应在多线程环境中使用，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">asctime         // use asctime_r or asctime_s instead</span><br><span class="line">ctime           // use ctime_r or ctime_s instead</span><br><span class="line">localtime       // use localtime_r or localtime_s instead</span><br><span class="line">gmtime          // use gmtime_r or gmtime_s instead</span><br><span class="line">strtok          // use strtok_r or strtok_s instead</span><br><span class="line">strerror        // use strerror_r or strerror_s instead</span><br><span class="line">tmpnam          // use tmpnam_r or tmpnam_s instead</span><br><span class="line">setlocale       // use mutex to protect multithreaded access</span><br><span class="line">rand, srand     // use random, srandom or BCryptGenRandom instead</span><br></pre></td></tr></table></figure>
<p>与线程同步不同，中断处理过程的同步较为特殊，可参见 ID_sig_dataRaces 的进一步讨论。  </p>
<p>考虑比数据竞争更高层面的问题，如果程序的正确性依赖进线程处理数据的特定时序，一旦这种特定时序被打破便会产生错误或漏洞，攻击者可以抢在某关键过程前后通过修改共享数据达到攻击目的，这种情况称为“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Race_condition">竞态条件（race condition）</a>”，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int* p = get_shared();   // #0, ‘p’ points to shared data</span><br><span class="line">if (*p == 0) &#123;           // #1, ‘*p’ is unreliable</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line">else if (*p == 1) &#123;      // #2, ‘*p’ is unreliable</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line">else &#123;                   // #3</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 p 指向共享数据，那么攻击者可以通过修改共享数据实现对程序流程的劫持，比如在 <code>#0</code> 处 *p 的值本为 0，攻击者在 <code>#1</code> 之前改变 *p 的值，迫使流程向 <code>#2</code> 或 <code>#3</code> 处跳转。  </p>
<p>关于竞态条件的进一步讨论可参见 ID_TOCTOU、ID_forbidSignalFunction 等规则。<br><br/><br><br/></p>
<h4 id="相关-243"><a href="#相关-243" class="headerlink" title="相关"></a>相关</h4><p>ID_sig_dataRaces<br>ID_sig_nonAsyncSafeCall<br><br/></p>
<h4 id="依据-210"><a href="#依据-210" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:2011 5.1.2.4(3)-undefined<br>ISO/IEC 9899:2011 5.1.2.4(20)-undefined<br>ISO/IEC 9899:2011 5.1.2.4(25)-undefined<br><br/></p>
<h4 id="参考-376"><a href="#参考-376" class="headerlink" title="参考"></a>参考</h4><p>CWE-362<br>C++ Core Guidelines CP.2<br>SEI CERT CON33-C<br>SEI CERT CON43-C<br><br/><br><br/></p>
<h3 id="▌R16-2-避免在事务中通过路径多次访问同一文件"><a href="#▌R16-2-避免在事务中通过路径多次访问同一文件" class="headerlink" title="▌R16.2 避免在事务中通过路径多次访问同一文件"></a><span id="toctou">▌R16.2 避免在事务中通过路径多次访问同一文件</span></h3><p>ID_TOCTOU&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: concurrency warning</p>
<hr/>

<p>攻击者可以在两次通过路径访问文件的中途对文件做手脚，从而造成不良后果。  </p>
<p>这种问题称为“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Time-of-check_to_time-of-use">TOCTOU（Time-of-check to time-of-use）</a>”。有时需要先检查文件的某种状态，如果状态满足条件的话，再使用该文件，如果“检查”和“使用”都是通过路径完成的，攻击者可以在中途将文件替换成不满足条件的文件，如将文件替换成指向另一个文件的链接，从而对系统造成破坏，这是一种典型的“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Race_condition">竞态条件</a>”。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void create(const char* path) &#123;</span><br><span class="line">    FILE* fp = fopen(path, &quot;r&quot;);</span><br><span class="line">    if (fp != NULL) &#123;              // #1, time-of-check</span><br><span class="line">        fclose(fp);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    fp = fopen(path, &quot;w&quot;);         // #2, time-of-use, non-compliant</span><br><span class="line">    if (fp != NULL) &#123;</span><br><span class="line">        fwrite(&quot;abc&quot;, 1, 3, fp);</span><br><span class="line">        fclose(fp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例代码先通过路径判断文件是否存在，如果存在则不作处理，如果不存在则再次通过路径创建文件并写入数据。如果攻击者把握住时机，在程序执行到 <code>#1</code> 和 <code>#2</code> 之间时按 path 创建指向其他文件的链接，那么被指向的文件会遭到破坏，尤其是当被攻击的进程权限比较高时，破坏力是难以控制的。  </p>
<p>应只通过路径打开文件对象一次，只通过文件对象操作文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void create(const char* path) &#123;</span><br><span class="line">    FILE* fp = fopen(path, &quot;wx&quot;);   // Compliant, since C11</span><br><span class="line">    if (fp != NULL) &#123;</span><br><span class="line">        fwrite(&quot;abc&quot;, 1, 3, fp);</span><br><span class="line">        fclose(fp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>利用“wx”模式即可保证 fopen 在文件不存在时创建文件，文件存在时返回空。  </p>
<p>注意，目前 C++ 的 fstream 尚无法完成与“wx”模式相同的功能，相同功能的代码要用 fopen 实现。<br><br/><br><br/></p>
<h4 id="依据-211"><a href="#依据-211" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 7.19.5.3(3)<br>ISO/IEC 9899:2011 7.21.5.3(3)<br><br/></p>
<h4 id="参考-377"><a href="#参考-377" class="headerlink" title="参考"></a>参考</h4><p>CWE-367<br><br/><br><br/></p>
<h3 id="▌R16-3-避免在事务中多次非同步地访问原子对象"><a href="#▌R16-3-避免在事务中多次非同步地访问原子对象" class="headerlink" title="▌R16.3 避免在事务中多次非同步地访问原子对象"></a><span id="atomicraces">▌R16.3 避免在事务中多次非同步地访问原子对象</span></h3><p>ID_atomicRaces&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: concurrency warning</p>
<hr/>

<p>原子对象可以保证某些特定操作的原子性，但特定操作的组合并不具备原子性，非同步地访问原子对象仍然存在数据竞争。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">atomic_int i = ATOMIC_VAR_INIT(0);</span><br><span class="line"></span><br><span class="line">void thd() &#123;</span><br><span class="line">    i = i + 1;   // Non-compliant, data races</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设 thd 为线程函数，原子对象 i 在表达式中出现了多次，其读取、计算、写入等过程在多线程中仍然是交织在一起的，造成数据竞争。  </p>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void thd() &#123;</span><br><span class="line">    atomic_fetch_add(&amp;i, 1);   // Compliant, or use ‘operator++’ in C++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于一些复杂的原子运算，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = (i + 1) % 5;   // Non-compliant</span><br></pre></td></tr></table></figure>
<p>可采用“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Compare-and-swap">CAS（compare and swap）</a>” 方法同步：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int old_i = atomic_load(&amp;i);</span><br><span class="line">int new_i = 0;</span><br><span class="line">do &#123;</span><br><span class="line">    new_i = (old_i + 1) % 5;</span><br><span class="line">&#125; while (!compare_and_swap(&amp;i, &amp;old_i, new_i));   // Compliant</span><br></pre></td></tr></table></figure>
<p>首先读取原子对象的值 old_i，old_i 经过运算得到新值 new_i，再通过 compare_and_swap 更新原子对象的值。compare_and_swap 具有原子性，将 old_i 和原子对象当前值比较，相等则说明在运算过程中原子对象没有被其他线程更新，将原子对象的值设为 new_i，不相等则说明原子对象已被其他线程更新，将 old_i 设为原子对象当前值，再重复这个过程，直到原子对象可用 new_i 更新。  </p>
<p>compare_and_swap 是重要的原子对象同步手段，在实际代码中可与 atomic_compare_exchange_weak、atomic_compare_exchange_strong 等函数对应。<br><br/><br><br/></p>
<h4 id="相关-244"><a href="#相关-244" class="headerlink" title="相关"></a>相关</h4><p>ID_dataRaces<br><br/></p>
<h4 id="参考-378"><a href="#参考-378" class="headerlink" title="参考"></a>参考</h4><p>SEI CERT CON40-C<br><br/><br><br/></p>
<h3 id="▌R16-4-避免死锁"><a href="#▌R16-4-避免死锁" class="headerlink" title="▌R16.4 避免死锁"></a><span id="deadlock">▌R16.4 避免死锁</span></h3><p>ID_deadlock&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: concurrency warning</p>
<hr/>

<p>对于锁等资源，错误的请求时序或管理方式会使程序永远陷入等待状态，这种问题称为“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Deadlock">死锁（deadlock）</a>”。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mtx_t m;               // Non-recursive mutex</span><br><span class="line"></span><br><span class="line">void foo() &#123;</span><br><span class="line">    mtx_lock(&amp;m);      // Lock the mutex</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void bar() &#123;</span><br><span class="line">    mtx_lock(&amp;m);      // Lock the mutex</span><br><span class="line">    foo();             // Undefined behavior, may deadlock</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设 m 是非递归互斥量，bar 锁定互斥量后调用 foo，而 foo 也会锁定互斥量，导致 foo 等待 bar 解锁，而 foo 返回之前 bar 不可能解锁，这是一种导致死锁的逻辑错误，C11 也明确规定在同一线程中不可重复锁定非递归互斥量。  </p>
<p>另外，线程之间相互等待对方解锁也是死锁的主要原因，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">struct A &#123;</span><br><span class="line">    ....</span><br><span class="line">    mtx_t m;          // Mutex</span><br><span class="line">&#125; a, b;</span><br><span class="line"></span><br><span class="line">void thr1() &#123;</span><br><span class="line">    mtx_lock(&amp;a.m);   // Lock</span><br><span class="line">    mtx_lock(&amp;b.m);</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void thr2() &#123;</span><br><span class="line">    mtx_lock(&amp;b.m);   // Lock in another order</span><br><span class="line">    mtx_lock(&amp;a.m);   // May deadlock</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设 thr1 和 thr2 是两个可以并发执行的函数，如果 a.m 被 thr1 锁定，b.m 被 thr2 锁定，thr1 等待 b.m 解锁，而 thr2 等待 a.m 解锁，这种相互等待导致了死锁的局面。例中 a 和 b 是具名全局对象，在各线程中按统一的顺序加锁可避免死锁。  </p>
<p>在更普遍的情况下，为不同对象加锁前，可使对象按某种内在的标准“排序”，再依次加锁，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct A &#123;</span><br><span class="line">    int id;           // Unique identifier</span><br><span class="line">    ....</span><br><span class="line">    mtx_t m;          // Mutex</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void lock_in_order(A* p, A* q) &#123;</span><br><span class="line">    if (p-&gt;id &gt; q-&gt;id) &#123;</span><br><span class="line">        A* t = p; p = q; q = t;</span><br><span class="line">    &#125;</span><br><span class="line">    mtx_lock(&amp;p-&gt;m);</span><br><span class="line">    mtx_lock(&amp;q-&gt;m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为每个对象分配一个 id 以标识不同的对象，每次 id 小的先加锁，可有效避免相互等待造成的死锁。示例代码忽略了 id 相等的情况，在实际代码中应补全，否则也会造成第一个例子中的问题。<br><br/><br><br/></p>
<h4 id="依据-212"><a href="#依据-212" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:2011 7.26.4.3(2)-undefined<br>ISO/IEC 14882:2011 17.3.8<br><br/></p>
<h4 id="参考-379"><a href="#参考-379" class="headerlink" title="参考"></a>参考</h4><p>SEI CERT CON35-C<br>SEI CERT CON53-CPP<br>SEI CERT CON56-CPP<br><br/><br><br/></p>
<h3 id="▌R16-5-避免异步终止线程"><a href="#▌R16-5-避免异步终止线程" class="headerlink" title="▌R16.5 避免异步终止线程"></a><span id="asynchronoustermination">▌R16.5 避免异步终止线程</span></h3><p>ID_asynchronousTermination&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: concurrency warning</p>
<hr/>

<p>资源的使用情况在异步过程中是难以掌控的，异步终止线程往往会导致泄漏或死锁等严重问题。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void* foo(void* param) &#123;</span><br><span class="line">    pthread_setcanceltype(</span><br><span class="line">        PTHREAD_CANCEL_ASYNCHRONOUS, ....  // Non-compliant</span><br><span class="line">    );</span><br><span class="line">    ....                                   // Allocate or lock</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void bar() &#123;</span><br><span class="line">    pthread_t thd;</span><br><span class="line">    pthread_create(&amp;thd, NULL, foo, NULL);</span><br><span class="line">    ....</span><br><span class="line">    pthread_cancel(thd);   // Non-compliant, leak or deadlock</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以 pthread 线程库为例，foo 和 bar 是两个相关的异步过程，foo 通过 PTHREAD_CANCEL_ASYNCHRONOUS 指定其线程可以随时被终止，bar 调用 pthread_cancel 终止 foo 线程，在一个过程中暴力终止另一个过程是非常危险的，会使锁、信号量或动态分配的资源无法释放。  </p>
<p>PTHREAD_CANCEL_ASYNCHRONOUS 等选项、TerminateThread 等 Windows API，以及具有相同功能的选项或 API 均不应使用，应使线程主动执行清理并正常结束执行。<br><br/><br><br/></p>
<h4 id="相关-245"><a href="#相关-245" class="headerlink" title="相关"></a>相关</h4><p>ID_resourceLeak<br>ID_deadlock<br>ID_illLifetime<br><br/></p>
<h4 id="参考-380"><a href="#参考-380" class="headerlink" title="参考"></a>参考</h4><p>SEI CERT POS47-C<br><br/><br><br/></p>
<h3 id="▌R16-6-避免异步终止共享对象的生命周期"><a href="#▌R16-6-避免异步终止共享对象的生命周期" class="headerlink" title="▌R16.6 避免异步终止共享对象的生命周期"></a><span id="illlifetime">▌R16.6 避免异步终止共享对象的生命周期</span></h3><p>ID_illLifetime&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: concurrency warning</p>
<hr/>

<p>共享对象的使用情况在异步过程中是难以掌控的，贸然终止共享对象的生命周期往往会导致标准未定义的行为。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void foo(mutex* pm) &#123;</span><br><span class="line">    lock(pm);</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void bar() &#123;</span><br><span class="line">    mutex m;</span><br><span class="line">    beginThread(foo, &amp;m);   // Non-compliant, ‘m’ is a local object</span><br><span class="line">    beginThread(foo, &amp;m);   // Non-compliant</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设例中 beginThread 创建执行 foo 函数的线程，bar 与 foo 是异步过程，共享对象 m 在 bar 返回后失效，如果 foo 继续访问共享对象就会出错，bar 应等待线程执行完毕或调整共享对象的生命周期。<br><br/><br><br/></p>
<h4 id="相关-246"><a href="#相关-246" class="headerlink" title="相关"></a>相关</h4><p>ID_asynchronousTermination<br>ID_localAddressFlowOut<br>ID_danglingDeref<br><br/></p>
<h4 id="依据-213"><a href="#依据-213" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 14882:2011 30.4.1.2.1(5)-undefined<br>ISO/IEC 14882:2017 33.4.3.2.1(5)-undefined<br><br/></p>
<h4 id="参考-381"><a href="#参考-381" class="headerlink" title="参考"></a>参考</h4><p>SEI CERT CON31-C<br>SEI CERT CON50-CPP<br><br/><br><br/></p>
<h3 id="▌R16-7-避免虚假唤醒造成同步错误"><a href="#▌R16-7-避免虚假唤醒造成同步错误" class="headerlink" title="▌R16.7 避免虚假唤醒造成同步错误"></a><span id="spuriouslywakeup">▌R16.7 避免虚假唤醒造成同步错误</span></h3><p>ID_spuriouslyWakeUp&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: concurrency warning</p>
<hr/>

<p>条件不满足时条件变量也可以被唤醒，这种情况称为“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Spurious_wakeup">虚假唤醒（spurious wakeup）</a>”，条件变量被唤醒后应检查相关条件是否满足，否则会造成同步相关的错误。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mtx_t m;    // Mutex</span><br><span class="line">cnd_t cv;   // Condition variable</span><br><span class="line">bool cnd;   // Represents the condition</span><br><span class="line"></span><br><span class="line">void thd() &#123;                 // Thread function</span><br><span class="line">    mtx_lock(&amp;m);            // Lock</span><br><span class="line">    if (!cnd) &#123;              // Non-compliant, use a while loop instead</span><br><span class="line">        cnd_wait(&amp;cv, &amp;m);   // Wait</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设例中 cv 是条件变量，cnd 代表相关条件，cnd_wait 等待条件被其他异步过程满足，条件的判断与更改应是互斥的，cnd_wait 会解锁并进入等待状态，当得到 cnd_signal 或 cnd_broadcast 的通知后会退出等待状态并再次加锁，但在条件不满足时也可能退出等待，原因主要有：  </p>
<ul>
<li>一个条件变量对应多个条件，与当前条件无关的条件被满足并通知了条件变量  </li>
<li>在退出等待并加锁的过程中其他线程使条件不被满足  </li>
<li>等待过程被信号打断  </li>
</ul>
<p>这些问题取决于程序和系统的具体实现，在循环中等待并判断条件可一并解决这些问题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void thd() &#123;</span><br><span class="line">    mtx_lock(&amp;m);</span><br><span class="line">    while (!cnd) &#123;           // Compliant</span><br><span class="line">        cnd_wait(&amp;cv, &amp;m);</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="参考-382"><a href="#参考-382" class="headerlink" title="参考"></a>参考</h4><p>SEI CERT CON36-C<br>SEI CERT CON54-CPP<br><br/><br><br/></p>
<h3 id="▌R16-8-避免并发访问位域造成的数据竞争"><a href="#▌R16-8-避免并发访问位域造成的数据竞争" class="headerlink" title="▌R16.8 避免并发访问位域造成的数据竞争"></a><span id="bitfielddataraces">▌R16.8 避免并发访问位域造成的数据竞争</span></h3><p>ID_bitfieldDataRaces&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: concurrency warning</p>
<hr/>

<p>相邻的位域成员可能在一个存储单元中，所以并发访问位域也可能造成数据竞争。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct A &#123;</span><br><span class="line">    unsigned x: 1;</span><br><span class="line">    unsigned y: 1;</span><br><span class="line">&#125; a;</span><br><span class="line"></span><br><span class="line">void thr1() &#123;</span><br><span class="line">    a.x = 0;    // Non-compliant, missing lock</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void thr2() &#123;</span><br><span class="line">    a.y = 1;    // Non-compliant, missing lock</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设例中 thr1 和 thr2 是可以并发执行的函数，位域成员 x 和 y 在一个存储单元中，对 x 或 y 的更新相当于用新数据更新存储单元的值，再将存储单元的值整体写入内存，这个过程如果是异步并发执行的就会产生错误，所以对不同位域成员的并发访问也应保证合理的同步措施。<br><br/><br><br/></p>
<h4 id="相关-247"><a href="#相关-247" class="headerlink" title="相关"></a>相关</h4><p>ID_dataRaces<br>ID_forbidBitfield<br><br/></p>
<h4 id="依据-214"><a href="#依据-214" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:2011 3.14(3)<br>ISO/IEC 14882:2011 1.7(4)<br><br/></p>
<h4 id="参考-383"><a href="#参考-383" class="headerlink" title="参考"></a>参考</h4><p>SEI CERT CON32-C<br>SEI CERT CON52-CPP<br><br/><br><br/></p>
<h3 id="▌R16-9-多线程环境中不可使用-signal-函数"><a href="#▌R16-9-多线程环境中不可使用-signal-函数" class="headerlink" title="▌R16.9 多线程环境中不可使用 signal 函数"></a><span id="signalinmultithreading">▌R16.9 多线程环境中不可使用 signal 函数</span></h3><p>ID_signalInMultiThreading&emsp;&emsp;&emsp;&emsp;&nbsp;:fire: concurrency warning</p>
<hr/>

<p>在多线程环境中使用 signal 函数会导致标准未定义的行为。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;threads.h&gt;</span><br><span class="line"></span><br><span class="line">void handler(int);</span><br><span class="line"></span><br><span class="line">int thread(void* param) &#123;</span><br><span class="line">    signal(SIGINT, handler);  // Non-compliant, undefined behavior</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中 thread 是线程函数，C11 标准指明在多线程环境中使用 signal 函数会导致未定义的行为。<br><br/><br><br/></p>
<h4 id="相关-248"><a href="#相关-248" class="headerlink" title="相关"></a>相关</h4><p>ID_forbidSignalFunction<br><br/></p>
<h4 id="依据-215"><a href="#依据-215" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:2011 7.14.1.1(7)-undefined<br><br/></p>
<h4 id="参考-384"><a href="#参考-384" class="headerlink" title="参考"></a>参考</h4><p>SEI CERT CON37-C<br><br/><br><br/></p>
<h2 id="17-Style"><a href="#17-Style" class="headerlink" title="17. Style"></a><span id="style">17. Style</span></h2><h3 id="▌R17-1-空格应遵循统一风格"><a href="#▌R17-1-空格应遵循统一风格" class="headerlink" title="▌R17.1 空格应遵循统一风格"></a><span id="spacestyle">▌R17.1 空格应遵循统一风格</span></h3><p>ID_spaceStyle&emsp;&emsp;&emsp;&emsp;&nbsp;:womans_hat: style suggestion</p>
<hr/>

<p>与运算符、标点符、关键字相关的空格应遵循统一风格，过于随意的空格会干扰阅读，甚至形成笔误。  </p>
<p>本规则暂不限定具体风格，但强调一致性，同类运算符、标点符、关键字的空格方式应保持一致，tab 等变长空白符不应用作空格。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a= 0;                   // Bad</span><br><span class="line">b = a +1;               // Bad</span><br><span class="line">c =~ a;                 // Bad</span><br><span class="line">while (d --&gt; 0)         // Bad</span><br><span class="line"></span><br><span class="line">a == 0 ? foo() :bar();  // Bad</span><br><span class="line">baz (1 , 2 ,3);         // Bad</span><br><span class="line"></span><br><span class="line">if (cond)</span><br><span class="line">if(cond)                // Missing a unified style</span><br></pre></td></tr></table></figure>
<p>例中运算符和关键字相关的空格风格不一致，代码显得很混乱。  </p>
<p>本规则是 ID_stickyAssignmentOperator 的泛化，该规则描述了一种由空格造成的错误。<br><br/><br><br/></p>
<h4 id="相关-249"><a href="#相关-249" class="headerlink" title="相关"></a>相关</h4><p>ID_stickyAssignmentOperator<br><br/><br><br/></p>
<h3 id="▌R17-2-大括号应遵循统一风格"><a href="#▌R17-2-大括号应遵循统一风格" class="headerlink" title="▌R17.2 大括号应遵循统一风格"></a><span id="bracestyle">▌R17.2 大括号应遵循统一风格</span></h3><p>ID_braceStyle&emsp;&emsp;&emsp;&emsp;&nbsp;:womans_hat: style suggestion</p>
<hr/>

<p>大括号应遵循统一的换行和缩进风格，否则不利于阅读和维护，甚至形成笔误。  </p>
<p>命名空间、类、函数体、复合语句等不同类别的大括号，换行方式可以不同，但同类大括号的换行方式应该是一致的，本规则暂不限定具体风格，但强调一致性。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void foo() &#123;     // Non-compliant, missing a unified style</span><br><span class="line">    if (cond)</span><br><span class="line">    &#123;</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void bar()       // Non-compliant, missing a unified style</span><br><span class="line">&#123;</span><br><span class="line">    if (cond) &#123;</span><br><span class="line">        ....</span><br><span class="line">    &#125; else</span><br><span class="line">    &#123;</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中大括号换行的方式不一致，代码显得很混乱。  </p>
<p>本规则是 ID_if_mayBeElseIf 的泛化，该规则描述了一种由换行造成的错误。<br><br/><br><br/></p>
<h4 id="相关-250"><a href="#相关-250" class="headerlink" title="相关"></a>相关</h4><p>ID_if_mayBeElseIf<br><br/><br><br/></p>
<h3 id="▌R17-3-赋值表达式不应作为子表达式"><a href="#▌R17-3-赋值表达式不应作为子表达式" class="headerlink" title="▌R17.3 赋值表达式不应作为子表达式"></a><span id="assignmentassubexpression">▌R17.3 赋值表达式不应作为子表达式</span></h3><p>ID_assignmentAsSubExpression&emsp;&emsp;&emsp;&emsp;&nbsp;:womans_hat: style suggestion</p>
<hr/>

<p>赋值及复合赋值表达式作为子表达式可读性较差，易产生求值顺序或运算符优先级相关的问题。  </p>
<p>示例（设 a、b、c 为变量）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a = b;    // Compliant</span><br><span class="line">a += b;   // Compliant</span><br><span class="line"></span><br><span class="line">while (a = b) &#123;   // Non-compliant</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line">if (a = b != 0) &#123;   // Non-compliant</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line">a += b += c;     // Non-compliant</span><br><span class="line">fun(a = b, c);   // Non-compliant</span><br></pre></td></tr></table></figure>
<p>连续赋值是一种惯用方式，但不值得提倡，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = b = c;   // Let it go?</span><br></pre></td></tr></table></figure>
<p>审计工具不妨通过配置决定是否放过这种方式。<br><br/><br><br/></p>
<h4 id="配置-43"><a href="#配置-43" class="headerlink" title="配置"></a>配置</h4><p>allowSuccessiveAssignment：是否允许连续赋值<br><br/></p>
<h4 id="相关-251"><a href="#相关-251" class="headerlink" title="相关"></a>相关</h4><p>ID_if_assignment<br><br/></p>
<h4 id="参考-385"><a href="#参考-385" class="headerlink" title="参考"></a>参考</h4><p>CWE-481<br>MISRA C 2004 13.1<br>MISRA C 2012 13.4<br>MISRA C++ 2008 6-2-1<br><br/><br><br/></p>
<h3 id="▌R17-4-自增、自减表达式不应作为子表达式"><a href="#▌R17-4-自增、自减表达式不应作为子表达式" class="headerlink" title="▌R17.4 自增、自减表达式不应作为子表达式"></a><span id="incdecassubexpression">▌R17.4 自增、自减表达式不应作为子表达式</span></h3><p>ID_incDecAsSubExpression&emsp;&emsp;&emsp;&emsp;&nbsp;:womans_hat: style suggestion</p>
<hr/>

<p>自增、自减表达式作为子表达式易使人费解，也易产生求值顺序相关的问题。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = ++b + c--;   // Non-compliant</span><br></pre></td></tr></table></figure>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">++b;             // Compliant</span><br><span class="line">a = b + c;</span><br><span class="line">c--;             // Compliant</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="相关-252"><a href="#相关-252" class="headerlink" title="相关"></a>相关</h4><p>ID_evaluationOrderReliance<br><br/></p>
<h4 id="参考-386"><a href="#参考-386" class="headerlink" title="参考"></a>参考</h4><p>MISRA C 2012 13.3<br>MISRA C++ 2008 5-2-10<br><br/><br><br/></p>
<h3 id="▌R17-5-控制条件应为-bool-型表达式"><a href="#▌R17-5-控制条件应为-bool-型表达式" class="headerlink" title="▌R17.5 控制条件应为 bool 型表达式"></a><span id="nonboolcondition">▌R17.5 控制条件应为 bool 型表达式</span></h3><p>ID_nonBoolCondition&emsp;&emsp;&emsp;&emsp;&nbsp;:womans_hat: style suggestion</p>
<hr/>

<p>如果控制条件均为 bool 型表达式，可使逻辑结构更清晰，有效避免隐式类型转换造成的问题。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void foo(int* p, size_t n, bool b)</span><br><span class="line">&#123;</span><br><span class="line">    if (p) &#123;     // Non-compliant</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">    if (n) &#123;     // Non-compliant</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">    if (b) &#123;     // Compliant</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中 p 和 n 不应直接作为条件，b 为 bool 型，可直接作为条件。  </p>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void foo(int* p, size_t n, bool b)</span><br><span class="line">&#123;</span><br><span class="line">    if (p != NULL) &#123;   // Compliant</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">    if (n != 0) &#123;      // Compliant</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>循环条件、三元表达式的条件等所有可作为控制条件的表达式均受本规则限制。  </p>
<p>例外：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (int* p = bar()) &#123;  // Let it go</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>C++03 允许将声明作为条件，这种情况可不受本规则限制。<br><br/><br><br/></p>
<h4 id="相关-253"><a href="#相关-253" class="headerlink" title="相关"></a>相关</h4><p>ID_nonBoolSubCondition<br><br/></p>
<h4 id="参考-387"><a href="#参考-387" class="headerlink" title="参考"></a>参考</h4><p>MISRA C 2012 14.4<br>MISRA C++ 2008 5-0-13<br>MISRA C++ 2008 5-0-14<br><br/><br><br/></p>
<h3 id="▌R17-6-、-amp-amp-、-的子表达式应为-bool-型表达式"><a href="#▌R17-6-、-amp-amp-、-的子表达式应为-bool-型表达式" class="headerlink" title="▌R17.6 !、&amp;&amp;、|| 的子表达式应为 bool 型表达式"></a><span id="nonboolsubcondition">▌R17.6 !、&amp;&amp;、|| 的子表达式应为 bool 型表达式</span></h3><p>ID_nonBoolSubCondition&emsp;&emsp;&emsp;&emsp;&nbsp;:womans_hat: style suggestion</p>
<hr/>

<p>如果 !、&amp;&amp;、|| 的子表达式均为 bool 型表达式，可使逻辑结构更清晰，有效避免隐式类型转换或运算符误用造成的问题。  </p>
<p>示例（设 p 为指针，a、b、c 为整型变量）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (!p)             // Non-compliant </span><br><span class="line">if (a &amp;&amp; b)         // Non-compliant</span><br><span class="line">if (a || (b + c))   // Non-compliant</span><br></pre></td></tr></table></figure>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (p == NULL)                  // Compliant </span><br><span class="line">if ((a != 0) &amp;&amp; (b != 0))       // Compliant </span><br><span class="line">if ((a != 0) || (b + c != 0))   // Compliant</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="相关-254"><a href="#相关-254" class="headerlink" title="相关"></a>相关</h4><p>ID_nonBoolCondition<br>ID_illBoolOperation<br><br/></p>
<h4 id="参考-388"><a href="#参考-388" class="headerlink" title="参考"></a>参考</h4><p>MISRA C++ 2008 5-3-1<br><br/><br><br/></p>
<h3 id="▌R17-7-amp-amp-、-的子表达式应为后缀表达式"><a href="#▌R17-7-amp-amp-、-的子表达式应为后缀表达式" class="headerlink" title="▌R17.7 &amp;&amp;、|| 的子表达式应为后缀表达式"></a><span id="nonpostfixsubcondition">▌R17.7 &amp;&amp;、|| 的子表达式应为后缀表达式</span></h3><p>ID_nonPostfixSubCondition&emsp;&emsp;&emsp;&emsp;&nbsp;:womans_hat: style suggestion</p>
<hr/>

<p>如果 &amp;&amp;、|| 的子表达式均为后缀表达式，可使逻辑结构更清晰，有效避免各种优先级问题。  </p>
<p>后缀表达式（postfix-expression）是 C/C++ 语言的文法概念，也是一类表达式的总称：  </p>
<ul>
<li>只包含标识符或常量的表达式  </li>
<li>用小括号括起来的表达式  </li>
<li>用于数组元素求值的 [ ] 表达式  </li>
<li>函数调用、函数式类型转换表达式  </li>
<li>.、-&gt; 表达式  </li>
<li>后置 ++、-- 表达式  </li>
<li>typeid 等表达式  </li>
</ul>
<p>本规则意在强调子表达式应适当地用括号括起来，以便提高可读性，并确保程序的行为符合开发者的意图。  </p>
<p>示例（设 a、b、c 为 bool 型变量，n 为整型变量）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (n == 0 &amp;&amp; b) &#123;   // Non-compliant </span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中 n == 0 不是后缀表达式，应使用括号括起来：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if ((n == 0) &amp;&amp; b) &#123;   // Compliant </span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>又如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (a || b &amp;&amp; c) &#123;   // Non-compliant</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即使知道 &amp;&amp; 的优先级高于 ||，也应使用括号将 || 的子表达式括起来，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (a || (b &amp;&amp; c)) &#123;   // Compliant</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例外：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (a || b || c)) &#123;   // Compliant</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当 &amp;&amp;、|| 的子表达式运算符与其相同时，可不受本规则约束。<br><br/><br><br/></p>
<h4 id="依据-216"><a href="#依据-216" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 9899:1999 6.5.2(1)<br>ISO/IEC 9899:2011 6.5.2(1)<br>ISO/IEC 14882:2003 5.2(1)<br>ISO/IEC 14882:2011 5.2(1)<br><br/></p>
<h4 id="参考-389"><a href="#参考-389" class="headerlink" title="参考"></a>参考</h4><p>MISRA C++ 2008 5-2-1<br><br/><br><br/></p>
<h3 id="▌R17-8-在-C-代码中-NULL-和-nullptr-不应混用"><a href="#▌R17-8-在-C-代码中-NULL-和-nullptr-不应混用" class="headerlink" title="▌R17.8 在 C++ 代码中 NULL 和 nullptr 不应混用"></a><span id="mixnullptrandnull">▌R17.8 在 C++ 代码中 NULL 和 nullptr 不应混用</span></h3><p>ID_mixNullptrAndNULL&emsp;&emsp;&emsp;&emsp;&nbsp;:womans_hat: style warning</p>
<hr/>

<p>在 C++ 代码中 NULL 和 nullptr 不应混用，应统一使用 nullptr。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void foo(int* a = NULL, int* b = nullptr);    // Non-compliant</span><br><span class="line">void bar(int* a = nullptr, int* b = nullptr);    // Compliant</span><br></pre></td></tr></table></figure>
<p><br/><br><br/></p>
<h4 id="相关-255"><a href="#相关-255" class="headerlink" title="相关"></a>相关</h4><p>ID_deprecatedNULL<br><br/></p>
<h4 id="参考-390"><a href="#参考-390" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines ES.47<br><br/><br><br/></p>
<h3 id="▌R17-9-在-C-代码中用-nullptr-代替-NULL"><a href="#▌R17-9-在-C-代码中用-nullptr-代替-NULL" class="headerlink" title="▌R17.9 在 C++ 代码中用 nullptr 代替 NULL"></a><span id="deprecatednull">▌R17.9 在 C++ 代码中用 nullptr 代替 NULL</span></h3><p>ID_deprecatedNULL&emsp;&emsp;&emsp;&emsp;&nbsp;:womans_hat: style suggestion</p>
<hr/>

<p>标识符 NULL 由实现定义，在 C++ 语言中往往等同于常量 0，无法有效区分整数与指针，用 nullptr 可避免这种问题。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void foo(int) &#123;</span><br><span class="line">    cout &lt;&lt; &quot;foo-1\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void foo(int*) &#123;</span><br><span class="line">    cout &lt;&lt; &quot;foo-2\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    foo(NULL);  // Non-compliant, what is output?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>NULL 表示空指针，所以应该调用参数为指针的重载函数，但不同的编译器对这段代码有不同的处理，有的无法通过编译，有的编译执行后会输出 foo-1，用 nullptr 代替 NULL 可解决这种问题。<br><br/><br><br/></p>
<h4 id="依据-217"><a href="#依据-217" class="headerlink" title="依据"></a>依据</h4><p>ISO/IEC 14882:2003 C.2.2.3(1)-implementation<br>ISO/IEC 14882:2011 2.14.7(1)<br>ISO/IEC 14882:2011 C.3.2.4(1)-implementation<br>ISO/IEC 14882:2017 C.5.2.7(1)-implementation<br><br/></p>
<h4 id="参考-391"><a href="#参考-391" class="headerlink" title="参考"></a>参考</h4><p>C++ Core Guidelines ES.47<br><br/><br><br/></p>
<h3 id="▌R17-10-避免多余的括号"><a href="#▌R17-10-避免多余的括号" class="headerlink" title="▌R17.10 避免多余的括号"></a><span id="redundantparentheses">▌R17.10 避免多余的括号</span></h3><p>ID_redundantParentheses&emsp;&emsp;&emsp;&emsp;&nbsp;:womans_hat: style suggestion</p>
<hr/>

<p>重复的或与优先级无关的括号使代码显得繁琐，应去掉。  </p>
<p>宏定义中的括号不受本规则限制。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = 1 + (p[0]);      // Non-compliant</span><br><span class="line">a = 2 + (p-&gt;n);      // Non-compliant</span><br><span class="line">a = (fun(x));        // Non-compliant</span><br><span class="line">a = ((u + v)) * w;   // Non-compliant</span><br></pre></td></tr></table></figure>
<p>例中括号均作用于“后缀表达式”，与优先级无关。可参见 ID_nonPostfixSubCondition 对“后缀表达式”的说明。  </p>
<p>应去掉多余的括号：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = 1 + p[0];        // Compliant</span><br><span class="line">a = 2 + p-&gt;n;        // Compliant</span><br><span class="line">a = fun(x);          // Compliant</span><br><span class="line">a = (u + v) * w;     // Compliant</span><br></pre></td></tr></table></figure>
<p>注意，设立本规则并不是为了提倡省略括号，如果可以更好地表达逻辑意义，或不确定运算符优先级时，应及时使用括号。<br><br/><br><br/></p>
<h4 id="参考-392"><a href="#参考-392" class="headerlink" title="参考"></a>参考</h4><p>MISRA C++ 2008 5-0-2<br><br/><br><br/></p>
<h3 id="▌R17-11-避免多余的分号"><a href="#▌R17-11-避免多余的分号" class="headerlink" title="▌R17.11 避免多余的分号"></a><span id="redundantsemicolon">▌R17.11 避免多余的分号</span></h3><p>ID_redundantSemicolon&emsp;&emsp;&emsp;&emsp;&nbsp;:womans_hat: style suggestion</p>
<hr/>

<p>多余的分号使代码显得繁琐，也可能意味着某种错误，应去掉。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">namespace N &#123;</span><br><span class="line">    void foo() &#123;</span><br><span class="line">        bar();;    // Non-compliant</span><br><span class="line">    &#125;;             // Non-compliant</span><br><span class="line">&#125;;                 // Non-compliant</span><br></pre></td></tr></table></figure>
<p><br/><br><br/><br><br/></p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>&emsp;&emsp;<a href="./c-ub-list.md"><code>c-ub-list.md</code></a>：C 未定义行为成因列表<br>&emsp;&emsp;<a href="./cpp-ub-list.md"><code>cpp-ub-list.md</code></a>：C++ 未定义行为成因列表与标准解读  </p>
<p><br/><br><br/></p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>&emsp;&emsp;保障软件安全、提升产品质量是宏大的主题，需要不断地学习、探索与实践，也难以在一篇文章中涵盖所有要点，这 487 条规则就暂且讨论至此了。欢迎提供修订意见和扩展建议，由于本文档是自动生成的，请不要直接编辑本文档，可在 Issue 区发表高见，管理员修正数据库后会在致谢列表中存档。</p>
<p>&emsp;&emsp;此致</p>
<p>祝编程愉快！</p>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">Hoshea Zhang</div><div class="post-copyright__author_desc">平安喜乐</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://example.com/2023/10/25/360CPP%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://example.com/2023/10/25/360CPP%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/')">360CPP代码规范</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://example.com/2023/10/25/360CPP%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=360CPP代码规范&amp;url=http://example.com/2023/10/25/360CPP%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/&amp;pic=https://hoshea-1318436778.cos.ap-nanjing.myqcloud.com/image360.jpg" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="rm.copyPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/C/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>C++<span class="tagsPageCount">5</span></a><a class="post-meta__box__tags" href="/tags/360/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>360<span class="tagsPageCount">1</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://hoshea-1318436778.cos.ap-nanjing.myqcloud.com/image360.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2023/10/25/workflow%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9A%E7%BA%BF%E7%A8%8B%E6%B1%A0/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://hoshea-1318436778.cos.ap-nanjing.myqcloud.com/imagebg_sougou.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">workflow源码分析：线程池</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2023/10/17/CPP_Primer%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/" title="C++primer第二章_变量和基本类型"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://hoshea-1318436778.cos.ap-nanjing.myqcloud.com/imagebg_c%2B%2Bprimer.webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-10-17</div><div class="title">C++primer第二章_变量和基本类型</div></div></a></div><div><a href="/2023/10/19/c-%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3%E6%B1%87%E6%80%BB/" title="c++报错解决汇总"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://hoshea-1318436778.cos.ap-nanjing.myqcloud.com/imagebg_develop.webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-10-19</div><div class="title">c++报错解决汇总</div></div></a></div><div><a href="/2023/10/23/effective-CPP%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" title="《effective C++》阅读笔记"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://hoshea-1318436778.cos.ap-nanjing.myqcloud.com/imagebg_effectivecpp.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-10-23</div><div class="title">《effective C++》阅读笔记</div></div></a></div><div><a href="/2023/10/24/CPP-Primer%E7%AC%AC%E4%B8%89-%E4%B8%83%E7%AB%A0/" title="CPP_Primer第三-七章"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://hoshea-1318436778.cos.ap-nanjing.myqcloud.com/imagebg_c%2B%2Bprimer.webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-10-24</div><div class="title">CPP_Primer第三-七章</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/24/64e6ce9c507bb.png" ait="status"/></div></div><div class="author-info__description"></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">Hoshea Zhang</h1><div class="author-info__desc">平安喜乐</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/HosheaZhang" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a></div></div></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bullhorn anzhiyu-shake"></i><span>Announcement</span></div><div class="announcement_content">e-mail:542978210@qq.com</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#C-C-%E5%AE%89%E5%85%A8%E8%A7%84%E5%88%99%E9%9B%86%E5%90%88"><span class="toc-number">1.</span> <span class="toc-text">C&#x2F;C++ 安全规则集合 </span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%84%E5%88%99%E8%AF%B4%E6%98%8E"><span class="toc-number">1.1.</span> <span class="toc-text">规则说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%84%E5%88%99%E9%80%89%E5%8F%96"><span class="toc-number">1.2.</span> <span class="toc-text">规则选取</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%84%E5%88%99%E5%88%97%E8%A1%A8"><span class="toc-number">1.3.</span> <span class="toc-text">规则列表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Security"><span class="toc-number">1.4.</span> <span class="toc-text">1. Security</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR1-1-%E6%95%8F%E6%84%9F%E6%95%B0%E6%8D%AE%E4%B8%8D%E5%8F%AF%E5%86%99%E5%85%A5%E4%BB%A3%E7%A0%81"><span class="toc-number">1.4.1.</span> <span class="toc-text">▌R1.1 敏感数据不可写入代码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR1-2-%E6%95%8F%E6%84%9F%E6%95%B0%E6%8D%AE%E4%B8%8D%E5%8F%AF%E8%A2%AB%E7%B3%BB%E7%BB%9F%E5%A4%96%E7%95%8C%E6%84%9F%E7%9F%A5"><span class="toc-number">1.4.2.</span> <span class="toc-text">▌R1.2 敏感数据不可被系统外界感知</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-1"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-1"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR1-3-%E6%95%8F%E6%84%9F%E6%95%B0%E6%8D%AE%E5%9C%A8%E4%BD%BF%E7%94%A8%E5%90%8E%E5%BA%94%E8%A2%AB%E6%9C%89%E6%95%88%E6%B8%85%E7%90%86"><span class="toc-number">1.4.3.</span> <span class="toc-text">▌R1.3 敏感数据在使用后应被有效清理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-2"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-2"><span class="toc-number">1.4.3.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR1-4-%E5%85%AC%E5%85%B1%E6%88%90%E5%91%98%E6%88%96%E5%85%A8%E5%B1%80%E5%AF%B9%E8%B1%A1%E4%B8%8D%E5%BA%94%E8%AE%B0%E5%BD%95%E6%95%8F%E6%84%9F%E6%95%B0%E6%8D%AE"><span class="toc-number">1.4.4.</span> <span class="toc-text">▌R1.4 公共成员或全局对象不应记录敏感数据</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-3"><span class="toc-number">1.4.4.1.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR1-5-%E9%A2%84%E5%88%A4%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E9%80%A0%E6%88%90%E7%9A%84%E4%B8%8D%E8%89%AF%E5%90%8E%E6%9E%9C"><span class="toc-number">1.4.5.</span> <span class="toc-text">▌R1.5 预判用户输入造成的不良后果</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-4"><span class="toc-number">1.4.5.1.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR1-6-%E5%AF%B9%E8%B5%84%E6%BA%90%E8%AE%BE%E5%AE%9A%E5%90%88%E7%90%86%E7%9A%84%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90"><span class="toc-number">1.4.6.</span> <span class="toc-text">▌R1.6 对资源设定合理的访问权限</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-1"><span class="toc-number">1.4.6.1.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-5"><span class="toc-number">1.4.6.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR1-7-%E5%AF%B9%E7%94%A8%E6%88%B7%E8%90%BD%E5%AE%9E%E6%9C%89%E6%95%88%E7%9A%84%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86"><span class="toc-number">1.4.7.</span> <span class="toc-text">▌R1.7 对用户落实有效的权限管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-6"><span class="toc-number">1.4.7.1.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR1-8-%E9%81%BF%E5%85%8D%E5%BC%95%E7%94%A8%E5%8D%B1%E9%99%A9%E7%AC%A6%E5%8F%B7%E5%90%8D%E7%A7%B0"><span class="toc-number">1.4.8.</span> <span class="toc-text">▌R1.8 避免引用危险符号名称</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-7"><span class="toc-number">1.4.8.1.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR1-9-%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8%E5%8D%B1%E9%99%A9%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.4.9.</span> <span class="toc-text">▌R1.9 避免使用危险接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-8"><span class="toc-number">1.4.9.1.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR1-10-%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8%E5%B7%B2%E8%BF%87%E6%97%B6%E7%9A%84%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.4.10.</span> <span class="toc-text">▌R1.10 避免使用已过时的接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-3"><span class="toc-number">1.4.10.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-9"><span class="toc-number">1.4.10.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR1-11-%E7%A6%81%E7%94%A8%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.11.</span> <span class="toc-text">▌R1.11 禁用不安全的字符串函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-4"><span class="toc-number">1.4.11.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-2"><span class="toc-number">1.4.11.2.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-10"><span class="toc-number">1.4.11.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR1-12-%E7%A1%AE%E4%BF%9D%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BB%A5%E7%A9%BA%E5%AD%97%E7%AC%A6%E7%BB%93%E5%B0%BE"><span class="toc-number">1.4.12.</span> <span class="toc-text">▌R1.12 确保字符串以空字符结尾</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-5"><span class="toc-number">1.4.12.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-3"><span class="toc-number">1.4.12.2.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-11"><span class="toc-number">1.4.12.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR1-13-%E9%81%BF%E5%85%8D%E9%99%A4-0-%E7%AD%89%E8%AE%A1%E7%AE%97%E5%BC%82%E5%B8%B8"><span class="toc-number">1.4.13.</span> <span class="toc-text">▌R1.13 避免除 0 等计算异常</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-6"><span class="toc-number">1.4.13.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-4"><span class="toc-number">1.4.13.2.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-12"><span class="toc-number">1.4.13.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR1-14-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%BA%94%E4%B8%BA%E5%B8%B8%E9%87%8F"><span class="toc-number">1.4.14.</span> <span class="toc-text">▌R1.14 格式化字符串应为常量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-7"><span class="toc-number">1.4.14.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-13"><span class="toc-number">1.4.14.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR1-15-%E4%B8%8E%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E5%B8%83%E5%B1%80%E7%9B%B8%E5%85%B3%E7%9A%84%E4%BF%A1%E6%81%AF%E4%B8%8D%E5%8F%AF%E8%A2%AB%E5%A4%96%E7%95%8C%E6%84%9F%E7%9F%A5"><span class="toc-number">1.4.15.</span> <span class="toc-text">▌R1.15 与内存空间布局相关的信息不可被外界感知</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-8"><span class="toc-number">1.4.15.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-14"><span class="toc-number">1.4.15.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR1-16-%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E7%9B%B8%E5%85%B3%E7%9A%84%E4%BF%A1%E6%81%AF%E4%B8%8D%E5%BA%94%E5%86%99%E5%85%A5%E4%BB%A3%E7%A0%81"><span class="toc-number">1.4.16.</span> <span class="toc-text">▌R1.16 与网络地址相关的信息不应写入代码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-9"><span class="toc-number">1.4.16.1.</span> <span class="toc-text">相关</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR1-17-%E9%80%89%E6%8B%A9%E5%AE%89%E5%85%A8%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">1.4.17.</span> <span class="toc-text">▌R1.17 选择安全的异常处理方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-15"><span class="toc-number">1.4.17.1.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR1-18-%E5%90%AF%E7%94%A8%E5%B9%B3%E5%8F%B0%E5%92%8C%E7%BC%96%E8%AF%91%E5%99%A8%E6%8F%90%E4%BE%9B%E7%9A%84%E9%98%B2%E5%BE%A1%E6%9C%BA%E5%88%B6"><span class="toc-number">1.4.18.</span> <span class="toc-text">▌R1.18 启用平台和编译器提供的防御机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Resource"><span class="toc-number">1.5.</span> <span class="toc-text">2. Resource</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR2-1-%E4%B8%8D%E5%8F%AF%E5%A4%B1%E5%8E%BB%E5%AF%B9%E5%B7%B2%E5%88%86%E9%85%8D%E8%B5%84%E6%BA%90%E7%9A%84%E6%8E%A7%E5%88%B6"><span class="toc-number">1.5.1.</span> <span class="toc-text">▌R2.1 不可失去对已分配资源的控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-10"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-16"><span class="toc-number">1.5.1.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR2-2-%E4%B8%8D%E5%8F%AF%E5%A4%B1%E5%8E%BB%E5%AF%B9%E5%B7%B2%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%E7%9A%84%E6%8E%A7%E5%88%B6"><span class="toc-number">1.5.2.</span> <span class="toc-text">▌R2.2 不可失去对已分配内存的控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-11"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-5"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-17"><span class="toc-number">1.5.2.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR2-3-%E4%B8%8D%E5%8F%AF%E8%AE%BF%E9%97%AE%E6%9C%AA%E5%88%9D%E5%A7%8B%E5%8C%96%E6%88%96%E5%B7%B2%E9%87%8A%E6%94%BE%E7%9A%84%E8%B5%84%E6%BA%90"><span class="toc-number">1.5.3.</span> <span class="toc-text">▌R2.3 不可访问未初始化或已释放的资源</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-12"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-6"><span class="toc-number">1.5.3.2.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-18"><span class="toc-number">1.5.3.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR2-4-%E8%B5%84%E6%BA%90%E5%BA%94%E6%8E%A5%E5%8F%97%E5%AF%B9%E8%B1%A1%E5%8C%96%E7%AE%A1%E7%90%86"><span class="toc-number">1.5.4.</span> <span class="toc-text">▌R2.4 资源应接受对象化管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-19"><span class="toc-number">1.5.4.1.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR2-5-%E8%B5%84%E6%BA%90%E7%9A%84%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%E6%96%B9%E6%B3%95%E5%BA%94%E6%88%90%E5%AF%B9%E6%8F%90%E4%BE%9B"><span class="toc-number">1.5.5.</span> <span class="toc-text">▌R2.5 资源的分配与回收方法应成对提供</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-13"><span class="toc-number">1.5.5.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-20"><span class="toc-number">1.5.5.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR2-6-%E8%B5%84%E6%BA%90%E7%9A%84%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%E6%96%B9%E6%B3%95%E5%BA%94%E9%85%8D%E5%A5%97%E4%BD%BF%E7%94%A8"><span class="toc-number">1.5.6.</span> <span class="toc-text">▌R2.6 资源的分配与回收方法应配套使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-14"><span class="toc-number">1.5.6.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-7"><span class="toc-number">1.5.6.2.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-21"><span class="toc-number">1.5.6.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR2-7-%E4%B8%8D%E5%BA%94%E5%9C%A8%E6%A8%A1%E5%9D%97%E4%B9%8B%E9%97%B4%E4%BC%A0%E9%80%92%E5%AE%B9%E5%99%A8%E7%B1%BB%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.5.7.</span> <span class="toc-text">▌R2.7 不应在模块之间传递容器类对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-15"><span class="toc-number">1.5.7.1.</span> <span class="toc-text">相关</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR2-8-%E4%B8%8D%E5%BA%94%E5%9C%A8%E6%A8%A1%E5%9D%97%E4%B9%8B%E9%97%B4%E4%BC%A0%E9%80%92%E9%9D%9E%E6%A0%87%E5%87%86%E5%B8%83%E5%B1%80%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.5.8.</span> <span class="toc-text">▌R2.8 不应在模块之间传递非标准布局类型的对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-8"><span class="toc-number">1.5.8.1.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-22"><span class="toc-number">1.5.8.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR2-9-%E5%AF%B9%E8%B1%A1%E7%94%B3%E8%AF%B7%E7%9A%84%E8%B5%84%E6%BA%90%E5%BA%94%E5%9C%A8%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B8%AD%E9%87%8A%E6%94%BE"><span class="toc-number">1.5.9.</span> <span class="toc-text">▌R2.9 对象申请的资源应在析构函数中释放</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-16"><span class="toc-number">1.5.9.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-23"><span class="toc-number">1.5.9.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR2-10-%E5%AF%B9%E8%B1%A1%E8%A2%AB%E7%A7%BB%E5%8A%A8%E5%90%8E%E5%BA%94%E9%87%8D%E7%BD%AE%E7%8A%B6%E6%80%81%E5%86%8D%E4%BD%BF%E7%94%A8"><span class="toc-number">1.5.10.</span> <span class="toc-text">▌R2.10 对象被移动后应重置状态再使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-17"><span class="toc-number">1.5.10.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-9"><span class="toc-number">1.5.10.2.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-24"><span class="toc-number">1.5.10.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR2-11-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E9%9C%80%E9%81%BF%E5%85%8D%E7%9B%B8%E5%85%B3%E8%B5%84%E6%BA%90%E6%B3%84%E6%BC%8F"><span class="toc-number">1.5.11.</span> <span class="toc-text">▌R2.11 构造函数抛出异常需避免相关资源泄漏</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-18"><span class="toc-number">1.5.11.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-10"><span class="toc-number">1.5.11.2.</span> <span class="toc-text">依据</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR2-12-%E8%B5%84%E6%BA%90%E4%B8%8D%E5%8F%AF%E8%A2%AB%E9%87%8D%E5%A4%8D%E9%87%8A%E6%94%BE"><span class="toc-number">1.5.12.</span> <span class="toc-text">▌R2.12 资源不可被重复释放</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-11"><span class="toc-number">1.5.12.1.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-25"><span class="toc-number">1.5.12.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR2-13-%E7%94%A8-delete-%E9%87%8A%E6%94%BE%E5%AF%B9%E8%B1%A1%E9%9C%80%E4%BF%9D%E8%AF%81%E5%85%B6%E7%B1%BB%E5%9E%8B%E5%AE%8C%E6%95%B4"><span class="toc-number">1.5.13.</span> <span class="toc-text">▌R2.13 用 delete 释放对象需保证其类型完整</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-12"><span class="toc-number">1.5.13.1.</span> <span class="toc-text">依据</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR2-14-%E7%94%A8-delete-%E9%87%8A%E6%94%BE%E5%AF%B9%E8%B1%A1%E4%B8%8D%E5%8F%AF%E5%A4%9A%E5%86%99%E4%B8%AD%E6%8B%AC%E5%8F%B7"><span class="toc-number">1.5.14.</span> <span class="toc-text">▌R2.14 用 delete 释放对象不可多写中括号</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-19"><span class="toc-number">1.5.14.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-13"><span class="toc-number">1.5.14.2.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-26"><span class="toc-number">1.5.14.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR2-15-%E7%94%A8-delete-%E9%87%8A%E6%94%BE%E6%95%B0%E7%BB%84%E4%B8%8D%E5%8F%AF%E6%BC%8F%E5%86%99%E4%B8%AD%E6%8B%AC%E5%8F%B7"><span class="toc-number">1.5.15.</span> <span class="toc-text">▌R2.15 用 delete 释放数组不可漏写中括号</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-20"><span class="toc-number">1.5.15.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-14"><span class="toc-number">1.5.15.2.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-27"><span class="toc-number">1.5.15.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR2-16-%E9%9D%9E%E5%8A%A8%E6%80%81%E7%94%B3%E8%AF%B7%E7%9A%84%E8%B5%84%E6%BA%90%E4%B8%8D%E5%8F%AF%E8%A2%AB%E9%87%8A%E6%94%BE"><span class="toc-number">1.5.16.</span> <span class="toc-text">▌R2.16 非动态申请的资源不可被释放</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-15"><span class="toc-number">1.5.16.1.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-28"><span class="toc-number">1.5.16.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR2-17-%E5%9C%A8%E4%B8%80%E4%B8%AA%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%AD%E5%8F%A5%E4%B8%AD%E6%9C%80%E5%A4%9A%E4%BD%BF%E7%94%A8%E4%B8%80%E6%AC%A1-new"><span class="toc-number">1.5.17.</span> <span class="toc-text">▌R2.17 在一个表达式语句中最多使用一次 new</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-21"><span class="toc-number">1.5.17.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-29"><span class="toc-number">1.5.17.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR2-18-%E6%B5%81%E5%BC%8F%E8%B5%84%E6%BA%90%E5%AF%B9%E8%B1%A1%E4%B8%8D%E5%BA%94%E8%A2%AB%E5%A4%8D%E5%88%B6"><span class="toc-number">1.5.18.</span> <span class="toc-text">▌R2.18 流式资源对象不应被复制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-16"><span class="toc-number">1.5.18.1.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-30"><span class="toc-number">1.5.18.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR2-19-%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8%E5%8F%98%E9%95%BF%E6%95%B0%E7%BB%84"><span class="toc-number">1.5.19.</span> <span class="toc-text">▌R2.19 避免使用变长数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-22"><span class="toc-number">1.5.19.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-17"><span class="toc-number">1.5.19.2.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-31"><span class="toc-number">1.5.19.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR2-20-%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8%E5%9C%A8%E6%A0%88%E4%B8%8A%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">1.5.20.</span> <span class="toc-text">▌R2.20 避免使用在栈上分配内存的函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-23"><span class="toc-number">1.5.20.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-32"><span class="toc-number">1.5.20.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR2-21-%E5%B1%80%E9%83%A8%E6%95%B0%E7%BB%84%E4%B8%8D%E5%BA%94%E8%BF%87%E5%A4%A7"><span class="toc-number">1.5.21.</span> <span class="toc-text">▌R2.21 局部数组不应过大</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE"><span class="toc-number">1.5.21.1.</span> <span class="toc-text">配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-33"><span class="toc-number">1.5.21.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR2-22-%E9%81%BF%E5%85%8D%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number">1.5.22.</span> <span class="toc-text">▌R2.22 避免不必要的内存分配</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-24"><span class="toc-number">1.5.22.1.</span> <span class="toc-text">相关</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR2-23-%E9%81%BF%E5%85%8D%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number">1.5.23.</span> <span class="toc-text">▌R2.23 避免动态内存分配</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-18"><span class="toc-number">1.5.23.1.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-34"><span class="toc-number">1.5.23.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR2-24-%E5%88%A4%E6%96%AD%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC%E6%98%AF%E5%90%A6%E6%9C%89%E6%95%88"><span class="toc-number">1.5.24.</span> <span class="toc-text">▌R2.24 判断资源分配函数的返回值是否有效</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-19"><span class="toc-number">1.5.24.1.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-35"><span class="toc-number">1.5.24.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR2-25-C-%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%A6%81%E7%94%A8-C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%87%BD%E6%95%B0"><span class="toc-number">1.5.25.</span> <span class="toc-text">▌R2.25 C++ 代码中禁用 C 内存管理函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-25"><span class="toc-number">1.5.25.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-36"><span class="toc-number">1.5.25.2.</span> <span class="toc-text">参考</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Precompile"><span class="toc-number">1.6.</span> <span class="toc-text">3. Precompile</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-Include"><span class="toc-number">1.6.1.</span> <span class="toc-text">3.1 Include</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR3-1-1-include-%E6%8C%87%E4%BB%A4%E5%BA%94%E7%AC%A6%E5%90%88%E6%A0%87%E5%87%86%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.6.2.</span> <span class="toc-text">▌R3.1.1 include 指令应符合标准格式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-26"><span class="toc-number">1.6.2.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-20"><span class="toc-number">1.6.2.2.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-37"><span class="toc-number">1.6.2.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR3-1-2-include-%E6%8C%87%E4%BB%A4%E4%B8%AD%E7%A6%81%E7%94%A8%E4%B8%8D%E5%90%88%E8%A7%84%E7%9A%84%E5%AD%97%E7%AC%A6"><span class="toc-number">1.6.3.</span> <span class="toc-text">▌R3.1.2 include 指令中禁用不合规的字符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-21"><span class="toc-number">1.6.3.1.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-38"><span class="toc-number">1.6.3.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR3-1-3-include-%E6%8C%87%E4%BB%A4%E4%B8%AD%E4%B8%8D%E5%BA%94%E4%BD%BF%E7%94%A8%E5%8F%8D%E6%96%9C%E6%9D%A0"><span class="toc-number">1.6.4.</span> <span class="toc-text">▌R3.1.3 include 指令中不应使用反斜杠</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-22"><span class="toc-number">1.6.4.1.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-39"><span class="toc-number">1.6.4.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR3-1-4-include-%E6%8C%87%E4%BB%A4%E4%B8%AD%E4%B8%8D%E5%BA%94%E4%BD%BF%E7%94%A8%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84"><span class="toc-number">1.6.5.</span> <span class="toc-text">▌R3.1.4 include 指令中不应使用绝对路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR3-1-5-include-%E6%8C%87%E4%BB%A4%E5%BA%94%E4%BD%8D%E4%BA%8E%E6%96%87%E4%BB%B6%E7%9A%84%E8%B5%B7%E5%A7%8B%E9%83%A8%E5%88%86"><span class="toc-number">1.6.6.</span> <span class="toc-text">▌R3.1.5 include 指令应位于文件的起始部分</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-23"><span class="toc-number">1.6.6.1.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-40"><span class="toc-number">1.6.6.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR3-1-6-%E7%A6%81%E7%94%A8%E4%B8%8D%E5%90%88%E8%A7%84%E7%9A%84%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="toc-number">1.6.7.</span> <span class="toc-text">▌R3.1.6 禁用不合规的头文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE-1"><span class="toc-number">1.6.7.1.</span> <span class="toc-text">配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-24"><span class="toc-number">1.6.7.2.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-41"><span class="toc-number">1.6.7.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR3-1-7-C-%E4%BB%A3%E7%A0%81%E4%B8%8D%E5%BA%94%E5%BC%95%E7%94%A8-C-%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="toc-number">1.6.8.</span> <span class="toc-text">▌R3.1.7 C++ 代码不应引用 C 头文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-27"><span class="toc-number">1.6.8.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-25"><span class="toc-number">1.6.8.2.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-42"><span class="toc-number">1.6.8.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-Macro-definition"><span class="toc-number">1.6.9.</span> <span class="toc-text">3.2 Macro-definition</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR3-2-1-%E5%AE%8F%E5%BA%94%E9%81%B5%E5%BE%AA%E5%90%88%E7%90%86%E7%9A%84%E5%91%BD%E5%90%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">1.6.10.</span> <span class="toc-text">▌R3.2.1 宏应遵循合理的命名方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-28"><span class="toc-number">1.6.10.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-43"><span class="toc-number">1.6.10.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR3-2-2-%E4%B8%8D%E5%8F%AF%E5%AE%9A%E4%B9%89%E5%85%B7%E6%9C%89%E4%BF%9D%E7%95%99%E6%84%8F%E4%B9%89%E7%9A%84%E5%AE%8F%E5%90%8D%E7%A7%B0"><span class="toc-number">1.6.11.</span> <span class="toc-text">▌R3.2.2 不可定义具有保留意义的宏名称</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE-2"><span class="toc-number">1.6.11.1.</span> <span class="toc-text">配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-29"><span class="toc-number">1.6.11.2.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-26"><span class="toc-number">1.6.11.3.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-44"><span class="toc-number">1.6.11.4.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR3-2-3-%E4%B8%8D%E5%8F%AF%E5%8F%96%E6%B6%88%E5%AE%9A%E4%B9%89%E5%85%B7%E6%9C%89%E4%BF%9D%E7%95%99%E6%84%8F%E4%B9%89%E7%9A%84%E5%AE%8F%E5%90%8D%E7%A7%B0"><span class="toc-number">1.6.12.</span> <span class="toc-text">▌R3.2.3 不可取消定义具有保留意义的宏名称</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE-3"><span class="toc-number">1.6.12.1.</span> <span class="toc-text">配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-30"><span class="toc-number">1.6.12.2.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-27"><span class="toc-number">1.6.12.3.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-45"><span class="toc-number">1.6.12.4.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR3-2-4-%E5%8F%AF%E4%BD%9C%E4%B8%BA%E5%AD%90%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%AE%8F%E5%AE%9A%E4%B9%89%E5%BA%94%E8%AF%A5%E7%94%A8%E6%8B%AC%E5%8F%B7%E6%8B%AC%E8%B5%B7%E6%9D%A5"><span class="toc-number">1.6.13.</span> <span class="toc-text">▌R3.2.4 可作为子表达式的宏定义应该用括号括起来</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-28"><span class="toc-number">1.6.13.1.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-46"><span class="toc-number">1.6.13.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR3-2-5-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%AD%E7%9A%84%E5%AE%8F%E5%8F%82%E6%95%B0%E5%BA%94%E8%AF%A5%E7%94%A8%E6%8B%AC%E5%8F%B7%E6%8B%AC%E8%B5%B7%E6%9D%A5"><span class="toc-number">1.6.14.</span> <span class="toc-text">▌R3.2.5 表达式中的宏参数应该用括号括起来</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-29"><span class="toc-number">1.6.14.1.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-47"><span class="toc-number">1.6.14.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR3-2-6-%E7%94%B1%E5%A4%9A%E4%B8%AA%E8%AF%AD%E5%8F%A5%E7%BB%84%E6%88%90%E7%9A%84%E5%AE%8F%E5%AE%9A%E4%B9%89%E5%BA%94%E8%AF%A5%E7%94%A8-do-while-0-%E6%8B%AC%E8%B5%B7%E6%9D%A5"><span class="toc-number">1.6.15.</span> <span class="toc-text">▌R3.2.6 由多个语句组成的宏定义应该用 do-while(0) 括起来</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-31"><span class="toc-number">1.6.15.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-30"><span class="toc-number">1.6.15.2.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-48"><span class="toc-number">1.6.15.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR3-2-7-%E5%AE%8F%E5%AE%9A%E4%B9%89%E4%B8%AD%E7%9A%84-%E5%92%8C-%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8D%E5%BA%94%E5%B5%8C%E5%A5%97%E4%BD%BF%E7%94%A8"><span class="toc-number">1.6.16.</span> <span class="toc-text">▌R3.2.7 宏定义中的 # 和 ## 运算符不应嵌套使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-31"><span class="toc-number">1.6.16.1.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-49"><span class="toc-number">1.6.16.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR3-2-8-%E4%B8%8D%E5%BA%94%E4%BD%BF%E7%94%A8%E5%AE%8F%E5%AE%9A%E4%B9%89%E5%B8%B8%E9%87%8F"><span class="toc-number">1.6.17.</span> <span class="toc-text">▌R3.2.8 不应使用宏定义常量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-32"><span class="toc-number">1.6.17.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-50"><span class="toc-number">1.6.17.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR3-2-9-%E4%B8%8D%E5%BA%94%E4%BD%BF%E7%94%A8%E5%AE%8F%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.6.18.</span> <span class="toc-text">▌R3.2.9 不应使用宏定义类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-33"><span class="toc-number">1.6.18.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-51"><span class="toc-number">1.6.18.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR3-2-10-%E5%8F%AF%E7%94%B1%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8A%9F%E8%83%BD%E4%B8%8D%E5%BA%94%E4%BD%BF%E7%94%A8%E5%AE%8F%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.6.19.</span> <span class="toc-text">▌R3.2.10 可由函数实现的功能不应使用宏实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-34"><span class="toc-number">1.6.19.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-52"><span class="toc-number">1.6.19.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR3-2-11-%E5%AE%8F%E4%B8%8D%E5%BA%94%E8%A2%AB%E9%87%8D%E5%AE%9A%E4%B9%89"><span class="toc-number">1.6.20.</span> <span class="toc-text">▌R3.2.11 宏不应被重定义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-32"><span class="toc-number">1.6.20.1.</span> <span class="toc-text">依据</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR3-2-12-%E5%8F%AA%E5%BA%94%E5%9C%A8%E5%85%A8%E5%B1%80%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%AD%E5%AE%9A%E4%B9%89%E5%AE%8F"><span class="toc-number">1.6.21.</span> <span class="toc-text">▌R3.2.12 只应在全局作用域中定义宏</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE-4"><span class="toc-number">1.6.21.1.</span> <span class="toc-text">配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-35"><span class="toc-number">1.6.21.2.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-33"><span class="toc-number">1.6.21.3.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-53"><span class="toc-number">1.6.21.4.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR3-2-13-%E9%81%BF%E5%85%8D%E5%AE%8F%E8%A2%AB%E5%8F%96%E6%B6%88%E5%AE%9A%E4%B9%89"><span class="toc-number">1.6.22.</span> <span class="toc-text">▌R3.2.13 避免宏被取消定义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE-5"><span class="toc-number">1.6.22.1.</span> <span class="toc-text">配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-36"><span class="toc-number">1.6.22.2.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-54"><span class="toc-number">1.6.22.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-Macro-usage"><span class="toc-number">1.6.23.</span> <span class="toc-text">3.3 Macro-usage</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR3-3-1-%E5%AE%8F%E7%9A%84%E5%AE%9E%E5%8F%82%E4%B8%8D%E5%BA%94%E6%9C%89%E5%89%AF%E4%BD%9C%E7%94%A8"><span class="toc-number">1.6.24.</span> <span class="toc-text">▌R3.3.1 宏的实参不应有副作用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-37"><span class="toc-number">1.6.24.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-55"><span class="toc-number">1.6.24.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR3-3-2-%E5%AE%8F%E7%9A%84%E5%AE%9E%E5%8F%82%E4%B8%AA%E6%95%B0%E4%B8%8D%E5%8F%AF%E5%B0%8F%E4%BA%8E%E5%BD%A2%E5%8F%82%E4%B8%AA%E6%95%B0"><span class="toc-number">1.6.25.</span> <span class="toc-text">▌R3.3.2 宏的实参个数不可小于形参个数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-38"><span class="toc-number">1.6.25.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-34"><span class="toc-number">1.6.25.2.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-56"><span class="toc-number">1.6.25.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR3-3-3-%E5%AE%8F%E7%9A%84%E5%AE%9E%E5%8F%82%E4%B8%AA%E6%95%B0%E4%B8%8D%E5%8F%AF%E5%A4%A7%E4%BA%8E%E5%BD%A2%E5%8F%82%E4%B8%AA%E6%95%B0"><span class="toc-number">1.6.26.</span> <span class="toc-text">▌R3.3.3 宏的实参个数不可大于形参个数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-39"><span class="toc-number">1.6.26.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-35"><span class="toc-number">1.6.26.2.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-57"><span class="toc-number">1.6.26.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR3-3-4-va-start-%E6%88%96-va-copy-%E5%BA%94%E9%85%8D%E5%90%88-va-end-%E4%BD%BF%E7%94%A8"><span class="toc-number">1.6.27.</span> <span class="toc-text">▌R3.3.4 va_start 或 va_copy 应配合 va_end 使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-40"><span class="toc-number">1.6.27.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-36"><span class="toc-number">1.6.27.2.</span> <span class="toc-text">依据</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR3-3-5-va-arg-%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0%E5%BA%94%E7%AC%A6%E5%90%88%E8%A6%81%E6%B1%82"><span class="toc-number">1.6.28.</span> <span class="toc-text">▌R3.3.5 va_arg 的类型参数应符合要求</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-41"><span class="toc-number">1.6.28.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-37"><span class="toc-number">1.6.28.2.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-58"><span class="toc-number">1.6.28.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR3-3-6-%E5%9C%A8-C-%E4%BB%A3%E7%A0%81%E4%B8%AD%E4%B8%8D%E5%BA%94%E4%BD%BF%E7%94%A8%E5%AE%8F-offsetof"><span class="toc-number">1.6.29.</span> <span class="toc-text">▌R3.3.6 在 C++ 代码中不应使用宏 offsetof</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-38"><span class="toc-number">1.6.29.1.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-59"><span class="toc-number">1.6.29.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-Directive"><span class="toc-number">1.6.30.</span> <span class="toc-text">3.4 Directive</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR3-4-1-%E5%A4%B4%E6%96%87%E4%BB%B6%E4%B8%8D%E5%BA%94%E7%BC%BA%E5%B0%91%E5%AE%88%E5%8D%AB"><span class="toc-number">1.6.31.</span> <span class="toc-text">▌R3.4.1 头文件不应缺少守卫</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE-6"><span class="toc-number">1.6.31.1.</span> <span class="toc-text">配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-60"><span class="toc-number">1.6.31.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR3-4-2-%E4%B8%8D%E5%BA%94%E5%87%BA%E7%8E%B0%E9%9D%9E%E6%A0%87%E5%87%86%E6%A0%BC%E5%BC%8F%E7%9A%84%E9%A2%84%E7%BC%96%E8%AF%91%E6%8C%87%E4%BB%A4"><span class="toc-number">1.6.32.</span> <span class="toc-text">▌R3.4.2 不应出现非标准格式的预编译指令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-39"><span class="toc-number">1.6.32.1.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-61"><span class="toc-number">1.6.32.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR3-4-3-%E4%B8%8D%E5%BA%94%E4%BD%BF%E7%94%A8%E9%9D%9E%E6%A0%87%E5%87%86%E9%A2%84%E7%BC%96%E8%AF%91%E6%8C%87%E4%BB%A4"><span class="toc-number">1.6.33.</span> <span class="toc-text">▌R3.4.3 不应使用非标准预编译指令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-40"><span class="toc-number">1.6.33.1.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-62"><span class="toc-number">1.6.33.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR3-4-4-%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8-pragma-%E6%8C%87%E4%BB%A4"><span class="toc-number">1.6.34.</span> <span class="toc-text">▌R3.4.4 避免使用 pragma 指令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-41"><span class="toc-number">1.6.34.1.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-63"><span class="toc-number">1.6.34.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR3-4-5-%E9%9D%9E%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E7%9A%84%E4%BB%A3%E7%A0%81%E4%B8%AD%E4%B8%8D%E5%BA%94%E5%87%BA%E7%8E%B0-line-%E6%8C%87%E4%BB%A4"><span class="toc-number">1.6.35.</span> <span class="toc-text">▌R3.4.5 非自动生成的代码中不应出现 line 指令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-42"><span class="toc-number">1.6.35.1.</span> <span class="toc-text">依据</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR3-4-6-%E5%AE%8F%E7%9A%84%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8%E4%B8%AD%E4%B8%8D%E5%BA%94%E5%87%BA%E7%8E%B0%E9%A2%84%E7%BC%96%E8%AF%91%E6%8C%87%E4%BB%A4"><span class="toc-number">1.6.36.</span> <span class="toc-text">▌R3.4.6 宏的参数列表中不应出现预编译指令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-43"><span class="toc-number">1.6.36.1.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-64"><span class="toc-number">1.6.36.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR3-4-7-%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91%E4%BB%A3%E7%A0%81%E5%9D%97%E5%BA%94%E5%9C%A8%E5%90%8C%E4%B8%80%E6%96%87%E4%BB%B6%E4%B8%AD"><span class="toc-number">1.6.37.</span> <span class="toc-text">▌R3.4.7 条件编译代码块应在同一文件中</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-65"><span class="toc-number">1.6.37.1.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR3-4-8-%E5%AF%B9%E7%BC%96%E8%AF%91%E8%AD%A6%E5%91%8A%E7%9A%84%E5%B1%8F%E8%94%BD%E5%BA%94%E6%85%8E%E9%87%8D"><span class="toc-number">1.6.38.</span> <span class="toc-text">▌R3.4.8 对编译警告的屏蔽应慎重</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-42"><span class="toc-number">1.6.38.1.</span> <span class="toc-text">相关</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR3-4-9-%E5%9C%A8%E9%AB%98%E7%BA%A7%E5%88%AB%E7%9A%84%E8%AD%A6%E5%91%8A%E8%AE%BE%E7%BD%AE%E4%B8%8B%E7%BC%96%E8%AF%91"><span class="toc-number">1.6.39.</span> <span class="toc-text">▌R3.4.9 在高级别的警告设置下编译</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-43"><span class="toc-number">1.6.39.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-66"><span class="toc-number">1.6.39.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-Comment"><span class="toc-number">1.6.40.</span> <span class="toc-text">3.5 Comment</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR3-5-1-%E5%85%B3%E6%B3%A8-TODO%E3%80%81FIXME%E3%80%81XXX%E3%80%81BUG-%E7%AD%89%E7%89%B9%E6%AE%8A%E6%B3%A8%E9%87%8A"><span class="toc-number">1.6.41.</span> <span class="toc-text">▌R3.5.1 关注 TODO、FIXME、XXX、BUG 等特殊注释</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE-7"><span class="toc-number">1.6.41.1.</span> <span class="toc-text">配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-67"><span class="toc-number">1.6.41.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR3-5-2-%E6%B3%A8%E9%87%8A%E4%B8%8D%E5%8F%AF%E5%B5%8C%E5%A5%97"><span class="toc-number">1.6.42.</span> <span class="toc-text">▌R3.5.2 注释不可嵌套</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-44"><span class="toc-number">1.6.42.1.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-68"><span class="toc-number">1.6.42.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR3-5-3-%E6%B3%A8%E9%87%8A%E5%BA%94%E5%87%BA%E7%8E%B0%E5%9C%A8%E5%90%88%E7%90%86%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="toc-number">1.6.43.</span> <span class="toc-text">▌R3.5.3 注释应出现在合理的位置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-45"><span class="toc-number">1.6.43.1.</span> <span class="toc-text">依据</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-Other"><span class="toc-number">1.6.44.</span> <span class="toc-text">3.6 Other</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR3-6-1-%E9%9D%9E%E7%A9%BA%E6%BA%90%E6%96%87%E4%BB%B6%E5%BA%94%E4%BB%A5%E6%8D%A2%E8%A1%8C%E7%AC%A6%E7%BB%93%E5%B0%BE"><span class="toc-number">1.6.45.</span> <span class="toc-text">▌R3.6.1 非空源文件应以换行符结尾</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE-8"><span class="toc-number">1.6.45.1.</span> <span class="toc-text">配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-46"><span class="toc-number">1.6.45.2.</span> <span class="toc-text">依据</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR3-6-2-%E9%99%A4%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6%E3%80%81%E5%AE%8F%E5%AE%9A%E4%B9%89%E4%B9%8B%E5%A4%96%E4%B8%8D%E5%BA%94%E4%BD%BF%E7%94%A8%E5%8F%8D%E6%96%9C%E6%9D%A0"><span class="toc-number">1.6.46.</span> <span class="toc-text">▌R3.6.2 除转义字符、宏定义之外不应使用反斜杠</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-47"><span class="toc-number">1.6.46.1.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-69"><span class="toc-number">1.6.46.2.</span> <span class="toc-text">参考</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Global"><span class="toc-number">1.7.</span> <span class="toc-text">4. Global</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR4-1-%E5%85%A8%E5%B1%80%E5%90%8D%E7%A7%B0%E5%BA%94%E9%81%B5%E5%BE%AA%E5%90%88%E7%90%86%E7%9A%84%E5%91%BD%E5%90%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">1.7.1.</span> <span class="toc-text">▌R4.1 全局名称应遵循合理的命名方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE-9"><span class="toc-number">1.7.1.1.</span> <span class="toc-text">配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-44"><span class="toc-number">1.7.1.2.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-70"><span class="toc-number">1.7.1.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR4-2-%E4%B8%BA%E4%BB%A3%E7%A0%81%E8%AE%BE%E5%AE%9A%E5%90%88%E7%90%86%E7%9A%84%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">1.7.2.</span> <span class="toc-text">▌R4.2 为代码设定合理的命名空间</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-45"><span class="toc-number">1.7.2.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-71"><span class="toc-number">1.7.2.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR4-3-main-%E5%87%BD%E6%95%B0%E5%8F%AA%E5%BA%94%E5%A4%84%E4%BA%8E%E5%85%A8%E5%B1%80%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%AD"><span class="toc-number">1.7.3.</span> <span class="toc-text">▌R4.3 main 函数只应处于全局作用域中</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-48"><span class="toc-number">1.7.3.1.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-72"><span class="toc-number">1.7.3.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR4-4-%E5%A4%B4%E6%96%87%E4%BB%B6%E4%B8%AD%E4%B8%8D%E5%BA%94%E4%BD%BF%E7%94%A8-using-directive"><span class="toc-number">1.7.4.</span> <span class="toc-text">▌R4.4 头文件中不应使用 using directive</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-46"><span class="toc-number">1.7.4.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-73"><span class="toc-number">1.7.4.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR4-5-%E5%A4%B4%E6%96%87%E4%BB%B6%E4%B8%AD%E4%B8%8D%E5%BA%94%E4%BD%BF%E7%94%A8%E9%9D%99%E6%80%81%E5%A3%B0%E6%98%8E"><span class="toc-number">1.7.5.</span> <span class="toc-text">▌R4.5 头文件中不应使用静态声明</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-47"><span class="toc-number">1.7.5.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-49"><span class="toc-number">1.7.5.2.</span> <span class="toc-text">依据</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR4-6-%E5%A4%B4%E6%96%87%E4%BB%B6%E4%B8%AD%E4%B8%8D%E5%BA%94%E5%AE%9A%E4%B9%89%E5%8C%BF%E5%90%8D%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">1.7.6.</span> <span class="toc-text">▌R4.6 头文件中不应定义匿名命名空间</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-48"><span class="toc-number">1.7.6.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-50"><span class="toc-number">1.7.6.2.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-74"><span class="toc-number">1.7.6.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR4-7-%E5%8C%BF%E5%90%8D%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E4%B8%AD%E4%B8%8D%E5%BA%94%E4%BD%BF%E7%94%A8%E9%9D%99%E6%80%81%E5%A3%B0%E6%98%8E"><span class="toc-number">1.7.7.</span> <span class="toc-text">▌R4.7 匿名命名空间中不应使用静态声明</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-51"><span class="toc-number">1.7.7.1.</span> <span class="toc-text">依据</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR4-8-%E5%85%A8%E5%B1%80%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8D%E5%8F%AF%E4%BE%9D%E8%B5%96%E6%9C%AA%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.7.8.</span> <span class="toc-text">▌R4.8 全局对象的初始化不可依赖未初始化的对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-52"><span class="toc-number">1.7.8.1.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-75"><span class="toc-number">1.7.8.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR4-9-%E5%85%A8%E5%B1%80%E5%AF%B9%E8%B1%A1%E5%8F%AA%E5%BA%94%E4%B8%BA%E5%B8%B8%E9%87%8F%E6%88%96%E9%9D%99%E6%80%81%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.7.9.</span> <span class="toc-text">▌R4.9 全局对象只应为常量或静态对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-49"><span class="toc-number">1.7.9.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-76"><span class="toc-number">1.7.9.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR4-10-%E5%85%A8%E5%B1%80%E5%AF%B9%E8%B1%A1%E5%8F%AA%E5%BA%94%E4%B8%BA%E5%B8%B8%E9%87%8F"><span class="toc-number">1.7.10.</span> <span class="toc-text">▌R4.10 全局对象只应为常量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE-10"><span class="toc-number">1.7.10.1.</span> <span class="toc-text">配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-50"><span class="toc-number">1.7.10.2.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-77"><span class="toc-number">1.7.10.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR4-11-%E5%85%A8%E5%B1%80%E5%AF%B9%E8%B1%A1%E4%B8%8D%E5%BA%94%E5%90%8C%E6%97%B6%E8%A2%AB-static-%E5%92%8C-const-%E7%AD%89%E5%85%B3%E9%94%AE%E5%AD%97%E9%99%90%E5%AE%9A"><span class="toc-number">1.7.11.</span> <span class="toc-text">▌R4.11 全局对象不应同时被 static 和 const 等关键字限定</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-51"><span class="toc-number">1.7.11.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-53"><span class="toc-number">1.7.11.2.</span> <span class="toc-text">依据</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR4-12-%E5%85%A8%E5%B1%80%E5%8F%8A%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%AD%E7%A6%81%E7%94%A8-using-directive"><span class="toc-number">1.7.12.</span> <span class="toc-text">▌R4.12 全局及命名空间作用域中禁用 using directive</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-52"><span class="toc-number">1.7.12.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-78"><span class="toc-number">1.7.12.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR4-13-%E9%81%BF%E5%85%8D%E6%97%A0%E6%95%88%E7%9A%84-using-directive"><span class="toc-number">1.7.13.</span> <span class="toc-text">▌R4.13 避免无效的 using directive</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR4-14-%E4%B8%8D%E5%BA%94%E5%AE%9A%E4%B9%89%E5%85%A8%E5%B1%80-inline-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">1.7.14.</span> <span class="toc-text">▌R4.14 不应定义全局 inline 命名空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR4-15-%E4%B8%8D%E5%8F%AF%E4%BF%AE%E6%94%B9-std-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">1.7.15.</span> <span class="toc-text">▌R4.15 不可修改 std 命名空间</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-54"><span class="toc-number">1.7.15.1.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-79"><span class="toc-number">1.7.15.2.</span> <span class="toc-text">参考</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Type"><span class="toc-number">1.8.</span> <span class="toc-text">5. Type</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-Class"><span class="toc-number">1.8.1.</span> <span class="toc-text">5.1 Class</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR5-1-1-%E7%B1%BB%E7%9A%84%E9%9D%9E%E5%B8%B8%E9%87%8F%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E5%9D%87%E5%BA%94%E4%B8%BA-private"><span class="toc-number">1.8.2.</span> <span class="toc-text">▌R5.1.1 类的非常量数据成员均应为 private</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-53"><span class="toc-number">1.8.2.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-80"><span class="toc-number">1.8.2.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR5-1-2-%E7%B1%BB%E7%9A%84%E9%9D%9E%E5%B8%B8%E9%87%8F%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E4%B8%8D%E5%BA%94%E5%AE%9A%E4%B9%89%E4%B8%BA-protected"><span class="toc-number">1.8.3.</span> <span class="toc-text">▌R5.1.2 类的非常量数据成员不应定义为 protected</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-54"><span class="toc-number">1.8.3.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-81"><span class="toc-number">1.8.3.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR5-1-3-%E7%B1%BB%E4%B8%8D%E5%BA%94%E6%97%A2%E6%9C%89-public-%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E5%8F%88%E6%9C%89-private-%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98"><span class="toc-number">1.8.4.</span> <span class="toc-text">▌R5.1.3 类不应既有 public 数据成员又有 private 数据成员</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-55"><span class="toc-number">1.8.4.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-82"><span class="toc-number">1.8.4.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR5-1-4-%E6%9C%89%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%9F%BA%E7%B1%BB%E5%BA%94%E5%85%B7%E6%9C%89%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">1.8.5.</span> <span class="toc-text">▌R5.1.4 有虚函数的基类应具有虚析构函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-55"><span class="toc-number">1.8.5.1.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-83"><span class="toc-number">1.8.5.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR5-1-5-%E9%81%BF%E5%85%8D%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%E8%87%AA%E5%90%8C%E4%B8%80%E9%9D%9E%E8%99%9A%E5%9F%BA%E7%B1%BB"><span class="toc-number">1.8.6.</span> <span class="toc-text">▌R5.1.5 避免多重继承自同一非虚基类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-56"><span class="toc-number">1.8.6.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-56"><span class="toc-number">1.8.6.2.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-84"><span class="toc-number">1.8.6.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR5-1-6-%E5%AD%98%E5%9C%A8%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E6%88%96%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E6%97%B6%EF%BC%8C%E4%B8%8D%E5%BA%94%E7%BC%BA%E5%B0%91%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.8.7.</span> <span class="toc-text">▌R5.1.6 存在析构函数或拷贝赋值运算符时，不应缺少拷贝构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-57"><span class="toc-number">1.8.7.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-85"><span class="toc-number">1.8.7.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR5-1-7-%E5%AD%98%E5%9C%A8%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%88%96%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E6%97%B6%EF%BC%8C%E4%B8%8D%E5%BA%94%E7%BC%BA%E5%B0%91%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.8.8.</span> <span class="toc-text">▌R5.1.7 存在拷贝构造函数或析构函数时，不应缺少拷贝赋值运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-58"><span class="toc-number">1.8.8.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-86"><span class="toc-number">1.8.8.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR5-1-8-%E5%AD%98%E5%9C%A8%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%88%96%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E6%97%B6%EF%BC%8C%E4%B8%8D%E5%BA%94%E7%BC%BA%E5%B0%91%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">1.8.9.</span> <span class="toc-text">▌R5.1.8 存在拷贝构造函数或拷贝赋值运算符时，不应缺少析构函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-59"><span class="toc-number">1.8.9.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-87"><span class="toc-number">1.8.9.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR5-1-9-%E5%AD%98%E5%9C%A8%E4%BB%BB%E4%B8%80%E6%8B%B7%E8%B4%9D%E3%80%81%E7%A7%BB%E5%8A%A8%E3%80%81%E6%9E%90%E6%9E%84%E7%9B%B8%E5%85%B3%E7%9A%84%E5%87%BD%E6%95%B0%E6%97%B6%EF%BC%8C%E5%BA%94%E5%AE%9A%E4%B9%89%E6%89%80%E6%9C%89%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="toc-number">1.8.10.</span> <span class="toc-text">▌R5.1.9 存在任一拷贝、移动、析构相关的函数时，应定义所有相关函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-60"><span class="toc-number">1.8.10.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-88"><span class="toc-number">1.8.10.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR5-1-10-%E9%81%BF%E5%85%8D%E9%87%8D%E5%A4%8D%E5%AE%9E%E7%8E%B0%E7%94%B1%E9%BB%98%E8%AE%A4%E6%8B%B7%E8%B4%9D%E3%80%81%E7%A7%BB%E5%8A%A8%E3%80%81%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E5%AE%8C%E6%88%90%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">1.8.11.</span> <span class="toc-text">▌R5.1.10 避免重复实现由默认拷贝、移动、析构函数完成的功能</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-61"><span class="toc-number">1.8.11.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-89"><span class="toc-number">1.8.11.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR5-1-11-%E5%8F%AF%E6%8E%A5%E5%8F%97%E4%B8%80%E4%B8%AA%E5%8F%82%E6%95%B0%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E9%9C%80%E7%94%A8-explicit-%E5%85%B3%E9%94%AE%E5%AD%97%E9%99%90%E5%AE%9A"><span class="toc-number">1.8.12.</span> <span class="toc-text">▌R5.1.11 可接受一个参数的构造函数需用 explicit 关键字限定</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-62"><span class="toc-number">1.8.12.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-90"><span class="toc-number">1.8.12.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR5-1-12-%E9%87%8D%E8%BD%BD%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%BF%90%E7%AE%97%E7%AC%A6%E9%9C%80%E7%94%A8-explicit-%E5%85%B3%E9%94%AE%E5%AD%97%E9%99%90%E5%AE%9A"><span class="toc-number">1.8.13.</span> <span class="toc-text">▌R5.1.12 重载的类型转换运算符需用 explicit 关键字限定</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-63"><span class="toc-number">1.8.13.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-91"><span class="toc-number">1.8.13.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR5-1-13-%E4%B8%8D%E5%BA%94%E8%BF%87%E5%BA%A6%E4%BD%BF%E7%94%A8-explicit-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.8.14.</span> <span class="toc-text">▌R5.1.13 不应过度使用 explicit 关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-92"><span class="toc-number">1.8.14.1.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR5-1-14-%E5%B8%A6%E6%A8%A1%E6%9D%BF%E7%9A%84%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8D%E5%BA%94%E4%B8%8E%E6%8B%B7%E8%B4%9D%E6%88%96%E7%A7%BB%E5%8A%A8%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E6%B7%B7%E6%B7%86"><span class="toc-number">1.8.15.</span> <span class="toc-text">▌R5.1.14 带模板的赋值运算符不应与拷贝或移动赋值运算符混淆</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-64"><span class="toc-number">1.8.15.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-57"><span class="toc-number">1.8.15.2.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-93"><span class="toc-number">1.8.15.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR5-1-15-%E5%B8%A6%E6%A8%A1%E6%9D%BF%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8D%E5%BA%94%E4%B8%8E%E6%8B%B7%E8%B4%9D%E6%88%96%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%B7%B7%E6%B7%86"><span class="toc-number">1.8.16.</span> <span class="toc-text">▌R5.1.15 带模板的构造函数不应与拷贝或移动构造函数混淆</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-65"><span class="toc-number">1.8.16.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-58"><span class="toc-number">1.8.16.2.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-94"><span class="toc-number">1.8.16.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR5-1-16-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%A6%81%E7%94%A8%E6%8B%B7%E8%B4%9D%E5%92%8C%E7%A7%BB%E5%8A%A8%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.8.17.</span> <span class="toc-text">▌R5.1.16 抽象类禁用拷贝和移动赋值运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-95"><span class="toc-number">1.8.17.1.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR5-1-17-%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E7%9A%84%E6%95%B0%E9%87%8F%E5%BA%94%E5%9C%A8%E8%A7%84%E5%AE%9A%E8%8C%83%E5%9B%B4%E4%B9%8B%E5%86%85"><span class="toc-number">1.8.18.</span> <span class="toc-text">▌R5.1.17 数据成员的数量应在规定范围之内</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE-11"><span class="toc-number">1.8.18.1.</span> <span class="toc-text">配置</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR5-1-18-%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E4%B9%8B%E9%97%B4%E7%9A%84%E5%A1%AB%E5%85%85%E6%95%B0%E6%8D%AE%E4%B8%8D%E5%BA%94%E8%A2%AB%E5%BF%BD%E8%A7%86"><span class="toc-number">1.8.19.</span> <span class="toc-text">▌R5.1.18 数据成员之间的填充数据不应被忽视</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-66"><span class="toc-number">1.8.19.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-59"><span class="toc-number">1.8.19.2.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-96"><span class="toc-number">1.8.19.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR5-1-19-%E5%B8%B8%E9%87%8F%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%B8%8D%E5%BA%94%E8%BF%94%E5%9B%9E%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E7%9A%84%E9%9D%9E%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88%E6%88%96%E5%BC%95%E7%94%A8"><span class="toc-number">1.8.20.</span> <span class="toc-text">▌R5.1.19 常量成员函数不应返回数据成员的非常量指针或引用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-67"><span class="toc-number">1.8.20.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-97"><span class="toc-number">1.8.20.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR5-1-20-%E7%B1%BB%E6%88%90%E5%91%98%E5%BA%94%E6%8C%89-public%E3%80%81protected%E3%80%81private-%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%A3%B0%E6%98%8E"><span class="toc-number">1.8.21.</span> <span class="toc-text">▌R5.1.20 类成员应按 public、protected、private 的顺序声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR5-1-21-%E5%AD%98%E5%9C%A8%E6%9E%84%E9%80%A0%E3%80%81%E6%9E%90%E6%9E%84%E6%88%96%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E7%B1%BB%E4%B8%8D%E5%BA%94%E9%87%87%E7%94%A8-struct-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.8.22.</span> <span class="toc-text">▌R5.1.21 存在构造、析构或虚函数的类不应采用 struct 关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-98"><span class="toc-number">1.8.22.1.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-Enum"><span class="toc-number">1.8.23.</span> <span class="toc-text">5.2 Enum</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR5-2-1-%E5%90%8C%E7%B1%BB%E6%9E%9A%E4%B8%BE%E9%A1%B9%E7%9A%84%E5%80%BC%E4%B8%8D%E5%BA%94%E7%9B%B8%E5%90%8C"><span class="toc-number">1.8.24.</span> <span class="toc-text">▌R5.2.1 同类枚举项的值不应相同</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-99"><span class="toc-number">1.8.24.1.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR5-2-2-%E5%90%88%E7%90%86%E5%88%9D%E5%A7%8B%E5%8C%96%E5%90%84%E6%9E%9A%E4%B8%BE%E9%A1%B9"><span class="toc-number">1.8.25.</span> <span class="toc-text">▌R5.2.2 合理初始化各枚举项</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-68"><span class="toc-number">1.8.25.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-100"><span class="toc-number">1.8.25.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR5-2-3-%E4%B8%8D%E5%BA%94%E4%BD%BF%E7%94%A8%E5%8C%BF%E5%90%8D%E6%9E%9A%E4%B8%BE%E5%A3%B0%E6%98%8E"><span class="toc-number">1.8.26.</span> <span class="toc-text">▌R5.2.3 不应使用匿名枚举声明</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-101"><span class="toc-number">1.8.26.1.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR5-2-4-%E7%94%A8-enum-class-%E5%8F%96%E4%BB%A3-enum"><span class="toc-number">1.8.27.</span> <span class="toc-text">▌R5.2.4 用 enum class 取代 enum</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-60"><span class="toc-number">1.8.27.1.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-102"><span class="toc-number">1.8.27.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-Union"><span class="toc-number">1.8.28.</span> <span class="toc-text">5.3 Union</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR5-3-1-%E8%81%94%E5%90%88%E4%BD%93%E5%86%85%E7%A6%81%E7%94%A8%E9%9D%9E%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.8.29.</span> <span class="toc-text">▌R5.3.1 联合体内禁用非基本类型的对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-61"><span class="toc-number">1.8.29.1.</span> <span class="toc-text">依据</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR5-3-2-%E7%A6%81%E7%94%A8%E5%9C%A8%E7%B1%BB%E4%B9%8B%E5%A4%96%E5%AE%9A%E4%B9%89%E7%9A%84%E8%81%94%E5%90%88%E4%BD%93"><span class="toc-number">1.8.30.</span> <span class="toc-text">▌R5.3.2 禁用在类之外定义的联合体</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-69"><span class="toc-number">1.8.30.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-103"><span class="toc-number">1.8.30.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR5-3-3-%E7%A6%81%E7%94%A8%E8%81%94%E5%90%88%E4%BD%93"><span class="toc-number">1.8.31.</span> <span class="toc-text">▌R5.3.3 禁用联合体</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-70"><span class="toc-number">1.8.31.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-104"><span class="toc-number">1.8.31.2.</span> <span class="toc-text">参考</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-Declaration"><span class="toc-number">1.9.</span> <span class="toc-text">6. Declaration</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-Naming"><span class="toc-number">1.9.1.</span> <span class="toc-text">6.1 Naming</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR6-1-1-%E9%81%B5%E5%BE%AA%E5%90%88%E7%90%86%E7%9A%84%E5%91%BD%E5%90%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">1.9.2.</span> <span class="toc-text">▌R6.1.1 遵循合理的命名方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE-12"><span class="toc-number">1.9.2.1.</span> <span class="toc-text">配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-62"><span class="toc-number">1.9.2.2.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-105"><span class="toc-number">1.9.2.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR6-1-2-%E4%B8%8D%E5%BA%94%E5%AE%9A%E4%B9%89%E5%85%B7%E6%9C%89%E4%BF%9D%E7%95%99%E6%84%8F%E4%B9%89%E7%9A%84%E5%90%8D%E7%A7%B0"><span class="toc-number">1.9.3.</span> <span class="toc-text">▌R6.1.2 不应定义具有保留意义的名称</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-71"><span class="toc-number">1.9.3.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-63"><span class="toc-number">1.9.3.2.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-106"><span class="toc-number">1.9.3.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR6-1-3-%E5%B1%80%E9%83%A8%E5%90%8D%E7%A7%B0%E4%B8%8D%E5%BA%94%E8%A2%AB%E8%A6%86%E7%9B%96"><span class="toc-number">1.9.4.</span> <span class="toc-text">▌R6.1.3 局部名称不应被覆盖</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-107"><span class="toc-number">1.9.4.1.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR6-1-4-%E6%88%90%E5%91%98%E5%90%8D%E7%A7%B0%E4%B8%8D%E5%BA%94%E8%A2%AB%E8%A6%86%E7%9B%96"><span class="toc-number">1.9.5.</span> <span class="toc-text">▌R6.1.4 成员名称不应被覆盖</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-108"><span class="toc-number">1.9.5.1.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR6-1-5-%E5%85%A8%E5%B1%80%E5%90%8D%E7%A7%B0%E4%B8%8D%E5%BA%94%E8%A2%AB%E8%A6%86%E7%9B%96"><span class="toc-number">1.9.6.</span> <span class="toc-text">▌R6.1.5 全局名称不应被覆盖</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-109"><span class="toc-number">1.9.6.1.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR6-1-6-%E7%B1%BB%E5%9E%8B%E5%90%8D%E7%A7%B0%E4%B8%8D%E5%BA%94%E9%87%8D%E5%A4%8D%E5%AE%9A%E4%B9%89"><span class="toc-number">1.9.7.</span> <span class="toc-text">▌R6.1.6 类型名称不应重复定义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-110"><span class="toc-number">1.9.7.1.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR6-1-7-%E7%B1%BB%E5%9E%8B%E5%90%8D%E7%A7%B0%E4%B8%8D%E5%BA%94%E4%B8%8E%E5%AF%B9%E8%B1%A1%E6%88%96%E5%87%BD%E6%95%B0%E5%90%8D%E7%A7%B0%E7%9B%B8%E5%90%8C"><span class="toc-number">1.9.8.</span> <span class="toc-text">▌R6.1.7 类型名称不应与对象或函数名称相同</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-111"><span class="toc-number">1.9.8.1.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR6-1-8-%E4%B8%8D%E5%BA%94%E5%AD%98%E5%9C%A8%E6%8B%BC%E5%86%99%E9%94%99%E8%AF%AF"><span class="toc-number">1.9.9.</span> <span class="toc-text">▌R6.1.8 不应存在拼写错误</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-Qualifier"><span class="toc-number">1.9.10.</span> <span class="toc-text">6.2 Qualifier</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR6-2-1-const%E3%80%81volatile-%E4%B8%8D%E5%BA%94%E9%87%8D%E5%A4%8D"><span class="toc-number">1.9.11.</span> <span class="toc-text">▌R6.2.1 const、volatile 不应重复</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-72"><span class="toc-number">1.9.11.1.</span> <span class="toc-text">相关</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR6-2-2-const%E3%80%81volatile-%E9%99%90%E5%AE%9A%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%88%AB%E5%90%8D%E6%98%AF%E5%8F%AF%E7%96%91%E7%9A%84"><span class="toc-number">1.9.12.</span> <span class="toc-text">▌R6.2.2 const、volatile 限定指针类型的别名是可疑的</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-73"><span class="toc-number">1.9.12.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-112"><span class="toc-number">1.9.12.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR6-2-3-const%E3%80%81volatile-%E4%B8%8D%E5%8F%AF%E9%99%90%E5%AE%9A%E5%BC%95%E7%94%A8"><span class="toc-number">1.9.13.</span> <span class="toc-text">▌R6.2.3 const、volatile 不可限定引用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-64"><span class="toc-number">1.9.13.1.</span> <span class="toc-text">依据</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR6-2-4-const%E3%80%81volatile-%E9%99%90%E5%AE%9A%E7%B1%BB%E5%9E%8B%E6%97%B6%E7%9A%84%E4%BD%8D%E7%BD%AE%E5%BA%94%E7%BB%9F%E4%B8%80"><span class="toc-number">1.9.14.</span> <span class="toc-text">▌R6.2.4 const、volatile 限定类型时的位置应统一</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE-13"><span class="toc-number">1.9.14.1.</span> <span class="toc-text">配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-74"><span class="toc-number">1.9.14.2.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-65"><span class="toc-number">1.9.14.3.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-113"><span class="toc-number">1.9.14.4.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR6-2-5-const%E3%80%81volatile-%E7%AD%89%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8D%E5%BA%94%E5%87%BA%E7%8E%B0%E5%9C%A8%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%90%8D%E7%A7%B0%E7%9A%84%E4%B8%AD%E9%97%B4"><span class="toc-number">1.9.15.</span> <span class="toc-text">▌R6.2.5 const、volatile 等关键字不应出现在基本类型名称的中间</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-75"><span class="toc-number">1.9.15.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-66"><span class="toc-number">1.9.15.2.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-114"><span class="toc-number">1.9.15.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR6-2-6-%E6%8C%87%E5%90%91%E5%B8%B8%E9%87%8F%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8C%87%E9%92%88%E5%BA%94%E4%BD%BF%E7%94%A8-const-%E5%A3%B0%E6%98%8E"><span class="toc-number">1.9.16.</span> <span class="toc-text">▌R6.2.6 指向常量字符串的指针应使用 const 声明</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-76"><span class="toc-number">1.9.16.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-67"><span class="toc-number">1.9.16.2.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-115"><span class="toc-number">1.9.16.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR6-2-7-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%BA%95%E5%B1%82%E7%B1%BB%E5%9E%8B%E4%B8%8D%E5%BA%94%E4%B8%BA-const-%E6%88%96-volatile"><span class="toc-number">1.9.17.</span> <span class="toc-text">▌R6.2.7 枚举类型的底层类型不应为 const 或 volatile</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-68"><span class="toc-number">1.9.17.1.</span> <span class="toc-text">依据</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR6-2-8-%E5%AF%B9%E5%B8%B8%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8D%E5%BA%94%E4%B8%BA%E5%BC%95%E7%94%A8"><span class="toc-number">1.9.18.</span> <span class="toc-text">▌R6.2.8 对常量的定义不应为引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR6-2-9-%E7%A6%81%E7%94%A8-restrict-%E6%8C%87%E9%92%88"><span class="toc-number">1.9.19.</span> <span class="toc-text">▌R6.2.9 禁用 restrict 指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-69"><span class="toc-number">1.9.19.1.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-116"><span class="toc-number">1.9.19.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR6-2-10-%E9%9D%9E%E9%80%82%E5%BD%93%E5%9C%BA%E6%99%AF%E7%A6%81%E7%94%A8-volatile"><span class="toc-number">1.9.20.</span> <span class="toc-text">▌R6.2.10 非适当场景禁用 volatile</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-70"><span class="toc-number">1.9.20.1.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-117"><span class="toc-number">1.9.20.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR6-2-11-%E7%9B%B8%E5%85%B3%E5%AF%B9%E8%B1%A1%E6%9C%AA%E8%A2%AB%E4%BF%AE%E6%94%B9%E6%97%B6%E5%BA%94%E4%BD%BF%E7%94%A8-const-%E5%A3%B0%E6%98%8E"><span class="toc-number">1.9.21.</span> <span class="toc-text">▌R6.2.11 相关对象未被修改时应使用 const 声明</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-77"><span class="toc-number">1.9.21.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-118"><span class="toc-number">1.9.21.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-Specifier"><span class="toc-number">1.9.22.</span> <span class="toc-text">6.3 Specifier</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR6-3-1-%E5%90%88%E7%90%86%E4%BD%BF%E7%94%A8-auto-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.9.23.</span> <span class="toc-text">▌R6.3.1 合理使用 auto 关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-78"><span class="toc-number">1.9.23.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-119"><span class="toc-number">1.9.23.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR6-3-2-%E4%B8%8D%E5%BA%94%E4%BD%BF%E7%94%A8%E5%B7%B2%E8%BF%87%E6%97%B6%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.9.24.</span> <span class="toc-text">▌R6.3.2 不应使用已过时的关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-71"><span class="toc-number">1.9.24.1.</span> <span class="toc-text">依据</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR6-3-3-%E4%B8%8D%E5%BA%94%E4%BD%BF%E7%94%A8%E5%A4%9A%E4%BD%99%E7%9A%84-inline-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.9.25.</span> <span class="toc-text">▌R6.3.3 不应使用多余的 inline 关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-72"><span class="toc-number">1.9.25.1.</span> <span class="toc-text">依据</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR6-3-4-extern-%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8D%E5%BA%94%E4%BD%9C%E7%94%A8%E4%BA%8E%E7%B1%BB%E6%88%90%E5%91%98%E7%9A%84%E5%A3%B0%E6%98%8E%E6%88%96%E5%AE%9A%E4%B9%89"><span class="toc-number">1.9.26.</span> <span class="toc-text">▌R6.3.4 extern 关键字不应作用于类成员的声明或定义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-73"><span class="toc-number">1.9.26.1.</span> <span class="toc-text">依据</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR6-3-5-%E9%87%8D%E5%86%99%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0%E5%BA%94%E5%A3%B0%E6%98%8E%E4%B8%BA-override-%E6%88%96-final"><span class="toc-number">1.9.27.</span> <span class="toc-text">▌R6.3.5 重写的虚函数应声明为 override 或 final</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-74"><span class="toc-number">1.9.27.1.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-120"><span class="toc-number">1.9.27.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR6-3-6-override-%E5%92%8C-final-%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8D%E5%BA%94%E5%90%8C%E6%97%B6%E5%87%BA%E7%8E%B0%E5%9C%A8%E5%A3%B0%E6%98%8E%E4%B8%AD"><span class="toc-number">1.9.28.</span> <span class="toc-text">▌R6.3.6 override 和 final 关键字不应同时出现在声明中</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-121"><span class="toc-number">1.9.28.1.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR6-3-7-override-%E6%88%96-final-%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8D%E5%BA%94%E4%B8%8E-virtual-%E5%85%B3%E9%94%AE%E5%AD%97%E5%90%8C%E6%97%B6%E5%87%BA%E7%8E%B0%E5%9C%A8%E5%A3%B0%E6%98%8E%E4%B8%AD"><span class="toc-number">1.9.29.</span> <span class="toc-text">▌R6.3.7 override 或 final 关键字不应与 virtual 关键字同时出现在声明中</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-122"><span class="toc-number">1.9.29.1.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR6-3-8-%E4%B8%8D%E5%BA%94%E5%B0%86-union-%E8%AE%BE%E4%B8%BA-final"><span class="toc-number">1.9.30.</span> <span class="toc-text">▌R6.3.8 不应将 union 设为 final</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-75"><span class="toc-number">1.9.30.1.</span> <span class="toc-text">依据</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR6-3-9-%E6%9C%AA%E8%AE%BF%E9%97%AE-this-%E6%8C%87%E9%92%88%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%BA%94%E4%BD%BF%E7%94%A8-static-%E5%A3%B0%E6%98%8E"><span class="toc-number">1.9.31.</span> <span class="toc-text">▌R6.3.9 未访问 this 指针的成员函数应使用 static 声明</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-123"><span class="toc-number">1.9.31.1.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR6-3-10-%E5%A3%B0%E6%98%8E%E5%92%8C%E5%AE%9A%E4%B9%89%E5%86%85%E9%83%A8%E9%93%BE%E6%8E%A5%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%87%BD%E6%95%B0%E6%97%B6%E5%9D%87%E5%BA%94%E4%BD%BF%E7%94%A8-static-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.9.32.</span> <span class="toc-text">▌R6.3.10 声明和定义内部链接的对象和函数时均应使用 static 关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-124"><span class="toc-number">1.9.32.1.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR6-3-11-inline%E3%80%81virtual%E3%80%81static%E3%80%81typedef-%E7%AD%89%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%8D%E7%BD%AE%E5%BA%94%E7%BB%9F%E4%B8%80"><span class="toc-number">1.9.33.</span> <span class="toc-text">▌R6.3.11 inline、virtual、static、typedef 等关键字的位置应统一</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-79"><span class="toc-number">1.9.33.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-76"><span class="toc-number">1.9.33.2.</span> <span class="toc-text">依据</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-Declarator"><span class="toc-number">1.9.34.</span> <span class="toc-text">6.4 Declarator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR6-4-1-%E7%94%A8-auto-%E5%A3%B0%E6%98%8E%E6%8C%87%E9%92%88%E6%88%96%E5%BC%95%E7%94%A8%E6%97%B6%E5%BA%94%E6%98%BE%E5%BC%8F%E6%A0%87%E6%98%8E-%E3%80%81-amp-%E7%AD%89%E7%AC%A6%E5%8F%B7"><span class="toc-number">1.9.35.</span> <span class="toc-text">▌R6.4.1 用 auto 声明指针或引用时应显式标明 *、&amp; 等符号</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-77"><span class="toc-number">1.9.35.1.</span> <span class="toc-text">依据</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR6-4-2-%E7%A6%81%E7%94%A8%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8"><span class="toc-number">1.9.36.</span> <span class="toc-text">▌R6.4.2 禁用可变参数列表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-80"><span class="toc-number">1.9.36.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-78"><span class="toc-number">1.9.36.2.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-125"><span class="toc-number">1.9.36.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR6-4-3-%E7%A6%81%E7%94%A8%E6%9F%94%E6%80%A7%E6%95%B0%E7%BB%84"><span class="toc-number">1.9.37.</span> <span class="toc-text">▌R6.4.3 禁用柔性数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-79"><span class="toc-number">1.9.37.1.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-126"><span class="toc-number">1.9.37.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR6-4-4-%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B%E4%B8%8D%E5%BA%94%E4%B8%BA-void"><span class="toc-number">1.9.38.</span> <span class="toc-text">▌R6.4.4 接口的参数类型和返回类型不应为 void*</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-81"><span class="toc-number">1.9.38.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-127"><span class="toc-number">1.9.38.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR6-4-5-%E7%B1%BB%E6%88%90%E5%91%98%E7%9A%84%E7%B1%BB%E5%9E%8B%E4%B8%8D%E5%BA%94%E4%B8%BA-void"><span class="toc-number">1.9.39.</span> <span class="toc-text">▌R6.4.5 类成员的类型不应为 void*</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-82"><span class="toc-number">1.9.39.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-128"><span class="toc-number">1.9.39.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR6-4-6-%E6%95%B0%E7%BB%84%E5%A4%A7%E5%B0%8F%E5%BA%94%E8%A2%AB%E6%98%BE%E5%BC%8F%E5%A3%B0%E6%98%8E"><span class="toc-number">1.9.40.</span> <span class="toc-text">▌R6.4.6 数组大小应被显式声明</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE-14"><span class="toc-number">1.9.40.1.</span> <span class="toc-text">配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-129"><span class="toc-number">1.9.40.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR6-4-7-%E4%B8%8D%E5%BA%94%E5%B0%86%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%A3%B0%E6%98%8E%E5%86%99%E5%9C%A8%E4%B8%80%E4%B8%AA%E8%AF%AD%E5%8F%A5%E4%B8%AD"><span class="toc-number">1.9.41.</span> <span class="toc-text">▌R6.4.7 不应将类型定义和对象声明写在一个语句中</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-130"><span class="toc-number">1.9.41.1.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR6-4-8-%E4%B8%8D%E5%BA%94%E5%B0%86%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%88%AB%E7%9A%84%E5%A3%B0%E6%98%8E%E5%86%99%E5%9C%A8%E4%B8%80%E4%B8%AA%E8%AF%AD%E5%8F%A5%E4%B8%AD"><span class="toc-number">1.9.42.</span> <span class="toc-text">▌R6.4.8 不应将不同类别的声明写在一个语句中</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-83"><span class="toc-number">1.9.42.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-131"><span class="toc-number">1.9.42.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-Object"><span class="toc-number">1.9.43.</span> <span class="toc-text">6.5 Object</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR6-5-1-%E4%B8%8D%E5%BA%94%E4%BA%A7%E7%94%9F%E6%97%A0%E6%95%88%E7%9A%84%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.9.44.</span> <span class="toc-text">▌R6.5.1 不应产生无效的临时对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-132"><span class="toc-number">1.9.44.1.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR6-5-2-%E4%B8%8D%E5%BA%94%E5%AD%98%E5%9C%A8%E6%B2%A1%E6%9C%89%E8%A2%AB%E7%94%A8%E5%88%B0%E7%9A%84%E5%B1%80%E9%83%A8%E5%A3%B0%E6%98%8E"><span class="toc-number">1.9.45.</span> <span class="toc-text">▌R6.5.2 不应存在没有被用到的局部声明</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-133"><span class="toc-number">1.9.45.1.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR6-5-3-%E5%AF%B9%E8%B1%A1%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8D%E5%8F%AF%E4%BE%9D%E8%B5%96%E8%87%AA%E8%BA%AB%E7%9A%84%E5%80%BC"><span class="toc-number">1.9.46.</span> <span class="toc-text">▌R6.5.3 对象初始化不可依赖自身的值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR6-5-4-%E5%8F%82%E4%B8%8E%E6%95%B0%E5%80%BC%E8%BF%90%E7%AE%97%E7%9A%84-char-%E5%AF%B9%E8%B1%A1%E5%BA%94%E6%98%BE%E5%BC%8F%E5%A3%B0%E6%98%8E-signed-%E6%88%96-unsigned"><span class="toc-number">1.9.47.</span> <span class="toc-text">▌R6.5.4 参与数值运算的 char 对象应显式声明 signed 或 unsigned</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-80"><span class="toc-number">1.9.47.1.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-134"><span class="toc-number">1.9.47.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR6-5-5-%E5%AD%97%E8%8A%82%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%BA%94%E4%B8%BA-std-byte-%E6%88%96-unsigned-char"><span class="toc-number">1.9.48.</span> <span class="toc-text">▌R6.5.5 字节的类型应为 std::byte 或 unsigned char</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-84"><span class="toc-number">1.9.48.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-81"><span class="toc-number">1.9.48.2.</span> <span class="toc-text">依据</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-Parameter"><span class="toc-number">1.9.49.</span> <span class="toc-text">6.6 Parameter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR6-6-1-%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B%E5%A3%B0%E6%98%8E%E4%B8%AD%E7%9A%84%E5%8F%82%E6%95%B0%E5%BA%94%E5%85%B7%E6%9C%89%E5%90%88%E7%90%86%E7%9A%84%E5%90%8D%E7%A7%B0"><span class="toc-number">1.9.50.</span> <span class="toc-text">▌R6.6.1 函数原型声明中的参数应具有合理的名称</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-135"><span class="toc-number">1.9.50.1.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR6-6-2-%E4%B8%8D%E5%BA%94%E5%B0%86%E6%95%B0%E7%BB%84%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E7%9A%84%E5%BD%A2%E5%BC%8F%E5%8F%82%E6%95%B0"><span class="toc-number">1.9.51.</span> <span class="toc-text">▌R6.6.2 不应将数组作为函数的形式参数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-82"><span class="toc-number">1.9.51.1.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-136"><span class="toc-number">1.9.51.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR6-6-3-parmN-%E7%9A%84%E5%A3%B0%E6%98%8E%E5%BA%94%E7%AC%A6%E5%90%88%E8%A6%81%E6%B1%82"><span class="toc-number">1.9.52.</span> <span class="toc-text">▌R6.6.3 parmN 的声明应符合要求</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-85"><span class="toc-number">1.9.52.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-83"><span class="toc-number">1.9.52.2.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-137"><span class="toc-number">1.9.52.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR6-6-4-%E8%99%9A%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC%E5%BA%94%E4%B8%8E%E5%9F%BA%E7%B1%BB%E4%B8%AD%E5%A3%B0%E6%98%8E%E7%9A%84%E4%B8%80%E8%87%B4"><span class="toc-number">1.9.53.</span> <span class="toc-text">▌R6.6.4 虚函数参数的默认值应与基类中声明的一致</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-86"><span class="toc-number">1.9.53.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-84"><span class="toc-number">1.9.53.2.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-138"><span class="toc-number">1.9.53.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR6-6-5-%E4%B8%8D%E5%BB%BA%E8%AE%AE%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0%E6%9C%89%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="toc-number">1.9.54.</span> <span class="toc-text">▌R6.6.5 不建议虚函数的参数有默认值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-87"><span class="toc-number">1.9.54.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-85"><span class="toc-number">1.9.54.2.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-139"><span class="toc-number">1.9.54.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR6-6-6-C-%E4%BB%A3%E7%A0%81%E4%B8%AD%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8%E5%A6%82%E6%9E%9C%E4%B8%BA%E7%A9%BA%E5%BA%94%E5%A3%B0%E6%98%8E%E4%B8%BA%E2%80%9C-void-%E2%80%9D"><span class="toc-number">1.9.55.</span> <span class="toc-text">▌R6.6.6 C 代码中参数列表如果为空应声明为“(void)”</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-88"><span class="toc-number">1.9.55.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-86"><span class="toc-number">1.9.55.2.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-140"><span class="toc-number">1.9.55.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR6-6-7-C-%E4%BB%A3%E7%A0%81%E4%B8%AD%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8%E5%A6%82%E6%9E%9C%E4%B8%BA%E7%A9%BA%E4%B8%8D%E5%BA%94%E5%A3%B0%E6%98%8E%E4%B8%BA%E2%80%9C-void-%E2%80%9D"><span class="toc-number">1.9.56.</span> <span class="toc-text">▌R6.6.7 C++ 代码中参数列表如果为空不应声明为“(void)”</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-89"><span class="toc-number">1.9.56.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-87"><span class="toc-number">1.9.56.2.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-141"><span class="toc-number">1.9.56.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR6-6-8-%E5%A3%B0%E6%98%8E%E6%95%B0%E7%BB%84%E5%8F%82%E6%95%B0%E7%9A%84%E5%A4%A7%E5%B0%8F%E6%97%B6%E7%A6%81%E7%94%A8-static-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.9.57.</span> <span class="toc-text">▌R6.6.8 声明数组参数的大小时禁用 static 关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-88"><span class="toc-number">1.9.57.1.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-142"><span class="toc-number">1.9.57.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-7-Function"><span class="toc-number">1.9.58.</span> <span class="toc-text">6.7 Function</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR6-7-1-%E6%B4%BE%E7%94%9F%E7%B1%BB%E4%B8%8D%E5%BA%94%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%9F%BA%E7%B1%BB%E7%9B%B8%E5%90%8C%E7%9A%84%E9%9D%9E%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">1.9.59.</span> <span class="toc-text">▌R6.7.1 派生类不应重新定义与基类相同的非虚函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-143"><span class="toc-number">1.9.59.1.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR6-7-2-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B%E5%BA%94%E4%B8%8E%E5%86%85%E7%BD%AE%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9B%B8%E7%AC%A6"><span class="toc-number">1.9.60.</span> <span class="toc-text">▌R6.7.2 重载运算符的返回类型应与内置运算符相符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-90"><span class="toc-number">1.9.60.1.</span> <span class="toc-text">相关</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR6-7-3-%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E5%BA%94%E8%BF%94%E5%9B%9E%E6%89%80%E5%B1%9E%E7%B1%BB%E7%9A%84%E9%9D%9E-const-%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8"><span class="toc-number">1.9.61.</span> <span class="toc-text">▌R6.7.3 赋值运算符应返回所属类的非 const 左值引用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-91"><span class="toc-number">1.9.61.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-89"><span class="toc-number">1.9.61.2.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-144"><span class="toc-number">1.9.61.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR6-7-4-%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0%E5%BA%94%E4%B8%BA%E5%90%8C%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84-const-%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8"><span class="toc-number">1.9.62.</span> <span class="toc-text">▌R6.7.4 拷贝构造函数的参数应为同类对象的 const 左值引用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-92"><span class="toc-number">1.9.62.1.</span> <span class="toc-text">相关</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR6-7-5-%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E5%8F%82%E6%95%B0%E5%BA%94%E4%B8%BA%E5%90%8C%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84-const-%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8"><span class="toc-number">1.9.63.</span> <span class="toc-text">▌R6.7.5 拷贝赋值运算符的参数应为同类对象的 const 左值引用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-93"><span class="toc-number">1.9.63.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-90"><span class="toc-number">1.9.63.2.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-145"><span class="toc-number">1.9.63.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR6-7-6-%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0%E5%BA%94%E4%B8%BA%E5%90%8C%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%9D%9E-const-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="toc-number">1.9.64.</span> <span class="toc-text">▌R6.7.6 移动构造函数的参数应为同类对象的非 const 右值引用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-94"><span class="toc-number">1.9.64.1.</span> <span class="toc-text">相关</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR6-7-7-%E7%A7%BB%E5%8A%A8%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E5%8F%82%E6%95%B0%E5%BA%94%E4%B8%BA%E5%90%8C%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%9D%9E-const-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="toc-number">1.9.65.</span> <span class="toc-text">▌R6.7.7 移动赋值运算符的参数应为同类对象的非 const 右值引用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-91"><span class="toc-number">1.9.65.1.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-146"><span class="toc-number">1.9.65.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR6-7-8-%E4%B8%8D%E5%BA%94%E9%87%8D%E8%BD%BD%E5%8F%96%E5%9C%B0%E5%9D%80%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.9.66.</span> <span class="toc-text">▌R6.7.8 不应重载取地址运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-92"><span class="toc-number">1.9.66.1.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-147"><span class="toc-number">1.9.66.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR6-7-9-%E4%B8%8D%E5%BA%94%E9%87%8D%E8%BD%BD%E9%80%97%E5%8F%B7%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.9.67.</span> <span class="toc-text">▌R6.7.9 不应重载逗号运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-95"><span class="toc-number">1.9.67.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-93"><span class="toc-number">1.9.67.2.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-148"><span class="toc-number">1.9.67.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR6-7-10-%E4%B8%8D%E5%BA%94%E9%87%8D%E8%BD%BD%E2%80%9C%E9%80%BB%E8%BE%91%E4%B8%8E%E2%80%9D%E5%92%8C%E2%80%9C%E9%80%BB%E8%BE%91%E6%88%96%E2%80%9D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.9.68.</span> <span class="toc-text">▌R6.7.10 不应重载“逻辑与”和“逻辑或”运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-96"><span class="toc-number">1.9.68.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-94"><span class="toc-number">1.9.68.2.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-149"><span class="toc-number">1.9.68.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR6-7-11-%E6%8B%B7%E8%B4%9D%E5%92%8C%E7%A7%BB%E5%8A%A8%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8D%E5%BA%94%E4%B8%BA%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">1.9.69.</span> <span class="toc-text">▌R6.7.11 拷贝和移动赋值运算符不应为虚函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-97"><span class="toc-number">1.9.69.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-95"><span class="toc-number">1.9.69.2.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-150"><span class="toc-number">1.9.69.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR6-7-12-%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8D%E5%BA%94%E4%B8%BA%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">1.9.70.</span> <span class="toc-text">▌R6.7.12 比较运算符不应为虚函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-151"><span class="toc-number">1.9.70.1.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR6-7-13-final-%E7%B1%BB%E4%B8%AD%E4%B8%8D%E5%BA%94%E5%A3%B0%E6%98%8E%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">1.9.71.</span> <span class="toc-text">▌R6.7.13 final 类中不应声明虚函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-96"><span class="toc-number">1.9.71.1.</span> <span class="toc-text">依据</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-8-Bitfield"><span class="toc-number">1.9.72.</span> <span class="toc-text">6.8 Bitfield</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR6-8-1-%E5%AF%B9%E4%BD%8D%E5%9F%9F%E5%A3%B0%E6%98%8E%E5%90%88%E7%90%86%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.9.73.</span> <span class="toc-text">▌R6.8.1 对位域声明合理的类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE-15"><span class="toc-number">1.9.73.1.</span> <span class="toc-text">配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-97"><span class="toc-number">1.9.73.2.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-152"><span class="toc-number">1.9.73.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR6-8-2-%E4%BD%8D%E5%9F%9F%E9%95%BF%E5%BA%A6%E4%B8%8D%E5%BA%94%E8%B6%85%E8%BF%87%E7%B1%BB%E5%9E%8B%E9%95%BF%E5%BA%A6"><span class="toc-number">1.9.74.</span> <span class="toc-text">▌R6.8.2 位域长度不应超过类型长度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-98"><span class="toc-number">1.9.74.1.</span> <span class="toc-text">依据</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR6-8-3-%E6%9C%89%E7%AC%A6%E5%8F%B7%E6%95%B4%E5%9E%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BD%8D%E5%9F%9F%E9%95%BF%E5%BA%A6%E4%B8%8D%E5%BA%94%E4%B8%BA-1"><span class="toc-number">1.9.75.</span> <span class="toc-text">▌R6.8.3 有符号整型对象的位域长度不应为 1</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-153"><span class="toc-number">1.9.75.1.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR6-8-4-%E4%B8%8D%E5%BA%94%E5%AF%B9%E6%9E%9A%E4%B8%BE%E5%AF%B9%E8%B1%A1%E5%A3%B0%E6%98%8E%E4%BD%8D%E5%9F%9F"><span class="toc-number">1.9.76.</span> <span class="toc-text">▌R6.8.4 不应对枚举对象声明位域</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-98"><span class="toc-number">1.9.76.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-99"><span class="toc-number">1.9.76.2.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-154"><span class="toc-number">1.9.76.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR6-8-5-%E7%A6%81%E7%94%A8%E4%BD%8D%E5%9F%9F"><span class="toc-number">1.9.77.</span> <span class="toc-text">▌R6.8.5 禁用位域</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-99"><span class="toc-number">1.9.77.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-100"><span class="toc-number">1.9.77.2.</span> <span class="toc-text">依据</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-9-Complexity"><span class="toc-number">1.9.78.</span> <span class="toc-text">6.9 Complexity</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR6-9-1-%E4%B8%8D%E5%BA%94%E9%87%87%E7%94%A8%E5%A4%8D%E6%9D%82%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="toc-number">1.9.79.</span> <span class="toc-text">▌R6.9.1 不应采用复杂的声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR6-9-2-%E5%A3%B0%E6%98%8E%E4%B8%AD%E4%B8%8D%E5%BA%94%E5%8C%85%E5%90%AB%E8%BF%87%E5%A4%9A%E7%9A%84%E6%8C%87%E9%92%88%E5%B5%8C%E5%A5%97"><span class="toc-number">1.9.80.</span> <span class="toc-text">▌R6.9.2 声明中不应包含过多的指针嵌套</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE-16"><span class="toc-number">1.9.80.1.</span> <span class="toc-text">配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-100"><span class="toc-number">1.9.80.2.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-155"><span class="toc-number">1.9.80.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR6-9-3-%E5%9C%A8%E4%B8%80%E4%B8%AA%E8%AF%AD%E5%8F%A5%E4%B8%AD%E4%B8%8D%E5%BA%94%E5%A3%B0%E6%98%8E%E5%A4%9A%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%88%96%E5%87%BD%E6%95%B0"><span class="toc-number">1.9.81.</span> <span class="toc-text">▌R6.9.3 在一个语句中不应声明多个对象或函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE-17"><span class="toc-number">1.9.81.1.</span> <span class="toc-text">配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-101"><span class="toc-number">1.9.81.2.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-156"><span class="toc-number">1.9.81.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-10-Other"><span class="toc-number">1.9.82.</span> <span class="toc-text">6.10 Other</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR6-10-1-%E9%81%B5%E5%BE%AA-One-Definition-Rule"><span class="toc-number">1.9.83.</span> <span class="toc-text">▌R6.10.1 遵循 One Definition Rule</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-101"><span class="toc-number">1.9.83.1.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-157"><span class="toc-number">1.9.83.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR6-10-2-%E5%A3%B0%E6%98%8E%E4%B8%8E%E5%AE%9E%E7%8E%B0%E5%BA%94%E4%B8%80%E8%87%B4"><span class="toc-number">1.9.84.</span> <span class="toc-text">▌R6.10.2 声明与实现应一致</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-102"><span class="toc-number">1.9.84.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-102"><span class="toc-number">1.9.84.2.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-158"><span class="toc-number">1.9.84.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR6-10-3-%E5%9C%A8%E5%90%88%E7%90%86%E7%9A%84%E4%BD%8D%E7%BD%AE%E5%A3%B0%E6%98%8E"><span class="toc-number">1.9.85.</span> <span class="toc-text">▌R6.10.3 在合理的位置声明</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-103"><span class="toc-number">1.9.85.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-103"><span class="toc-number">1.9.85.2.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-159"><span class="toc-number">1.9.85.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR6-10-4-%E4%B8%8D%E5%BA%94%E5%AD%98%E5%9C%A8%E6%B2%A1%E6%9C%89%E8%A2%AB%E7%94%A8%E5%88%B0%E7%9A%84%E6%A0%87%E7%AD%BE"><span class="toc-number">1.9.86.</span> <span class="toc-text">▌R6.10.4 不应存在没有被用到的标签</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-160"><span class="toc-number">1.9.86.1.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR6-10-5-%E4%B8%8D%E5%BA%94%E5%AD%98%E5%9C%A8%E6%B2%A1%E6%9C%89%E8%A2%AB%E7%94%A8%E5%88%B0%E7%9A%84%E9%9D%99%E6%80%81%E5%A3%B0%E6%98%8E"><span class="toc-number">1.9.87.</span> <span class="toc-text">▌R6.10.5 不应存在没有被用到的静态声明</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-104"><span class="toc-number">1.9.87.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-161"><span class="toc-number">1.9.87.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR6-10-6-%E4%B8%8D%E5%BA%94%E5%AD%98%E5%9C%A8%E6%B2%A1%E6%9C%89%E8%A2%AB%E7%94%A8%E5%88%B0%E7%9A%84-private-%E6%88%90%E5%91%98"><span class="toc-number">1.9.88.</span> <span class="toc-text">▌R6.10.6 不应存在没有被用到的 private 成员</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-105"><span class="toc-number">1.9.88.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-162"><span class="toc-number">1.9.88.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR6-10-7-%E4%B8%8D%E5%BA%94%E7%9C%81%E7%95%A5%E5%A3%B0%E6%98%8E%E5%AF%B9%E8%B1%A1%E6%88%96%E5%87%BD%E6%95%B0%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.9.89.</span> <span class="toc-text">▌R6.10.7 不应省略声明对象或函数的类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-163"><span class="toc-number">1.9.89.1.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR6-10-8-%E7%94%A8-stdint-h-%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E4%BB%A3%E6%9B%BF-short%E3%80%81int%E3%80%81long-%E7%AD%89%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.9.90.</span> <span class="toc-text">▌R6.10.8 用 stdint.h 中的类型代替 short、int、long 等类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-104"><span class="toc-number">1.9.90.1.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-164"><span class="toc-number">1.9.90.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR6-10-9-%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8%E5%B7%B2%E8%BF%87%E6%97%B6%E7%9A%84%E6%A0%87%E5%87%86%E5%BA%93%E7%BB%84%E4%BB%B6"><span class="toc-number">1.9.91.</span> <span class="toc-text">▌R6.10.9 避免使用已过时的标准库组件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-106"><span class="toc-number">1.9.91.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-105"><span class="toc-number">1.9.91.2.</span> <span class="toc-text">依据</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-Exception"><span class="toc-number">1.10.</span> <span class="toc-text">7. Exception</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR7-1-%E4%BF%9D%E8%AF%81%E5%BC%82%E5%B8%B8%E5%AE%89%E5%85%A8"><span class="toc-number">1.10.1.</span> <span class="toc-text">▌R7.1 保证异常安全</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-107"><span class="toc-number">1.10.1.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-165"><span class="toc-number">1.10.1.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR7-2-%E5%A4%84%E7%90%86%E6%89%80%E6%9C%89%E5%BC%82%E5%B8%B8"><span class="toc-number">1.10.2.</span> <span class="toc-text">▌R7.2 处理所有异常</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-108"><span class="toc-number">1.10.2.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-106"><span class="toc-number">1.10.2.2.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-166"><span class="toc-number">1.10.2.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR7-3-%E4%B8%8D%E5%BA%94%E6%8A%9B%E5%87%BA%E8%BF%87%E4%BA%8E%E5%AE%BD%E6%B3%9B%E7%9A%84%E5%BC%82%E5%B8%B8"><span class="toc-number">1.10.3.</span> <span class="toc-text">▌R7.3 不应抛出过于宽泛的异常</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-109"><span class="toc-number">1.10.3.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-167"><span class="toc-number">1.10.3.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR7-4-%E4%B8%8D%E5%BA%94%E6%8D%95%E8%8E%B7%E8%BF%87%E4%BA%8E%E5%AE%BD%E6%B3%9B%E7%9A%84%E5%BC%82%E5%B8%B8"><span class="toc-number">1.10.4.</span> <span class="toc-text">▌R7.4 不应捕获过于宽泛的异常</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-110"><span class="toc-number">1.10.4.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-168"><span class="toc-number">1.10.4.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR7-5-%E4%B8%8D%E5%BA%94%E6%8A%9B%E5%87%BA%E9%9D%9E%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.10.5.</span> <span class="toc-text">▌R7.5 不应抛出非异常类型的对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE-18"><span class="toc-number">1.10.5.1.</span> <span class="toc-text">配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-111"><span class="toc-number">1.10.5.2.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-169"><span class="toc-number">1.10.5.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR7-6-%E4%B8%8D%E5%BA%94%E6%8D%95%E8%8E%B7%E9%9D%9E%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.10.6.</span> <span class="toc-text">▌R7.6 不应捕获非异常类型的对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-112"><span class="toc-number">1.10.6.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-170"><span class="toc-number">1.10.6.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR7-7-%E5%85%A8%E5%B1%80%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B%E4%B8%8D%E5%8F%AF%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8"><span class="toc-number">1.10.7.</span> <span class="toc-text">▌R7.7 全局对象的初始化过程不可抛出异常</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-113"><span class="toc-number">1.10.7.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-107"><span class="toc-number">1.10.7.2.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-171"><span class="toc-number">1.10.7.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR7-8-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B8%8D%E5%8F%AF%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8"><span class="toc-number">1.10.8.</span> <span class="toc-text">▌R7.8 析构函数不可抛出异常</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-114"><span class="toc-number">1.10.8.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-108"><span class="toc-number">1.10.8.2.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-172"><span class="toc-number">1.10.8.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR7-9-%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6%E5%87%BD%E6%95%B0%E4%B8%8D%E5%8F%AF%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8"><span class="toc-number">1.10.9.</span> <span class="toc-text">▌R7.9 内存回收函数不可抛出异常</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-115"><span class="toc-number">1.10.9.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-109"><span class="toc-number">1.10.9.2.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-173"><span class="toc-number">1.10.9.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR7-10-%E5%AF%B9%E8%B1%A1%E4%BA%A4%E6%8D%A2%E8%BF%87%E7%A8%8B%E4%B8%8D%E5%8F%AF%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8"><span class="toc-number">1.10.10.</span> <span class="toc-text">▌R7.10 对象交换过程不可抛出异常</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-116"><span class="toc-number">1.10.10.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-174"><span class="toc-number">1.10.10.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR7-11-%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E7%A7%BB%E5%8A%A8%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8D%E5%8F%AF%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8"><span class="toc-number">1.10.11.</span> <span class="toc-text">▌R7.11 移动构造函数和移动赋值运算符不可抛出异常</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-117"><span class="toc-number">1.10.11.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-175"><span class="toc-number">1.10.11.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR7-12-%E5%BC%82%E5%B8%B8%E7%B1%BB%E7%9A%84%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8D%E5%8F%AF%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8"><span class="toc-number">1.10.12.</span> <span class="toc-text">▌R7.12 异常类的拷贝构造函数不可抛出异常</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-118"><span class="toc-number">1.10.12.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-110"><span class="toc-number">1.10.12.2.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-176"><span class="toc-number">1.10.12.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR7-13-%E5%BC%82%E5%B8%B8%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E5%BC%82%E5%B8%B8%E4%BF%A1%E6%81%AF%E7%9B%B8%E5%85%B3%E7%9A%84%E5%87%BD%E6%95%B0%E4%B8%8D%E5%BA%94%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8"><span class="toc-number">1.10.13.</span> <span class="toc-text">▌R7.13 异常类的构造函数和异常信息相关的函数不应抛出异常</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-119"><span class="toc-number">1.10.13.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-111"><span class="toc-number">1.10.13.2.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-177"><span class="toc-number">1.10.13.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR7-14-%E4%B8%8E%E6%A0%87%E5%87%86%E5%BA%93%E7%9B%B8%E5%85%B3%E7%9A%84-hash-%E8%BF%87%E7%A8%8B%E4%B8%8D%E5%BA%94%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8"><span class="toc-number">1.10.14.</span> <span class="toc-text">▌R7.14 与标准库相关的 hash 过程不应抛出异常</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-178"><span class="toc-number">1.10.14.1.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR7-15-%E7%94%B1-noexcept-%E6%A0%87%E8%AE%B0%E7%9A%84%E5%87%BD%E6%95%B0%E4%B8%8D%E5%8F%AF%E4%BA%A7%E7%94%9F%E6%9C%AA%E5%A4%84%E7%90%86%E7%9A%84%E5%BC%82%E5%B8%B8"><span class="toc-number">1.10.15.</span> <span class="toc-text">▌R7.15 由 noexcept 标记的函数不可产生未处理的异常</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-120"><span class="toc-number">1.10.15.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-112"><span class="toc-number">1.10.15.2.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-179"><span class="toc-number">1.10.15.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR7-16-%E9%81%BF%E5%85%8D%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%E8%87%AA%E5%90%8C%E4%B8%80%E9%9D%9E%E8%99%9A%E5%9F%BA%E7%B1%BB"><span class="toc-number">1.10.16.</span> <span class="toc-text">▌R7.16 避免异常类多重继承自同一非虚基类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-121"><span class="toc-number">1.10.16.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-113"><span class="toc-number">1.10.16.2.</span> <span class="toc-text">依据</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR7-17-%E9%80%9A%E8%BF%87%E5%BC%95%E7%94%A8%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8"><span class="toc-number">1.10.17.</span> <span class="toc-text">▌R7.17 通过引用捕获异常</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-122"><span class="toc-number">1.10.17.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-180"><span class="toc-number">1.10.17.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR7-18-%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8%E6%97%B6%E4%B8%8D%E5%BA%94%E4%BA%A7%E7%94%9F%E5%AF%B9%E8%B1%A1%E5%88%87%E7%89%87%E9%97%AE%E9%A2%98"><span class="toc-number">1.10.18.</span> <span class="toc-text">▌R7.18 捕获异常时不应产生对象切片问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-123"><span class="toc-number">1.10.18.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-181"><span class="toc-number">1.10.18.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR7-19-%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8%E5%90%8E%E4%B8%8D%E5%BA%94%E7%9B%B4%E6%8E%A5%E5%86%8D%E6%AC%A1%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8"><span class="toc-number">1.10.19.</span> <span class="toc-text">▌R7.19 捕获异常后不应直接再次抛出异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR7-20-%E9%87%8D%E6%96%B0%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E6%97%B6%E5%BA%94%E4%BD%BF%E7%94%A8%E7%A9%BA-throw-%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88throw-%EF%BC%89"><span class="toc-number">1.10.20.</span> <span class="toc-text">▌R7.20 重新抛出异常时应使用空 throw 表达式（throw;）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-114"><span class="toc-number">1.10.20.1.</span> <span class="toc-text">依据</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR7-21-%E4%B8%8D%E5%BA%94%E5%9C%A8-catch-%E5%AD%90%E5%8F%A5%E5%A4%96%E4%BD%BF%E7%94%A8%E7%A9%BA-throw-%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88throw-%EF%BC%89"><span class="toc-number">1.10.21.</span> <span class="toc-text">▌R7.21 不应在 catch 子句外使用空 throw 表达式（throw;）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-115"><span class="toc-number">1.10.21.1.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-182"><span class="toc-number">1.10.21.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR7-22-%E4%B8%8D%E5%BA%94%E6%8A%9B%E5%87%BA%E6%8C%87%E9%92%88"><span class="toc-number">1.10.22.</span> <span class="toc-text">▌R7.22 不应抛出指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-183"><span class="toc-number">1.10.22.1.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR7-23-%E4%B8%8D%E5%BA%94%E6%8A%9B%E5%87%BA-NULL"><span class="toc-number">1.10.23.</span> <span class="toc-text">▌R7.23 不应抛出 NULL</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-124"><span class="toc-number">1.10.23.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-116"><span class="toc-number">1.10.23.2.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-184"><span class="toc-number">1.10.23.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR7-24-%E4%B8%8D%E5%BA%94%E6%8A%9B%E5%87%BA-nullptr"><span class="toc-number">1.10.24.</span> <span class="toc-text">▌R7.24 不应抛出 nullptr</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-125"><span class="toc-number">1.10.24.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-185"><span class="toc-number">1.10.24.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR7-25-%E4%B8%8D%E5%BA%94%E5%9C%A8%E6%A8%A1%E5%9D%97%E4%B9%8B%E9%97%B4%E4%BC%A0%E6%92%AD%E5%BC%82%E5%B8%B8"><span class="toc-number">1.10.25.</span> <span class="toc-text">▌R7.25 不应在模块之间传播异常</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-126"><span class="toc-number">1.10.25.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-186"><span class="toc-number">1.10.25.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR7-26-%E7%A6%81%E7%94%A8%E5%8A%A8%E6%80%81%E5%BC%82%E5%B8%B8%E8%AF%B4%E6%98%8E"><span class="toc-number">1.10.26.</span> <span class="toc-text">▌R7.26 禁用动态异常说明</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE-19"><span class="toc-number">1.10.26.1.</span> <span class="toc-text">配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-117"><span class="toc-number">1.10.26.2.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-187"><span class="toc-number">1.10.26.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR7-27-%E7%A6%81%E7%94%A8-C-%E5%BC%82%E5%B8%B8"><span class="toc-number">1.10.27.</span> <span class="toc-text">▌R7.27 禁用 C++ 异常</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-127"><span class="toc-number">1.10.27.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-188"><span class="toc-number">1.10.27.2.</span> <span class="toc-text">参考</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-Function"><span class="toc-number">1.11.</span> <span class="toc-text">8. Function</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR8-1-main-%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B%E5%8F%AA%E5%BA%94%E4%B8%BA-int"><span class="toc-number">1.11.1.</span> <span class="toc-text">▌R8.1 main 函数的返回类型只应为 int</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-118"><span class="toc-number">1.11.1.1.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-189"><span class="toc-number">1.11.1.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR8-2-main-%E5%87%BD%E6%95%B0%E4%B8%8D%E5%BA%94%E8%A2%AB%E8%B0%83%E7%94%A8%E3%80%81%E9%87%8D%E8%BD%BD%E6%88%96%E8%A2%AB-inline%E3%80%81static-%E7%AD%89%E5%85%B3%E9%94%AE%E5%AD%97%E9%99%90%E5%AE%9A"><span class="toc-number">1.11.2.</span> <span class="toc-text">▌R8.2 main 函数不应被调用、重载或被 inline、static 等关键字限定</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-119"><span class="toc-number">1.11.2.1.</span> <span class="toc-text">依据</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR8-3-%E5%9C%A8%E5%A4%B4%E6%96%87%E4%BB%B6%E4%B8%AD%E4%B8%8D%E5%BA%94%E5%AE%9E%E7%8E%B0%E5%87%BD%E6%95%B0%E6%88%96%E5%AE%9A%E4%B9%89%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.11.3.</span> <span class="toc-text">▌R8.3 在头文件中不应实现函数或定义对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-190"><span class="toc-number">1.11.3.1.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR8-4-%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0%E5%90%8D%E7%A7%B0%E5%9C%A8%E5%A3%B0%E6%98%8E%E5%A4%84%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%A4%84%E5%BA%94%E4%BF%9D%E6%8C%81%E4%B8%80%E8%87%B4"><span class="toc-number">1.11.4.</span> <span class="toc-text">▌R8.4 函数的参数名称在声明处和实现处应保持一致</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-128"><span class="toc-number">1.11.4.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-191"><span class="toc-number">1.11.4.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR8-5-%E5%A4%9A%E6%80%81%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0%E6%97%B6%E4%B8%8D%E5%BA%94%E9%87%87%E7%94%A8%E5%80%BC%E4%BC%A0%E9%80%92%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">1.11.5.</span> <span class="toc-text">▌R8.5 多态类的对象作为参数时不应采用值传递的方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-129"><span class="toc-number">1.11.5.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-192"><span class="toc-number">1.11.5.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR8-6-%E4%B8%8D%E5%BA%94%E5%AD%98%E5%9C%A8%E6%9C%AA%E8%A2%AB%E4%BD%BF%E7%94%A8%E7%9A%84%E5%85%B7%E5%90%8D%E5%BD%A2%E5%BC%8F%E5%8F%82%E6%95%B0"><span class="toc-number">1.11.6.</span> <span class="toc-text">▌R8.6 不应存在未被使用的具名形式参数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-193"><span class="toc-number">1.11.6.1.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR8-7-%E9%9D%9E%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%B8%B8%E9%87%8F%E5%8F%82%E6%95%B0%E4%B8%8D%E5%BA%94%E6%8C%89%E5%80%BC%E4%BC%A0%E9%80%92"><span class="toc-number">1.11.7.</span> <span class="toc-text">▌R8.7 非基本类型的常量参数不应按值传递</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-194"><span class="toc-number">1.11.7.1.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR8-8-%E8%BD%AC%E5%8F%91%E5%BC%95%E7%94%A8%E5%8F%AA%E5%BA%94%E4%BD%9C%E4%B8%BA-std-forward-%E7%9A%84%E5%8F%82%E6%95%B0"><span class="toc-number">1.11.8.</span> <span class="toc-text">▌R8.8 转发引用只应作为 std::forward 的参数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-130"><span class="toc-number">1.11.8.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-120"><span class="toc-number">1.11.8.2.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-195"><span class="toc-number">1.11.8.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR8-9-%E5%B1%80%E9%83%A8%E5%AF%B9%E8%B1%A1%E5%9C%A8%E4%BD%BF%E7%94%A8%E5%89%8D%E5%BA%94%E8%A2%AB%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.11.9.</span> <span class="toc-text">▌R8.9 局部对象在使用前应被初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-131"><span class="toc-number">1.11.9.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-121"><span class="toc-number">1.11.9.2.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-196"><span class="toc-number">1.11.9.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR8-10-%E6%88%90%E5%91%98%E9%A1%BB%E5%9C%A8%E5%A3%B0%E6%98%8E%E5%A4%84%E6%88%96%E6%9E%84%E9%80%A0%E6%97%B6%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.11.10.</span> <span class="toc-text">▌R8.10 成员须在声明处或构造时初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-197"><span class="toc-number">1.11.10.1.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR8-11-%E5%9F%BA%E7%B1%BB%E5%AF%B9%E8%B1%A1%E6%9E%84%E9%80%A0%E5%AE%8C%E6%AF%95%E4%B9%8B%E5%89%8D%E4%B8%8D%E5%8F%AF%E8%B0%83%E7%94%A8%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">1.11.11.</span> <span class="toc-text">▌R8.11 基类对象构造完毕之前不可调用成员函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-122"><span class="toc-number">1.11.11.1.</span> <span class="toc-text">依据</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR8-12-%E5%9C%A8%E9%9D%A2%E5%90%91%E6%9E%84%E9%80%A0%E6%88%96%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%BD%93%E7%9A%84-catch-%E5%AD%90%E5%8F%A5%E4%B8%AD%E4%B8%8D%E5%8F%AF%E8%AE%BF%E9%97%AE%E9%9D%9E%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="toc-number">1.11.12.</span> <span class="toc-text">▌R8.12 在面向构造或析构函数体的 catch 子句中不可访问非静态成员</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-123"><span class="toc-number">1.11.12.1.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-198"><span class="toc-number">1.11.12.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR8-13-%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%E5%BA%94%E9%81%B5%E5%BE%AA%E5%A3%B0%E6%98%8E%E7%9A%84%E9%A1%BA%E5%BA%8F"><span class="toc-number">1.11.13.</span> <span class="toc-text">▌R8.13 成员初始化应遵循声明的顺序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-124"><span class="toc-number">1.11.13.1.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-199"><span class="toc-number">1.11.13.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR8-14-%E5%9C%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%AD%E4%B8%8D%E5%BA%94%E4%BD%BF%E7%94%A8%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.11.14.</span> <span class="toc-text">▌R8.14 在构造函数中不应使用动态类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-125"><span class="toc-number">1.11.14.1.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-200"><span class="toc-number">1.11.14.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR8-15-%E5%9C%A8%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B8%AD%E4%B8%8D%E5%BA%94%E4%BD%BF%E7%94%A8%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.11.15.</span> <span class="toc-text">▌R8.15 在析构函数中不应使用动态类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-126"><span class="toc-number">1.11.15.1.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-201"><span class="toc-number">1.11.15.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR8-16-%E5%9C%A8%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B8%AD%E9%81%BF%E5%85%8D%E8%B0%83%E7%94%A8-exit-%E5%87%BD%E6%95%B0"><span class="toc-number">1.11.16.</span> <span class="toc-text">▌R8.16 在析构函数中避免调用 exit 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-127"><span class="toc-number">1.11.16.1.</span> <span class="toc-text">依据</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR8-17-%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%BA%94%E9%81%BF%E5%85%8D%E5%AE%9E%E7%8E%B0%E5%A4%8D%E5%88%B6%E4%B9%8B%E5%A4%96%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">1.11.17.</span> <span class="toc-text">▌R8.17 拷贝构造函数应避免实现复制之外的功能</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-132"><span class="toc-number">1.11.17.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-128"><span class="toc-number">1.11.17.2.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-202"><span class="toc-number">1.11.17.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR8-18-%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%BA%94%E9%81%BF%E5%85%8D%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E7%A7%BB%E5%8A%A8%E4%B9%8B%E5%A4%96%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">1.11.18.</span> <span class="toc-text">▌R8.18 移动构造函数应避免实现数据移动之外的功能</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-133"><span class="toc-number">1.11.18.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-129"><span class="toc-number">1.11.18.2.</span> <span class="toc-text">依据</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR8-19-%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E5%BA%94%E5%A4%84%E7%90%86%E5%8F%82%E6%95%B0%E6%98%AF%E8%87%AA%E8%BA%AB%E5%AF%B9%E8%B1%A1%E6%97%B6%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">1.11.19.</span> <span class="toc-text">▌R8.19 拷贝赋值运算符应处理参数是自身对象时的情况</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-203"><span class="toc-number">1.11.19.1.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR8-20-%E4%B8%8D%E5%BA%94%E5%AD%98%E5%9C%A8%E6%97%A0%E6%95%88%E7%9A%84%E5%86%99%E5%85%A5%E6%93%8D%E4%BD%9C"><span class="toc-number">1.11.20.</span> <span class="toc-text">▌R8.20 不应存在无效的写入操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR8-21-%E4%B8%8D%E5%BA%94%E5%AD%98%E5%9C%A8%E6%B2%A1%E6%9C%89%E5%89%AF%E4%BD%9C%E7%94%A8%E7%9A%84%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.11.21.</span> <span class="toc-text">▌R8.21 不应存在没有副作用的语句</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-130"><span class="toc-number">1.11.21.1.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-204"><span class="toc-number">1.11.21.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR8-22-%E4%B8%8D%E5%BA%94%E5%AD%98%E5%9C%A8%E5%BE%97%E4%B8%8D%E5%88%B0%E6%89%A7%E8%A1%8C%E6%9C%BA%E4%BC%9A%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="toc-number">1.11.22.</span> <span class="toc-text">▌R8.22 不应存在得不到执行机会的代码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-134"><span class="toc-number">1.11.22.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-205"><span class="toc-number">1.11.22.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR8-23-%E6%9C%89%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E5%87%BD%E6%95%B0%E5%85%B6%E6%89%80%E6%9C%89%E5%88%86%E6%9E%9D%E9%83%BD%E5%BA%94%E6%98%BE%E5%BC%8F%E8%BF%94%E5%9B%9E"><span class="toc-number">1.11.23.</span> <span class="toc-text">▌R8.23 有返回值的函数其所有分枝都应显式返回</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-131"><span class="toc-number">1.11.23.1.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-206"><span class="toc-number">1.11.23.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR8-24-%E4%B8%8D%E5%8F%AF%E8%BF%94%E5%9B%9E%E5%B1%80%E9%83%A8%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9C%B0%E5%9D%80%E6%88%96%E5%BC%95%E7%94%A8"><span class="toc-number">1.11.24.</span> <span class="toc-text">▌R8.24 不可返回局部对象的地址或引用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-135"><span class="toc-number">1.11.24.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-132"><span class="toc-number">1.11.24.2.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-207"><span class="toc-number">1.11.24.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR8-25-%E4%B8%8D%E5%8F%AF%E8%BF%94%E5%9B%9E%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9C%B0%E5%9D%80%E6%88%96%E5%BC%95%E7%94%A8"><span class="toc-number">1.11.25.</span> <span class="toc-text">▌R8.25 不可返回临时对象的地址或引用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-136"><span class="toc-number">1.11.25.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-133"><span class="toc-number">1.11.25.2.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-208"><span class="toc-number">1.11.25.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR8-26-%E5%90%88%E7%90%86%E8%AE%BE%E7%BD%AE-lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E6%8D%95%E8%8E%B7%E6%96%B9%E5%BC%8F"><span class="toc-number">1.11.26.</span> <span class="toc-text">▌R8.26 合理设置 lambda 表达式的捕获方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-137"><span class="toc-number">1.11.26.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-134"><span class="toc-number">1.11.26.2.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-209"><span class="toc-number">1.11.26.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR8-27-%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E4%B8%8D%E5%BA%94%E4%B8%BA%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="toc-number">1.11.27.</span> <span class="toc-text">▌R8.27 函数返回值不应为右值引用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-138"><span class="toc-number">1.11.27.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-210"><span class="toc-number">1.11.27.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR8-28-%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E4%B8%8D%E5%BA%94%E4%B8%BA%E5%B8%B8%E9%87%8F%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.11.28.</span> <span class="toc-text">▌R8.28 函数返回值不应为常量对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-139"><span class="toc-number">1.11.28.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-211"><span class="toc-number">1.11.28.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR8-29-%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E4%B8%8D%E5%BA%94%E4%B8%BA%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%B8%B8%E9%87%8F"><span class="toc-number">1.11.29.</span> <span class="toc-text">▌R8.29 函数返回值不应为基本类型的常量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-140"><span class="toc-number">1.11.29.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-135"><span class="toc-number">1.11.29.2.</span> <span class="toc-text">依据</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR8-30-%E8%A2%AB%E8%BF%94%E5%9B%9E%E7%9A%84%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BA%94%E4%B8%8E%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B%E4%B8%80%E8%87%B4"><span class="toc-number">1.11.30.</span> <span class="toc-text">▌R8.30 被返回的表达式应与函数的返回类型一致</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-212"><span class="toc-number">1.11.30.1.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR8-31-%E8%A2%AB%E8%BF%94%E5%9B%9E%E7%9A%84%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8D%E5%BA%94%E4%B8%BA%E7%9B%B8%E5%90%8C%E7%9A%84%E5%B8%B8%E9%87%8F"><span class="toc-number">1.11.31.</span> <span class="toc-text">▌R8.31 被返回的表达式不应为相同的常量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR8-32-%E5%85%B7%E6%9C%89-noreturn-%E5%B1%9E%E6%80%A7%E7%9A%84%E5%87%BD%E6%95%B0%E4%B8%8D%E5%BA%94%E8%BF%94%E5%9B%9E"><span class="toc-number">1.11.32.</span> <span class="toc-text">▌R8.32 具有 noreturn 属性的函数不应返回</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-141"><span class="toc-number">1.11.32.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-136"><span class="toc-number">1.11.32.2.</span> <span class="toc-text">依据</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR8-33-%E5%85%B7%E6%9C%89-noreturn-%E5%B1%9E%E6%80%A7%E7%9A%84%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B%E5%8F%AA%E5%BA%94%E4%B8%BA-void"><span class="toc-number">1.11.33.</span> <span class="toc-text">▌R8.33 具有 noreturn 属性的函数返回类型只应为 void</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-142"><span class="toc-number">1.11.33.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-137"><span class="toc-number">1.11.33.2.</span> <span class="toc-text">依据</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR8-34-%E7%94%B1-atexit%E3%80%81at-quick-exit-%E6%8C%87%E5%AE%9A%E7%9A%84%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0%E5%BA%94%E6%AD%A3%E5%B8%B8%E8%BF%94%E5%9B%9E"><span class="toc-number">1.11.34.</span> <span class="toc-text">▌R8.34 由 atexit、at_quick_exit 指定的处理函数应正常返回</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-138"><span class="toc-number">1.11.34.1.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-213"><span class="toc-number">1.11.34.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR8-35-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E4%B8%8D%E5%BA%94%E8%A2%AB%E7%89%B9%E5%8C%96"><span class="toc-number">1.11.35.</span> <span class="toc-text">▌R8.35 函数模板不应被特化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-214"><span class="toc-number">1.11.35.1.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR8-36-%E5%87%BD%E6%95%B0%E7%9A%84%E9%80%80%E5%87%BA%E7%82%B9%E6%95%B0%E9%87%8F%E5%BA%94%E5%9C%A8%E8%A7%84%E5%AE%9A%E8%8C%83%E5%9B%B4%E4%B9%8B%E5%86%85"><span class="toc-number">1.11.36.</span> <span class="toc-text">▌R8.36 函数的退出点数量应在规定范围之内</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE-20"><span class="toc-number">1.11.36.1.</span> <span class="toc-text">配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-143"><span class="toc-number">1.11.36.2.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-215"><span class="toc-number">1.11.36.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR8-37-%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%87%E7%AD%BE%E6%95%B0%E9%87%8F%E5%BA%94%E5%9C%A8%E8%A7%84%E5%AE%9A%E8%8C%83%E5%9B%B4%E4%B9%8B%E5%86%85"><span class="toc-number">1.11.37.</span> <span class="toc-text">▌R8.37 函数的标签数量应在规定范围之内</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE-21"><span class="toc-number">1.11.37.1.</span> <span class="toc-text">配置</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR8-38-%E5%87%BD%E6%95%B0%E7%9A%84%E8%A1%8C%E6%95%B0%E5%BA%94%E5%9C%A8%E8%A7%84%E5%AE%9A%E8%8C%83%E5%9B%B4%E4%B9%8B%E5%86%85"><span class="toc-number">1.11.38.</span> <span class="toc-text">▌R8.38 函数的行数应在规定范围之内</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE-22"><span class="toc-number">1.11.38.1.</span> <span class="toc-text">配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-216"><span class="toc-number">1.11.38.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR8-39-lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%A1%8C%E6%95%B0%E5%BA%94%E5%9C%A8%E8%A7%84%E5%AE%9A%E8%8C%83%E5%9B%B4%E4%B9%8B%E5%86%85"><span class="toc-number">1.11.39.</span> <span class="toc-text">▌R8.39 lambda 表达式的行数应在规定范围之内</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE-23"><span class="toc-number">1.11.39.1.</span> <span class="toc-text">配置</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR8-40-%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E6%95%B0%E9%87%8F%E5%BA%94%E5%9C%A8%E8%A7%84%E5%AE%9A%E8%8C%83%E5%9B%B4%E4%B9%8B%E5%86%85"><span class="toc-number">1.11.40.</span> <span class="toc-text">▌R8.40 函数参数的数量应在规定范围之内</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE-24"><span class="toc-number">1.11.40.1.</span> <span class="toc-text">配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-217"><span class="toc-number">1.11.40.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR8-41-%E4%B8%8D%E5%BA%94%E5%AE%9A%E4%B9%89%E8%BF%87%E4%BA%8E%E5%A4%8D%E6%9D%82%E7%9A%84%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="toc-number">1.11.41.</span> <span class="toc-text">▌R8.41 不应定义过于复杂的内联函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE-25"><span class="toc-number">1.11.41.1.</span> <span class="toc-text">配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-139"><span class="toc-number">1.11.41.2.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-218"><span class="toc-number">1.11.41.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR8-42-%E9%81%BF%E5%85%8D%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%87%AA%E8%BA%AB"><span class="toc-number">1.11.42.</span> <span class="toc-text">▌R8.42 避免函数调用自身</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-219"><span class="toc-number">1.11.42.1.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR8-43-%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%8F%8A%E7%B1%BB%E5%9E%8B%E5%B5%8C%E5%A5%97%E4%B8%8D%E5%BA%94%E8%BF%87%E6%B7%B1"><span class="toc-number">1.11.43.</span> <span class="toc-text">▌R8.43 作用域及类型嵌套不应过深</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE-26"><span class="toc-number">1.11.43.1.</span> <span class="toc-text">配置</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR8-44-%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81%E4%B8%8D%E5%BA%94%E4%B8%8E%E6%99%AE%E9%80%9A%E4%BB%A3%E7%A0%81%E6%B7%B7%E5%90%88"><span class="toc-number">1.11.44.</span> <span class="toc-text">▌R8.44 汇编代码不应与普通代码混合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-140"><span class="toc-number">1.11.44.1.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-220"><span class="toc-number">1.11.44.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR8-45-%E9%81%BF%E5%85%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.11.45.</span> <span class="toc-text">▌R8.45 避免重复的函数实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE-27"><span class="toc-number">1.11.45.1.</span> <span class="toc-text">配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-221"><span class="toc-number">1.11.45.2.</span> <span class="toc-text">参考</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-Control"><span class="toc-number">1.12.</span> <span class="toc-text">9. Control</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-If"><span class="toc-number">1.12.1.</span> <span class="toc-text">9.1 If</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR9-1-1-if-%E8%AF%AD%E5%8F%A5%E4%B8%8D%E5%BA%94%E8%A2%AB%E5%88%86%E5%8F%B7%E9%9A%94%E6%96%AD"><span class="toc-number">1.12.2.</span> <span class="toc-text">▌R9.1.1 if 语句不应被分号隔断</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-222"><span class="toc-number">1.12.2.1.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR9-1-2-%E5%9C%A8-if%E2%80%A6else-if-%E5%88%86%E6%9E%9D%E4%B8%AD%E4%B8%8D%E5%BA%94%E6%9C%89%E9%87%8D%E5%A4%8D%E7%9A%84%E6%9D%A1%E4%BB%B6"><span class="toc-number">1.12.3.</span> <span class="toc-text">▌R9.1.2 在 if…else-if 分枝中不应有重复的条件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-144"><span class="toc-number">1.12.3.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-223"><span class="toc-number">1.12.3.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR9-1-3-%E5%9C%A8-if%E2%80%A6else-if-%E5%88%86%E6%9E%9D%E4%B8%AD%E4%B8%8D%E5%BA%94%E6%9C%89%E8%A2%AB%E9%81%AE%E7%9B%96%E7%9A%84%E6%9D%A1%E4%BB%B6"><span class="toc-number">1.12.4.</span> <span class="toc-text">▌R9.1.3 在 if…else-if 分枝中不应有被遮盖的条件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-145"><span class="toc-number">1.12.4.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-224"><span class="toc-number">1.12.4.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR9-1-4-if-%E5%88%86%E6%9E%9D%E5%92%8C-else-%E5%88%86%E6%9E%9D%E7%9A%84%E4%BB%A3%E7%A0%81%E4%B8%8D%E5%BA%94%E5%AE%8C%E5%85%A8%E7%9B%B8%E5%90%8C"><span class="toc-number">1.12.5.</span> <span class="toc-text">▌R9.1.4 if 分枝和 else 分枝的代码不应完全相同</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-146"><span class="toc-number">1.12.5.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-225"><span class="toc-number">1.12.5.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR9-1-5-if%E2%80%A6else-if-%E5%90%84%E5%88%86%E6%9E%9D%E7%9A%84%E4%BB%A3%E7%A0%81%E4%B8%8D%E5%BA%94%E5%AE%8C%E5%85%A8%E7%9B%B8%E5%90%8C"><span class="toc-number">1.12.6.</span> <span class="toc-text">▌R9.1.5 if…else-if 各分枝的代码不应完全相同</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE-28"><span class="toc-number">1.12.6.1.</span> <span class="toc-text">配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-147"><span class="toc-number">1.12.6.2.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-226"><span class="toc-number">1.12.6.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR9-1-6-if-%E5%88%86%E6%9E%9D%E5%92%8C%E9%9A%90%E5%90%AB%E7%9A%84-else-%E5%88%86%E6%9E%9D%E4%BB%A3%E7%A0%81%E4%B8%8D%E5%BA%94%E5%AE%8C%E5%85%A8%E7%9B%B8%E5%90%8C"><span class="toc-number">1.12.7.</span> <span class="toc-text">▌R9.1.6 if 分枝和隐含的 else 分枝代码不应完全相同</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-148"><span class="toc-number">1.12.7.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-227"><span class="toc-number">1.12.7.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR9-1-7-%E6%B2%A1%E6%9C%89-else-%E5%AD%90%E5%8F%A5%E7%9A%84-if-%E8%AF%AD%E5%8F%A5%E4%B8%8E%E5%85%B6%E5%90%8E%E7%BB%AD%E4%BB%A3%E7%A0%81%E7%9B%B8%E5%90%8C%E6%98%AF%E5%8F%AF%E7%96%91%E7%9A%84"><span class="toc-number">1.12.8.</span> <span class="toc-text">▌R9.1.7 没有 else 子句的 if 语句与其后续代码相同是可疑的</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-149"><span class="toc-number">1.12.8.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-228"><span class="toc-number">1.12.8.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR9-1-8-if-%E5%88%86%E6%9E%9D%E5%92%8C-else-%E5%88%86%E6%9E%9D%E7%9A%84%E8%B5%B7%E6%AD%A2%E8%AF%AD%E5%8F%A5%E4%B8%8D%E5%BA%94%E7%9B%B8%E5%90%8C"><span class="toc-number">1.12.9.</span> <span class="toc-text">▌R9.1.8 if 分枝和 else 分枝的起止语句不应相同</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-150"><span class="toc-number">1.12.9.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-229"><span class="toc-number">1.12.9.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR9-1-9-if-%E8%AF%AD%E5%8F%A5%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E8%8C%83%E5%9B%B4%E4%B8%8D%E5%BA%94%E6%9C%89%E8%AF%AF"><span class="toc-number">1.12.10.</span> <span class="toc-text">▌R9.1.9 if 语句作用域的范围不应有误</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-151"><span class="toc-number">1.12.10.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-230"><span class="toc-number">1.12.10.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR9-1-10-%E5%A6%82%E6%9E%9C-if-%E5%85%B3%E9%94%AE%E5%AD%97%E5%89%8D%E9%9D%A2%E6%98%AF%E5%8F%B3%E5%A4%A7%E6%8B%AC%E5%8F%B7%EF%BC%8Cif-%E5%85%B3%E9%94%AE%E5%AD%97%E5%BA%94%E5%8F%A6%E8%B5%B7%E4%B8%80%E8%A1%8C"><span class="toc-number">1.12.11.</span> <span class="toc-text">▌R9.1.10 如果 if 关键字前面是右大括号，if 关键字应另起一行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR9-1-11-if-%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%9D%A1%E4%BB%B6%E4%B8%8D%E5%BA%94%E4%B8%BA%E8%B5%8B%E5%80%BC%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.12.12.</span> <span class="toc-text">▌R9.1.11 if 语句的条件不应为赋值表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE-29"><span class="toc-number">1.12.12.1.</span> <span class="toc-text">配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-152"><span class="toc-number">1.12.12.2.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-231"><span class="toc-number">1.12.12.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR9-1-12-if-%E8%AF%AD%E5%8F%A5%E4%B8%8D%E5%BA%94%E4%B8%BA%E7%A9%BA"><span class="toc-number">1.12.13.</span> <span class="toc-text">▌R9.1.12 if 语句不应为空</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-232"><span class="toc-number">1.12.13.1.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR9-1-13-if%E2%80%A6else-if-%E5%88%86%E6%9E%9D%E6%95%B0%E9%87%8F%E5%BA%94%E5%9C%A8%E8%A7%84%E5%AE%9A%E8%8C%83%E5%9B%B4%E4%B9%8B%E5%86%85"><span class="toc-number">1.12.14.</span> <span class="toc-text">▌R9.1.13 if…else-if 分枝数量应在规定范围之内</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE-30"><span class="toc-number">1.12.14.1.</span> <span class="toc-text">配置</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR9-1-14-if-%E5%88%86%E6%9E%9D%E4%B8%AD%E7%9A%84%E8%AF%AD%E5%8F%A5%E5%BA%94%E8%AF%A5%E7%94%A8%E5%A4%A7%E6%8B%AC%E5%8F%B7%E6%8B%AC%E8%B5%B7%E6%9D%A5"><span class="toc-number">1.12.15.</span> <span class="toc-text">▌R9.1.14 if 分枝中的语句应该用大括号括起来</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-153"><span class="toc-number">1.12.15.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-233"><span class="toc-number">1.12.15.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR9-1-15-%E6%89%80%E6%9C%89-if%E2%80%A6else-if-%E5%88%86%E6%9E%9D%E9%83%BD%E5%BA%94%E4%BB%A5-else-%E5%AD%90%E5%8F%A5%E7%BB%93%E6%9D%9F"><span class="toc-number">1.12.16.</span> <span class="toc-text">▌R9.1.15 所有 if…else-if 分枝都应以 else 子句结束</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-154"><span class="toc-number">1.12.16.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-234"><span class="toc-number">1.12.16.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-For"><span class="toc-number">1.12.17.</span> <span class="toc-text">9.2 For</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR9-2-1-for-%E8%AF%AD%E5%8F%A5%E4%B8%8D%E5%BA%94%E8%A2%AB%E5%88%86%E5%8F%B7%E9%9A%94%E6%96%AD"><span class="toc-number">1.12.18.</span> <span class="toc-text">▌R9.2.1 for 语句不应被分号隔断</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-155"><span class="toc-number">1.12.18.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-235"><span class="toc-number">1.12.18.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR9-2-2-for-%E8%AF%AD%E5%8F%A5%E4%B8%AD%E4%B8%8D%E5%BA%94%E5%AD%98%E5%9C%A8%E6%97%A0%E6%9D%A1%E4%BB%B6%E7%9A%84%E8%B7%B3%E8%BD%AC%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.12.19.</span> <span class="toc-text">▌R9.2.2 for 语句中不应存在无条件的跳转语句</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-156"><span class="toc-number">1.12.19.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-236"><span class="toc-number">1.12.19.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR9-2-3-for-%E8%AF%AD%E5%8F%A5%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E8%8C%83%E5%9B%B4%E4%B8%8D%E5%BA%94%E6%9C%89%E8%AF%AF"><span class="toc-number">1.12.20.</span> <span class="toc-text">▌R9.2.3 for 语句作用域的范围不应有误</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-157"><span class="toc-number">1.12.20.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-237"><span class="toc-number">1.12.20.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR9-2-4-for-%E8%AF%AD%E5%8F%A5%E6%B2%A1%E6%9C%89%E6%98%8E%E7%A1%AE%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%8F%98%E9%87%8F%E6%97%B6%E5%BA%94%E6%94%B9%E7%94%A8-while-%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.12.21.</span> <span class="toc-text">▌R9.2.4 for 语句没有明确的循环变量时应改用 while 语句</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-238"><span class="toc-number">1.12.21.1.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR9-2-5-for-%E5%BE%AA%E7%8E%AF%E4%BD%93%E4%B8%8D%E5%BA%94%E4%B8%BA%E7%A9%BA"><span class="toc-number">1.12.22.</span> <span class="toc-text">▌R9.2.5 for 循环体不应为空</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-239"><span class="toc-number">1.12.22.1.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR9-2-6-for-%E5%BE%AA%E7%8E%AF%E5%8F%98%E9%87%8F%E4%B8%8D%E5%BA%94%E4%B8%BA%E6%B5%AE%E7%82%B9%E5%9E%8B"><span class="toc-number">1.12.23.</span> <span class="toc-text">▌R9.2.6 for 循环变量不应为浮点型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-158"><span class="toc-number">1.12.23.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-240"><span class="toc-number">1.12.23.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR9-2-7-for-%E5%BE%AA%E7%8E%AF%E5%8F%98%E9%87%8F%E4%B8%8D%E5%BA%94%E5%9C%A8%E5%BE%AA%E7%8E%AF%E4%BD%93%E5%86%85%E8%A2%AB%E6%94%B9%E5%8F%98"><span class="toc-number">1.12.24.</span> <span class="toc-text">▌R9.2.7 for 循环变量不应在循环体内被改变</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-241"><span class="toc-number">1.12.24.1.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR9-2-8-%E5%B5%8C%E5%A5%97%E7%9A%84-for-%E8%AF%AD%E5%8F%A5%E4%B8%8D%E5%BA%94%E4%BD%BF%E7%94%A8%E7%9B%B8%E5%90%8C%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%8F%98%E9%87%8F"><span class="toc-number">1.12.25.</span> <span class="toc-text">▌R9.2.8 嵌套的 for 语句不应使用相同的循环变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-159"><span class="toc-number">1.12.25.1.</span> <span class="toc-text">相关</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR9-2-9-for-%E5%BE%AA%E7%8E%AF%E4%BD%93%E5%BA%94%E8%AF%A5%E7%94%A8%E5%A4%A7%E6%8B%AC%E5%8F%B7%E6%8B%AC%E8%B5%B7%E6%9D%A5"><span class="toc-number">1.12.26.</span> <span class="toc-text">▌R9.2.9 for 循环体应该用大括号括起来</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-242"><span class="toc-number">1.12.26.1.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-While"><span class="toc-number">1.12.27.</span> <span class="toc-text">9.3 While</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR9-3-1-while-%E8%AF%AD%E5%8F%A5%E4%B8%8D%E5%BA%94%E8%A2%AB%E5%88%86%E5%8F%B7%E9%9A%94%E6%96%AD"><span class="toc-number">1.12.28.</span> <span class="toc-text">▌R9.3.1 while 语句不应被分号隔断</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-243"><span class="toc-number">1.12.28.1.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR9-3-2-while-%E8%AF%AD%E5%8F%A5%E4%B8%AD%E4%B8%8D%E5%BA%94%E5%AD%98%E5%9C%A8%E6%97%A0%E6%9D%A1%E4%BB%B6%E7%9A%84%E8%B7%B3%E8%BD%AC%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.12.29.</span> <span class="toc-text">▌R9.3.2 while 语句中不应存在无条件的跳转语句</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-160"><span class="toc-number">1.12.29.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-244"><span class="toc-number">1.12.29.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR9-3-3-while-%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%9D%A1%E4%BB%B6%E4%B8%8D%E5%BA%94%E4%B8%BA%E8%B5%8B%E5%80%BC%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.12.30.</span> <span class="toc-text">▌R9.3.3 while 语句的条件不应为赋值表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-161"><span class="toc-number">1.12.30.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-245"><span class="toc-number">1.12.30.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR9-3-4-while-%E8%AF%AD%E5%8F%A5%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E8%8C%83%E5%9B%B4%E4%B8%8D%E5%BA%94%E6%9C%89%E8%AF%AF"><span class="toc-number">1.12.31.</span> <span class="toc-text">▌R9.3.4 while 语句作用域的范围不应有误</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-162"><span class="toc-number">1.12.31.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-246"><span class="toc-number">1.12.31.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR9-3-5-while-%E5%BE%AA%E7%8E%AF%E4%BD%93%E4%B8%8D%E5%BA%94%E4%B8%BA%E7%A9%BA"><span class="toc-number">1.12.32.</span> <span class="toc-text">▌R9.3.5 while 循环体不应为空</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-247"><span class="toc-number">1.12.32.1.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR9-3-6-while-%E5%BE%AA%E7%8E%AF%E4%BD%93%E5%BA%94%E8%AF%A5%E7%94%A8%E5%A4%A7%E6%8B%AC%E5%8F%B7%E6%8B%AC%E8%B5%B7%E6%9D%A5"><span class="toc-number">1.12.33.</span> <span class="toc-text">▌R9.3.6 while 循环体应该用大括号括起来</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-163"><span class="toc-number">1.12.33.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-248"><span class="toc-number">1.12.33.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-4-Do"><span class="toc-number">1.12.34.</span> <span class="toc-text">9.4 Do</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR9-4-1-%E6%B3%A8%E6%84%8F-do-while-0-%E4%B8%AD%E5%8F%AF%E7%96%91%E7%9A%84-continue-%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.12.35.</span> <span class="toc-text">▌R9.4.1 注意 do-while(0) 中可疑的 continue 语句</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-249"><span class="toc-number">1.12.35.1.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR9-4-2-do-while-%E5%BE%AA%E7%8E%AF%E4%BD%93%E4%B8%8D%E5%BA%94%E4%B8%BA%E7%A9%BA"><span class="toc-number">1.12.36.</span> <span class="toc-text">▌R9.4.2 do-while 循环体不应为空</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-164"><span class="toc-number">1.12.36.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-250"><span class="toc-number">1.12.36.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR9-4-3-do-while-%E5%BE%AA%E7%8E%AF%E4%BD%93%E5%BA%94%E8%AF%A5%E7%94%A8%E5%A4%A7%E6%8B%AC%E5%8F%B7%E6%8B%AC%E8%B5%B7%E6%9D%A5"><span class="toc-number">1.12.37.</span> <span class="toc-text">▌R9.4.3 do-while 循环体应该用大括号括起来</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-165"><span class="toc-number">1.12.37.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-251"><span class="toc-number">1.12.37.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR9-4-4-%E4%B8%8D%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8-do-%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.12.38.</span> <span class="toc-text">▌R9.4.4 不建议使用 do 语句</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-252"><span class="toc-number">1.12.38.1.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-5-Switch"><span class="toc-number">1.12.39.</span> <span class="toc-text">9.5 Switch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR9-5-1-switch-%E8%AF%AD%E5%8F%A5%E4%B8%8D%E5%BA%94%E8%A2%AB%E5%88%86%E5%8F%B7%E9%9A%94%E6%96%AD"><span class="toc-number">1.12.40.</span> <span class="toc-text">▌R9.5.1 switch 语句不应被分号隔断</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-253"><span class="toc-number">1.12.40.1.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR9-5-2-switch-%E8%AF%AD%E5%8F%A5%E4%B8%8D%E5%BA%94%E4%B8%BA%E7%A9%BA"><span class="toc-number">1.12.41.</span> <span class="toc-text">▌R9.5.2 switch 语句不应为空</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-254"><span class="toc-number">1.12.41.1.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR9-5-3-case-%E6%A0%87%E7%AD%BE%E7%9A%84%E5%80%BC%E4%B8%8D%E5%8F%AF%E8%B6%85%E5%87%BA-switch-%E6%9D%A1%E4%BB%B6%E7%9A%84%E8%8C%83%E5%9B%B4"><span class="toc-number">1.12.42.</span> <span class="toc-text">▌R9.5.3 case 标签的值不可超出 switch 条件的范围</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-166"><span class="toc-number">1.12.42.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-255"><span class="toc-number">1.12.42.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR9-5-4-switch-%E8%AF%AD%E5%8F%A5%E4%B8%AD%E4%BB%BB%E4%BD%95%E5%AD%90%E5%8F%A5%E9%83%BD%E5%BA%94%E4%BB%8E%E5%B1%9E%E4%BA%8E%E6%9F%90%E4%B8%AA-case-%E6%88%96-default-%E5%88%86%E6%9E%9D"><span class="toc-number">1.12.43.</span> <span class="toc-text">▌R9.5.4 switch 语句中任何子句都应从属于某个 case 或 default 分枝</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-256"><span class="toc-number">1.12.43.1.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR9-5-5-case-%E5%92%8C-default-%E6%A0%87%E7%AD%BE%E5%BA%94%E7%9B%B4%E6%8E%A5%E4%BB%8E%E5%B1%9E%E4%BA%8E-switch-%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.12.44.</span> <span class="toc-text">▌R9.5.5 case 和 default 标签应直接从属于 switch 语句</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-167"><span class="toc-number">1.12.44.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-257"><span class="toc-number">1.12.44.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR9-5-6-%E4%B8%8D%E5%BA%94%E5%AD%98%E5%9C%A8%E7%B4%A7%E9%82%BB-default-%E6%A0%87%E7%AD%BE%E7%9A%84%E7%A9%BA-case-%E6%A0%87%E7%AD%BE"><span class="toc-number">1.12.45.</span> <span class="toc-text">▌R9.5.6 不应存在紧邻 default 标签的空 case 标签</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR9-5-7-%E4%B8%8D%E5%BA%94%E5%AD%98%E5%9C%A8%E5%86%85%E5%AE%B9%E5%AE%8C%E5%85%A8%E7%9B%B8%E5%90%8C%E7%9A%84-case-%E5%88%86%E6%9E%9D"><span class="toc-number">1.12.46.</span> <span class="toc-text">▌R9.5.7 不应存在内容完全相同的 case 分枝</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE-31"><span class="toc-number">1.12.46.1.</span> <span class="toc-text">配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-168"><span class="toc-number">1.12.46.2.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-258"><span class="toc-number">1.12.46.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR9-5-8-switch-%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%9D%A1%E4%BB%B6%E4%B8%8D%E5%BA%94%E4%B8%BA-bool-%E5%9E%8B"><span class="toc-number">1.12.47.</span> <span class="toc-text">▌R9.5.8 switch 语句的条件不应为 bool 型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-259"><span class="toc-number">1.12.47.1.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR9-5-9-switch-%E8%AF%AD%E5%8F%A5%E4%B8%8D%E5%BA%94%E5%8F%AA%E5%8C%85%E5%90%AB-default-%E6%A0%87%E7%AD%BE"><span class="toc-number">1.12.48.</span> <span class="toc-text">▌R9.5.9 switch 语句不应只包含 default 标签</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-260"><span class="toc-number">1.12.48.1.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR9-5-10-switch-%E8%AF%AD%E5%8F%A5%E4%B8%8D%E5%BA%94%E5%8F%AA%E5%8C%85%E5%90%AB%E4%B8%80%E4%B8%AA-case-%E6%A0%87%E7%AD%BE"><span class="toc-number">1.12.49.</span> <span class="toc-text">▌R9.5.10 switch 语句不应只包含一个 case 标签</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-261"><span class="toc-number">1.12.49.1.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR9-5-11-switch-%E8%AF%AD%E5%8F%A5%E5%88%86%E6%9E%9D%E6%95%B0%E9%87%8F%E5%BA%94%E5%9C%A8%E8%A7%84%E5%AE%9A%E8%8C%83%E5%9B%B4%E4%B9%8B%E5%86%85"><span class="toc-number">1.12.50.</span> <span class="toc-text">▌R9.5.11 switch 语句分枝数量应在规定范围之内</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE-32"><span class="toc-number">1.12.50.1.</span> <span class="toc-text">配置</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR9-5-12-switch-%E8%AF%AD%E5%8F%A5%E5%BA%94%E9%85%8D%E6%9C%89-default-%E5%88%86%E6%9E%9D"><span class="toc-number">1.12.51.</span> <span class="toc-text">▌R9.5.12 switch 语句应配有 default 分枝</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-169"><span class="toc-number">1.12.51.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-262"><span class="toc-number">1.12.51.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR9-5-13-switch-%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%AF%8F%E4%B8%AA%E9%9D%9E%E7%A9%BA%E5%88%86%E6%9E%9D%E9%83%BD%E5%BA%94%E8%AF%A5%E7%94%A8%E6%97%A0%E6%9D%A1%E4%BB%B6%E7%9A%84-break-%E6%88%96-return-%E8%AF%AD%E5%8F%A5%E7%BB%88%E6%AD%A2"><span class="toc-number">1.12.52.</span> <span class="toc-text">▌R9.5.13 switch 语句的每个非空分枝都应该用无条件的 break 或 return 语句终止</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-141"><span class="toc-number">1.12.52.1.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-263"><span class="toc-number">1.12.52.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR9-5-14-switch-%E8%AF%AD%E5%8F%A5%E5%BA%94%E8%AF%A5%E7%94%A8%E5%A4%A7%E6%8B%AC%E5%8F%B7%E6%8B%AC%E8%B5%B7%E6%9D%A5"><span class="toc-number">1.12.53.</span> <span class="toc-text">▌R9.5.14 switch 语句应该用大括号括起来</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-170"><span class="toc-number">1.12.53.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-264"><span class="toc-number">1.12.53.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR9-5-15-switch-%E8%AF%AD%E5%8F%A5%E4%B8%8D%E5%BA%94%E5%B5%8C%E5%A5%97"><span class="toc-number">1.12.54.</span> <span class="toc-text">▌R9.5.15 switch 语句不应嵌套</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-6-Try-catch"><span class="toc-number">1.12.55.</span> <span class="toc-text">9.6 Try-catch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR9-6-1-try-%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8D%E5%BA%94%E4%B8%BA%E7%A9%BA"><span class="toc-number">1.12.56.</span> <span class="toc-text">▌R9.6.1 try 关键字的作用域不应为空</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-265"><span class="toc-number">1.12.56.1.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR9-6-2-catch-%E5%AD%90%E5%8F%A5%E4%B8%8D%E5%BA%94%E4%B8%BA%E7%A9%BA"><span class="toc-number">1.12.57.</span> <span class="toc-text">▌R9.6.2 catch 子句不应为空</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-266"><span class="toc-number">1.12.57.1.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR9-6-3-%E4%B8%8D%E5%BA%94%E5%B5%8C%E5%A5%97-try-catch-%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.12.58.</span> <span class="toc-text">▌R9.6.3 不应嵌套 try-catch 语句</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-267"><span class="toc-number">1.12.58.1.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR9-6-4-%E6%8D%95%E8%8E%B7%E6%89%80%E6%9C%89%E5%BC%82%E5%B8%B8%E7%9A%84-catch-%E2%80%A6-%E5%AD%90%E5%8F%A5%E5%BA%94%E4%BD%8D%E4%BA%8E%E6%9C%80%E5%90%8E"><span class="toc-number">1.12.59.</span> <span class="toc-text">▌R9.6.4 捕获所有异常的 catch(…) 子句应位于最后</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-171"><span class="toc-number">1.12.59.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-142"><span class="toc-number">1.12.59.2.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-268"><span class="toc-number">1.12.59.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR9-6-5-%E9%9D%A2%E5%90%91%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84-catch-%E5%AD%90%E5%8F%A5%E5%BA%94%E6%8E%92%E5%9C%A8%E9%9D%A2%E5%90%91%E5%9F%BA%E7%B1%BB%E7%9A%84-catch-%E5%AD%90%E5%8F%A5%E4%B9%8B%E5%89%8D"><span class="toc-number">1.12.60.</span> <span class="toc-text">▌R9.6.5 面向派生类的 catch 子句应排在面向基类的 catch 子句之前</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-172"><span class="toc-number">1.12.60.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-143"><span class="toc-number">1.12.60.2.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-269"><span class="toc-number">1.12.60.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-7-Jump"><span class="toc-number">1.12.61.</span> <span class="toc-text">9.7 Jump</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR9-7-1-%E7%A6%81%E6%AD%A2-goto-%E8%AF%AD%E5%8F%A5%E5%90%91%E5%B5%8C%E5%A5%97%E7%9A%84%E6%88%96%E6%97%A0%E5%8C%85%E5%90%AB%E5%85%B3%E7%B3%BB%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E8%B7%B3%E8%BD%AC"><span class="toc-number">1.12.62.</span> <span class="toc-text">▌R9.7.1 禁止 goto 语句向嵌套的或无包含关系的作用域跳转</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-173"><span class="toc-number">1.12.62.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-270"><span class="toc-number">1.12.62.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR9-7-2-%E7%A6%81%E6%AD%A2-goto-%E8%AF%AD%E5%8F%A5%E5%90%91%E5%89%8D%E8%B7%B3%E8%BD%AC"><span class="toc-number">1.12.63.</span> <span class="toc-text">▌R9.7.2 禁止 goto 语句向前跳转</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-174"><span class="toc-number">1.12.63.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-271"><span class="toc-number">1.12.63.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR9-7-3-%E7%A6%81%E7%94%A8-goto-%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.12.64.</span> <span class="toc-text">▌R9.7.3 禁用 goto 语句</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-175"><span class="toc-number">1.12.64.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-272"><span class="toc-number">1.12.64.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR9-7-4-%E7%A6%81%E7%94%A8-setjmp%E3%80%81longjmp"><span class="toc-number">1.12.65.</span> <span class="toc-text">▌R9.7.4 禁用 setjmp、longjmp</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-144"><span class="toc-number">1.12.65.1.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-273"><span class="toc-number">1.12.65.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR9-7-5-%E4%B8%8D%E5%BA%94%E5%AD%98%E5%9C%A8%E4%B8%8D%E5%8F%97%E6%9D%A1%E4%BB%B6%E6%8E%A7%E5%88%B6%E7%9A%84%E8%B7%B3%E8%BD%AC%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.12.66.</span> <span class="toc-text">▌R9.7.5 不应存在不受条件控制的跳转语句</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-176"><span class="toc-number">1.12.66.1.</span> <span class="toc-text">相关</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR9-7-6-%E4%B8%8D%E5%BA%94%E5%AD%98%E5%9C%A8%E4%B8%8D%E6%94%B9%E5%8F%98%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E7%9A%84%E8%B7%B3%E8%BD%AC%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.12.67.</span> <span class="toc-text">▌R9.7.6 不应存在不改变程序流程的跳转语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR9-7-7-%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8%E8%B7%B3%E8%BD%AC%E8%AF%AD%E5%8F%A5%E9%80%80%E5%87%BA%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.12.68.</span> <span class="toc-text">▌R9.7.7 避免使用跳转语句退出循环</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-177"><span class="toc-number">1.12.68.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-274"><span class="toc-number">1.12.68.2.</span> <span class="toc-text">参考</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-Expression"><span class="toc-number">1.13.</span> <span class="toc-text">10. Expression</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-Logic"><span class="toc-number">1.13.1.</span> <span class="toc-text">10.1 Logic</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR10-1-1-%E4%B8%8D%E5%BA%94%E5%AD%98%E5%9C%A8%E6%97%A0%E6%84%8F%E4%B9%89%E7%9A%84%E9%87%8D%E5%A4%8D%E5%AD%90%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.13.2.</span> <span class="toc-text">▌R10.1.1 不应存在无意义的重复子表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-275"><span class="toc-number">1.13.2.1.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR10-1-2-%E9%80%BB%E8%BE%91%E5%AD%90%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B9%8B%E9%97%B4%E4%B8%8D%E5%BA%94%E5%AD%98%E5%9C%A8%E7%9F%9B%E7%9B%BE"><span class="toc-number">1.13.3.</span> <span class="toc-text">▌R10.1.2 逻辑子表达式之间不应存在矛盾</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-178"><span class="toc-number">1.13.3.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-276"><span class="toc-number">1.13.3.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR10-1-3-%E4%BD%9C%E4%B8%BA%E6%9D%A1%E4%BB%B6%E7%9A%84%E9%80%BB%E8%BE%91%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8D%E5%BA%94%E6%81%92%E4%B8%BA%E7%9C%9F%E6%88%96%E6%81%92%E4%B8%BA%E5%81%87"><span class="toc-number">1.13.4.</span> <span class="toc-text">▌R10.1.3 作为条件的逻辑表达式不应恒为真或恒为假</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-179"><span class="toc-number">1.13.4.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-277"><span class="toc-number">1.13.4.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR10-1-4-%E4%B8%8D%E5%BA%94%E5%AD%98%E5%9C%A8%E5%A4%9A%E4%BD%99%E7%9A%84%E9%80%BB%E8%BE%91%E5%AD%90%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.13.5.</span> <span class="toc-text">▌R10.1.4 不应存在多余的逻辑子表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-180"><span class="toc-number">1.13.5.1.</span> <span class="toc-text">相关</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR10-1-5-%E9%80%BB%E8%BE%91%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8F%8A%E9%80%BB%E8%BE%91%E5%AD%90%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8D%E5%BA%94%E4%B8%BA%E5%B8%B8%E9%87%8F"><span class="toc-number">1.13.6.</span> <span class="toc-text">▌R10.1.5 逻辑表达式及逻辑子表达式不应为常量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-278"><span class="toc-number">1.13.6.1.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR10-1-6-%E9%80%BB%E8%BE%91%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%8F%B3%E5%AD%90%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8D%E5%BA%94%E6%9C%89%E5%89%AF%E4%BD%9C%E7%94%A8"><span class="toc-number">1.13.7.</span> <span class="toc-text">▌R10.1.6 逻辑表达式的右子表达式不应有副作用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-145"><span class="toc-number">1.13.7.1.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-279"><span class="toc-number">1.13.7.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR10-1-7-%E5%8C%96%E7%AE%80%E5%8F%AF%E8%A2%AB%E5%90%88%E5%B9%B6%E7%9A%84%E9%80%BB%E8%BE%91%E5%AD%90%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.13.8.</span> <span class="toc-text">▌R10.1.7 化简可被合并的逻辑子表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-181"><span class="toc-number">1.13.8.1.</span> <span class="toc-text">相关</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR10-1-8-%E5%8C%96%E7%AE%80%E5%8F%AF%E8%BD%AC%E6%8D%A2%E4%B8%BA%E9%80%BB%E8%BE%91%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E4%B8%89%E5%85%83%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.13.9.</span> <span class="toc-text">▌R10.1.8 化简可转换为逻辑表达式的三元表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-Evaluation"><span class="toc-number">1.13.10.</span> <span class="toc-text">10.2 Evaluation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR10-2-1-%E4%B8%8D%E5%8F%AF%E4%BE%9D%E8%B5%96%E4%B8%8D%E4%BC%9A%E7%94%9F%E6%95%88%E7%9A%84%E5%89%AF%E4%BD%9C%E7%94%A8"><span class="toc-number">1.13.11.</span> <span class="toc-text">▌R10.2.1 不可依赖不会生效的副作用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-182"><span class="toc-number">1.13.11.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-146"><span class="toc-number">1.13.11.2.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-280"><span class="toc-number">1.13.11.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR10-2-2-%E9%81%BF%E5%85%8D%E4%BE%9D%E8%B5%96%E7%89%B9%E5%AE%9A%E7%9A%84%E5%AD%90%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC%E9%A1%BA%E5%BA%8F"><span class="toc-number">1.13.12.</span> <span class="toc-text">▌R10.2.2 避免依赖特定的子表达式求值顺序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-183"><span class="toc-number">1.13.12.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-147"><span class="toc-number">1.13.12.2.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-281"><span class="toc-number">1.13.12.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR10-2-3-%E5%9C%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%AD%E4%B8%8D%E5%BA%94%E5%A4%9A%E6%AC%A1%E8%AF%BB%E5%86%99%E5%90%8C%E4%B8%80%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.13.13.</span> <span class="toc-text">▌R10.2.3 在表达式中不应多次读写同一对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-184"><span class="toc-number">1.13.13.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-148"><span class="toc-number">1.13.13.2.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-282"><span class="toc-number">1.13.13.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR10-2-4-%E6%B3%A8%E6%84%8F%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7%EF%BC%8C%E9%81%BF%E5%85%8D%E9%9D%9E%E9%A2%84%E6%9C%9F%E7%9A%84%E7%BB%93%E6%9E%9C"><span class="toc-number">1.13.14.</span> <span class="toc-text">▌R10.2.4 注意运算符优先级，避免非预期的结果</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-283"><span class="toc-number">1.13.14.1.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR10-2-5-%E4%B8%8D%E5%9C%A8%E5%90%8C%E4%B8%80%E6%95%B0%E7%BB%84%E6%88%96%E5%AF%B9%E8%B1%A1%E4%B8%AD%E7%9A%84%E5%9C%B0%E5%9D%80%E4%B8%8D%E5%8F%AF%E7%9B%B8%E5%87%8F%E6%88%96%E6%AF%94%E8%BE%83%E5%A4%A7%E5%B0%8F"><span class="toc-number">1.13.15.</span> <span class="toc-text">▌R10.2.5 不在同一数组或对象中的地址不可相减或比较大小</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-185"><span class="toc-number">1.13.15.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-149"><span class="toc-number">1.13.15.2.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-284"><span class="toc-number">1.13.15.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR10-2-6-bool-%E5%80%BC%E4%B8%8D%E5%BA%94%E5%8F%82%E4%B8%8E%E4%BD%8D%E8%BF%90%E7%AE%97%E3%80%81%E5%A4%A7%E5%B0%8F%E6%AF%94%E8%BE%83%E3%80%81%E6%95%B0%E5%80%BC%E5%A2%9E%E5%87%8F"><span class="toc-number">1.13.16.</span> <span class="toc-text">▌R10.2.6 bool 值不应参与位运算、大小比较、数值增减</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-150"><span class="toc-number">1.13.16.1.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-285"><span class="toc-number">1.13.16.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR10-2-7-%E4%B8%8D%E5%BA%94%E5%87%BA%E7%8E%B0%E5%A4%8D%E5%90%88%E8%B5%8B%E5%80%BC%E7%9A%84%E9%94%99%E8%AF%AF%E5%BD%A2%E5%BC%8F"><span class="toc-number">1.13.17.</span> <span class="toc-text">▌R10.2.7 不应出现复合赋值的错误形式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-286"><span class="toc-number">1.13.17.1.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR10-2-8-%E9%81%BF%E5%85%8D%E5%87%BA%E7%8E%B0%E5%A4%8D%E5%90%88%E8%B5%8B%E5%80%BC%E7%9A%84%E5%8F%AF%E7%96%91%E5%BD%A2%E5%BC%8F"><span class="toc-number">1.13.18.</span> <span class="toc-text">▌R10.2.8 避免出现复合赋值的可疑形式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-287"><span class="toc-number">1.13.18.1.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR10-2-9-amp-%E3%80%81-%E3%80%81-%E3%80%81-%E3%80%81-%E5%B7%A6%E5%8F%B3%E5%AD%90%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8D%E5%BA%94%E7%9B%B8%E5%90%8C"><span class="toc-number">1.13.19.</span> <span class="toc-text">▌R10.2.9 &amp;&#x3D;、|&#x3D;、-&#x3D;、&#x2F;&#x3D;、%&#x3D; 左右子表达式不应相同</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-288"><span class="toc-number">1.13.19.1.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR10-2-10-%E4%B8%8D%E5%BA%94%E5%B0%86-NULL-%E5%BD%93%E4%BD%9C%E6%95%B4%E6%95%B0%E4%BD%BF%E7%94%A8"><span class="toc-number">1.13.20.</span> <span class="toc-text">▌R10.2.10 不应将 NULL 当作整数使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-151"><span class="toc-number">1.13.20.1.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-289"><span class="toc-number">1.13.20.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR10-2-11-%E6%B3%A8%E6%84%8F%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E4%B8%80%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E7%A9%BA%E6%A0%BC%E6%96%B9%E5%BC%8F"><span class="toc-number">1.13.21.</span> <span class="toc-text">▌R10.2.11 注意赋值运算符与一元运算符的空格方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-290"><span class="toc-number">1.13.21.1.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR10-2-12-%E4%B8%8D%E5%8F%AF%E5%B0%86%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%80%BC%E8%B5%8B%E7%BB%99%E5%85%B7%E6%9C%89%E9%83%A8%E5%88%86%E9%87%8D%E5%8F%A0%E5%8C%BA%E5%9F%9F%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.13.22.</span> <span class="toc-text">▌R10.2.12 不可将对象的值赋给具有部分重叠区域的对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-152"><span class="toc-number">1.13.22.1.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-291"><span class="toc-number">1.13.22.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR10-2-13-%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E5%B7%A6%E5%8F%B3%E5%AD%90%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8D%E5%BA%94%E7%9B%B8%E5%90%8C"><span class="toc-number">1.13.23.</span> <span class="toc-text">▌R10.2.13 赋值运算符左右子表达式不应相同</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-292"><span class="toc-number">1.13.23.1.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR10-2-14-%E9%99%A4%E6%B3%95%E5%92%8C%E6%B1%82%E4%BD%99%E8%BF%90%E7%AE%97%E7%AC%A6%E5%B7%A6%E5%8F%B3%E5%AD%90%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8D%E5%BA%94%E7%9B%B8%E5%90%8C"><span class="toc-number">1.13.24.</span> <span class="toc-text">▌R10.2.14 除法和求余运算符左右子表达式不应相同</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-293"><span class="toc-number">1.13.24.1.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR10-2-15-%E5%87%8F%E6%B3%95%E8%BF%90%E7%AE%97%E7%AC%A6%E5%B7%A6%E5%8F%B3%E5%AD%90%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8D%E5%BA%94%E7%9B%B8%E5%90%8C"><span class="toc-number">1.13.25.</span> <span class="toc-text">▌R10.2.15 减法运算符左右子表达式不应相同</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-294"><span class="toc-number">1.13.25.1.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR10-2-16-%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97%E7%AC%A6%E5%B7%A6%E5%8F%B3%E5%AD%90%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8D%E5%BA%94%E7%9B%B8%E5%90%8C"><span class="toc-number">1.13.26.</span> <span class="toc-text">▌R10.2.16 异或运算符左右子表达式不应相同</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-295"><span class="toc-number">1.13.26.1.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR10-2-17-%E8%B4%9F%E5%8F%B7%E4%B8%8D%E5%BA%94%E4%BD%9C%E7%94%A8%E4%BA%8E%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B4%E6%95%B0"><span class="toc-number">1.13.27.</span> <span class="toc-text">▌R10.2.17 负号不应作用于无符号整数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE-33"><span class="toc-number">1.13.27.1.</span> <span class="toc-text">配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-153"><span class="toc-number">1.13.27.2.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-296"><span class="toc-number">1.13.27.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR10-2-18-%E4%B8%8D%E5%BA%94%E9%87%8D%E5%A4%8D%E4%BD%BF%E7%94%A8%E4%B8%80%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.13.28.</span> <span class="toc-text">▌R10.2.18 不应重复使用一元运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR10-2-19-%E8%BF%90%E7%AE%97%E7%BB%93%E6%9E%9C%E4%B8%8D%E5%BA%94%E6%BA%A2%E5%87%BA"><span class="toc-number">1.13.29.</span> <span class="toc-text">▌R10.2.19 运算结果不应溢出</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-154"><span class="toc-number">1.13.29.1.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-297"><span class="toc-number">1.13.29.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR10-2-20-%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8D%E5%BA%94%E4%BD%9C%E7%94%A8%E4%BA%8E%E6%9C%89%E7%AC%A6%E5%8F%B7%E6%95%B4%E6%95%B0"><span class="toc-number">1.13.30.</span> <span class="toc-text">▌R10.2.20 位运算符不应作用于有符号整数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-155"><span class="toc-number">1.13.30.1.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-298"><span class="toc-number">1.13.30.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR10-2-21-%E7%A7%BB%E4%BD%8D%E6%95%B0%E9%87%8F%E4%B8%8D%E5%BA%94%E8%B6%85%E8%BF%87%E7%9B%B8%E5%85%B3%E7%B1%BB%E5%9E%8B%E6%AF%94%E7%89%B9%E4%BD%8D%E7%9A%84%E6%95%B0%E9%87%8F"><span class="toc-number">1.13.31.</span> <span class="toc-text">▌R10.2.21 移位数量不应超过相关类型比特位的数量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-156"><span class="toc-number">1.13.31.1.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-299"><span class="toc-number">1.13.31.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR10-2-22-%E6%8C%89%E4%BD%8D%E5%8F%96%E5%8F%8D%E9%9C%80%E9%81%BF%E5%85%8D%E7%94%B1%E7%B1%BB%E5%9E%8B%E6%8F%90%E5%8D%87%E4%BA%A7%E7%94%9F%E7%9A%84%E5%A4%9A%E4%BD%99%E6%95%B0%E6%8D%AE"><span class="toc-number">1.13.32.</span> <span class="toc-text">▌R10.2.22 按位取反需避免由类型提升产生的多余数据</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-300"><span class="toc-number">1.13.32.1.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR10-2-23-%E9%80%97%E5%8F%B7%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%AD%90%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BA%94%E5%85%B7%E6%9C%89%E5%BF%85%E8%A6%81%E7%9A%84%E5%89%AF%E4%BD%9C%E7%94%A8"><span class="toc-number">1.13.33.</span> <span class="toc-text">▌R10.2.23 逗号表达式的子表达式应具有必要的副作用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-186"><span class="toc-number">1.13.33.1.</span> <span class="toc-text">相关</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-3-Comparison"><span class="toc-number">1.13.34.</span> <span class="toc-text">10.3 Comparison</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR10-3-1-%E5%8F%82%E4%B8%8E%E6%AF%94%E8%BE%83%E7%9A%84%E5%AF%B9%E8%B1%A1%E4%B9%8B%E9%97%B4%E5%BA%94%E5%85%B7%E5%A4%87%E5%90%88%E7%90%86%E7%9A%84%E5%A4%A7%E5%B0%8F%E5%85%B3%E7%B3%BB"><span class="toc-number">1.13.35.</span> <span class="toc-text">▌R10.3.1 参与比较的对象之间应具备合理的大小关系</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-187"><span class="toc-number">1.13.35.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-301"><span class="toc-number">1.13.35.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR10-3-2-%E4%B8%8D%E5%BA%94%E4%BD%BF%E7%94%A8-%E6%88%96-%E5%88%A4%E6%96%AD%E6%B5%AE%E7%82%B9%E6%95%B0%E6%98%AF%E5%90%A6%E7%9B%B8%E7%AD%89"><span class="toc-number">1.13.36.</span> <span class="toc-text">▌R10.3.2 不应使用 &#x3D;&#x3D; 或 !&#x3D; 判断浮点数是否相等</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-302"><span class="toc-number">1.13.36.1.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR10-3-3-%E6%8C%87%E9%92%88%E4%B8%8D%E5%BA%94%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E7%9B%B4%E6%8E%A5%E6%AF%94%E8%BE%83"><span class="toc-number">1.13.37.</span> <span class="toc-text">▌R10.3.3 指针不应与字符串常量直接比较</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-157"><span class="toc-number">1.13.37.1.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-303"><span class="toc-number">1.13.37.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR10-3-4-%E4%B8%8D%E5%BA%94%E6%AF%94%E8%BE%83%E9%9D%9E%E5%90%8C%E7%B1%BB%E6%9E%9A%E4%B8%BE%E5%80%BC"><span class="toc-number">1.13.38.</span> <span class="toc-text">▌R10.3.4 不应比较非同类枚举值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR10-3-5-%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6%E5%B7%A6%E5%8F%B3%E5%AD%90%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8D%E5%BA%94%E7%9B%B8%E5%90%8C"><span class="toc-number">1.13.39.</span> <span class="toc-text">▌R10.3.5 比较运算符左右子表达式不应相同</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-304"><span class="toc-number">1.13.39.1.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR10-3-6-%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E4%B8%8D%E5%8F%AF%E4%BD%9C%E4%B8%BA%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%9A%84%E7%9B%B4%E6%8E%A5%E5%AD%90%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.13.40.</span> <span class="toc-text">▌R10.3.6 比较运算不可作为另一个比较运算的直接子表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-188"><span class="toc-number">1.13.40.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-305"><span class="toc-number">1.13.40.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-4-Call"><span class="toc-number">1.13.41.</span> <span class="toc-text">10.4 Call</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR10-4-1-%E4%B8%8D%E5%BA%94%E5%BF%BD%E7%95%A5%E9%87%8D%E8%A6%81%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">1.13.42.</span> <span class="toc-text">▌R10.4.1 不应忽略重要的返回值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE-34"><span class="toc-number">1.13.42.1.</span> <span class="toc-text">配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-158"><span class="toc-number">1.13.42.2.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-306"><span class="toc-number">1.13.42.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR10-4-2-%E4%B8%8D%E5%8F%AF%E8%87%86%E6%96%AD%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E6%84%8F%E4%B9%89"><span class="toc-number">1.13.43.</span> <span class="toc-text">▌R10.4.2 不可臆断返回值的意义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-159"><span class="toc-number">1.13.43.1.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-307"><span class="toc-number">1.13.43.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR10-4-3-%E9%81%BF%E5%85%8D%E5%AF%B9%E8%B1%A1%E5%88%87%E7%89%87"><span class="toc-number">1.13.44.</span> <span class="toc-text">▌R10.4.3 避免对象切片</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-189"><span class="toc-number">1.13.44.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-308"><span class="toc-number">1.13.44.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR10-4-4-%E9%81%BF%E5%85%8D%E6%98%BE%E5%BC%8F%E8%B0%83%E7%94%A8%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">1.13.45.</span> <span class="toc-text">▌R10.4.4 避免显式调用析构函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-190"><span class="toc-number">1.13.45.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-160"><span class="toc-number">1.13.45.2.</span> <span class="toc-text">依据</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR10-4-5-%E4%B8%8D%E5%BA%94%E5%B0%86%E9%9D%9E-POD-%E5%AF%B9%E8%B1%A1%E4%BC%A0%E5%85%A5%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8"><span class="toc-number">1.13.46.</span> <span class="toc-text">▌R10.4.5 不应将非 POD 对象传入可变参数列表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-191"><span class="toc-number">1.13.46.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-161"><span class="toc-number">1.13.46.2.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-309"><span class="toc-number">1.13.46.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR10-4-6-C-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%9C%80%E8%A6%81%E7%9A%84%E5%8F%82%E6%95%B0%E4%B8%AA%E6%95%B0%E4%B8%8E%E5%AE%9E%E9%99%85%E4%BC%A0%E5%85%A5%E7%9A%84%E5%8F%82%E6%95%B0%E4%B8%AA%E6%95%B0%E5%BA%94%E4%B8%80%E8%87%B4"><span class="toc-number">1.13.47.</span> <span class="toc-text">▌R10.4.6 C 格式化字符串需要的参数个数与实际传入的参数个数应一致</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-192"><span class="toc-number">1.13.47.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-162"><span class="toc-number">1.13.47.2.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-310"><span class="toc-number">1.13.47.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR10-4-7-C-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%8D%A0%E4%BD%8D%E7%AC%A6%E4%B8%8E%E5%85%B6%E5%AF%B9%E5%BA%94%E5%8F%82%E6%95%B0%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%BA%94%E4%B8%80%E8%87%B4"><span class="toc-number">1.13.48.</span> <span class="toc-text">▌R10.4.7 C 格式化占位符与其对应参数的类型应一致</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-193"><span class="toc-number">1.13.48.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-163"><span class="toc-number">1.13.48.2.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-311"><span class="toc-number">1.13.48.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR10-4-8-%E5%9C%A8-C-%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%A6%81%E7%94%A8-C-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%96%B9%E6%B3%95"><span class="toc-number">1.13.49.</span> <span class="toc-text">▌R10.4.8 在 C++ 代码中禁用 C 字符串格式化方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-194"><span class="toc-number">1.13.49.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-164"><span class="toc-number">1.13.49.2.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-312"><span class="toc-number">1.13.49.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR10-4-9-%E7%A6%81%E7%94%A8-atof%E3%80%81atoi%E3%80%81atol-%E4%BB%A5%E5%8F%8A-atoll-%E7%AD%89%E5%87%BD%E6%95%B0"><span class="toc-number">1.13.50.</span> <span class="toc-text">▌R10.4.9 禁用 atof、atoi、atol 以及 atoll 等函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-165"><span class="toc-number">1.13.50.1.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-313"><span class="toc-number">1.13.50.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR10-4-10-%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8%E7%94%B1%E5%AE%9E%E7%8E%B0%E5%AE%9A%E4%B9%89%E7%9A%84%E5%BA%93%E5%87%BD%E6%95%B0"><span class="toc-number">1.13.51.</span> <span class="toc-text">▌R10.4.10 避免使用由实现定义的库函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-166"><span class="toc-number">1.13.51.1.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-314"><span class="toc-number">1.13.51.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR10-4-11-%E5%90%88%E7%90%86%E4%BD%BF%E7%94%A8-std-move"><span class="toc-number">1.13.52.</span> <span class="toc-text">▌R10.4.11 合理使用 std::move</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-167"><span class="toc-number">1.13.52.1.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-315"><span class="toc-number">1.13.52.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR10-4-12-%E5%90%88%E7%90%86%E4%BD%BF%E7%94%A8-std-forward"><span class="toc-number">1.13.53.</span> <span class="toc-text">▌R10.4.12 合理使用 std::forward</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-195"><span class="toc-number">1.13.53.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-168"><span class="toc-number">1.13.53.2.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-316"><span class="toc-number">1.13.53.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-5-Sizeof"><span class="toc-number">1.13.54.</span> <span class="toc-text">10.5 Sizeof</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR10-5-1-sizeof-%E4%B8%8D%E5%BA%94%E4%BD%9C%E7%94%A8%E4%BA%8E%E6%95%B0%E7%BB%84%E5%8F%82%E6%95%B0"><span class="toc-number">1.13.55.</span> <span class="toc-text">▌R10.5.1 sizeof 不应作用于数组参数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-169"><span class="toc-number">1.13.55.1.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-317"><span class="toc-number">1.13.55.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR10-5-2-sizeof-%E4%B8%8D%E5%BA%94%E4%BD%9C%E7%94%A8%E4%BA%8E%E9%80%BB%E8%BE%91%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.13.56.</span> <span class="toc-text">▌R10.5.2 sizeof 不应作用于逻辑表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR10-5-3-sizeof-%E4%BD%9C%E7%94%A8%E4%BA%8E%E6%8C%87%E9%92%88%E6%98%AF%E5%8F%AF%E7%96%91%E7%9A%84"><span class="toc-number">1.13.57.</span> <span class="toc-text">▌R10.5.3 sizeof 作用于指针是可疑的</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-196"><span class="toc-number">1.13.57.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-318"><span class="toc-number">1.13.57.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR10-5-4-%E8%A2%AB%E9%99%A4%E6%95%B0%E4%B8%8D%E5%BA%94%E6%98%AF%E4%BD%9C%E7%94%A8%E4%BA%8E%E6%8C%87%E9%92%88%E7%9A%84-sizeof-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.13.58.</span> <span class="toc-text">▌R10.5.4 被除数不应是作用于指针的 sizeof 表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-197"><span class="toc-number">1.13.58.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-319"><span class="toc-number">1.13.58.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR10-5-5-%E6%8C%87%E9%92%88%E5%8A%A0%E5%87%8F%E5%81%8F%E7%A7%BB%E9%87%8F%E6%97%B6%E8%AE%A1%E5%85%A5-sizeof-%E6%98%AF%E5%8F%AF%E7%96%91%E7%9A%84"><span class="toc-number">1.13.59.</span> <span class="toc-text">▌R10.5.5 指针加减偏移量时计入 sizeof 是可疑的</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-170"><span class="toc-number">1.13.59.1.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-320"><span class="toc-number">1.13.59.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR10-5-6-sizeof-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%9C%E4%B8%8D%E5%BA%94%E4%B8%8E-0-%E6%88%96%E8%B4%9F%E6%95%B0%E6%AF%94%E8%BE%83"><span class="toc-number">1.13.60.</span> <span class="toc-text">▌R10.5.6 sizeof 表达式的结果不应与 0 或负数比较</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-171"><span class="toc-number">1.13.60.1.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-321"><span class="toc-number">1.13.60.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR10-5-7-sizeof-%E4%B8%8D%E5%BA%94%E5%86%8D%E4%BD%9C%E7%94%A8%E4%BA%8E-sizeof-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.13.61.</span> <span class="toc-text">▌R10.5.7 sizeof 不应再作用于 sizeof 表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-172"><span class="toc-number">1.13.61.1.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-322"><span class="toc-number">1.13.61.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR10-5-8-C-%E4%BB%A3%E7%A0%81%E4%B8%AD-sizeof-%E4%B8%8D%E5%BA%94%E4%BD%9C%E7%94%A8%E4%BA%8E-NULL"><span class="toc-number">1.13.62.</span> <span class="toc-text">▌R10.5.8 C++ 代码中 sizeof 不应作用于 NULL</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-198"><span class="toc-number">1.13.62.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-173"><span class="toc-number">1.13.62.2.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-323"><span class="toc-number">1.13.62.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR10-5-9-sizeof-%E4%B8%8D%E5%8F%AF%E4%BD%9C%E7%94%A8%E4%BA%8E-void"><span class="toc-number">1.13.63.</span> <span class="toc-text">▌R10.5.9 sizeof 不可作用于 void</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-174"><span class="toc-number">1.13.63.1.</span> <span class="toc-text">依据</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-6-Assertion"><span class="toc-number">1.13.64.</span> <span class="toc-text">10.6 Assertion</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR10-6-1-%E6%96%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8D%E5%BA%94%E6%81%92%E4%B8%BA%E7%9C%9F"><span class="toc-number">1.13.65.</span> <span class="toc-text">▌R10.6.1 断言中的表达式不应恒为真</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-175"><span class="toc-number">1.13.65.1.</span> <span class="toc-text">依据</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR10-6-2-%E6%96%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8D%E5%BA%94%E6%9C%89%E5%89%AF%E4%BD%9C%E7%94%A8"><span class="toc-number">1.13.66.</span> <span class="toc-text">▌R10.6.2 断言中的表达式不应有副作用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-199"><span class="toc-number">1.13.66.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-176"><span class="toc-number">1.13.66.2.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-324"><span class="toc-number">1.13.66.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR10-6-3-%E6%96%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8D%E5%BA%94%E8%BF%87%E4%BA%8E%E5%A4%8D%E6%9D%82"><span class="toc-number">1.13.67.</span> <span class="toc-text">▌R10.6.3 断言中的表达式不应过于复杂</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE-35"><span class="toc-number">1.13.67.1.</span> <span class="toc-text">配置</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-7-Complexity"><span class="toc-number">1.13.68.</span> <span class="toc-text">10.7 Complexity</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR10-7-1-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8D%E5%BA%94%E8%BF%87%E4%BA%8E%E5%A4%8D%E6%9D%82"><span class="toc-number">1.13.69.</span> <span class="toc-text">▌R10.7.1 表达式不应过于复杂</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE-36"><span class="toc-number">1.13.69.1.</span> <span class="toc-text">配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-325"><span class="toc-number">1.13.69.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-8-Other"><span class="toc-number">1.13.70.</span> <span class="toc-text">10.8 Other</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR10-8-1-%E4%B8%8D%E5%BA%94%E8%AE%BF%E9%97%AE%E5%A1%AB%E5%85%85%E6%95%B0%E6%8D%AE"><span class="toc-number">1.13.71.</span> <span class="toc-text">▌R10.8.1 不应访问填充数据</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-200"><span class="toc-number">1.13.71.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-177"><span class="toc-number">1.13.71.2.</span> <span class="toc-text">依据</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR10-8-2-new-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8F%AA%E5%8F%AF%E7%94%A8%E4%BA%8E%E8%B5%8B%E5%80%BC%E6%88%96%E5%BD%93%E4%BD%9C%E5%8F%82%E6%95%B0"><span class="toc-number">1.13.72.</span> <span class="toc-text">▌R10.8.2 new 表达式只可用于赋值或当作参数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-201"><span class="toc-number">1.13.72.1.</span> <span class="toc-text">相关</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR10-8-3-%E6%95%B0%E7%BB%84%E4%B8%8B%E6%A0%87%E5%BA%94%E4%B8%BA%E6%95%B4%E5%9E%8B%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.13.73.</span> <span class="toc-text">▌R10.8.3 数组下标应为整型表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-178"><span class="toc-number">1.13.73.1.</span> <span class="toc-text">依据</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR10-8-4-%E7%A6%81%E7%94%A8%E9%80%97%E5%8F%B7%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.13.74.</span> <span class="toc-text">▌R10.8.4 禁用逗号表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE-37"><span class="toc-number">1.13.74.1.</span> <span class="toc-text">配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-326"><span class="toc-number">1.13.74.2.</span> <span class="toc-text">参考</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-Literal"><span class="toc-number">1.14.</span> <span class="toc-text">11. Literal</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR11-1-%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6%E7%9A%84%E5%8F%8D%E6%96%9C%E6%9D%A0%E4%B8%8D%E5%8F%AF%E8%AF%AF%E5%86%99%E6%88%90%E6%96%9C%E6%9D%A0"><span class="toc-number">1.14.1.</span> <span class="toc-text">▌R11.1 转义字符的反斜杠不可误写成斜杠</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-202"><span class="toc-number">1.14.1.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-179"><span class="toc-number">1.14.1.2.</span> <span class="toc-text">依据</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR11-2-%E5%9C%A8%E5%AD%97%E7%AC%A6%E5%B8%B8%E9%87%8F%E4%B8%AD%E7%94%A8%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6%E8%A1%A8%E7%A4%BA%E5%88%B6%E8%A1%A8%E7%AC%A6%E5%92%8C%E6%8E%A7%E5%88%B6%E5%AD%97%E7%AC%A6"><span class="toc-number">1.14.2.</span> <span class="toc-text">▌R11.2 在字符常量中用转义字符表示制表符和控制字符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-203"><span class="toc-number">1.14.2.1.</span> <span class="toc-text">相关</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR11-3-%E5%9C%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E4%B8%AD%E7%94%A8%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6%E8%A1%A8%E7%A4%BA%E5%88%B6%E8%A1%A8%E7%AC%A6%E5%92%8C%E6%8E%A7%E5%88%B6%E5%AD%97%E7%AC%A6"><span class="toc-number">1.14.3.</span> <span class="toc-text">▌R11.3 在字符串常量中用转义字符表示制表符和控制字符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-204"><span class="toc-number">1.14.3.1.</span> <span class="toc-text">相关</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR11-4-%E4%B8%8D%E5%BA%94%E4%BD%BF%E7%94%A8%E9%9D%9E%E6%A0%87%E5%87%86%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6"><span class="toc-number">1.14.4.</span> <span class="toc-text">▌R11.4 不应使用非标准转义字符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-180"><span class="toc-number">1.14.4.1.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-327"><span class="toc-number">1.14.4.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR11-5-%E4%B8%8D%E5%BA%94%E8%BF%9E%E6%8E%A5%E4%B8%8D%E5%90%8C%E5%89%8D%E7%BC%80%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F"><span class="toc-number">1.14.5.</span> <span class="toc-text">▌R11.5 不应连接不同前缀的字符串常量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE-38"><span class="toc-number">1.14.5.1.</span> <span class="toc-text">配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-181"><span class="toc-number">1.14.5.2.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-328"><span class="toc-number">1.14.5.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR11-6-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E4%B8%AD%E4%B8%8D%E5%BA%94%E5%AD%98%E5%9C%A8%E6%8B%BC%E5%86%99%E9%94%99%E8%AF%AF"><span class="toc-number">1.14.6.</span> <span class="toc-text">▌R11.6 字符串常量中不应存在拼写错误</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-205"><span class="toc-number">1.14.6.1.</span> <span class="toc-text">相关</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR11-7-%E5%B8%B8%E9%87%8F%E5%90%8E%E7%BC%80%E7%94%B1%E5%BA%94%E7%94%B1%E5%A4%A7%E5%86%99%E5%AD%97%E6%AF%8D%E7%BB%84%E6%88%90"><span class="toc-number">1.14.7.</span> <span class="toc-text">▌R11.7 常量后缀由应由大写字母组成</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE-39"><span class="toc-number">1.14.7.1.</span> <span class="toc-text">配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-329"><span class="toc-number">1.14.7.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR11-8-%E7%A6%81%E7%94%A8-8-%E8%BF%9B%E5%88%B6%E5%B8%B8%E9%87%8F"><span class="toc-number">1.14.8.</span> <span class="toc-text">▌R11.8 禁用 8 进制常量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-330"><span class="toc-number">1.14.8.1.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR11-9-%E4%B8%8D%E5%BA%94%E4%BD%BF%E7%94%A8%E9%9D%9E%E6%A0%87%E5%87%86%E5%B8%B8%E9%87%8F%E5%90%8E%E7%BC%80"><span class="toc-number">1.14.9.</span> <span class="toc-text">▌R11.9 不应使用非标准常量后缀</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-206"><span class="toc-number">1.14.9.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-182"><span class="toc-number">1.14.9.2.</span> <span class="toc-text">依据</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR11-10-%E5%B0%8F%E5%BF%83%E9%81%97%E6%BC%8F%E9%80%97%E5%8F%B7%E5%AF%BC%E8%87%B4%E7%9A%84%E9%9D%9E%E9%A2%84%E6%9C%9F%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.14.10.</span> <span class="toc-text">▌R11.10 小心遗漏逗号导致的非预期字符串连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR11-11-%E4%B8%8D%E5%BA%94%E5%AD%98%E5%9C%A8-magic-number"><span class="toc-number">1.14.11.</span> <span class="toc-text">▌R11.11 不应存在 magic number</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-207"><span class="toc-number">1.14.11.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-331"><span class="toc-number">1.14.11.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR11-12-%E4%B8%8D%E5%BA%94%E5%AD%98%E5%9C%A8-magic-string"><span class="toc-number">1.14.12.</span> <span class="toc-text">▌R11.12 不应存在 magic string</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-208"><span class="toc-number">1.14.12.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-332"><span class="toc-number">1.14.12.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR11-13-%E4%B8%8D%E5%BA%94%E4%BD%BF%E7%94%A8%E5%A4%9A%E5%AD%97%E7%AC%A6%E5%B8%B8%E9%87%8F"><span class="toc-number">1.14.13.</span> <span class="toc-text">▌R11.13 不应使用多字符常量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-209"><span class="toc-number">1.14.13.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-183"><span class="toc-number">1.14.13.2.</span> <span class="toc-text">依据</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-Cast"><span class="toc-number">1.15.</span> <span class="toc-text">12. Cast</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR12-1-%E9%81%BF%E5%85%8D%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E9%80%A0%E6%88%90%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1"><span class="toc-number">1.15.1.</span> <span class="toc-text">▌R12.1 避免类型转换造成数据丢失</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-184"><span class="toc-number">1.15.1.1.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-333"><span class="toc-number">1.15.1.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR12-2-%E9%81%BF%E5%85%8D%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1%E9%80%A0%E6%88%90%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%A4%B1%E6%95%88"><span class="toc-number">1.15.2.</span> <span class="toc-text">▌R12.2 避免数据丢失造成类型转换失效</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-210"><span class="toc-number">1.15.2.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-334"><span class="toc-number">1.15.2.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR12-3-%E9%81%BF%E5%85%8D%E6%9C%89%E7%AC%A6%E5%8F%B7%E6%95%B4%E5%9E%8B%E4%B8%8E%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B4%E5%9E%8B%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.15.3.</span> <span class="toc-text">▌R12.3 避免有符号整型与无符号整型相互转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-185"><span class="toc-number">1.15.3.1.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-335"><span class="toc-number">1.15.3.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR12-4-%E9%81%BF%E5%85%8D%E4%B8%8E-void-%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.15.4.</span> <span class="toc-text">▌R12.4 避免与 void* 相互转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-211"><span class="toc-number">1.15.4.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-186"><span class="toc-number">1.15.4.2.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-336"><span class="toc-number">1.15.4.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR12-5-%E9%81%BF%E5%85%8D%E5%90%91%E4%B8%8B%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.15.5.</span> <span class="toc-text">▌R12.5 避免向下类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-212"><span class="toc-number">1.15.5.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-337"><span class="toc-number">1.15.5.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR12-6-%E6%8C%87%E9%92%88%E4%B8%8E%E6%95%B4%E6%95%B0%E4%B8%8D%E5%BA%94%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.15.6.</span> <span class="toc-text">▌R12.6 指针与整数不应相互转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE-40"><span class="toc-number">1.15.6.1.</span> <span class="toc-text">配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-213"><span class="toc-number">1.15.6.2.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-187"><span class="toc-number">1.15.6.3.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-338"><span class="toc-number">1.15.6.4.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR12-7-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E4%B8%8D%E5%BA%94%E5%8E%BB%E6%8E%89-const%E3%80%81volatile-%E7%AD%89%E5%B1%9E%E6%80%A7"><span class="toc-number">1.15.7.</span> <span class="toc-text">▌R12.7 类型转换不应去掉 const、volatile 等属性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-188"><span class="toc-number">1.15.7.1.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-339"><span class="toc-number">1.15.7.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR12-8-%E4%B8%8D%E5%BA%94%E8%BD%AC%E6%8D%A2%E6%97%A0%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E7%9A%84%E6%8C%87%E9%92%88%E6%88%96%E5%BC%95%E7%94%A8"><span class="toc-number">1.15.8.</span> <span class="toc-text">▌R12.8 不应转换无继承关系的指针或引用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE-41"><span class="toc-number">1.15.8.1.</span> <span class="toc-text">配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-214"><span class="toc-number">1.15.8.2.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-189"><span class="toc-number">1.15.8.3.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-340"><span class="toc-number">1.15.8.4.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR12-9-%E4%B8%8D%E5%BA%94%E8%BD%AC%E6%8D%A2%E6%97%A0-public-%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E7%9A%84%E6%8C%87%E9%92%88%E6%88%96%E5%BC%95%E7%94%A8"><span class="toc-number">1.15.9.</span> <span class="toc-text">▌R12.9 不应转换无 public 继承关系的指针或引用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-215"><span class="toc-number">1.15.9.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-190"><span class="toc-number">1.15.9.2.</span> <span class="toc-text">依据</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR12-10-%E9%9D%9E-POD-%E7%B1%BB%E7%9A%84%E6%8C%87%E9%92%88%E4%B8%8E%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%8C%87%E9%92%88%E4%B8%8D%E5%BA%94%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.15.10.</span> <span class="toc-text">▌R12.10 非 POD 类的指针与基本类型的指针不应相互转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-216"><span class="toc-number">1.15.10.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-341"><span class="toc-number">1.15.10.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR12-11-%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E4%B9%8B%E9%97%B4%E4%B8%8D%E5%8F%AF%E7%9B%B4%E6%8E%A5%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.15.11.</span> <span class="toc-text">▌R12.11 不同的字符串类型之间不可直接转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-217"><span class="toc-number">1.15.11.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-342"><span class="toc-number">1.15.11.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR12-12-%E9%81%BF%E5%85%8D%E5%90%91%E5%AF%B9%E9%BD%90%E8%A6%81%E6%B1%82%E6%9B%B4%E4%B8%A5%E6%A0%BC%E7%9A%84%E6%8C%87%E9%92%88%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.15.12.</span> <span class="toc-text">▌R12.12 避免向对齐要求更严格的指针转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-218"><span class="toc-number">1.15.12.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-191"><span class="toc-number">1.15.12.2.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-343"><span class="toc-number">1.15.12.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR12-13-%E9%81%BF%E5%85%8D%E8%BD%AC%E6%8D%A2%E6%8C%87%E5%90%91%E6%95%B0%E7%BB%84%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-number">1.15.13.</span> <span class="toc-text">▌R12.13 避免转换指向数组的指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-192"><span class="toc-number">1.15.13.1.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-344"><span class="toc-number">1.15.13.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR12-14-%E9%81%BF%E5%85%8D%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-number">1.15.14.</span> <span class="toc-text">▌R12.14 避免转换函数指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-193"><span class="toc-number">1.15.14.1.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-345"><span class="toc-number">1.15.14.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR12-15-%E5%90%91%E4%B8%8B%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%BA%94%E4%BD%BF%E7%94%A8-dynamic-cast"><span class="toc-number">1.15.15.</span> <span class="toc-text">▌R12.15 向下动态类型转换应使用 dynamic_cast</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-219"><span class="toc-number">1.15.15.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-194"><span class="toc-number">1.15.15.2.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-346"><span class="toc-number">1.15.15.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR12-16-%E5%AF%B9-new-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8D%E5%BA%94%E8%BF%9B%E8%A1%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.15.16.</span> <span class="toc-text">▌R12.16 对 new 表达式不应进行类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-220"><span class="toc-number">1.15.16.1.</span> <span class="toc-text">相关</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR12-17-%E4%B8%8D%E5%BA%94%E5%AD%98%E5%9C%A8%E5%A4%9A%E4%BD%99%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.15.17.</span> <span class="toc-text">▌R12.17 不应存在多余的类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-347"><span class="toc-number">1.15.17.1.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR12-18-%E5%8F%AF%E7%94%A8%E5%85%B6%E4%BB%96%E6%96%B9%E5%BC%8F%E5%AE%8C%E6%88%90%E7%9A%84%E8%BD%AC%E6%8D%A2%E4%B8%8D%E5%BA%94%E4%BD%BF%E7%94%A8-reinterpret-cast"><span class="toc-number">1.15.18.</span> <span class="toc-text">▌R12.18 可用其他方式完成的转换不应使用 reinterpret_cast</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-221"><span class="toc-number">1.15.18.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-195"><span class="toc-number">1.15.18.2.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-348"><span class="toc-number">1.15.18.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR12-19-%E5%90%88%E7%90%86%E4%BD%BF%E7%94%A8-reinterpret-cast"><span class="toc-number">1.15.19.</span> <span class="toc-text">▌R12.19 合理使用 reinterpret_cast</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-222"><span class="toc-number">1.15.19.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-349"><span class="toc-number">1.15.19.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR12-20-%E5%9C%A8-C-%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%A6%81%E7%94%A8-C-%E9%A3%8E%E6%A0%BC%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.15.20.</span> <span class="toc-text">▌R12.20 在 C++ 代码中禁用 C 风格类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-350"><span class="toc-number">1.15.20.1.</span> <span class="toc-text">参考</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-Buffer"><span class="toc-number">1.16.</span> <span class="toc-text">13. Buffer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR13-1-%E9%81%BF%E5%85%8D%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA"><span class="toc-number">1.16.1.</span> <span class="toc-text">▌R13.1 避免缓冲区溢出</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-223"><span class="toc-number">1.16.1.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-351"><span class="toc-number">1.16.1.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR13-2-%E6%95%B0%E7%BB%84%E4%B8%8B%E6%A0%87%E4%B8%8D%E5%8F%AF%E8%B6%8A%E7%95%8C"><span class="toc-number">1.16.2.</span> <span class="toc-text">▌R13.2 数组下标不可越界</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-224"><span class="toc-number">1.16.2.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-196"><span class="toc-number">1.16.2.2.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-352"><span class="toc-number">1.16.2.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR13-3-%E4%B8%BA%E7%BC%93%E5%86%B2%E5%8C%BA%E5%88%86%E9%85%8D%E8%B6%B3%E5%A4%9F%E7%9A%84%E7%A9%BA%E9%97%B4"><span class="toc-number">1.16.3.</span> <span class="toc-text">▌R13.3 为缓冲区分配足够的空间</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-225"><span class="toc-number">1.16.3.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-353"><span class="toc-number">1.16.3.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR13-4-memset-%E7%AD%89%E5%87%BD%E6%95%B0%E4%B8%8D%E5%BA%94%E4%BD%9C%E7%94%A8%E4%BA%8E%E9%9D%9E-POD-%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.16.4.</span> <span class="toc-text">▌R13.4 memset 等函数不应作用于非 POD 对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-226"><span class="toc-number">1.16.4.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-354"><span class="toc-number">1.16.4.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR13-5-memset-%E7%AD%89%E5%87%BD%E6%95%B0%E9%95%BF%E5%BA%A6%E7%9B%B8%E5%85%B3%E7%9A%84%E5%8F%82%E6%95%B0%E4%B8%8D%E5%BA%94%E6%9C%89%E8%AF%AF"><span class="toc-number">1.16.5.</span> <span class="toc-text">▌R13.5 memset 等函数长度相关的参数不应有误</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-355"><span class="toc-number">1.16.5.1.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR13-6-memset-%E7%AD%89%E5%87%BD%E6%95%B0%E5%A1%AB%E5%85%85%E5%80%BC%E7%9B%B8%E5%85%B3%E7%9A%84%E5%8F%82%E6%95%B0%E4%B8%8D%E5%BA%94%E6%9C%89%E8%AF%AF"><span class="toc-number">1.16.6.</span> <span class="toc-text">▌R13.6 memset 等函数填充值相关的参数不应有误</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-197"><span class="toc-number">1.16.6.1.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-356"><span class="toc-number">1.16.6.2.</span> <span class="toc-text">参考</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-Pointer"><span class="toc-number">1.17.</span> <span class="toc-text">14. Pointer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR14-1-%E9%81%BF%E5%85%8D%E7%A9%BA%E6%8C%87%E9%92%88%E8%A7%A3%E5%BC%95%E7%94%A8"><span class="toc-number">1.17.1.</span> <span class="toc-text">▌R14.1 避免空指针解引用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-198"><span class="toc-number">1.17.1.1.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-357"><span class="toc-number">1.17.1.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR14-2-%E6%B3%A8%E6%84%8F%E9%80%BB%E8%BE%91%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%86%85%E7%9A%84%E7%A9%BA%E6%8C%87%E9%92%88%E8%A7%A3%E5%BC%95%E7%94%A8"><span class="toc-number">1.17.2.</span> <span class="toc-text">▌R14.2 注意逻辑表达式内的空指针解引用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-199"><span class="toc-number">1.17.2.1.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-358"><span class="toc-number">1.17.2.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR14-3-%E4%B8%8D%E5%8F%AF%E8%A7%A3%E5%BC%95%E7%94%A8%E6%9C%AA%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-number">1.17.3.</span> <span class="toc-text">▌R14.3 不可解引用未初始化的指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-227"><span class="toc-number">1.17.3.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-200"><span class="toc-number">1.17.3.2.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-359"><span class="toc-number">1.17.3.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR14-4-%E4%B8%8D%E5%8F%AF%E8%A7%A3%E5%BC%95%E7%94%A8%E5%B7%B2%E8%A2%AB%E9%87%8A%E6%94%BE%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-number">1.17.4.</span> <span class="toc-text">▌R14.4 不可解引用已被释放的指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-228"><span class="toc-number">1.17.4.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-201"><span class="toc-number">1.17.4.2.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-360"><span class="toc-number">1.17.4.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR14-5-%E9%81%BF%E5%85%8D%E6%97%A0%E6%95%88%E7%9A%84%E7%A9%BA%E6%8C%87%E9%92%88%E6%A3%80%E6%9F%A5"><span class="toc-number">1.17.5.</span> <span class="toc-text">▌R14.5 避免无效的空指针检查</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-229"><span class="toc-number">1.17.5.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-202"><span class="toc-number">1.17.5.2.</span> <span class="toc-text">依据</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR14-6-%E4%B8%8D%E5%BA%94%E9%87%8D%E5%A4%8D%E6%A3%80%E6%9F%A5%E6%8C%87%E9%92%88%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA"><span class="toc-number">1.17.6.</span> <span class="toc-text">▌R14.6 不应重复检查指针是否为空</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-230"><span class="toc-number">1.17.6.1.</span> <span class="toc-text">相关</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR14-7-%E4%B8%8D%E5%BA%94%E5%B0%86%E9%9D%9E%E9%9B%B6%E5%B8%B8%E9%87%8F%E5%80%BC%E8%B5%8B%E5%80%BC%E7%BB%99%E6%8C%87%E9%92%88"><span class="toc-number">1.17.7.</span> <span class="toc-text">▌R14.7 不应将非零常量值赋值给指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE-42"><span class="toc-number">1.17.7.1.</span> <span class="toc-text">配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-231"><span class="toc-number">1.17.7.2.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-361"><span class="toc-number">1.17.7.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR14-8-%E4%B8%8D%E5%BA%94%E4%BD%BF%E7%94%A8%E5%B8%B8%E9%87%8F-0-%E8%A1%A8%E7%A4%BA%E7%A9%BA%E6%8C%87%E9%92%88"><span class="toc-number">1.17.8.</span> <span class="toc-text">▌R14.8 不应使用常量 0 表示空指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-232"><span class="toc-number">1.17.8.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-203"><span class="toc-number">1.17.8.2.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-362"><span class="toc-number">1.17.8.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR14-9-%E4%B8%8D%E5%BA%94%E4%BD%BF%E7%94%A8-false-%E5%AF%B9%E6%8C%87%E9%92%88%E8%B5%8B%E5%80%BC"><span class="toc-number">1.17.9.</span> <span class="toc-text">▌R14.9 不应使用 false 对指针赋值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-233"><span class="toc-number">1.17.9.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-363"><span class="toc-number">1.17.9.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR14-10-%E4%B8%8D%E5%BA%94%E4%BD%BF%E7%94%A8-%E2%80%98-0%E2%80%99-%E7%AD%89%E5%AD%97%E7%AC%A6%E5%B8%B8%E9%87%8F%E5%AF%B9%E6%8C%87%E9%92%88%E8%B5%8B%E5%80%BC"><span class="toc-number">1.17.10.</span> <span class="toc-text">▌R14.10 不应使用 ‘\0’ 等字符常量对指针赋值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-234"><span class="toc-number">1.17.10.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-364"><span class="toc-number">1.17.10.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR14-11-%E6%8C%87%E9%92%88%E4%B8%8D%E5%BA%94%E4%B8%8E-false-%E6%AF%94%E8%BE%83%E5%A4%A7%E5%B0%8F"><span class="toc-number">1.17.11.</span> <span class="toc-text">▌R14.11 指针不应与 false 比较大小</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-235"><span class="toc-number">1.17.11.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-365"><span class="toc-number">1.17.11.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR14-12-%E6%8C%87%E9%92%88%E4%B8%8D%E5%BA%94%E4%B8%8E-%E2%80%98-0%E2%80%99-%E7%AD%89%E5%AD%97%E7%AC%A6%E5%B8%B8%E9%87%8F%E6%AF%94%E8%BE%83%E5%A4%A7%E5%B0%8F"><span class="toc-number">1.17.12.</span> <span class="toc-text">▌R14.12 指针不应与 ‘\0’ 等字符常量比较大小</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-236"><span class="toc-number">1.17.12.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-366"><span class="toc-number">1.17.12.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR14-13-%E6%8C%87%E9%92%88%E4%B8%8E%E7%A9%BA%E6%8C%87%E9%92%88%E4%B8%8D%E5%BA%94%E6%AF%94%E8%BE%83%E5%A4%A7%E5%B0%8F"><span class="toc-number">1.17.13.</span> <span class="toc-text">▌R14.13 指针与空指针不应比较大小</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-237"><span class="toc-number">1.17.13.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-204"><span class="toc-number">1.17.13.2.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-367"><span class="toc-number">1.17.13.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR14-14-%E4%B8%8D%E5%BA%94%E5%88%A4%E6%96%AD-this-%E6%8C%87%E9%92%88%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA"><span class="toc-number">1.17.14.</span> <span class="toc-text">▌R14.14 不应判断 this 指针是否为空</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-368"><span class="toc-number">1.17.14.1.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR14-15-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B8%AD%E4%B8%8D%E5%8F%AF%E4%BD%BF%E7%94%A8-delete-this"><span class="toc-number">1.17.15.</span> <span class="toc-text">▌R14.15 析构函数中不可使用 delete this</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-369"><span class="toc-number">1.17.15.1.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR14-16-%E7%A6%81%E7%94%A8-delete-this"><span class="toc-number">1.17.16.</span> <span class="toc-text">▌R14.16 禁用 delete this</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR14-17-%E5%88%A4%E6%96%AD-dynamic-cast-%E8%BD%AC%E6%8D%A2%E6%98%AF%E5%90%A6%E6%88%90%E5%8A%9F"><span class="toc-number">1.17.17.</span> <span class="toc-text">▌R14.17 判断 dynamic_cast 转换是否成功</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-238"><span class="toc-number">1.17.17.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-205"><span class="toc-number">1.17.17.2.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-370"><span class="toc-number">1.17.17.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR14-18-%E6%8C%87%E9%92%88%E5%9C%A8%E9%87%8A%E6%94%BE%E5%90%8E%E5%BA%94%E7%BD%AE%E7%A9%BA"><span class="toc-number">1.17.18.</span> <span class="toc-text">▌R14.18 指针在释放后应置空</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-239"><span class="toc-number">1.17.18.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-371"><span class="toc-number">1.17.18.2.</span> <span class="toc-text">参考</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-Interruption"><span class="toc-number">1.18.</span> <span class="toc-text">15. Interruption</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR15-1-%E9%81%BF%E5%85%8D%E7%94%B1%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%BA%A7%E7%94%9F%E7%9A%84%E6%95%B0%E6%8D%AE%E7%AB%9E%E4%BA%89"><span class="toc-number">1.18.1.</span> <span class="toc-text">▌R15.1 避免由信号处理产生的数据竞争</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-240"><span class="toc-number">1.18.1.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-206"><span class="toc-number">1.18.1.2.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-372"><span class="toc-number">1.18.1.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR15-2-%E5%A4%84%E7%90%86%E4%BF%A1%E5%8F%B7%E6%97%B6%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8%E9%9D%9E%E5%BC%82%E6%AD%A5%E4%BF%A1%E5%8F%B7%E5%AE%89%E5%85%A8%E5%87%BD%E6%95%B0"><span class="toc-number">1.18.2.</span> <span class="toc-text">▌R15.2 处理信号时避免使用非异步信号安全函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-241"><span class="toc-number">1.18.2.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-207"><span class="toc-number">1.18.2.2.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-373"><span class="toc-number">1.18.2.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR15-3-SIGFPE%E3%80%81SIGILL%E3%80%81SIGSEGV-%E7%AD%89%E4%BF%A1%E5%8F%B7%E7%9A%84%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0%E4%B8%8D%E5%8F%AF%E8%BF%94%E5%9B%9E"><span class="toc-number">1.18.3.</span> <span class="toc-text">▌R15.3 SIGFPE、SIGILL、SIGSEGV 等信号的处理函数不可返回</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-208"><span class="toc-number">1.18.3.1.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-374"><span class="toc-number">1.18.3.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR15-4-%E7%A6%81%E7%94%A8-signal-%E5%87%BD%E6%95%B0"><span class="toc-number">1.18.4.</span> <span class="toc-text">▌R15.4 禁用 signal 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-242"><span class="toc-number">1.18.4.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-209"><span class="toc-number">1.18.4.2.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-375"><span class="toc-number">1.18.4.3.</span> <span class="toc-text">参考</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-Concurrency"><span class="toc-number">1.19.</span> <span class="toc-text">16. Concurrency</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR16-1-%E8%AE%BF%E9%97%AE%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE%E5%BA%94%E9%81%B5%E5%BE%AA%E5%90%88%E7%90%86%E7%9A%84%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6"><span class="toc-number">1.19.1.</span> <span class="toc-text">▌R16.1 访问共享数据应遵循合理的同步机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-243"><span class="toc-number">1.19.1.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-210"><span class="toc-number">1.19.1.2.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-376"><span class="toc-number">1.19.1.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR16-2-%E9%81%BF%E5%85%8D%E5%9C%A8%E4%BA%8B%E5%8A%A1%E4%B8%AD%E9%80%9A%E8%BF%87%E8%B7%AF%E5%BE%84%E5%A4%9A%E6%AC%A1%E8%AE%BF%E9%97%AE%E5%90%8C%E4%B8%80%E6%96%87%E4%BB%B6"><span class="toc-number">1.19.2.</span> <span class="toc-text">▌R16.2 避免在事务中通过路径多次访问同一文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-211"><span class="toc-number">1.19.2.1.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-377"><span class="toc-number">1.19.2.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR16-3-%E9%81%BF%E5%85%8D%E5%9C%A8%E4%BA%8B%E5%8A%A1%E4%B8%AD%E5%A4%9A%E6%AC%A1%E9%9D%9E%E5%90%8C%E6%AD%A5%E5%9C%B0%E8%AE%BF%E9%97%AE%E5%8E%9F%E5%AD%90%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.19.3.</span> <span class="toc-text">▌R16.3 避免在事务中多次非同步地访问原子对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-244"><span class="toc-number">1.19.3.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-378"><span class="toc-number">1.19.3.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR16-4-%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81"><span class="toc-number">1.19.4.</span> <span class="toc-text">▌R16.4 避免死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-212"><span class="toc-number">1.19.4.1.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-379"><span class="toc-number">1.19.4.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR16-5-%E9%81%BF%E5%85%8D%E5%BC%82%E6%AD%A5%E7%BB%88%E6%AD%A2%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.19.5.</span> <span class="toc-text">▌R16.5 避免异步终止线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-245"><span class="toc-number">1.19.5.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-380"><span class="toc-number">1.19.5.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR16-6-%E9%81%BF%E5%85%8D%E5%BC%82%E6%AD%A5%E7%BB%88%E6%AD%A2%E5%85%B1%E4%BA%AB%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.19.6.</span> <span class="toc-text">▌R16.6 避免异步终止共享对象的生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-246"><span class="toc-number">1.19.6.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-213"><span class="toc-number">1.19.6.2.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-381"><span class="toc-number">1.19.6.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR16-7-%E9%81%BF%E5%85%8D%E8%99%9A%E5%81%87%E5%94%A4%E9%86%92%E9%80%A0%E6%88%90%E5%90%8C%E6%AD%A5%E9%94%99%E8%AF%AF"><span class="toc-number">1.19.7.</span> <span class="toc-text">▌R16.7 避免虚假唤醒造成同步错误</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-382"><span class="toc-number">1.19.7.1.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR16-8-%E9%81%BF%E5%85%8D%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE%E4%BD%8D%E5%9F%9F%E9%80%A0%E6%88%90%E7%9A%84%E6%95%B0%E6%8D%AE%E7%AB%9E%E4%BA%89"><span class="toc-number">1.19.8.</span> <span class="toc-text">▌R16.8 避免并发访问位域造成的数据竞争</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-247"><span class="toc-number">1.19.8.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-214"><span class="toc-number">1.19.8.2.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-383"><span class="toc-number">1.19.8.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR16-9-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%8E%AF%E5%A2%83%E4%B8%AD%E4%B8%8D%E5%8F%AF%E4%BD%BF%E7%94%A8-signal-%E5%87%BD%E6%95%B0"><span class="toc-number">1.19.9.</span> <span class="toc-text">▌R16.9 多线程环境中不可使用 signal 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-248"><span class="toc-number">1.19.9.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-215"><span class="toc-number">1.19.9.2.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-384"><span class="toc-number">1.19.9.3.</span> <span class="toc-text">参考</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-Style"><span class="toc-number">1.20.</span> <span class="toc-text">17. Style</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR17-1-%E7%A9%BA%E6%A0%BC%E5%BA%94%E9%81%B5%E5%BE%AA%E7%BB%9F%E4%B8%80%E9%A3%8E%E6%A0%BC"><span class="toc-number">1.20.1.</span> <span class="toc-text">▌R17.1 空格应遵循统一风格</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-249"><span class="toc-number">1.20.1.1.</span> <span class="toc-text">相关</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR17-2-%E5%A4%A7%E6%8B%AC%E5%8F%B7%E5%BA%94%E9%81%B5%E5%BE%AA%E7%BB%9F%E4%B8%80%E9%A3%8E%E6%A0%BC"><span class="toc-number">1.20.2.</span> <span class="toc-text">▌R17.2 大括号应遵循统一风格</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-250"><span class="toc-number">1.20.2.1.</span> <span class="toc-text">相关</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR17-3-%E8%B5%8B%E5%80%BC%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8D%E5%BA%94%E4%BD%9C%E4%B8%BA%E5%AD%90%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.20.3.</span> <span class="toc-text">▌R17.3 赋值表达式不应作为子表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE-43"><span class="toc-number">1.20.3.1.</span> <span class="toc-text">配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-251"><span class="toc-number">1.20.3.2.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-385"><span class="toc-number">1.20.3.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR17-4-%E8%87%AA%E5%A2%9E%E3%80%81%E8%87%AA%E5%87%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8D%E5%BA%94%E4%BD%9C%E4%B8%BA%E5%AD%90%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.20.4.</span> <span class="toc-text">▌R17.4 自增、自减表达式不应作为子表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-252"><span class="toc-number">1.20.4.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-386"><span class="toc-number">1.20.4.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR17-5-%E6%8E%A7%E5%88%B6%E6%9D%A1%E4%BB%B6%E5%BA%94%E4%B8%BA-bool-%E5%9E%8B%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.20.5.</span> <span class="toc-text">▌R17.5 控制条件应为 bool 型表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-253"><span class="toc-number">1.20.5.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-387"><span class="toc-number">1.20.5.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR17-6-%E3%80%81-amp-amp-%E3%80%81-%E7%9A%84%E5%AD%90%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BA%94%E4%B8%BA-bool-%E5%9E%8B%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.20.6.</span> <span class="toc-text">▌R17.6 !、&amp;&amp;、|| 的子表达式应为 bool 型表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-254"><span class="toc-number">1.20.6.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-388"><span class="toc-number">1.20.6.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR17-7-amp-amp-%E3%80%81-%E7%9A%84%E5%AD%90%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BA%94%E4%B8%BA%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.20.7.</span> <span class="toc-text">▌R17.7 &amp;&amp;、|| 的子表达式应为后缀表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-216"><span class="toc-number">1.20.7.1.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-389"><span class="toc-number">1.20.7.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR17-8-%E5%9C%A8-C-%E4%BB%A3%E7%A0%81%E4%B8%AD-NULL-%E5%92%8C-nullptr-%E4%B8%8D%E5%BA%94%E6%B7%B7%E7%94%A8"><span class="toc-number">1.20.8.</span> <span class="toc-text">▌R17.8 在 C++ 代码中 NULL 和 nullptr 不应混用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-255"><span class="toc-number">1.20.8.1.</span> <span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-390"><span class="toc-number">1.20.8.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR17-9-%E5%9C%A8-C-%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%94%A8-nullptr-%E4%BB%A3%E6%9B%BF-NULL"><span class="toc-number">1.20.9.</span> <span class="toc-text">▌R17.9 在 C++ 代码中用 nullptr 代替 NULL</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE-217"><span class="toc-number">1.20.9.1.</span> <span class="toc-text">依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-391"><span class="toc-number">1.20.9.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR17-10-%E9%81%BF%E5%85%8D%E5%A4%9A%E4%BD%99%E7%9A%84%E6%8B%AC%E5%8F%B7"><span class="toc-number">1.20.10.</span> <span class="toc-text">▌R17.10 避免多余的括号</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-392"><span class="toc-number">1.20.10.1.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%8CR17-11-%E9%81%BF%E5%85%8D%E5%A4%9A%E4%BD%99%E7%9A%84%E5%88%86%E5%8F%B7"><span class="toc-number">1.20.11.</span> <span class="toc-text">▌R17.11 避免多余的分号</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%84%E5%BD%95"><span class="toc-number">1.21.</span> <span class="toc-text">附录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E8%AF%AD"><span class="toc-number">1.22.</span> <span class="toc-text">结语</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/10/25/360CPP%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/" title="360CPP代码规范"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://hoshea-1318436778.cos.ap-nanjing.myqcloud.com/image360.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="360CPP代码规范"/></a><div class="content"><a class="title" href="/2023/10/25/360CPP%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/" title="360CPP代码规范">360CPP代码规范</a><time datetime="2023-10-25T13:19:49.000Z" title="Created 2023-10-25 21:19:49">2023-10-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/10/25/workflow%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9A%E7%BA%BF%E7%A8%8B%E6%B1%A0/" title="workflow源码分析：线程池"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://hoshea-1318436778.cos.ap-nanjing.myqcloud.com/imagebg_sougou.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="workflow源码分析：线程池"/></a><div class="content"><a class="title" href="/2023/10/25/workflow%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9A%E7%BA%BF%E7%A8%8B%E6%B1%A0/" title="workflow源码分析：线程池">workflow源码分析：线程池</a><time datetime="2023-10-25T07:10:55.000Z" title="Created 2023-10-25 15:10:55">2023-10-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/10/25/%E6%B1%82%E4%B8%80%E4%B8%AA%E6%95%B4%E6%95%B0%E7%9A%84%E6%83%A9%E7%BD%9A%E6%95%B0/" title="求一个整数的惩罚数"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://hoshea-1318436778.cos.ap-nanjing.myqcloud.com/imagebg_leetcode.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="求一个整数的惩罚数"/></a><div class="content"><a class="title" href="/2023/10/25/%E6%B1%82%E4%B8%80%E4%B8%AA%E6%95%B4%E6%95%B0%E7%9A%84%E6%83%A9%E7%BD%9A%E6%95%B0/" title="求一个整数的惩罚数">求一个整数的惩罚数</a><time datetime="2023-10-24T23:59:48.000Z" title="Created 2023-10-25 07:59:48">2023-10-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/10/24/CSAPP%E7%AC%AC%E5%85%AB%E7%AB%A0%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/" title="CSAPP第八章异常控制流"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://hoshea-1318436778.cos.ap-nanjing.myqcloud.com/imagebg_CSAPP.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CSAPP第八章异常控制流"/></a><div class="content"><a class="title" href="/2023/10/24/CSAPP%E7%AC%AC%E5%85%AB%E7%AB%A0%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/" title="CSAPP第八章异常控制流">CSAPP第八章异常控制流</a><time datetime="2023-10-24T12:50:25.000Z" title="Created 2023-10-24 20:50:25">2023-10-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/10/24/CPP-Primer%E7%AC%AC%E4%B8%89-%E4%B8%83%E7%AB%A0/" title="CPP_Primer第三-七章"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://hoshea-1318436778.cos.ap-nanjing.myqcloud.com/imagebg_c%2B%2Bprimer.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CPP_Primer第三-七章"/></a><div class="content"><a class="title" href="/2023/10/24/CPP-Primer%E7%AC%AC%E4%B8%89-%E4%B8%83%E7%AB%A0/" title="CPP_Primer第三-七章">CPP_Primer第三-七章</a><time datetime="2023-10-24T07:15:51.000Z" title="Created 2023-10-24 15:15:51">2023-10-24</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2021 - 2023 By <a class="footer-bar-link" href="/" title="Hoshea Zhang" target="_blank">Hoshea Zhang</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">Articles</div><div class="length-num">54</div></a><a href="/tags/" title="tag"><div class="headline">Tags</div><div class="length-num">30</div></a><a href="/categories/" title="category"><div class="headline">Categories</div><div class="length-num">8</div></a></div><span class="sidebar-menu-item-title">Function</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="Display Mode"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>Display Mode</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://hosheazhang.github.io/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://github.com/HosheaZhang/cmu15445" title="cmu15445"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="cmu15445"/><span class="back-menu-item-text">cmu15445</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/360/" style="font-size: 0.88rem;">360<sup>1</sup></a><a href="/tags/C/" style="font-size: 0.88rem;">C++<sup>5</sup></a><a href="/tags/CMU15445/" style="font-size: 0.88rem;">CMU15445<sup>2</sup></a><a href="/tags/CMake/" style="font-size: 0.88rem;">CMake<sup>1</sup></a><a href="/tags/CSAPP/" style="font-size: 0.88rem;">CSAPP<sup>9</sup></a><a href="/tags/MYSQL/" style="font-size: 0.88rem;">MYSQL<sup>6</sup></a><a href="/tags/VSCODE/" style="font-size: 0.88rem;">VSCODE<sup>1</sup></a><a href="/tags/dfs/" style="font-size: 0.88rem;">dfs<sup>1</sup></a><a href="/tags/gdb/" style="font-size: 0.88rem;">gdb<sup>1</sup></a><a href="/tags/git/" style="font-size: 0.88rem;">git<sup>1</sup></a><a href="/tags/github/" style="font-size: 0.88rem;">github<sup>1</sup></a><a href="/tags/linux/" style="font-size: 0.88rem;">linux<sup>6</sup></a><a href="/tags/markdown/" style="font-size: 0.88rem;">markdown<sup>1</sup></a><a href="/tags/ssh/" style="font-size: 0.88rem;">ssh<sup>1</sup></a><a href="/tags/workflow/" style="font-size: 0.88rem;">workflow<sup>3</sup></a><a href="/tags/%E4%B8%AD%E7%AD%89/" style="font-size: 0.88rem;">中等<sup>9</sup></a><a href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" style="font-size: 0.88rem;">动态规划<sup>2</sup></a><a href="/tags/%E5%91%A8%E8%B5%9B/" style="font-size: 0.88rem;">周赛<sup>9</sup></a><a href="/tags/%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/" style="font-size: 0.88rem;">学习计划<sup>1</sup></a><a href="/tags/%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3/" style="font-size: 0.88rem;">报错解决<sup>4</sup></a><a href="/tags/%E6%A0%A1%E6%8B%9B/" style="font-size: 0.88rem;">校招<sup>1</sup></a><a href="/tags/%E6%A8%A1%E6%8B%9F/" style="font-size: 0.88rem;">模拟<sup>6</sup></a><a href="/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/" style="font-size: 0.88rem;">每日一题<sup>3</sup></a><a href="/tags/%E6%B1%87%E7%BC%96/" style="font-size: 0.88rem;">汇编<sup>1</sup></a><a href="/tags/%E6%BA%90%E7%A0%81/" style="font-size: 0.88rem;">源码<sup>2</sup></a><a href="/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/" style="font-size: 0.88rem;">滑动窗口<sup>1</sup></a><a href="/tags/%E7%AE%80%E5%8D%95/" style="font-size: 0.88rem;">简单<sup>3</sup></a><a href="/tags/%E7%BC%96%E8%AF%91/" style="font-size: 0.88rem;">编译<sup>1</sup></a><a href="/tags/%E8%84%91%E7%AD%8B%E6%80%A5%E8%BD%AC%E5%BC%AF/" style="font-size: 0.88rem;">脑筋急转弯<sup>1</sup></a><a href="/tags/%E8%B4%AA%E5%BF%83/" style="font-size: 0.88rem;">贪心<sup>2</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="Switch Between Traditional Chinese And Simplified Chinese">繁</button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Setting"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="7372688489" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;undefined&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div id="he-plugin-simple"></div><script>var WIDGET = {
  "CONFIG": {
    "modules": "0124",
    "background": "2",
    "tmpColor": "FFFFFF",
    "tmpSize": "16",
    "cityColor": "FFFFFF",
    "citySize": "16",
    "aqiColor": "E8D87B",
    "aqiSize": "16",
    "weatherIconSize": "24",
    "alertIconSize": "18",
    "padding": "10px 10px 10px 10px",
    "shadow": "0",
    "language": "auto",
    "borderRadius": "20",
    "fixed": "true",
    "vertical": "top",
    "horizontal": "left",
    "left": "20",
    "top": "7.1",
    "key": "df245676fb434a0691ead1c63341cd94"
  }
}
</script><link rel="stylesheet" href="https://widget.qweather.net/simple/static/css/he-simple.css?v=1.4.0"/><script src="https://widget.qweather.net/simple/static/js/he-simple.js?v=1.4.0"></script><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.4/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2021 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2021 By 安知鱼 V1.6.8",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 Hoshea Zhang 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.1/bubble/bubble.js"></script><script>var visitorMail = "visitor@anheyu.com";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script src="/js/anzhiyu/right_click_menu.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>