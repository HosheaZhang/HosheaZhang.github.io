<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>360代码规范五：type | Hoshea的主页</title><meta name="keywords" content="C++,360"><meta name="author" content="Hoshea Zhang,542978210@qq.com"><meta name="copyright" content="Hoshea Zhang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="360代码规范五：type"><meta name="application-name" content="360代码规范五：type"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="360代码规范五：type"><meta property="og:url" content="http://example.com/2023/10/30/360%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E4%BA%94%EF%BC%9Atype/index.html"><meta property="og:site_name" content="Hoshea的主页"><meta property="og:description" content="class类的非常量数据成员均应该是private类的数据成员均应设为 private，对外统一由成员函数提供访问方法，且应避免返回 private 成员的非常量引用或指针。   将类的所有接口都实现为成员函数，由成员函数按指定逻辑读写数据，以便保证有效地改变对象状态。良好的接口设计会对代码的职责进"><meta property="og:locale" content="en"><meta property="og:image" content="https://hoshea-1318436778.cos.ap-nanjing.myqcloud.com/image360.jpg"><meta property="article:author" content="Hoshea Zhang"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://hoshea-1318436778.cos.ap-nanjing.myqcloud.com/image360.jpg"><meta name="description" content="class类的非常量数据成员均应该是private类的数据成员均应设为 private，对外统一由成员函数提供访问方法，且应避免返回 private 成员的非常量引用或指针。   将类的所有接口都实现为成员函数，由成员函数按指定逻辑读写数据，以便保证有效地改变对象状态。良好的接口设计会对代码的职责进"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="http://example.com/2023/10/30/360%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E4%BA%94%EF%BC%9Atype/"><link rel="preconnect" href="//cdn.cbd.int"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/swiper/swiper.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2023/09/03/125766904/ee23df8517f3c3e3efc4145658269c06_5714860933110284659.png"},
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: {"enable":true,"default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 宝贝","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: 'hoshea-env-2gxt402g10c22211',
  commentBarrageConfig:undefined,
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: {"skills":null},
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: 'days',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"Author: Hoshea Zhang","link":"Link: ","source":"Source: Hoshea的主页","info":"Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source.","copySuccess":"Copy success, copy and reprint please mark the address of this article"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"Traditional Chinese Activated Manually","cht_to_chs":"Simplified Chinese Activated Manually","day_to_night":"Dark Mode Activated Manually","night_to_day":"Light Mode Activated Manually","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'Hoshea的主页',
  title: '360代码规范五：type',
  postAI: '',
  pageFillDescription: 'class, 类的非常量数据成员均应该是private, 类的非常量数据成员不应定义为 protected, 类不应既有public数据成员又有private数据成员, 有虚函数的基类应具有虚析构函数, 避免多重继承自同一非虚基类, 存在析构函数或拷贝赋值运算符时不应缺少拷贝构造函数, 避免重复实现由默认拷贝、移动、析构函数完成的功能, 可接受一个参数的构造函数需用 explicit 关键字限定, 重载的类型转换运算符需用explicit关键字限定, 不要过度使用explicit, 带模板的赋值运算符不应与拷贝或移动赋值运算符混淆, 带模板的构造函数不应与拷贝或移动构造函数混淆, 抽象类禁用拷贝和移动赋值运算符, 数据成员的数量应在规定范围之内, 数据成员之间的填充数据不应被忽视, 常量成员函数不应返回数据成员的非常量指针或引用, 类成员应按 public、protected、private 的顺序声明, 存在构造、析构或虚函数的类不应采用 struct 关键字, enum, 同类枚举项的值不应相同, 合理初始化各枚举项, 不应使用匿名枚举类型, 用enum class取代enum, Union, 联合体禁用非基本类型的对象, 禁用在类之外定义的联合体, 禁用联合体类的非常量数据成员均应该是类的数据成员均应设为对外统一由成员函数提供访问方法且应避免返回成员的非常量引用或指针将类的所有接口都实现为成员函数由成员函数按指定逻辑读写数据以便保证有效地改变对象状态良好的接口设计会对代码的职责进行合理划分显著提升可维护性理想状态下当有错误需要修正或有功能需要调整时只改动相关接口的实现即可调用接口的代码不需要改动从而将改动降到最低这种设计的基础便是将数据设为只能由本类的成员函数访问否则数据可被各个模块随意读写当有一处需要改动时很难控制其影响范围常量数据成员不可被改变所以可不受本规则约束示例例中类的数据成员指向动态分配的内存区域记录区域大小和之间存在紧密的逻辑关系这种内在关系应由成员函数统一维护不暴露给类的使用者这便是面向对象的封装理念也是语言的核心理念之一应改为这样数据成员不能被外界直接访问成员之间的关系也不会被随意打破显著提升可维护性类的非常量数据成员不应定义为数据成员在派生类中仍可被随意读写破坏了封装理念本规则是的特化关于封装的进一步讨论可参见常量数据成员不可被改变所以可不受本规则约束示例应改为由接口访问类不应既有数据成员又有数据成员类的设计应遵循成员之间没有依赖关系且都可以随意被读写时则都应声明为成员之间有依赖关系或成员的状态会影响到整个对象的状态时则都应声明为否则应对类进行改造或拆分面向对象的封装理念更倾向于将所有数据成员都设为由成员函数按指定逻辑控制每个成员的读写方法以供外部访问对代码的职责进行有效地划分从而提高可维护性并降低风险关于封装的进一步讨论可参见常量数据成员不可被改变所以可不受本规则约束示例应改为有虚函数的基类应具有虚析构函数为了避免意料之外的资源泄漏有虚函数的基类都应该具有虚析构函数通过基类指针析构派生类对象时如果基类没有虚析构函数会导致标准未定义的行为无法正确执行派生类的析构函数示例由于基类的析构函数不是虚函数只调用了基类析构函数派生类对象的资源没有得到释放例外如果有意阻止外界通过基类指针析构对象如析构函数是可不受本规则限制避免多重继承自同一非虚基类当派生类有多个基类这些基类又派生自同一非虚基类时派生类对象会持有该非虚基类的多个实例造成逻辑和存储上的冗余示例在类对象中基类的成员有两个不同的实例不能直接访问只能通过或这种怪异的方式访问将共同的基类设为虚基类可以解决这种问题注意直接将虚基类指针转为派生类指针会导致标准未定义的行为如这种转换一般不会通过编译但标准并未要求编译器必须阻止这种转换改用可解决这些问题存在析构函数或拷贝赋值运算符时不应缺少拷贝构造函数三个紧密相关的函数拷贝构造函数拷贝赋值运算符析构函数当这三个函数中的任何一个函数被定义时说明对象在资源管理等方面有特定的需求其他两个函数也需要被定义否则难以适应各种应用场景易产生意料之外的错误这种规则称为如果缺少某个函数编译器会生成相关默认函数但其特定需求不会被实现示例例中的类有析构函数但没有拷贝构造函数和拷贝赋值运算符只能进行变量值的复制使多个对象的资源指针指向同一块内存区域导致重复释放和内存泄漏所以应定义拷贝构造函数和拷贝赋值运算符重新分配内存并复制数据同理在遵循及之后标准的代码中拷贝构造函数拷贝赋值运算符析构函数移动构造函数移动赋值运算符当定义了这五个函数中的任何一个函数时其他四个函数也需要定义详见避免重复实现由默认拷贝移动析构函数完成的功能当类只负责成员对象的包装或组合而没有特殊的复制移动析构需求时不应定义下列函数拷贝构造函数拷贝赋值运算符析构函数移动构造函数移动赋值运算符应由编译器生成相关默认函数否则会产生多余的代码增加维护成本这种规则称为示例例中的类只涉及字符串对象的组合复制移动和析构可交由成员对象完成其拷贝构造函数赋值运算符以及析构函数是多余的应该去掉编译器会进行更好地处理可接受一个参数的构造函数需用关键字限定为了避免意料之外的类型转换可接受一个参数的构造函数应该用关键字限定示例由于类的构造函数接受一个型参数相当于将隐式转为类的对象这种隐式转换是怪异的也往往意味着意料之外的错误应改为这样这种写法便不会通过编译例外拷贝移动构造函数可不受本规则约束如果将拷贝移动构造函数声明为则无法再按值传递参数或按值返回对象在类的接口设计中应尽量减少隐式转换以避免不易察觉的问题重载的类型转换运算符需用关键字限定为了避免意料之外的类型转换重载的类型转换运算符需用关键字限定示例例中返回临时对象类型转换运算符被隐式调用然而当返回后临时对象被销毁返回的指针是无效的将类型转换运算符用关键字限定有问题的代码便不会通过编译在类的接口设计中应尽量减少隐式转换以避免不易察觉的问题不要过度使用对类的拷贝移动以及不接受个参数的构造函数一般不用限定否则有损代码的易用性和可扩展性示例当类的拷贝移动构造函数被限定时无法再按值传递参数或按值返回对象当不接受个参数的构造函数被限定时无法再用初始化列表定义临时对象如下代码将无法通过编译带模板的赋值运算符不应与拷贝或移动赋值运算符混淆带模板的赋值运算符不应与拷贝或移动赋值运算符混淆存在带模板的赋值运算符时应明确声明拷贝和移动赋值运算符示例设例中的类需要深拷贝标准规定即使带模板的赋值运算符在功能上可以满足拷贝或移动赋值运算符的需求也不能作为拷贝或移动赋值运算符故其拷贝和移动赋值运算符仍然是默认的无法完成深拷贝以及正确的数据移动应明确声明拷贝和移动赋值运算符带模板的构造函数不应与拷贝或移动构造函数混淆带模板的构造函数不应与拷贝或移动构造函数混淆存在带模板的构造函数时应明确声明拷贝和移动构造函数示例设例中的类需要深拷贝标准规定即使带模板的构造函数在功能上可以满足拷贝或移动构造函数的需求也不能作为拷贝或移动构造函数故其拷贝和移动构造函数仍然是默认的无法完成深拷贝以及正确的数据移动应明确声明拷贝和移动构造函数抽象类禁用拷贝和移动赋值运算符抽象类只能作为基类没有独立的对象调用拷贝或移动赋值运算符会造成数据不完整示例例中函数的参数只能是的派生类对象派生类对象调用基类的拷贝赋值运算符会得到不完整的复制结果应改为将抽象类的拷贝和移动赋值运算符设为或可在编译期阻止不完整的复制和移动数据成员的数量应在规定范围之内类或联合体的数据成员过多意味着一个逻辑或功能单位承担了过多的职责违反了模块化设计理念是难以维护的示例数据成员之间的填充数据不应被忽视成员之间存在填充数据且没有声明对齐方式时填充数据的长度是由实现定义的这种数据不应在不同的环境之间传输而且应注意成员的声明顺序避免由填充数据造成的空间浪费关于填充数据的具体组织方式详见内存对齐示例例中成员和之间存在填充数据但没有声明对齐方式直接在网络上传输这种类型的对象是不符合要求的如果发送端的对齐方式与接收端不一致就会造成混乱应在发送端和接收端统一声明对齐方式注意敏感数据可能会残留在填充数据中所以当存储或传输对象前有必要清理填充数据的值如常量成员函数不应返回数据成员的非常量指针或引用如果常量成员函数返回数据成员的非常量指针或引用既打破了常量限定又违反了封装理念属于不良实现方式本规则是的特化示例类成员应按的顺序声明类成员统一按的顺序声明有利于提高可读性示例供外部使用的成员应作为重点写在前面其次是成员成员应写在最后存在构造析构或虚函数的类不应采用关键字简单结构体应采用关键字具有封装或多态等特性的类应采用关键字以便提高可读性示例同类枚举项的值不应相同枚举项用于标记不同的事物名称不同但值相同的枚举项往往意味着错误示例例中三个枚举项应分别表示三种颜色但与的值相同会造成逻辑错误又如例中定义了三种水果而表示最喜欢的水果与其他枚举项不是同一层面的概念不应聚为一类应采用更结构化的方式合理初始化各枚举项合理初始化各枚举项只应从下列方式中选择一种全不初始化只初始化第一个全部初始化为不同的值示例应改为不应使用匿名枚举类型匿名枚举声明相当于在当前作用域定义常量但类型不够明确示例如果无法确定枚举类型的名称也意味着各枚举项不应聚为一类应改为用取代传统枚举没有有效的类型和作用域控制极易造成类型混淆和名称冲突在代码中建议改用示例传统枚举值与等类型可以随意转换如果和表示某种错误情况表示正确情况那么函数中对返回值的判断就是错误的这也是一种常见问题提出了的概念加强了类型检查提倡在新项目中尽量使用应改为联合体禁用非基本类型的对象因为联合体成员之间共享内存地址所以成员具有构造或析构函数时会导致混乱禁止具有拷贝构造函数或析构函数的对象出现在联合体中解除了这条禁令但在语言层面上不保障正确性相当于把问题抛给了用户示例示例代码在某些环境中会崩溃原因是没能正确区分对象当前持有的类型执行了错误的构造或析构过程正确的做法是在类中用一个成员变量记录当前持有的类型再将匿名联合体与类的构造函数以及析构函数相关联从而根据当前持有的类型正确地初始化或销毁对象禁用在类之外定义的联合体联合体各成员共享存储地址易引发意料之外的错误如果一定要使用联合体需对其进行一定的封装避免对成员的错误访问不应出现在命名空间作用域内定义的联合体在类中定义的具有访问权限的联合体示例类的数据成员本来就违反了封装原则如果这种数据成员又处于联合体中会进一步增加风险禁用联合体联合体的问题主要有无法只通过对象获取当前有效的成员访问不同的成员相当于不安全的类型转换对非基本类型的成员造成构造和析构的混乱不能作为基类这些问题在本质上是对类型理念的破坏面向对象的程序设计应避免使用联合体示例例中对的访问也相当于一种没有任何限制的类型转换在代码中建议用或取代联合体可以有效记录对象当前持有的类型如果以不正确的类型访问对象会及时抛出异常本规则比更严格针对所有联合体',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-10-30 13:42:15',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://npm.elemecdn.com/anzhiyu-blog-static@1.0.4/img/avatar.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://hosheazhang.github.io/" title="博客"><img class="back-menu-item-icon" src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://github.com/HosheaZhang/cmu15445" title="cmu15445"><img class="back-menu-item-icon" src="https://image.anheyu.com/favicon.ico" alt="cmu15445"/><span class="back-menu-item-text">cmu15445</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">Hoshea的主页</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button only-home" id="travellings_button" title="随机前往一个开往项目网站"><a class="site-page" onclick="anzhiyu.totraveling()" title="随机前往一个开往项目网站" href="javascript:void(0);" rel="external nofollow" data-pjax-state="external"><i class="anzhiyufont anzhiyu-icon-train"></i></a></div><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> Newest Comments</span></div><div class="aside-list"><span>loading...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/360/" style="font-size: 1.05rem;">360<sup>6</sup></a><a href="/tags/C/" style="font-size: 1.05rem;">C++<sup>44</sup></a><a href="/tags/CMU15445/" style="font-size: 1.05rem;">CMU15445<sup>5</sup></a><a href="/tags/CMake/" style="font-size: 1.05rem;">CMake<sup>1</sup></a><a href="/tags/CSAPP/" style="font-size: 1.05rem;">CSAPP<sup>13</sup></a><a href="/tags/MYSQL/" style="font-size: 1.05rem;">MYSQL<sup>6</sup></a><a href="/tags/VSCODE/" style="font-size: 1.05rem;">VSCODE<sup>1</sup></a><a href="/tags/dfs/" style="font-size: 1.05rem;">dfs<sup>2</sup></a><a href="/tags/gdb/" style="font-size: 1.05rem;">gdb<sup>1</sup></a><a href="/tags/git/" style="font-size: 1.05rem;">git<sup>1</sup></a><a href="/tags/github/" style="font-size: 1.05rem;">github<sup>1</sup></a><a href="/tags/linux/" style="font-size: 1.05rem;">linux<sup>6</sup></a><a href="/tags/markdown/" style="font-size: 1.05rem;">markdown<sup>1</sup></a><a href="/tags/ssh/" style="font-size: 1.05rem;">ssh<sup>1</sup></a><a href="/tags/workflow/" style="font-size: 1.05rem;">workflow<sup>3</sup></a><a href="/tags/%E4%B8%AD%E7%AD%89/" style="font-size: 1.05rem;">中等<sup>16</sup></a><a href="/tags/%E4%BA%8C%E5%88%86/" style="font-size: 1.05rem;">二分<sup>1</sup></a><a href="/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/" style="font-size: 1.05rem;">优先队列<sup>1</sup></a><a href="/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/" style="font-size: 1.05rem;">位运算<sup>3</sup></a><a href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" style="font-size: 1.05rem;">动态规划<sup>2</sup></a><a href="/tags/%E5%91%A8%E8%B5%9B/" style="font-size: 1.05rem;">周赛<sup>9</sup></a><a href="/tags/%E5%9B%B0%E9%9A%BE/" style="font-size: 1.05rem;">困难<sup>1</sup></a><a href="/tags/%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/" style="font-size: 1.05rem;">学习计划<sup>1</sup></a><a href="/tags/%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3/" style="font-size: 1.05rem;">报错解决<sup>4</sup></a><a href="/tags/%E6%8E%92%E5%BA%8F/" style="font-size: 1.05rem;">排序<sup>6</sup></a><a href="/tags/%E6%95%B0%E5%AD%A6/" style="font-size: 1.05rem;">数学<sup>1</sup></a><a href="/tags/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/" style="font-size: 1.05rem;">智能指针<sup>7</sup></a><a href="/tags/%E6%A0%91/" style="font-size: 1.05rem;">树<sup>1</sup></a><a href="/tags/%E6%A0%A1%E6%8B%9B/" style="font-size: 1.05rem;">校招<sup>1</sup></a><a href="/tags/%E6%A8%A1%E6%8B%9F/" style="font-size: 1.05rem;">模拟<sup>8</sup></a><a href="/tags/%E6%A8%A1%E6%9D%BF/" style="font-size: 1.05rem;">模板<sup>6</sup></a><a href="/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/" style="font-size: 1.05rem;">每日一题<sup>14</sup></a><a href="/tags/%E6%B1%87%E7%BC%96/" style="font-size: 1.05rem;">汇编<sup>1</sup></a><a href="/tags/%E6%BA%90%E7%A0%81/" style="font-size: 1.05rem;">源码<sup>2</sup></a><a href="/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/" style="font-size: 1.05rem;">滑动窗口<sup>1</sup></a><a href="/tags/%E7%AE%80%E5%8D%95/" style="font-size: 1.05rem;">简单<sup>7</sup></a><a href="/tags/%E7%BC%96%E8%AF%91/" style="font-size: 1.05rem;">编译<sup>1</sup></a><a href="/tags/%E8%84%91%E7%AD%8B%E6%80%A5%E8%BD%AC%E5%BC%AF/" style="font-size: 1.05rem;">脑筋急转弯<sup>1</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 1.05rem;">计算机网络<sup>8</sup></a><a href="/tags/%E8%B4%AA%E5%BF%83/" style="font-size: 1.05rem;">贪心<sup>3</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>Archives</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/11/"><span class="card-archive-list-date">November 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">33</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/10/"><span class="card-archive-list-date">October 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">66</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2022/10/"><span class="card-archive-list-date">October 2022</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2022/07/"><span class="card-archive-list-date">July 2022</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">4</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2022/04/"><span class="card-archive-list-date">April 2022</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">7</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item on" id="consoleCommentBarrage" onclick="anzhiyu.switchCommentBarrage()" title="热评开关"><a class="commentBarrage"><i class="anzhiyufont anzhiyu-icon-message"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/" itemprop="url">开发笔记</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/C/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>C++</span></a><a class="article-meta__tags" href="/tags/360/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>360</span></a></span></div></div><h1 class="post-title" itemprop="name headline">360代码规范五：type</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2023-10-30T03:39:59.000Z" title="Created 2023-10-30 11:39:59">2023-10-30</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2023-10-30T05:42:15.505Z" title="Updated 2023-10-30 13:42:15">2023-10-30</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-wordcount"><i class="anzhiyufont anzhiyu-icon-file-word post-meta-icon" title="文章字数"></i><span class="post-meta-label" title="文章字数">Word count:</span><span class="word-count" title="文章字数">5.3k</span><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-clock post-meta-icon" title="阅读时长"></i><span class="post-meta-label" title="阅读时长">Reading time:</span><span>19min</span></span><span class="post-meta-separator"></span><span class="post-meta-pv-cv" id="" data-flag-title="360代码规范五：type"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">Post View:</span><span id="busuanzi_value_page_pv"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为南京"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>南京</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://hoshea-1318436778.cos.ap-nanjing.myqcloud.com/image360.jpg"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="http://example.com/2023/10/30/360%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E4%BA%94%EF%BC%9Atype/"><header><a class="post-meta-categories" href="/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/" itemprop="url">开发笔记</a><a href="/tags/C/" tabindex="-1" itemprop="url">C++</a><a href="/tags/360/" tabindex="-1" itemprop="url">360</a><h1 id="CrawlerTitle" itemprop="name headline">360代码规范五：type</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">Hoshea Zhang</span><time itemprop="dateCreated datePublished" datetime="2023-10-30T03:39:59.000Z" title="Created 2023-10-30 11:39:59">2023-10-30</time><time itemprop="dateCreated datePublished" datetime="2023-10-30T05:42:15.505Z" title="Updated 2023-10-30 13:42:15">2023-10-30</time></header><h1 id="class"><a href="#class" class="headerlink" title="class"></a>class</h1><h2 id="类的非常量数据成员均应该是private"><a href="#类的非常量数据成员均应该是private" class="headerlink" title="类的非常量数据成员均应该是private"></a>类的非常量数据成员均应该是private</h2><p>类的数据成员均应设为 private，对外统一由成员函数提供访问方法，且应避免返回 private 成员的非常量引用或指针。  </p>
<p>将类的所有接口都实现为成员函数，由成员函数按指定逻辑读写数据，以便保证有效地改变对象状态。良好的接口设计会对代码的职责进行合理划分，显著提升可维护性。理想状态下，当有错误需要修正或有功能需要调整时，只改动相关接口的实现即可，调用接口的代码不需要改动，从而将改动降到最低。这种设计的基础便是将数据设为 private，只能由本类的成员函数访问，否则数据可被各个模块随意读写，当有一处需要改动时，很难控制其影响范围。  </p>
<p>常量数据成员不可被改变，所以可不受本规则约束。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct A &#123;</span><br><span class="line">    int *p, n;   // Non-compliant</span><br><span class="line"></span><br><span class="line">    A(int n): p(new int[n]), n(n) &#123;&#125;</span><br><span class="line">   ~A() &#123; delete[] p; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>例中类的数据成员 p 指向动态分配的内存区域，n 记录区域大小，p 和 n 之间存在紧密的逻辑关系，这种内在关系应由成员函数统一维护，不暴露给类的使用者，这便是面向对象的封装理念，也是 C++ 语言的核心理念之一。  </p>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    int *p, n;   // Compliant</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    A(int n): p(new int[n]), n(n) &#123;&#125;</span><br><span class="line">   ~A() &#123; delete[] p; &#125;</span><br><span class="line"></span><br><span class="line">    int* begin() &#123; return p; &#125;     // Interfaces for members</span><br><span class="line">    int* end() &#123; return p + n; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这样数据成员不能被外界直接访问，成员之间的关系也不会被随意打破，显著提升可维护性。</p>
<h2 id="类的非常量数据成员不应定义为-protected"><a href="#类的非常量数据成员不应定义为-protected" class="headerlink" title="类的非常量数据成员不应定义为 protected"></a>类的非常量数据成员不应定义为 protected</h2><p>protected 数据成员在派生类中仍可被随意读写，破坏了封装理念。  </p>
<p>本规则是 ID_nonPrivateData 的特化，关于封装的进一步讨论可参见 ID_nonPrivateData。  </p>
<p>常量数据成员不可被改变，所以可不受本规则约束。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    ....</span><br><span class="line">protected:</span><br><span class="line">    int data;   // Non-compliant</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>应改为由接口访问：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    ....</span><br><span class="line">protected:</span><br><span class="line">    int access_data();   // Interfaces for data</span><br><span class="line">private:</span><br><span class="line">    int data;   // Compliant</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="类不应既有public数据成员又有private数据成员"><a href="#类不应既有public数据成员又有private数据成员" class="headerlink" title="类不应既有public数据成员又有private数据成员"></a>类不应既有public数据成员又有private数据成员</h2><p>类的设计应遵循：  </p>
<ul>
<li>成员之间没有依赖关系，且都可以随意被读写时，则都应声明为 public  </li>
<li>成员之间有依赖关系，或成员的状态会影响到整个对象的状态时，则都应声明为 private  </li>
</ul>
<p>否则应对类进行改造或拆分。  </p>
<p>面向对象的封装理念更倾向于将所有数据成员都设为 private，由成员函数按指定逻辑控制每个成员的读写方法，以供外部访问，对代码的职责进行有效地划分，从而提高可维护性并降低风险，关于封装的进一步讨论可参见 ID_nonPrivateData。  </p>
<p>常量数据成员不可被改变，所以可不受本规则约束。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;  // Non-compliant</span><br><span class="line">public:</span><br><span class="line">    int n;</span><br><span class="line">    ....</span><br><span class="line">private:</span><br><span class="line">    int d;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;  // Compliant</span><br><span class="line">public:</span><br><span class="line">    int method_for_n();</span><br><span class="line">    ....</span><br><span class="line">private:</span><br><span class="line">    int n, d;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="有虚函数的基类应具有虚析构函数"><a href="#有虚函数的基类应具有虚析构函数" class="headerlink" title="有虚函数的基类应具有虚析构函数"></a>有虚函数的基类应具有虚析构函数</h2><p>为了避免意料之外的资源泄漏，有虚函数的基类都应该具有虚析构函数。  </p>
<p>通过基类指针析构派生类对象时，如果基类没有虚析构函数会导致标准未定义的行为，无法正确执行派生类的析构函数。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">public:</span><br><span class="line">    A() = default;</span><br><span class="line">   ~A() = default;          // Non-compliant, missing ‘virtual’</span><br><span class="line">    virtual int foo() = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class B: public A &#123;</span><br><span class="line">    int *m, n;              // New resource</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    B(int s): m(new int[s]), n(s) &#123;&#125;</span><br><span class="line">   ~B() &#123; delete[] m; &#125;</span><br><span class="line">    int foo() override &#123; return n; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A* p = new B(10);</span><br><span class="line">....</span><br><span class="line">delete p;                   // Undefined behavior, may leak</span><br></pre></td></tr></table></figure>
<p>由于基类 A 的析构函数不是虚函数，delete p 只调用了基类析构函数，派生类对象的资源没有得到释放。  </p>
<p>例外：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class C &#123;</span><br><span class="line">    ....</span><br><span class="line">protected:</span><br><span class="line">   ~C();     // Compliant</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果有意阻止外界通过基类指针析构对象，如析构函数是 protected，可不受本规则限制。</p>
<h2 id="避免多重继承自同一非虚基类"><a href="#避免多重继承自同一非虚基类" class="headerlink" title="避免多重继承自同一非虚基类"></a>避免多重继承自同一非虚基类</h2><p>当派生类有多个基类，这些基类又派生自同一非虚基类时，派生类对象会持有该非虚基类的多个实例，造成逻辑和存储上的冗余。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct A &#123;</span><br><span class="line">    int i = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class B: public A &#123;&#125;;</span><br><span class="line">class C: public A &#123;&#125;;</span><br><span class="line">class D: public B, public C &#123;&#125;;   // Non-compliant</span><br><span class="line"></span><br><span class="line">void foo(D&amp; d) &#123;</span><br><span class="line">    d.i = 1;       // Compile error</span><br><span class="line">    d.B::i = 1;    // Odd</span><br><span class="line">    d.C::i = 1;    // Odd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 D 类对象 d 中，基类 A 的成员 i 有两个不同的实例，d 不能直接访问 i，只能通过 d.B::i 或 d.C::i 这种怪异的方式访问。  </p>
<p>将共同的基类设为虚基类可以解决这种问题： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class B: virtual public A &#123;&#125;;</span><br><span class="line">class C: virtual public A &#123;&#125;;</span><br><span class="line">class D: public B, public C &#123;&#125;;   // Compliant</span><br><span class="line"></span><br><span class="line">void foo(D&amp; d) &#123;</span><br><span class="line">    d.i = 1;       // OK</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，直接将虚基类指针转为派生类指针会导致标准未定义的行为，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void bar(A* a) &#123;</span><br><span class="line">    B* p = (B*)a;  // Undefined behavior</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种转换一般不会通过编译，但标准并未要求编译器必须阻止这种转换，改用 dynamic_cast 可解决这些问题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void bar(A* a) &#123;</span><br><span class="line">    B* p = dynamic_cast&lt;B*&gt;(a);  // OK</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="存在析构函数或拷贝赋值运算符时，不应缺少拷贝构造函数"><a href="#存在析构函数或拷贝赋值运算符时，不应缺少拷贝构造函数" class="headerlink" title="存在析构函数或拷贝赋值运算符时，不应缺少拷贝构造函数"></a>存在析构函数或拷贝赋值运算符时，不应缺少拷贝构造函数</h2><p>三个紧密相关的函数：  </p>
<ol>
<li>拷贝构造函数  </li>
<li>拷贝赋值运算符  </li>
<li>析构函数  </li>
</ol>
<p>当这三个函数中的任何一个函数被定义时，说明对象在资源管理等方面有特定的需求，其他两个函数也需要被定义，否则难以适应各种应用场景，易产生意料之外的错误，这种规则称为“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Rule_of_three_(C%2B%2B_programming">Rule of three</a>)”。  </p>
<p>如果缺少某个函数，编译器会生成相关默认函数，但其特定需求不会被实现。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class A   // Non-compliant</span><br><span class="line">&#123;</span><br><span class="line">    int* p = new int[8];</span><br><span class="line">public:</span><br><span class="line">   ~A() &#123;</span><br><span class="line">        delete[] p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;      // Missing copy constructor and assignment operator</span><br><span class="line"></span><br><span class="line">void foo()</span><br><span class="line">&#123;</span><br><span class="line">    A a;</span><br><span class="line">    A b(a);   // Shallow copy</span><br><span class="line">    ....</span><br><span class="line">&#125;             // Double free</span><br><span class="line"></span><br><span class="line">void bar(A&amp; a, A&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">    a = b;    // Memory leak</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中的类有析构函数，但没有拷贝构造函数和拷贝赋值运算符，只能进行变量值的复制，使多个对象的资源指针指向同一块内存区域，导致重复释放和内存泄漏，所以应定义拷贝构造函数和拷贝赋值运算符重新分配内存并复制数据。  </p>
<p>同理，在遵循 C++11 及之后标准的代码中：  </p>
<ol>
<li>拷贝构造函数  </li>
<li>拷贝赋值运算符  </li>
<li>析构函数  </li>
<li>移动构造函数  </li>
<li>移动赋值运算符  </li>
</ol>
<p>当定义了这五个函数中的任何一个函数时，其他四个函数也需要定义，详见 ID_violateRuleOfFive。</p>
<h2 id="避免重复实现由默认拷贝、移动、析构函数完成的功能"><a href="#避免重复实现由默认拷贝、移动、析构函数完成的功能" class="headerlink" title="避免重复实现由默认拷贝、移动、析构函数完成的功能"></a>避免重复实现由默认拷贝、移动、析构函数完成的功能</h2><p>当类只负责成员对象的包装或组合而没有特殊的复制、移动、析构需求时，不应定义下列函数：  </p>
<ol>
<li>拷贝构造函数  </li>
<li>拷贝赋值运算符  </li>
<li>析构函数  </li>
<li>移动构造函数  </li>
<li>移动赋值运算符  </li>
</ol>
<p>应由编译器生成相关默认函数，否则会产生多余的代码，增加维护成本，这种规则称为“<a target="_blank" rel="noopener" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-zero">Rule of zero</a>”。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    string a, b;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    A(const A&amp; rhs): a(rhs.a), b(rhs.b) &#123;  // Redundant</span><br><span class="line">    &#125;</span><br><span class="line">    A&amp; operator = (const A&amp; rhs) &#123;  // Redundant</span><br><span class="line">        a = rhs.a;</span><br><span class="line">        b = rhs.b;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">   ~A() &#123;  // Redundant</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>例中的类只涉及字符串对象的组合，复制、移动和析构可交由成员对象完成，其拷贝构造函数、赋值运算符以及析构函数是多余的，应该去掉，编译器会进行更好地处理。</p>
<h2 id="可接受一个参数的构造函数需用-explicit-关键字限定"><a href="#可接受一个参数的构造函数需用-explicit-关键字限定" class="headerlink" title="可接受一个参数的构造函数需用 explicit 关键字限定"></a>可接受一个参数的构造函数需用 explicit 关键字限定</h2><p>为了避免意料之外的类型转换，可接受一个参数的构造函数应该用 explicit 关键字限定。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class String &#123;</span><br><span class="line">public:</span><br><span class="line">    String(int capacity);   // Non-compliant, missing ‘explicit’</span><br><span class="line">    ....</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void foo(const String&amp;);</span><br><span class="line"></span><br><span class="line">int bar() &#123;</span><br><span class="line">    foo(100);   // Can be compiled, but very odd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于 String 类的构造函数接受一个 int 型参数，foo(100) 相当于将 100 隐式转为 String 类的对象，这种隐式转换是怪异的，也往往意味着意料之外的错误。  </p>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class String &#123;</span><br><span class="line">public:</span><br><span class="line">    explicit String(int capacity);   // Compliant</span><br><span class="line">    ....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这样 foo(100) 这种写法便不会通过编译。  </p>
<p>例外：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class String &#123;</span><br><span class="line">public:</span><br><span class="line">    String(const String&amp;);   // Explicit or not depends on your design intent</span><br><span class="line">    String(String&amp;&amp;);        // ditto</span><br><span class="line">    ....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>拷贝、移动构造函数可不受本规则约束，如果将拷贝、移动构造函数声明为 explicit 则无法再按值传递参数或按值返回对象。在类的接口设计中，应尽量减少隐式转换以避免不易察觉的问题。</p>
<h2 id="重载的类型转换运算符需用explicit关键字限定"><a href="#重载的类型转换运算符需用explicit关键字限定" class="headerlink" title="重载的类型转换运算符需用explicit关键字限定"></a>重载的类型转换运算符需用explicit关键字限定</h2><p>为了避免意料之外的类型转换，重载的类型转换运算符需用 explicit 关键字限定。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct A &#123;</span><br><span class="line">    ....</span><br><span class="line">    operator char*();   // Non-compliant</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A foo();</span><br><span class="line"></span><br><span class="line">char* bar() &#123;</span><br><span class="line">    return foo();   // Invalid address returned</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中 foo 返回临时对象，类型转换运算符被隐式调用，然而当 bar 返回后，临时对象被销毁，返回的指针是无效的。  </p>
<p>将类型转换运算符用 explicit 关键字限定，有问题的代码便不会通过编译：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct A &#123;</span><br><span class="line">    ....</span><br><span class="line">    explicit operator char*();   // Compliant</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在类的接口设计中，应尽量减少隐式转换以避免不易察觉的问题。</p>
<h2 id="不要过度使用explicit"><a href="#不要过度使用explicit" class="headerlink" title="不要过度使用explicit"></a>不要过度使用explicit</h2><p>对类的拷贝、移动以及不接受 1 个参数的构造函数一般不用 explicit 限定，否则有损代码的易用性和可扩展性。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">public:</span><br><span class="line">    explicit A(const A&amp;);  // In general, ‘explicit’ is not required</span><br><span class="line">    explicit A(A&amp;&amp;);       // Ditto</span><br><span class="line">    explicit A(int, int);  // Ditto</span><br><span class="line">    ....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当类的拷贝、移动构造函数被 explicit 限定时，无法再按值传递参数或按值返回对象，当不接受 1 个参数的构造函数被 explicit 限定时，无法再用初始化列表定义临时对象，如下代码将无法通过编译：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void foo(A);</span><br><span class="line">void bar(const A&amp;);</span><br><span class="line"></span><br><span class="line">A a(1, 2);</span><br><span class="line"></span><br><span class="line">foo(a);       // Compile error</span><br><span class="line">bar(&#123;3, 4&#125;);  // Compile error</span><br></pre></td></tr></table></figure>
<h2 id="带模板的赋值运算符不应与拷贝或移动赋值运算符混淆"><a href="#带模板的赋值运算符不应与拷贝或移动赋值运算符混淆" class="headerlink" title="带模板的赋值运算符不应与拷贝或移动赋值运算符混淆"></a>带模板的赋值运算符不应与拷贝或移动赋值运算符混淆</h2><p>带模板的赋值运算符不应与拷贝或移动赋值运算符混淆，存在带模板的赋值运算符时应明确声明拷贝和移动赋值运算符。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class A   // Non-compliant, missing copy and move assignment operators</span><br><span class="line">&#123;</span><br><span class="line">    int* dat;   // Need deep copy</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    A();</span><br><span class="line">   ~A();</span><br><span class="line">    template &lt;class T&gt;</span><br><span class="line">    A&amp; operator = (const T&amp; a) &#123;   // Not a copy assignment operator</span><br><span class="line">        return do_copy(a.dat);</span><br><span class="line">    &#125;</span><br><span class="line">    template &lt;class T&gt;</span><br><span class="line">    A&amp; operator = (T&amp;&amp; a) &#123;   // Not a move assignment operator</span><br><span class="line">        return do_move(a.dat);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void foo(A&amp; x, A&amp; y)</span><br><span class="line">&#123;</span><br><span class="line">    x = y;   // Not a deep copy</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设例中的类需要深拷贝，标准规定即使带模板的赋值运算符在功能上可以满足拷贝或移动赋值运算符的需求，也不能作为拷贝或移动赋值运算符，故其拷贝和移动赋值运算符仍然是默认的，无法完成深拷贝以及正确的数据移动。  </p>
<p>应明确声明拷贝和移动赋值运算符：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class A   // Compliant</span><br><span class="line">&#123;</span><br><span class="line">    ....</span><br><span class="line">    A&amp; operator = (const A&amp;);</span><br><span class="line">    A&amp; operator = (A&amp;&amp;);  </span><br><span class="line">    ....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="带模板的构造函数不应与拷贝或移动构造函数混淆"><a href="#带模板的构造函数不应与拷贝或移动构造函数混淆" class="headerlink" title="带模板的构造函数不应与拷贝或移动构造函数混淆"></a>带模板的构造函数不应与拷贝或移动构造函数混淆</h2><p>带模板的构造函数不应与拷贝或移动构造函数混淆，存在带模板的构造函数时应明确声明拷贝和移动构造函数。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class A   // Non-compliant, missing copy and move constructors</span><br><span class="line">&#123;</span><br><span class="line">    int* dat;   // Need deep copy</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    A();</span><br><span class="line">   ~A();</span><br><span class="line">    template &lt;class T&gt; A(const T&amp; a) &#123;   // Not a copy constructor</span><br><span class="line">        do_copy(a.dat);</span><br><span class="line">    &#125;</span><br><span class="line">    template &lt;class T&gt; A(T&amp;&amp; a) &#123;   // Not a move constructor</span><br><span class="line">        do_move(a.dat);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void foo(A&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">    A y(x);   // Not a deep copy</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设例中的类需要深拷贝，标准规定即使带模板的构造函数在功能上可以满足拷贝或移动构造函数的需求，也不能作为拷贝或移动构造函数，故其拷贝和移动构造函数仍然是默认的，无法完成深拷贝以及正确的数据移动。  </p>
<p>应明确声明拷贝和移动构造函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class A   // Compliant</span><br><span class="line">&#123;</span><br><span class="line">    ....</span><br><span class="line">    A(const A&amp;);</span><br><span class="line">    A(A&amp;&amp;);</span><br><span class="line">    ....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="抽象类禁用拷贝和移动赋值运算符"><a href="#抽象类禁用拷贝和移动赋值运算符" class="headerlink" title="抽象类禁用拷贝和移动赋值运算符"></a>抽象类禁用拷贝和移动赋值运算符</h2><p>抽象类只能作为基类，没有独立的对象，调用拷贝或移动赋值运算符会造成数据不完整。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct A &#123;</span><br><span class="line">    virtual ~A() = 0;</span><br><span class="line">    A&amp; operator = (const A&amp;);   // Non-compliant</span><br><span class="line">    A&amp; operator = (A&amp;&amp;);        // Non-compliant</span><br><span class="line">    ....</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void foo(A&amp; x, A&amp; y) &#123;</span><br><span class="line">    x = y;               // Incomplete assignment</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中 foo 函数的参数只能是 A 的派生类对象，派生类对象调用基类的拷贝赋值运算符会得到不完整的复制结果。  </p>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct A &#123;</span><br><span class="line">    virtual ~A() = 0;</span><br><span class="line">    A&amp; operator = (const A&amp;) = delete;   // Compliant</span><br><span class="line">    A&amp; operator = (A&amp;&amp;) = delete;        // Compliant</span><br><span class="line">    ....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>将抽象类的拷贝和移动赋值运算符设为 =delete 或 private，可在编译期阻止不完整的复制和移动。</p>
<h2 id="数据成员的数量应在规定范围之内"><a href="#数据成员的数量应在规定范围之内" class="headerlink" title="数据成员的数量应在规定范围之内"></a>数据成员的数量应在规定范围之内</h2><p>类或联合体的数据成员过多意味着一个逻辑或功能单位承担了过多的职责，违反了模块化设计理念，是难以维护的。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class C</span><br><span class="line">&#123;</span><br><span class="line">    // ... 3000 members ...</span><br><span class="line">    // Who has the courage to read?</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">union U</span><br><span class="line">&#123;</span><br><span class="line">    // ... 3000 members ...</span><br><span class="line">    // Here is hell!</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="数据成员之间的填充数据不应被忽视"><a href="#数据成员之间的填充数据不应被忽视" class="headerlink" title="数据成员之间的填充数据不应被忽视"></a>数据成员之间的填充数据不应被忽视</h2><p>成员之间存在填充数据，且没有声明对齐方式时，填充数据的长度是由实现定义的，这种数据不应在不同的环境之间传输，而且应注意成员的声明顺序，避免由填充数据造成的空间浪费。  </p>
<p>关于填充数据的具体组织方式，详见“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Data_structure_alignment">内存对齐</a>”。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct T &#123;</span><br><span class="line">    int8_t  a;</span><br><span class="line">    int32_t b;</span><br><span class="line">&#125; obj;</span><br><span class="line"></span><br><span class="line">recv(sockfd, &amp;obj, sizeof obj, flags);   // Non-compliant</span><br></pre></td></tr></table></figure>
<p>例中成员 a 和 b 之间存在填充数据，但没有声明对齐方式，直接在网络上传输这种类型的对象是不符合要求的，如果发送端的对齐方式与接收端不一致就会造成混乱。  </p>
<p>应在发送端和接收端统一声明对齐方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct alignas(4) T &#123;   // Or use _Alignas in C</span><br><span class="line">    int8_t  a;</span><br><span class="line">    int32_t b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意，敏感数据可能会残留在填充数据中，所以当存储或传输对象前有必要清理填充数据的值，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">T obj;</span><br><span class="line">memset(&amp;obj, 0, sizeof(obj));   // Required</span><br><span class="line">....</span><br><span class="line">fwrite(&amp;obj, sizeof(obj), 1, fp);</span><br></pre></td></tr></table></figure>
<h2 id="常量成员函数不应返回数据成员的非常量指针或引用"><a href="#常量成员函数不应返回数据成员的非常量指针或引用" class="headerlink" title="常量成员函数不应返回数据成员的非常量指针或引用"></a>常量成员函数不应返回数据成员的非常量指针或引用</h2><p>如果常量成员函数返回数据成员的非常量指针或引用，既打破了常量限定，又违反了封装理念，属于不良实现方式。  </p>
<p>本规则是 ID_qualifierCastedAway 的特化。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    int&amp; foo() const &#123;</span><br><span class="line">        return (int&amp;)i;   // Non-compliant</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="类成员应按-public、protected、private-的顺序声明"><a href="#类成员应按-public、protected、private-的顺序声明" class="headerlink" title="类成员应按 public、protected、private 的顺序声明"></a>类成员应按 public、protected、private 的顺序声明</h2><p>类成员统一按 public、protected、private 的顺序声明，有利于提高可读性。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class A   // Bad</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    int baz();</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    int foo();</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">    int bar();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>供外部使用的 public 成员应作为重点写在前面，其次是 protected 成员，private 成员应写在最后：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class A   // Good</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int foo();</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">    int bar();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    int baz();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="存在构造、析构或虚函数的类不应采用-struct-关键字"><a href="#存在构造、析构或虚函数的类不应采用-struct-关键字" class="headerlink" title="存在构造、析构或虚函数的类不应采用 struct 关键字"></a>存在构造、析构或虚函数的类不应采用 struct 关键字</h2><p>简单结构体应采用 struct 关键字，具有封装或多态等特性的类应采用 class 关键字，以便提高可读性。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct A &#123;     // Compliant</span><br><span class="line">    int x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct B &#123;     // Non-compliant</span><br><span class="line">    B();</span><br><span class="line">   ~B();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    int x, y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="enum"><a href="#enum" class="headerlink" title="enum"></a>enum</h1><h2 id="同类枚举项的值不应相同"><a href="#同类枚举项的值不应相同" class="headerlink" title="同类枚举项的值不应相同"></a>同类枚举项的值不应相同</h2><p>枚举项用于标记不同的事物，名称不同但值相同的枚举项往往意味着错误。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enum Color &#123;</span><br><span class="line">    red = 1,</span><br><span class="line">    yellow = 2,</span><br><span class="line">    blue = 2,    // Non-compliant, see ‘yellow’</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>例中三个枚举项应分别表示三种颜色，但 blue 与 yellow 的值相同会造成逻辑错误。  </p>
<p>又如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum Fruit &#123;</span><br><span class="line">    apple,</span><br><span class="line">    pear,</span><br><span class="line">    grape,</span><br><span class="line">    favorite = grape,  // Non-compliant</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>例中 Fruit 定义了三种水果，而 favorite 表示最喜欢的水果，与其他枚举项不是同一层面的概念，不应聚为一类。  </p>
<p>应采用更结构化的方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">enum Fruit &#123;</span><br><span class="line">    apple, pear, grape</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Fruit favorite () &#123;</span><br><span class="line">    return grape;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="合理初始化各枚举项"><a href="#合理初始化各枚举项" class="headerlink" title="合理初始化各枚举项"></a>合理初始化各枚举项</h2><p>合理初始化各枚举项，只应从下列方式中选择一种：   </p>
<ul>
<li>全不初始化  </li>
<li>只初始化第一个  </li>
<li>全部初始化为不同的值  </li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum Color &#123;</span><br><span class="line">    red,</span><br><span class="line">    blue,</span><br><span class="line">    green,</span><br><span class="line">    yellow = 2   // Non-compliant</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum Color &#123;</span><br><span class="line">    red,</span><br><span class="line">    blue,</span><br><span class="line">    green,</span><br><span class="line">    yellow   // Compliant</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="不应使用匿名枚举类型"><a href="#不应使用匿名枚举类型" class="headerlink" title="不应使用匿名枚举类型"></a>不应使用匿名枚举类型</h2><p>匿名枚举声明相当于在当前作用域定义常量，但类型不够明确。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enum &#123; rabbit = 0xAA, carrot = 1234 &#125;;  // Non-compliant</span><br></pre></td></tr></table></figure>
<p>如果无法确定枚举类型的名称，也意味着各枚举项不应聚为一类。  </p>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const int rabbit = 0xAA;  // Compliant</span><br><span class="line">const int carrot = 1234;  // Compliant</span><br></pre></td></tr></table></figure>
<h2 id="用enum-class取代enum"><a href="#用enum-class取代enum" class="headerlink" title="用enum class取代enum"></a>用enum class取代enum</h2><p>传统 C 枚举没有有效的类型和作用域控制，极易造成类型混淆和名称冲突，在 C++ 代码中建议改用 enum class。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">enum E &#123;      // Non-compliant</span><br><span class="line">    e0 = 0,</span><br><span class="line">    e1 = 1,</span><br><span class="line">    e2 = -1</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">E foo();</span><br><span class="line"></span><br><span class="line">void bar() &#123;</span><br><span class="line">    if (foo()) &#123;   // ‘e1’ or ‘e2’??</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>传统 C 枚举值与 int 等类型可以随意转换，如果 e0 和 e2 表示某种错误情况，e1 表示正确情况，那么 bar 函数中对 foo 返回值的判断就是错误的，这也是一种常见问题，C++11 提出了 enum class 的概念加强了类型检查，提倡在新项目中尽量使用 enum class。  </p>
<p>应改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">enum class E &#123;   // Compliant</span><br><span class="line">    e0 = 0,</span><br><span class="line">    e1 = 1,</span><br><span class="line">    e2 = -1</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void bar() &#123;</span><br><span class="line">    if (foo() == E::e1) &#123;   // OK</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">    if (foo()) &#123;   // Compile error, cannot cast the enum class casually</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Union"><a href="#Union" class="headerlink" title="Union"></a>Union</h1><h2 id="联合体禁用非基本类型的对象"><a href="#联合体禁用非基本类型的对象" class="headerlink" title="联合体禁用非基本类型的对象"></a>联合体禁用非基本类型的对象</h2><p>因为联合体成员之间共享内存地址，所以成员具有构造或析构函数时会导致混乱。  </p>
<p>C++98/03 禁止具有拷贝构造函数或析构函数的对象出现在联合体中，C++11 解除了这条禁令，但在语言层面上不保障正确性，相当于把问题抛给了用户。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">union U &#123;</span><br><span class="line">    int i;</span><br><span class="line">    string s;  // Non-compliant</span><br><span class="line"></span><br><span class="line">    U(int x): i(x) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    U(const char* x) &#123;</span><br><span class="line">        new(&amp;s) string(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   ~U() &#123;</span><br><span class="line">        s.~string();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">U u(1);</span><br><span class="line">u.s = &quot;abc&quot;;  // No error, no warning, just crash</span><br></pre></td></tr></table></figure>
<p>示例代码在某些环境中会崩溃，原因是没能正确区分对象当前持有的类型，执行了错误的构造或析构过程。  </p>
<p>正确的做法是在类中用一个成员变量记录当前持有的类型，再将匿名联合体与类的构造函数以及析构函数相关联，从而根据当前持有的类型正确地初始化或销毁对象。</p>
<h2 id="禁用在类之外定义的联合体"><a href="#禁用在类之外定义的联合体" class="headerlink" title="禁用在类之外定义的联合体"></a>禁用在类之外定义的联合体</h2><p>联合体各成员共享存储地址，易引发意料之外的错误。如果一定要使用联合体，需对其进行一定的封装，避免对成员的错误访问。  </p>
<p>不应出现：  </p>
<ul>
<li>在命名空间作用域内定义的联合体  </li>
<li>在类中定义的具有 public 访问权限的联合体  </li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">union U &#123;      // Non-compliant, global union</span><br><span class="line">    ....</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class A &#123;</span><br><span class="line">public:</span><br><span class="line">    union &#123;    // Non-compliant, public union</span><br><span class="line">        ....</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class B &#123;</span><br><span class="line">public:</span><br><span class="line">    ....       // Interfaces about the union</span><br><span class="line">private:</span><br><span class="line">    union &#123;    // Compliant, the union is under control</span><br><span class="line">        ....</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>类的 public 数据成员本来就违反了封装原则，如果这种数据成员又处于联合体中，会进一步增加风险。</p>
<h2 id="禁用联合体"><a href="#禁用联合体" class="headerlink" title="禁用联合体"></a>禁用联合体</h2><p>联合体的问题主要有：  </p>
<ul>
<li>无法只通过对象获取当前有效的成员  </li>
<li>访问不同的成员相当于不安全的类型转换  </li>
<li>对非基本类型的成员造成构造和析构的混乱  </li>
<li>不能作为基类  </li>
</ul>
<p>这些问题在本质上是对类型理念的破坏，面向对象的程序设计应避免使用联合体。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">union U &#123;    // Non-compliant</span><br><span class="line">    int i;</span><br><span class="line">    char c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">U u;</span><br><span class="line">u.i = 1000;</span><br><span class="line">cout &lt;&lt; u.c &lt;&lt; &#x27;\n&#x27;;   // Equivalent to a cast without any restrictions</span><br></pre></td></tr></table></figure>
<p>例中对 u.c 的访问也相当于一种没有任何限制的类型转换。  </p>
<p>在 C++ 代码中建议用 std::variant 或 std::any 取代联合体：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::variant&lt;int, char&gt; u;</span><br><span class="line">u = 1000;</span><br><span class="line">cout &lt;&lt; get&lt;int&gt;(u) &lt;&lt; &#x27;\n&#x27;;    // OK</span><br><span class="line">cout &lt;&lt; get&lt;char&gt;(u) &lt;&lt; &#x27;\n&#x27;;   // Throw ‘std::bad_variant_access’</span><br></pre></td></tr></table></figure>
<p>std::variant 可以有效记录对象当前持有的类型，如果以不正确的类型访问对象会及时抛出异常。  </p>
<p>本规则比 ID_forbidNakedUnion 更严格，针对所有联合体。</p>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">Hoshea Zhang</div><div class="post-copyright__author_desc">No Silver Bullet</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://example.com/2023/10/30/360%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E4%BA%94%EF%BC%9Atype/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://example.com/2023/10/30/360%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E4%BA%94%EF%BC%9Atype/')">360代码规范五：type</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://example.com/2023/10/30/360%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E4%BA%94%EF%BC%9Atype/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=360代码规范五：type&amp;url=http://example.com/2023/10/30/360%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E4%BA%94%EF%BC%9Atype/&amp;pic=https://hoshea-1318436778.cos.ap-nanjing.myqcloud.com/image360.jpg" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="rm.copyPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/C/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>C++<span class="tagsPageCount">44</span></a><a class="post-meta__box__tags" href="/tags/360/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>360<span class="tagsPageCount">6</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://hoshea-1318436778.cos.ap-nanjing.myqcloud.com/imageanderson-1.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/10/30/H%E6%8C%87%E6%95%B0II/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://hoshea-1318436778.cos.ap-nanjing.myqcloud.com/imagebg_leetcode.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">H指数II</div></div></a></div><div class="next-post pull-right"><a href="/2023/10/30/CSAPP%E7%AC%AC%E4%B9%9D%E7%AB%A0%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://hoshea-1318436778.cos.ap-nanjing.myqcloud.com/imagebg_CSAPP.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">CSAPP第九章虚拟内存</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2023/10/25/360%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E4%B8%80%EF%BC%9Asecurity/" title="360代码规范一：security"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://hoshea-1318436778.cos.ap-nanjing.myqcloud.com/image360.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-10-25</div><div class="title">360代码规范一：security</div></div></a></div><div><a href="/2023/10/26/360%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E4%BA%8C%EF%BC%9Aresource/" title="360代码规范二：resource"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://hoshea-1318436778.cos.ap-nanjing.myqcloud.com/image360.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-10-26</div><div class="title">360代码规范二：resource</div></div></a></div><div><a href="/2023/10/27/360%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E4%B8%89%EF%BC%9Aprecompile/" title="360代码规范三：precompile"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://hoshea-1318436778.cos.ap-nanjing.myqcloud.com/image360.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-10-27</div><div class="title">360代码规范三：precompile</div></div></a></div><div><a href="/2023/10/29/360%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E5%9B%9B%EF%BC%9Aglobal/" title="360代码规范四：global"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://hoshea-1318436778.cos.ap-nanjing.myqcloud.com/image360.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-10-29</div><div class="title">360代码规范四：global</div></div></a></div><div><a href="/2023/10/31/360%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E5%85%AD%EF%BC%9Adeclaration/" title="360代码规范六：declaration"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://hoshea-1318436778.cos.ap-nanjing.myqcloud.com/image360.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-10-31</div><div class="title">360代码规范六：declaration</div></div></a></div><div><a href="/2023/10/19/c-%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3%E6%B1%87%E6%80%BB/" title="c++报错解决汇总"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://hoshea-1318436778.cos.ap-nanjing.myqcloud.com/imagebg_develop.webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-10-19</div><div class="title">c++报错解决汇总</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/24/64e6ce9c507bb.png" ait="status"/></div></div><div class="author-info__description"></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">Hoshea Zhang</h1><div class="author-info__desc">No Silver Bullet</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/HosheaZhang" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a></div></div></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bullhorn anzhiyu-shake"></i><span>Announcement</span></div><div class="announcement_content">e-mail:542978210@qq.com</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#class"><span class="toc-number">1.</span> <span class="toc-text">class</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E9%9D%9E%E5%B8%B8%E9%87%8F%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E5%9D%87%E5%BA%94%E8%AF%A5%E6%98%AFprivate"><span class="toc-number">1.1.</span> <span class="toc-text">类的非常量数据成员均应该是private</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E9%9D%9E%E5%B8%B8%E9%87%8F%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E4%B8%8D%E5%BA%94%E5%AE%9A%E4%B9%89%E4%B8%BA-protected"><span class="toc-number">1.2.</span> <span class="toc-text">类的非常量数据成员不应定义为 protected</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E4%B8%8D%E5%BA%94%E6%97%A2%E6%9C%89public%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E5%8F%88%E6%9C%89private%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98"><span class="toc-number">1.3.</span> <span class="toc-text">类不应既有public数据成员又有private数据成员</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%9F%BA%E7%B1%BB%E5%BA%94%E5%85%B7%E6%9C%89%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.</span> <span class="toc-text">有虚函数的基类应具有虚析构函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%E8%87%AA%E5%90%8C%E4%B8%80%E9%9D%9E%E8%99%9A%E5%9F%BA%E7%B1%BB"><span class="toc-number">1.5.</span> <span class="toc-text">避免多重继承自同一非虚基类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%9C%A8%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E6%88%96%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E6%97%B6%EF%BC%8C%E4%B8%8D%E5%BA%94%E7%BC%BA%E5%B0%91%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.6.</span> <span class="toc-text">存在析构函数或拷贝赋值运算符时，不应缺少拷贝构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E9%87%8D%E5%A4%8D%E5%AE%9E%E7%8E%B0%E7%94%B1%E9%BB%98%E8%AE%A4%E6%8B%B7%E8%B4%9D%E3%80%81%E7%A7%BB%E5%8A%A8%E3%80%81%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E5%AE%8C%E6%88%90%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">1.7.</span> <span class="toc-text">避免重复实现由默认拷贝、移动、析构函数完成的功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E6%8E%A5%E5%8F%97%E4%B8%80%E4%B8%AA%E5%8F%82%E6%95%B0%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E9%9C%80%E7%94%A8-explicit-%E5%85%B3%E9%94%AE%E5%AD%97%E9%99%90%E5%AE%9A"><span class="toc-number">1.8.</span> <span class="toc-text">可接受一个参数的构造函数需用 explicit 关键字限定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%BF%90%E7%AE%97%E7%AC%A6%E9%9C%80%E7%94%A8explicit%E5%85%B3%E9%94%AE%E5%AD%97%E9%99%90%E5%AE%9A"><span class="toc-number">1.9.</span> <span class="toc-text">重载的类型转换运算符需用explicit关键字限定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E8%A6%81%E8%BF%87%E5%BA%A6%E4%BD%BF%E7%94%A8explicit"><span class="toc-number">1.10.</span> <span class="toc-text">不要过度使用explicit</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%A6%E6%A8%A1%E6%9D%BF%E7%9A%84%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8D%E5%BA%94%E4%B8%8E%E6%8B%B7%E8%B4%9D%E6%88%96%E7%A7%BB%E5%8A%A8%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E6%B7%B7%E6%B7%86"><span class="toc-number">1.11.</span> <span class="toc-text">带模板的赋值运算符不应与拷贝或移动赋值运算符混淆</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%A6%E6%A8%A1%E6%9D%BF%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8D%E5%BA%94%E4%B8%8E%E6%8B%B7%E8%B4%9D%E6%88%96%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%B7%B7%E6%B7%86"><span class="toc-number">1.12.</span> <span class="toc-text">带模板的构造函数不应与拷贝或移动构造函数混淆</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%A6%81%E7%94%A8%E6%8B%B7%E8%B4%9D%E5%92%8C%E7%A7%BB%E5%8A%A8%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.13.</span> <span class="toc-text">抽象类禁用拷贝和移动赋值运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E7%9A%84%E6%95%B0%E9%87%8F%E5%BA%94%E5%9C%A8%E8%A7%84%E5%AE%9A%E8%8C%83%E5%9B%B4%E4%B9%8B%E5%86%85"><span class="toc-number">1.14.</span> <span class="toc-text">数据成员的数量应在规定范围之内</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E4%B9%8B%E9%97%B4%E7%9A%84%E5%A1%AB%E5%85%85%E6%95%B0%E6%8D%AE%E4%B8%8D%E5%BA%94%E8%A2%AB%E5%BF%BD%E8%A7%86"><span class="toc-number">1.15.</span> <span class="toc-text">数据成员之间的填充数据不应被忽视</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%B8%8D%E5%BA%94%E8%BF%94%E5%9B%9E%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E7%9A%84%E9%9D%9E%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88%E6%88%96%E5%BC%95%E7%94%A8"><span class="toc-number">1.16.</span> <span class="toc-text">常量成员函数不应返回数据成员的非常量指针或引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E6%88%90%E5%91%98%E5%BA%94%E6%8C%89-public%E3%80%81protected%E3%80%81private-%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%A3%B0%E6%98%8E"><span class="toc-number">1.17.</span> <span class="toc-text">类成员应按 public、protected、private 的顺序声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%9C%A8%E6%9E%84%E9%80%A0%E3%80%81%E6%9E%90%E6%9E%84%E6%88%96%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E7%B1%BB%E4%B8%8D%E5%BA%94%E9%87%87%E7%94%A8-struct-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.18.</span> <span class="toc-text">存在构造、析构或虚函数的类不应采用 struct 关键字</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#enum"><span class="toc-number">2.</span> <span class="toc-text">enum</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E7%B1%BB%E6%9E%9A%E4%B8%BE%E9%A1%B9%E7%9A%84%E5%80%BC%E4%B8%8D%E5%BA%94%E7%9B%B8%E5%90%8C"><span class="toc-number">2.1.</span> <span class="toc-text">同类枚举项的值不应相同</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%88%E7%90%86%E5%88%9D%E5%A7%8B%E5%8C%96%E5%90%84%E6%9E%9A%E4%B8%BE%E9%A1%B9"><span class="toc-number">2.2.</span> <span class="toc-text">合理初始化各枚举项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E5%BA%94%E4%BD%BF%E7%94%A8%E5%8C%BF%E5%90%8D%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.3.</span> <span class="toc-text">不应使用匿名枚举类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8enum-class%E5%8F%96%E4%BB%A3enum"><span class="toc-number">2.4.</span> <span class="toc-text">用enum class取代enum</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Union"><span class="toc-number">3.</span> <span class="toc-text">Union</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%94%E5%90%88%E4%BD%93%E7%A6%81%E7%94%A8%E9%9D%9E%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.1.</span> <span class="toc-text">联合体禁用非基本类型的对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A6%81%E7%94%A8%E5%9C%A8%E7%B1%BB%E4%B9%8B%E5%A4%96%E5%AE%9A%E4%B9%89%E7%9A%84%E8%81%94%E5%90%88%E4%BD%93"><span class="toc-number">3.2.</span> <span class="toc-text">禁用在类之外定义的联合体</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A6%81%E7%94%A8%E8%81%94%E5%90%88%E4%BD%93"><span class="toc-number">3.3.</span> <span class="toc-text">禁用联合体</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/11/08/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E4%B9%8B%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/" title="经典算法实现之优先级队列"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://hoshea-1318436778.cos.ap-nanjing.myqcloud.com/imageanderson-1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="经典算法实现之优先级队列"/></a><div class="content"><a class="title" href="/2023/11/08/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E4%B9%8B%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/" title="经典算法实现之优先级队列">经典算法实现之优先级队列</a><time datetime="2023-11-08T13:36:23.000Z" title="Created 2023-11-08 21:36:23">2023-11-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/11/08/C-templates%E7%AC%AC%E4%B8%83%E7%AB%A0%E6%8C%89%E5%80%BC%E4%BC%A0%E9%80%92%E8%BF%98%E6%98%AF%E6%8C%89%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%EF%BC%9F/" title="C++templates第七章按值传递还是按引用传递？"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://hoshea-1318436778.cos.ap-nanjing.myqcloud.com/images29925490.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++templates第七章按值传递还是按引用传递？"/></a><div class="content"><a class="title" href="/2023/11/08/C-templates%E7%AC%AC%E4%B8%83%E7%AB%A0%E6%8C%89%E5%80%BC%E4%BC%A0%E9%80%92%E8%BF%98%E6%98%AF%E6%8C%89%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%EF%BC%9F/" title="C++templates第七章按值传递还是按引用传递？">C++templates第七章按值传递还是按引用传递？</a><time datetime="2023-11-08T13:07:06.000Z" title="Created 2023-11-08 21:07:06">2023-11-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/11/08/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E7%AC%AC%E5%85%AB%E7%AB%A0%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6/" title="Linux高性能服务器编程第八章高性能服务器程序框架"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://hoshea-1318436778.cos.ap-nanjing.myqcloud.com/imagebg_server.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux高性能服务器编程第八章高性能服务器程序框架"/></a><div class="content"><a class="title" href="/2023/11/08/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E7%AC%AC%E5%85%AB%E7%AB%A0%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6/" title="Linux高性能服务器编程第八章高性能服务器程序框架">Linux高性能服务器编程第八章高性能服务器程序框架</a><time datetime="2023-11-08T02:17:59.000Z" title="Created 2023-11-08 10:17:59">2023-11-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/11/07/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E7%AC%AC%E4%B8%83%E7%AB%A0Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F%E8%A7%84%E8%8C%83/" title="Linux高性能服务器编程第七章Linux服务器程序规范"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://hoshea-1318436778.cos.ap-nanjing.myqcloud.com/imagebg_server.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux高性能服务器编程第七章Linux服务器程序规范"/></a><div class="content"><a class="title" href="/2023/11/07/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E7%AC%AC%E4%B8%83%E7%AB%A0Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F%E8%A7%84%E8%8C%83/" title="Linux高性能服务器编程第七章Linux服务器程序规范">Linux高性能服务器编程第七章Linux服务器程序规范</a><time datetime="2023-11-07T07:56:55.000Z" title="Created 2023-11-07 15:56:55">2023-11-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/11/07/%E8%B5%84%E6%BA%90pdf/" title="资源pdf集合">资源pdf集合</a><time datetime="2023-11-07T03:59:12.000Z" title="Created 2023-11-07 11:59:12">2023-11-07</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2021 - 2023 By <a class="footer-bar-link" href="/" title="Hoshea Zhang" target="_blank">Hoshea Zhang</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">Articles</div><div class="length-num">111</div></a><a href="/tags/" title="tag"><div class="headline">Tags</div><div class="length-num">46</div></a><a href="/categories/" title="category"><div class="headline">Categories</div><div class="length-num">11</div></a></div><span class="sidebar-menu-item-title">Function</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="Display Mode"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>Display Mode</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://hosheazhang.github.io/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://github.com/HosheaZhang/cmu15445" title="cmu15445"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="cmu15445"/><span class="back-menu-item-text">cmu15445</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/360/" style="font-size: 0.88rem;">360<sup>6</sup></a><a href="/tags/C/" style="font-size: 0.88rem;">C++<sup>44</sup></a><a href="/tags/CMU15445/" style="font-size: 0.88rem;">CMU15445<sup>5</sup></a><a href="/tags/CMake/" style="font-size: 0.88rem;">CMake<sup>1</sup></a><a href="/tags/CSAPP/" style="font-size: 0.88rem;">CSAPP<sup>13</sup></a><a href="/tags/MYSQL/" style="font-size: 0.88rem;">MYSQL<sup>6</sup></a><a href="/tags/VSCODE/" style="font-size: 0.88rem;">VSCODE<sup>1</sup></a><a href="/tags/dfs/" style="font-size: 0.88rem;">dfs<sup>2</sup></a><a href="/tags/gdb/" style="font-size: 0.88rem;">gdb<sup>1</sup></a><a href="/tags/git/" style="font-size: 0.88rem;">git<sup>1</sup></a><a href="/tags/github/" style="font-size: 0.88rem;">github<sup>1</sup></a><a href="/tags/linux/" style="font-size: 0.88rem;">linux<sup>6</sup></a><a href="/tags/markdown/" style="font-size: 0.88rem;">markdown<sup>1</sup></a><a href="/tags/ssh/" style="font-size: 0.88rem;">ssh<sup>1</sup></a><a href="/tags/workflow/" style="font-size: 0.88rem;">workflow<sup>3</sup></a><a href="/tags/%E4%B8%AD%E7%AD%89/" style="font-size: 0.88rem;">中等<sup>16</sup></a><a href="/tags/%E4%BA%8C%E5%88%86/" style="font-size: 0.88rem;">二分<sup>1</sup></a><a href="/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/" style="font-size: 0.88rem;">优先队列<sup>1</sup></a><a href="/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/" style="font-size: 0.88rem;">位运算<sup>3</sup></a><a href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" style="font-size: 0.88rem;">动态规划<sup>2</sup></a><a href="/tags/%E5%91%A8%E8%B5%9B/" style="font-size: 0.88rem;">周赛<sup>9</sup></a><a href="/tags/%E5%9B%B0%E9%9A%BE/" style="font-size: 0.88rem;">困难<sup>1</sup></a><a href="/tags/%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/" style="font-size: 0.88rem;">学习计划<sup>1</sup></a><a href="/tags/%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3/" style="font-size: 0.88rem;">报错解决<sup>4</sup></a><a href="/tags/%E6%8E%92%E5%BA%8F/" style="font-size: 0.88rem;">排序<sup>6</sup></a><a href="/tags/%E6%95%B0%E5%AD%A6/" style="font-size: 0.88rem;">数学<sup>1</sup></a><a href="/tags/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/" style="font-size: 0.88rem;">智能指针<sup>7</sup></a><a href="/tags/%E6%A0%91/" style="font-size: 0.88rem;">树<sup>1</sup></a><a href="/tags/%E6%A0%A1%E6%8B%9B/" style="font-size: 0.88rem;">校招<sup>1</sup></a><a href="/tags/%E6%A8%A1%E6%8B%9F/" style="font-size: 0.88rem;">模拟<sup>8</sup></a><a href="/tags/%E6%A8%A1%E6%9D%BF/" style="font-size: 0.88rem;">模板<sup>6</sup></a><a href="/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/" style="font-size: 0.88rem;">每日一题<sup>14</sup></a><a href="/tags/%E6%B1%87%E7%BC%96/" style="font-size: 0.88rem;">汇编<sup>1</sup></a><a href="/tags/%E6%BA%90%E7%A0%81/" style="font-size: 0.88rem;">源码<sup>2</sup></a><a href="/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/" style="font-size: 0.88rem;">滑动窗口<sup>1</sup></a><a href="/tags/%E7%AE%80%E5%8D%95/" style="font-size: 0.88rem;">简单<sup>7</sup></a><a href="/tags/%E7%BC%96%E8%AF%91/" style="font-size: 0.88rem;">编译<sup>1</sup></a><a href="/tags/%E8%84%91%E7%AD%8B%E6%80%A5%E8%BD%AC%E5%BC%AF/" style="font-size: 0.88rem;">脑筋急转弯<sup>1</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 0.88rem;">计算机网络<sup>8</sup></a><a href="/tags/%E8%B4%AA%E5%BF%83/" style="font-size: 0.88rem;">贪心<sup>3</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="Switch Between Traditional Chinese And Simplified Chinese">繁</button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Setting"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="7372688489" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;undefined&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div id="he-plugin-simple"></div><script>var WIDGET = {
  "CONFIG": {
    "modules": "0124",
    "background": "2",
    "tmpColor": "FFFFFF",
    "tmpSize": "16",
    "cityColor": "FFFFFF",
    "citySize": "16",
    "aqiColor": "E8D87B",
    "aqiSize": "16",
    "weatherIconSize": "24",
    "alertIconSize": "18",
    "padding": "10px 10px 10px 10px",
    "shadow": "0",
    "language": "auto",
    "borderRadius": "20",
    "fixed": "true",
    "vertical": "top",
    "horizontal": "left",
    "left": "20",
    "top": "7.1",
    "key": "df245676fb434a0691ead1c63341cd94"
  }
}
</script><link rel="stylesheet" href="https://widget.qweather.net/simple/static/css/he-simple.css?v=1.4.0"/><script src="https://widget.qweather.net/simple/static/js/he-simple.js?v=1.4.0"></script><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.4/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2021 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2021 By 安知鱼 V1.6.8",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 Hoshea Zhang 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.1/bubble/bubble.js"></script><script>var visitorMail = "visitor@anheyu.com";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script src="/js/anzhiyu/right_click_menu.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>