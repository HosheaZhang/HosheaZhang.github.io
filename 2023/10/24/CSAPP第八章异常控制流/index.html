<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>CSAPP第八章异常控制流 | Hoshea的主页</title><meta name="keywords" content="CSAPP"><meta name="author" content="Hoshea Zhang,542978210@qq.com"><meta name="copyright" content="Hoshea Zhang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="CSAPP第八章异常控制流"><meta name="application-name" content="CSAPP第八章异常控制流"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="CSAPP第八章异常控制流"><meta property="og:url" content="http://example.com/2023/10/24/CSAPP%E7%AC%AC%E5%85%AB%E7%AB%A0%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/index.html"><meta property="og:site_name" content="Hoshea的主页"><meta property="og:description" content="从给处理器加电开始，直到你断电为止，程序计数器假设一个值的序列a0,a1,⋯ ,an−1 其中，每个 a~k~ 是某个相应的指令 I~k~ 的地址。每次从 a~k~到 a~k+1~ 的过渡称为控制转移（control transfer）。这样的控制转移序列叫做处理器的控制流（flow of cont"><meta property="og:locale" content="en"><meta property="og:image" content="https://hoshea-1318436778.cos.ap-nanjing.myqcloud.com/imagebg_CSAPP.webp"><meta property="article:author" content="Hoshea Zhang"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://hoshea-1318436778.cos.ap-nanjing.myqcloud.com/imagebg_CSAPP.webp"><meta name="description" content="从给处理器加电开始，直到你断电为止，程序计数器假设一个值的序列a0,a1,⋯ ,an−1 其中，每个 a~k~ 是某个相应的指令 I~k~ 的地址。每次从 a~k~到 a~k+1~ 的过渡称为控制转移（control transfer）。这样的控制转移序列叫做处理器的控制流（flow of cont"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="http://example.com/2023/10/24/CSAPP%E7%AC%AC%E5%85%AB%E7%AB%A0%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/"><link rel="preconnect" href="//cdn.cbd.int"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/swiper/swiper.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2023/09/03/125766904/ee23df8517f3c3e3efc4145658269c06_5714860933110284659.png"},
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: {"enable":true,"default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 宝贝","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: 'hoshea-env-2gxt402g10c22211',
  commentBarrageConfig:undefined,
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: {"skills":null},
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: 'days',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"Author: Hoshea Zhang","link":"Link: ","source":"Source: Hoshea的主页","info":"Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source.","copySuccess":"Copy success, copy and reprint please mark the address of this article"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"Traditional Chinese Activated Manually","cht_to_chs":"Simplified Chinese Activated Manually","day_to_night":"Dark Mode Activated Manually","night_to_day":"Light Mode Activated Manually","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'Hoshea的主页',
  title: 'CSAPP第八章异常控制流',
  postAI: '',
  pageFillDescription: '异常, 异常处理, 异常的类别, 中断, 陷阱和系统调用, 故障, 终止, 进程, 逻辑控制流, 并发流, 私有地址空间, 用户模式和内核模式, 上下文切换, 系统调用错误处理, 进程控制, 获取进程id, 创建和终止进程, 回收子进程, 旁注 - 为什么已终止的子进程被称为僵死进程, 判定等待集合的成员, 修改默认行为, 检查已回收子进程的退出状态, 错误条件, wait, 进程休眠, 加载并运行程序, 利用fork或者execve运行程序, 信号, 术语, 发送信号, 进程组, 用/bin/kill发送信号, 从键盘发送信号, 用 kill 函数发送信号, 用alarm函数发送信号, 接收信号, 非本地跳转, 操作进程的工具从给处理器加电开始直到你断电为止程序计数器假设一个值的序列其中每个是某个相应的指令的地址每次从到的过渡称为控制转移这样的控制转移序列叫做处理器的控制流或系统也必须能够对系统状态的变化做出反应这些系统状态不是被内部程序变量捕获的而且也不一定要和程序的执行相关比如一个硬件定时器定期产生信号这个事件必须得到处理包到达网络适配器后必须存放在内存中程序向磁盘请求数据然后休眠直到被通知说数据已就绪当子进程终止时创造这些子进程的父进程必须得到通知现代系统通过使控制流发生突变来对这些情况做出反应一般而言我们把这些突变称为异常控制流异常控制流发生在计算机系统的各个层次比如在硬件层硬件检测到的事件会触发控制突然转移到异常处理程序在操作系统层内核通过上下文切换将控制从一个用户进程转移到另一个用户进程在应用层一个进程可以发送信号到另一个进程而接收者会将控制突然转移到它的一个信号处理程序个程序可以通过回避通常的栈规则并执行到其他函数中任意位置的非本地跳转来对错误做出反应作为程序员理解很重要这有很多原因理解将帮助你理解重要的系统概念是操作系统用来实现进程和虚拟内存的基本机制在能够真正理解这些重要概念之前你必须理解理解将帮助你理解应用程序是如何与操作系统交互的应用程序通过使用一个叫做陷阱或者系统调用的形式向操作系统请求服务比如向磁盘写数据从网络读取数据创建一个新进程以及终止当前进程都是通过应用程序调用系统调用来实现的理解基本的系统调用机制将帮助你理解这些服务是如何提供给应用的理解将帮助你编写有趣的新应用程序操作系统为应用程序提供了强大的机制用来创建新进程等待进程终止通知其他进程系统中的异常事件以及检测和响应这些事件如果理解了这些机制那么你就能用它们来编写诸如和服务器之类的有趣程序了理解将帮助你理解并发是计算机系统中实现并发的基本机制在运行中的并发的例子有中断应用程序执行的异常处理程序在时间上重叠执行的进程和线程以及中断应用程序执行的信号处理程序理解是理解并发的第一步我们会在第章中更详细地研究并发理解将帮助你理解软件异常如何工作像和这样的语言通过以及语句来提供软件异常机制软件异常允许程序进行非本地跳转即违反通常的调用返回栈规则的跳转来响应错误情况非本地跳转是一种应用层在中是通过和函数提供的理解这些低级函数将帮助你理解高级软件异常如何得以实现异常异常是异常控制流的一种形式它一部分由硬件实现一部分由操作系统实现因为它们有一部分是由硬件实现的所以具体细节将随系统的不同而有所不同然而对于每个系统而言基本的思想都是相同的在这一节中我们的目的是让你对异常和异常处理有一个一般性的了解并且向你揭示现代计算机系统的一个经常令人感到迷惑的方面异常就是控制流中的突变用来响应处理器状态中的某些变化下图展示了基本的思想在图中当处理器状态中发生一个重要的变化时处理器正在执行某个当前指令在处理器中状态被编码为不同的位和信号状态变化称为事件事件可能和当前指令的执行直接相关比如发生虚拟内存缺页算术溢出或者一条指令试图除以零另一方面事件也可能和当前指令的执行没有关系比如一个系统定时器产生信号或者一个请求完成在任何情况下当处理器检测到有事件发生时它就会通过一张叫做异常表的跳转表进行一个间接过程调用异常到一个专门设计用来处理这类事件的操作系统子程序异常处理程序当异常处理程序完成处理后根据引起异常的事件的类型会发生以下种情况中的一种处理程序将控制返回给当前指令即当事件发生时正在执行的指令处理程序将控制返回给如果没有发生异常将会执行的下一条指令处理程序终止被中断的程序异常处理异常可能会难以理解因为处理异常需要硬件和软件紧密合作很容易搞混哪个部分执行哪个任务让我们更详细地来看看硬件和软件的分工吧系统中可能的每种类型的异常都分配了一个唯一的非负整数的异常号其中一些号码是由处理器的设计者分配的其他号码是由操作系统内核操作系统常驻内存的部分的设计者分配的前者的示例包括被零除缺页内存访问违例断点以及算术运算溢出后者的示例包括系统调用和来自外部设备的信号在系统启动时当计算机重启或者加电时操作系统分配和初始化一张称为异常表的跳转表使得表目包含异常的处理程序的地址下图展示了异常表的格式在运行时当系统在执行某个程序时处理器检测到发生了一个事件并且确定了相应的异常号随后处理器触发异常方法是执行间接过程调用通过异常表的表目转到相应的处理程序下图展示了处理器如何使用异常表来形成适当的异常处理程序的地址异常号是到异常表中的索引异常表的起始地址放在一个叫做异常表基址寄存器的特殊寄存器里异常类似于过程调用但是有一些重要的不同之处过程调用时在跳转到处理程序之前处理器将返回地址压入栈中然而根据异常的类型返回地址要么是当前指令当事件发生时正在执行的指令要么是下一条指令如果事件不发生将会在当前指令后执行的指令处理器也把一些额外的处理器状态压到栈里在处理程序返回时重新开始执行被中断的程序会需要这些状态比如系统会将包含当前条件码的寄存器和其他内容压入栈中如果控制从用户程序转移到内核所有这些项目都被压到内核栈中而不是压到用户栈中异常处理程序运行在内核模式下见节这意味着它们对所有的系统资源都有完全的访问权限一旦硬件触发了异常剩下的工作就是由异常处理程序在软件中完成在处理程序处理完事件之后它通过执行一条特殊的从中断返回指令可选地返回到被中断的程序该指令将适当的状态弹回到处理器的控制和数据寄存器中如果异常中断的是一个用户程序就将状态恢复为用户模式见节然后将控制返回给被中断的程序异常的类别异常可以分为四类中断陷阱故障和终止图中的表对这些类别的属性做了小结类别原因异步同步返回行为中断来自设备的信号异步总是返回到下一条指令陷阱有意的异常同步总是返回到下一条指令故障潜在可恢复的错误同步可能返回到当前指令终止不可恢复的错误同步不会返回中断中断是异步发生的是来自处理器外部的设备的信号的结果硬件中断不是由任何一条专门的指令造成的从这个意义上来说它是异步的硬件中断的异常处理程序常常称为中断处理程序下图概述了一个中断的处理设备例如网络适配器磁盘控制器和定时器芯片通过向处理器芯片上的一个引脚发信号并将异常号放到系统总线上来触发中断这个异常号标识了引起中断的设备在当前指令完成执行之后处理器注意到中断引脚的电压变高了就从系统总线读取异常号然后调用适当的中断处理程序当处理程序返回时它就将控制返回给下一条指令也即如果没有发生中断在控制流中会在当前指令之后的那条指令结果是程序继续执行就好像没有发生过中断一样剩下的异常类型陷阱故障和终止是同步发生的是执行当前指令的结果我们把这类指令叫做故障指令陷阱和系统调用陷阱是有意的异常是执行一条指令的结果就像中断处理程序一样陷阱处理程序将控制返回到下一条指令陷阱最重要的用途是在用户程序和内核之间提供一个像过程一样的接口叫做系统调用用户程序经常需要向内核请求服务比如读一个文件创建一个新的进程加载一个新的程序或者终止当前进程为了允许对这些内核服务的受控的访问处理器提供了一条特殊的指令当用户程序想要请求服务时可以执行这条指令执行指令会导致一个到异常处理程序的陷阱这个处理程序解析参数并调用适当的内核程序故障故障由错误情况引起它可能能够被故障处理程序修正当故障发生时处理器将控制转移给故障处理程序如果处理程序能够修正这个错误情况它就将控制返回到引起故障的指令从而重新执行它否则处理程序返回到内核中的例程例程会终止引起故障的应用程序一个经典的故障示例是缺页异常当指令引用一个虚拟地址而与该地址相对应的物理页面不在内存中因此必须从磁盘中取出时就会发生故障就像我们将在第章中看到的那样一个页面就是虚拟内存的一个连续的块典型的是缺页处理程序从磁盘加载适当的页面然后将控制返回给引起故障的指令当指令再次执行时相应的物理页面已经驻留在内存中了指令就可以没有故障地运行完成了终止终止是不可恢复的致命错误造成的结果通常是一些硬件错误比如或者位被损坏时发生的奇偶错误终止处理程序从不将控制返回给应用程序如图所示处理程序将控制返回给一个例程该例程会终止这个应用程序进程异常是允许操作系统内核提供进程概念的基本构造块进程是计算机科学中最深刻最成功的概念之一在现代系统上运行一个程序时我们会得到一个假象就好像我们的程序是系统中当前运行的唯一的程序一样我们的程序好像是独占地使用处理器和内存处理器就好像是无间断地一条接一条地执行我们程序中的指令最后我们程序中的代码和数据好像是系统内存中唯一的对象这些假象都是通过进程的概念提供给我们的进程的经典定义就是一个执行中程序的实例系统中的每个程序都运行在某个进程的上下文中上下文是由程序正确运行所需的状态组成的这个状态包括存放在内存中的程序的代码和数据它的栈通用目的寄存器的内容程序计数器环境变量以及打开文件描述符的集合每次用户通过向输入一个可执行目标文件的名字运行程序时就会创建一个新的进程然后在这个新进程的上下文中运行这个可执行目标文件应用程序也能够创建新进程并且在这个新进程的上下文中运行它们自己的代码或其他应用程序关于操作系统如何实现进程的细节的讨论超出了本书的范围反之我们将关注进程提供给应用程序的关键抽象一个独立的逻辑控制流它提供一个假象好像我们的程序独占地使用处理器一个私有的地址空间它提供一个假象好像我们的程序独占地使用内存系统让我们更深入地看看这些抽象逻辑控制流即使在系统中通常有许多其他程序在运行像它在独占地使用处理器如果想用调试器单步执行程序我们会看到一系列的程序计数器的值这些值唯一地对应于包含在程序的可执行目标文件中的指令或是包含在运行时动态链接到程序的共享对象中的指令这个值的序列叫做逻辑控制流或者简称逻辑流考虑一个运行着三个进程的系统如下图所示处理器的一个物理控制流被分成了三个逻辑流每个进程一个图中每个竖直的条表示一个进程的逻辑流的一部分在这个例子中三个逻辑流的执行是交错的进程运行了一会儿然后是进程开始运行到完成然后进程运行了一会儿进程接着运行直到完成最后进程可以运行到结束了下图的关键点在于进程是轮流使用处理器的每个进程执行它的流的一部分然后被抢占暂时挂起然后轮到其他进程对于一个运行在这些进程之一的上下文中的程序它看上去就像是在独占地使用处理器唯一的反面例证是如果我们精确地测量每条指令使用的时间会发现在程序中一些指令的执行之间好像会周期性地停顿然而每次处理器停顿它随后会继续执行我们的程序并不改变程序内存位置或寄存器的内容并发流计算机系统中逻辑流有许多不同的形式异常处理程序进程信号处理程序线程和进程都是逻辑流的例子一个逻辑流的执行在时间上与另一个流重叠称为并发流这两个流被称为并发地运行更准确地说流和互相并发当且仅当在开始之后和结束之前开始或者在开始之后和结束之前开始例如图中进程和并发地运行和也一样另一方面和没有并发地运行因为的最后一条指令在的第一条指令之前执行多个流并发地执行的一般现象被称为并发一个进程和其他进程轮流运行的概念称为多任务一个进程执行它的控制流的一部分的每一时间段叫做时间片因此多任务也叫做时间分片例如上图中进程的流由两个时间片组成注意并发流的思想与流运行的处理器核数或者计算机数无关如果两个流在时间上重叠那么它们就是并发的即使它们是运行在同一个处理器上不过有时我们会发现确认并行流是很有帮助的它是并发流的一个真子集如果两个流并发地运行在不同的处理器核或者计算机上那么我们称它们为并行流它们并行地运行且并行地执行私有地址空间进程也为每个程序提供一种假象好像它独占地使用系统地址空间在一台位地址的机器上地址空间是个可能地址的集合进程为每个程序提供它自己的私有地址空间一般而言和这个空间中某个地址相关联的那个内存字节是不能被其他进程读或者写的从这个意义上说这个地址空间是私有的尽管和每个私有地址空间相关联的内存的内容一般是不同的但是每个这样的空间都有相同的通用结构比如图展示了一个进程的地址空间的组织结构地址空间底部是保留给用户程序的包括通常的代码数据堆和栈段代码段总是从地址开始地址空间顶部保留给内核操作系统常驻内存的部分地址空间的这个部分包含内核在代表进程执行指令时比如当应用程序执行系统调用时使用的代码数据和栈用户模式和内核模式为了使操作系统内核提供一个无懈可击的进程抽象处理器必须提供一种机制限制一个应用可以执行的指令以及它可以访问的地址空间范围处理器通常是用某个控制寄存器中的一个模式位来提供这种功能的该寄存器描述了进程当前享有的特权当设置了模式位时进程就运行在内核模式中有时叫做超级用户模式一个运行在内核模式的进程可以执行指令集中的任何指令并且可以访问系统中的任何内存位置没有设置模式位时进程就运行在用户模式中用户模式中的进程不允许执行特权指令比如停止处理器改变模式位或者发起一个操作也不允许用户模式中的进程直接引用地址空间中内核区内的代码和数据任何这样的尝试都会导致致命的保护故障反之用户程序必须通过系统调用接口间接地访问内核代码和数据运行应用程序代码的进程初始时是在用户模式中的进程从用户模式变为内核模式的唯一方法是通过诸如中断故障或者陷入系统调用这样的异常当异常发生时控制传递到异常处理程序处理器将模式从用户模式变为内核模式处理程序运行在内核模式中当它返回到应用程序代码时处理器就把模式从内核模式改回到用户模式提供了一种聪明的机制叫做文件系统它允许用户模式进程访问内核数据结构的内容文件系统将许多内核数据结构的内容输出为一个用户程序可以读的文本文件的层次结构比如你可以使用文件系统找出一般的系统属性比如类型或者某个特殊的进程使用的内存段版本的内核引入文件系统它输岀关于系统总线和设备的额外的低层信息上下文切换操作系统内核使用一种称为上下文切换的较高层形式的异常控制流来实现多任务上下文切换机制是建立在节中已经讨论过的那些较低层异常机制之上的内核为每个进程维持一个上下文上下文就是内核重新启动一个被抢占的进程所需的状态它由一些对象的值组成这些对象包括通用目的寄存器浮点寄存器程序计数器用户栈状态寄存器内核栈和各种内核数据结构比如描述地址空间的页表包含有关当前进程信息的进程表以及包含进程已打开文件的信息的文件表在进程执行的某些时刻内核可以决定抢占当前进程并重新开始一个先前被抢占了的进程这种决策就叫做调度是由内核中称为调度器的代码处理的当内核选择一个新的进程运行时我们说内核调度了这个进程在内核调度了一个新的进程运行后它就抢占当前进程并使用一种称为上下文切换的机制来将控制转移到新的进程上下文切换保存当前进程的上下文恢复某个先前被抢占的进程被保存的上下文将控制传递给这个新恢复的进程当内核代表用户执行系统调用时可能会发生上下文切换如果系统调用因为等待某个事件发生而阻塞那么内核可以让当前进程休眠切换到另一个进程比如如果一个系统调用需要访问磁盘内核可以选择执行上下文切换运行另外一个进程而不是等待数据从磁盘到达另一个示例是系统调用它显式地请求让调用进程休眠一般而言即使系统调用没有阻塞内核也可以决定执行上下文切换而不是将控制返回给调用进程中断也可能引发上下文切换比如所有的系统都有某种产生周期性定时器中断的机制通常为每毫秒或每毫秒每次发生定时器中断时内核就能判定当前进程已经运行了足够长的时间并切换到一个新的进程下图展示了一对进程和之间上下文切换的示例在这个例子中进程初始运行在用户模式中直到它通过执行系统调用陷入到内核内核中的陷阱处理程序请求来自磁盘控制器的传输并且安排在磁盘控制器完成从磁盘到内存的数据传输后磁盘中断处理器磁盘取数据要用一段相对较长的时间数量级为几十毫秒所以内核执行从进程到进程的上下文切换而不是在这个间歇时间内等待什么都不做注意在切换之前内核正代表进程在用户模式下执行指令即没有单独的内核进程在切换的第一部分中内核代表进程在内核模式下执行指令然后在某一时刻它开始代表进程仍然是内核模式下执行指令在切换之后内核代表进程在用户模式下执行指令随后进程在用户模式下运行一会儿直到磁盘发出一个中断信号表示数据已经从磁盘传送到了内存内核判定进程已经运行了足够长的时间就执行一个从进程到进程的上下文切换将控制返回给进程中紧随在系统调用之后的那条指令进程继续运行直到下一次异常发生依此类推系统调用错误处理当系统级函数遇到错误时它们通常会返回并设置全局整数变量来表示什么出错了程序员应该总是检査错误但是不幸的是许多人都忽略了错误检查因为它使代码变得臃肿而且难以读懂比如下面是我们调用函数时会如何检査错误函数返回一个文本串描述了和某个值相关联的错误通过定义下面的错误报告函数我们能够在某种程度上简化这个代码给定这个函数我们对的调用从行缩减到行通过使用错误处理包装函数我们可以更进一步地简化代码在中首先提出了这种方法对于一个给定的基本函数我们定义一个具有相同参数的包装函数但是第一个字母大写了包装函数调用基本函数检査错误如果有任何问题就终止比如下面是函数的错误处理包装函数给定这个包装函数我们对的调用就缩减为行进程控制获取进程每个进程都有一个唯一的正数非零进程函数返回调用进程的函数返回它的父进程的创建调用进程的进程返回调用者或其父进程的和函数返回一个类型为的整数值在系统上它在中被定义为创建和终止进程从程序员的角度我们可以认为进程总是处于下面三种状态之一运行进程要么在上执行要么在等待被执行且最终会被内核调度停止进程的执行被挂起且不会被调度当收到或者信号时进程就停止并且保持停止直到它收到一个信号在这个时刻进程再次开始运行信号是一种软件中断的形式将在节中详细描述终止进程永远地停止了进程会因为三种原因终止收到一个信号该信号的默认行为是终止进程从主程序返回调用函数该函数不返回父进程通过调用函数创建一个新的运行的子进程返回子进程返回父进程返回子进程的如果出错则为新创建的子进程几乎但不完全与父进程相同子进程得到与父进程用户级虚拟地址空间相同的但是独立的一份副本包括代码和数据段堆共享库以及用户栈子进程还获得与父进程任何打开文件描述符相同的副本这就意味着当父进程调用时子进程可以读写父进程中打开的任何文件父进程和新创建的子进程之间最大的区别在于它们有不同的函数是有趣的也常常令人迷惑因为它只被调用一次却会返回两次一次是在调用进程父进程中一次是在新创建的子进程中在父进程中返回子进程的在子进程中返回因为子进程的总是为非零返回值就提供一个明确的方法来分辨程序是在父进程还是在子进程中执行下面的代码展示了一个使用创建子进程的父进程的示例当调用在第行返回时在父进程和子进程中的值都为子进程在第行加一并输出它的的副本相似地父进程在第行减一并输出它的的副本调用一次返回两次函数被父进程调用一次但是却返回两次一次是返回到父进程一次是返回到新创建的子进程对于只创建一个子进程的程序来说这还是相当简单直接的但是具有多个实例的程序可能就会令人迷惑需要仔细地推敲了并发执行父进程和子进程是并发运行的独立进程内核能够以任意方式交替执行它们的逻辑控制流中的指令在我们的系统上运行这个程序时父进程先完成它的语句然后是子进程然而在另一个系统上可能正好相反一般而言作为程序员我们决不能对不同进程中指令的交替执行做任何假设相同但是独立的地址空间如果能够在函数在父进程和子进程中返回后立即暂停这两个进程我们会看到两个进程的地址空间都是相同的每个进程有相同的用户栈相同的本地变量值相同的堆相同的全局变量值以及相同的代码因此在我们的示例程序中当函数在第行返回时本地变量在父进程和子进程中都为然而因为父进程和子进程是独立的进程它们都有自己的私有地址空间后面父进程和子进程对所做的任何改变都是独立的不会反映在另一个进程的内存中这就是为什么当父进程和子进程调用它们各自的语句时它们中的变量会有不同的值共享文件当运行这个示例程序时我们注意到父进程和子进程都把它们的输出显示在屏幕上原因是子进程继承了父进程所有的打开文件当父进程调用时文件是打开的并指向屏幕子进程继承了这个文件因此它的输出也是指向屏幕的进程图特别有助于理解带有嵌套调用的程序例如下图中的程序源码中两次调用了对应的进程图可帮助我们看清这个程序运行了四个进程每个都调用了次这些可以以任意顺序执行回收子进程当一个进程由于某种原因终止时内核并不是立即把它从系统中清除相反进程被保持在一种已终止的状态中直到被它的父进程回收当父进程回收已终止的子进程时内核将子进程的退出状态传递给父进程然后抛弃已终止的进程从此时开始该进程就不存在了一个终止了但还未被回收的进程称为僵死进程旁注为什么已终止的子进程被称为僵死进程在民间传说中僵尸是活着的尸体一种半生半死的实体僵死进程已经终止了而内核仍保留着它的某些状态直到父进程回收它为止从这个意义上说它们是类似的如果一个父进程终止了内核会安排进程成为它的孤儿进程的养父进程的为是在系统启动时由内核创建的它不会终止是所有进程的祖先如果父进程没有回收它的僵死子进程就终止了那么内核会安排进程去回收它们不过长时间运行的程序比如或者服务器总是应该回收它们的僵死子进程即使僵死子进程没有运行它们仍然消耗系统的内存资源一个进程可以通过调用函数来等待它的子进程终止或者停止返回如果成功则为子进程的如果则为如果其他错误则为函数有点复杂默认情况下当时挂起调用进程的执行直到它的等待集合中的一个子进程终止如果等待集合中的一个进程在刚调用的时刻就已经终止了那么就立即返回在这两种情况中返回导致返回的已终止子进程的此时已终止的子进程已经被回收内核会从系统中删除掉它的所有痕迹判定等待集合的成员等待集合的成员是由参数来确定的如果那么等待集合就是一个单独的子进程它的进程等于如果那么等待集合就是由父进程所有的子进程组成的函数还支持其他类型的等待集合包括进程组对此我们将不做讨论修改默认行为可以通过将设置为常量和的各种组合来修改默认行为如果等待集合中的任何子进程都还没有终止那么就立即返回返回值为默认的行为是挂起调用进程直到有子进程终止在等待子进程终止的同时如果还想做些有用的工作这个选项会有用挂起调用进程的执行直到等待集合中的一个进程变成已终止或者被停止返回的为导致返回的已终止或被停止子进程的默认的行为是只返回已终止的子进程当你想要检査已终止和被停止的子进程时这个选项会有用挂起调用进程的执行直到等待集合中一个正在运行的进程终止或等待集合中一个被停止的进程收到信号重新开始执行节会解释这些信号可以用或运算把这些选项组合起来例如立即返回如果等待集合中的子进程都没有被停止或终止则返回值为如果有一个停止或终止则返回值为该子进程的检查已回收子进程的退出状态如果参数是非空的那么就会在中放上关于导致返回的子进程的状态信息是指向的值头文件定义了解释参数的几个宏如果于进程通过调用或者一个返回正常终止就返回真返回一令正常终止的子进程的退出状态只有在返回为真时才会定义这个状态如果子进程是因为一个未被捕获的信号终止的那么就返回真返回导致子进程终止的信号的编号只有在返回为真时才定义这个状态如果引起返回的子进程当前是停止的那么就返回真返回引起子进程停止的信号的编号只有在返回为真时才定义这个状态如果子进程收到信号重新启动则返回真错误条件如果调用进程没有子进程那么返回并且设置为如果函数被一个信号中断那么它返回并设置为返回如果成功则为子进程的如果出错则为进程休眠返回还要休眠的秒数如果请求的时间量已经到了返回否则返回还剩下的要休眠的秒数后一种情况是可能的如果因为函数被一个信号中断而过早地返回我们将在节中详细讨论信号我们会发现另一个很有用的函数是函数该函数让调用函数休眠直到该进程收到一个信号总是返回加载并运行程序函数在当前进程的上下文中加载并运行一个新程序如果成功则不返回如果错误则返回函数加载并运行可执行目标文件且带参数列表和环境变量列表只有当出现错误时例如找不到才会返回到调用程序所以与次调用返回两次不同调用一次并从不返回参数列表是用下图中的数据结构表示的变量指向一个以结尾的指针数组其中每个指针都指向一个参数字符串按照惯例是可执行目标文件的名字环境变量的列表是由一个类似的数据结构表示的如图所示变量指向一个以结尾的指针数组其中每个指针指向一个环境变量字符串每个串都是形如的名字值对在加载了之后它调用节中描述的启动代码启动代码设置栈并将控制传递给新程序的主函数该主函数有如下形式的原型或者等价的确认一下你理解了程序和进程之间的区别程序是一堆代码和数据程序可以作为目标文件存在于磁盘上或者作为段存在于地址空间中进程是执行中程序的一个具体的实例程序总是运行在某个进程的上下文中如果你想要理解和函数理解这个差异是很重要的函数在新的子进程中运行相同的程序新的子进程是父进程的一个复制品函数在当前进程的上下文中加载并运行一个新的程序它会覆盖当前进程的地址空间但并没有创建一个新进程新的程序仍然有相同的并且继承了调用函数时已打开的所有文件描述符利用或者运行程序像和服务器这样的程序大量使用了和函数是一个交互型的应用级程序它代表用户运行其他程序最早的是程序后面出现了些变种比如和执行一系列的读求值步骤然后终止读步骤读取来自用户的一个命令行求值步骤解析命令行并代表用户运行程序下面展示了一个简单的例程打印一个命令行提示符等待用户在上输入命令行然后对这个命令行求值注意这个简单的是有缺陷的因为它并不回收它的后台子进程修改这个缺陷就要求使用信号我们将在下一节中讲述信号信号到目前为止对异常控制流的学习中我们已经看到了硬件和软件是如何合作以提供基本的低层异常机制的我们也看到了操作系统如何利用异常来支持进程上下文切换的异常控制流形式在本节中我们将研究一种更高层的软件形式的异常称为信号它允许进程和内核中断其他进程一个信号就是一条小消息它通知进程系统中发生了一个某种类型的事件比如下图展示了系统上支持的种不同类型的信号每种信号类型都对应于某种系统事件低层的硬件异常是由内核异常处理程序处理的正常情况下对用户进程而言是不可见的信号提供了一种机制通知用户进程发生了这些异常比如如果一个进程试图除以那么内核就发送给它一个信号号码如果一个进程执行一条非法指令那么内核就发送给它一个信号号码如果进程进行非法内存引用内核就发送给它一个信号号码其他信号对应于内核或者其他用户进程中较高层的软件事件比如如果当进程在前台运行时你键入也就是同时按下键和键那么内核就会发送一个信号号码给这个前台进程组中的每个进程一个进程可以通过向另一个进程发送一个信号号码强制终止它当一个子进程终止或者停止时内核会发送一个信号号码给父进程序号名称默认行为相应事件终止终端线挂断终止来自键盘的中断终止来自键盘的退出终止非法指令终止并转储内存跟踪陷阱终止并转储内存来自函数的终止信号终止总线错误终止并转储内存浮点异常终止杀死程序终止用户定义的信号终止并转储内存无效的内存引用段故障终止用户定义的信号终止向一个没有读用户的管道做写操作终止来自函数的定时器信号终止软件终止信号终止协处理器上的栈故障忽略一个子进程停止或者终止忽略继续进程如果该进程停止停止直到下一个不是来自终端的停止信号停止直到下一个来自终端的停止信号停止直到下一个后台进程从终端读停止直到下一个后台进程向终端写忽略套接字上的紧急情况终止时间限制超出终止文件大小限制超出终止虚拟定时器期满终止剖析定时器期满忽略窗口大小变化终止在某个描述符上可执行操作终止电源故障术语传送一个信号到目的进程是由两个不同步骤组成的发送信号内核通过更新目的进程上下文中的某个状态发送递送一个信号给目的进程发送信号可以有如下两种原因内核检测到一个系统事件比如除零错误或者子进程终止一个进程调用了函数在下一节中讨论显式地要求内核发送一个信号给目的进程一个进程可以发送信号给它自己接收信号当目的进程被内核强迫以某种方式对信号的发送做出反应时它就接收了信号进程可以忽略这个信号终止或者通过执行一个称为信号处理程序的用户层函数捕获这个信号给出了信号处理程序捕获信号的基本思想发送信号系统提供了大量向进程发送信号的机制所有这些机制都是基于进程组这个概念的进程组每个进程都只属于一个进程组进程组是由一个正整数进程组来标识的函数返回当前进程的进程组返回调用进程的进程组默认地一个子进程和它的父进程同属于一个进程组一个进程可以通过使用函数来改变自己或者其他进程的进程组返回若成功则为若错误则为函数将进程的进程组改为如果是那么就使用当前进程的如果是那么就用指定的进程的作为进程组例如如果进程是调用进程那么会创建一个新的进程组其进程组是并且把进程加入到这个新的进程组中用发送信号程序可以向另外的进程发送任意的信号比如命令发送信号给进程一个为负的会导致信号被发送到进程组中的每个进程比如命令发送一个信号给进程组中的每个进程注意在此我们使用完整路径因为有些有自己内置的命令从键盘发送信号使用作业这个抽象概念来表示为对一条命令行求值而创建的进程在任何时刻至多只有一个前台作业和个或多个后台作业比如键入会创建一个由两个进程组成的前台作业这两个进程是通过管道连接起来的一个进程运行程序另一个运行程序为每个作业创建一个独立的进程组进程组通常取自作业中父进程中的一个比如图展示了有一个前台作业和两个后台作业的前台作业中的父进程为进程组也为父进程创建两个子进程每个也都是进程组的成员用函数发送信号进程通过调用函数发送信号给其他进程包括它们自己返回若成功则为若错误则为如果大于零那么函数发送信号号码给进程如果等于零那么发送信号给调用进程所在进程组中的每个进程包括调用进程自己如果小于零发送信号给进程组的绝对值中的每个进程下图展示了一个示例父进程用函数发送信号给它的子进程用函数发送信号进程可以通过调用函数向它自己发送信号返回前一次闹钟剩余的秒数若以前没有设定闹钟则为函数安排内核在秒后发送一个信号给调用进程如果是零那么不会调度安排新的闹钟在任何情况下对的调用都将取消任何待处理的闹钟并且返回任何待处理的闹钟在被发送前还剩下的秒数如果这次对的调用没有取消它的话如果没有任何待处理的闹钟就返回零接收信号当内核把进程从内核模式切换到用户模式时例如从系统调用返回或是完成了一次上下文切换它会检查进程的未被阻塞的待处理信号的集合如果这个集合为空通常情况下那么内核将控制传递到的逻辑控制流中的下一条指令然而如果集合是非空的那么内核选择集合中的某个信号通常是最小的并且强制接收信号收到这个信号会触发进程采取某种行为一旦进程完成了这个行为那么控制就传递回的逻辑控制流中的下一条指令每个信号类型都有一个预定义的默认行为是下面中的一种进程终止进程终止并转储内存进程停止挂起直到被信号重启进程忽略该信号进程可以通过使用函数修改和信号相关联的默认行为唯一的例外是和它们的默认行为是不能修改的返回若成功则为指向前次处理程序的指针若出错则为不设置函数可以通过下列三种方法之一来改变和信号相关联的行为如果是那么忽略类型为的信号如果是那么类型为的信号行为恢复为默认行为否则就是用户定义的函数的地址这个函数被称为信号处理程序只要进程接收到一个类型为的信号就会调用这个程序通过把处理程序的地址传递到函数从而改变默认行为这叫做设置信号处理程序调用信号处理程序被称为捕获信号执行信号处理程序被称为处理信号非本地跳转语言提供了一种用户级异常控制流形式称为非本地跳转它将控制直接从一个函数转移到另一个当前正在执行的函数而不需要经过正常的调用返回序列非本地跳转是通过和函数来提供的返回返回返回非零函数在缓冲区中保存当前调用环境以供后面的使用并返回调用环境包括程序计数器栈指针和通用目的寄存器岀于某种超出本书描述范围的原因返回的值不能被赋值给变量从不返回函数从缓冲区中恢复调用环境然后触发一个从最近一次初始化的调用的返回然后返回并带有非零的返回值第一眼看过去和之间的相互关系令人迷惑函数只被调用一次但返回多次一次是当第一次调用而调用环境保存在缓冲区中时一次是为每个相应的调用另一方面函数被调用一次但从不返回非本地跳转的一个重要应用就是允许从一个深层嵌套的函数调用中立即返回通常是由检测到某个错误情况引起的如果在一个深层嵌套的函数调用中发现了一个错误情况我们可以使用非本地跳转直接返回到一个普通的本地化的错误处理程序而不是费力地解开调用栈图展示了一个示例说明这可能是如何工作的函数首先调用以保存当前的调用环境然后调用函数依次调用函数如果或者遇到一个错误它们立即通过一次调用从返回的非零返回值指明了错误类型随后可以被解码且在代码中的某个位置进行处理操作进程的工具系统提供了大量的监控和操作进程的有用工具打印一个正在运行的程序和它的子进程调用的每个系统调用的轨迹对于好奇的学生而言这是一个令人着迷的工具用编译你的程序能得到一个更干净的不带有大量与共享库相关的输出的轨迹列出当前系统中的进程包括僵死进程打印出关于当前进程资源使用的信息显示进程的内存映射一个虚拟文件系统以文本格式输出大量内核数据结构的内容用户程序可以读取这些内容比如输入可以看到你的系统上当前的平均负载',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-10-25 11:10:17',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://npm.elemecdn.com/anzhiyu-blog-static@1.0.4/img/avatar.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://hosheazhang.github.io/" title="博客"><img class="back-menu-item-icon" src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://github.com/HosheaZhang/cmu15445" title="cmu15445"><img class="back-menu-item-icon" src="https://image.anheyu.com/favicon.ico" alt="cmu15445"/><span class="back-menu-item-text">cmu15445</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">Hoshea的主页</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button only-home" id="travellings_button" title="随机前往一个开往项目网站"><a class="site-page" onclick="anzhiyu.totraveling()" title="随机前往一个开往项目网站" href="javascript:void(0);" rel="external nofollow" data-pjax-state="external"><i class="anzhiyufont anzhiyu-icon-train"></i></a></div><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> Newest Comments</span></div><div class="aside-list"><span>loading...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/360/" style="font-size: 1.05rem;">360<sup>2</sup></a><a href="/tags/C/" style="font-size: 1.05rem;">C++<sup>6</sup></a><a href="/tags/CMU15445/" style="font-size: 1.05rem;">CMU15445<sup>2</sup></a><a href="/tags/CMake/" style="font-size: 1.05rem;">CMake<sup>1</sup></a><a href="/tags/CSAPP/" style="font-size: 1.05rem;">CSAPP<sup>9</sup></a><a href="/tags/MYSQL/" style="font-size: 1.05rem;">MYSQL<sup>6</sup></a><a href="/tags/VSCODE/" style="font-size: 1.05rem;">VSCODE<sup>1</sup></a><a href="/tags/dfs/" style="font-size: 1.05rem;">dfs<sup>1</sup></a><a href="/tags/gdb/" style="font-size: 1.05rem;">gdb<sup>1</sup></a><a href="/tags/git/" style="font-size: 1.05rem;">git<sup>1</sup></a><a href="/tags/github/" style="font-size: 1.05rem;">github<sup>1</sup></a><a href="/tags/linux/" style="font-size: 1.05rem;">linux<sup>6</sup></a><a href="/tags/markdown/" style="font-size: 1.05rem;">markdown<sup>1</sup></a><a href="/tags/ssh/" style="font-size: 1.05rem;">ssh<sup>1</sup></a><a href="/tags/workflow/" style="font-size: 1.05rem;">workflow<sup>3</sup></a><a href="/tags/%E4%B8%AD%E7%AD%89/" style="font-size: 1.05rem;">中等<sup>9</sup></a><a href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" style="font-size: 1.05rem;">动态规划<sup>2</sup></a><a href="/tags/%E5%91%A8%E8%B5%9B/" style="font-size: 1.05rem;">周赛<sup>9</sup></a><a href="/tags/%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/" style="font-size: 1.05rem;">学习计划<sup>1</sup></a><a href="/tags/%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3/" style="font-size: 1.05rem;">报错解决<sup>4</sup></a><a href="/tags/%E6%A0%A1%E6%8B%9B/" style="font-size: 1.05rem;">校招<sup>1</sup></a><a href="/tags/%E6%A8%A1%E6%8B%9F/" style="font-size: 1.05rem;">模拟<sup>7</sup></a><a href="/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/" style="font-size: 1.05rem;">每日一题<sup>4</sup></a><a href="/tags/%E6%B1%87%E7%BC%96/" style="font-size: 1.05rem;">汇编<sup>1</sup></a><a href="/tags/%E6%BA%90%E7%A0%81/" style="font-size: 1.05rem;">源码<sup>2</sup></a><a href="/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/" style="font-size: 1.05rem;">滑动窗口<sup>1</sup></a><a href="/tags/%E7%AE%80%E5%8D%95/" style="font-size: 1.05rem;">简单<sup>4</sup></a><a href="/tags/%E7%BC%96%E8%AF%91/" style="font-size: 1.05rem;">编译<sup>1</sup></a><a href="/tags/%E8%84%91%E7%AD%8B%E6%80%A5%E8%BD%AC%E5%BC%AF/" style="font-size: 1.05rem;">脑筋急转弯<sup>1</sup></a><a href="/tags/%E8%B4%AA%E5%BF%83/" style="font-size: 1.05rem;">贪心<sup>2</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>Archives</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/10/"><span class="card-archive-list-date">October 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">44</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2022/10/"><span class="card-archive-list-date">October 2022</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2022/07/"><span class="card-archive-list-date">July 2022</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">4</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2022/04/"><span class="card-archive-list-date">April 2022</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">7</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item on" id="consoleCommentBarrage" onclick="anzhiyu.switchCommentBarrage()" title="热评开关"><a class="commentBarrage"><i class="anzhiyufont anzhiyu-icon-message"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BB%8F%E5%85%B8%E4%B9%A6%E7%B1%8D%E5%AD%A6%E4%B9%A0/" itemprop="url">经典书籍学习</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/CSAPP/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>CSAPP</span></a></span></div></div><h1 class="post-title" itemprop="name headline">CSAPP第八章异常控制流</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2023-10-24T12:50:25.000Z" title="Created 2023-10-24 20:50:25">2023-10-24</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2023-10-25T03:10:17.946Z" title="Updated 2023-10-25 11:10:17">2023-10-25</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-wordcount"><i class="anzhiyufont anzhiyu-icon-file-word post-meta-icon" title="文章字数"></i><span class="post-meta-label" title="文章字数">Word count:</span><span class="word-count" title="文章字数">15.1k</span><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-clock post-meta-icon" title="阅读时长"></i><span class="post-meta-label" title="阅读时长">Reading time:</span><span>48min</span></span><span class="post-meta-separator"></span><span class="post-meta-pv-cv" id="" data-flag-title="CSAPP第八章异常控制流"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">Post View:</span><span id="busuanzi_value_page_pv"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为南京"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>南京</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://hoshea-1318436778.cos.ap-nanjing.myqcloud.com/imagebg_CSAPP.webp"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="http://example.com/2023/10/24/CSAPP%E7%AC%AC%E5%85%AB%E7%AB%A0%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/"><header><a class="post-meta-categories" href="/categories/%E7%BB%8F%E5%85%B8%E4%B9%A6%E7%B1%8D%E5%AD%A6%E4%B9%A0/" itemprop="url">经典书籍学习</a><a href="/tags/CSAPP/" tabindex="-1" itemprop="url">CSAPP</a><h1 id="CrawlerTitle" itemprop="name headline">CSAPP第八章异常控制流</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">Hoshea Zhang</span><time itemprop="dateCreated datePublished" datetime="2023-10-24T12:50:25.000Z" title="Created 2023-10-24 20:50:25">2023-10-24</time><time itemprop="dateCreated datePublished" datetime="2023-10-25T03:10:17.946Z" title="Updated 2023-10-25 11:10:17">2023-10-25</time></header><p>从给处理器加电开始，直到你断电为止，程序计数器假设一个值的序列<code>a0,a1,⋯ ,an−1</code></p>
<p>其中，每个 a~k~ 是某个相应的指令 I~k~ 的地址。每次从 a~k~到 a~k+1~ 的过渡称为<strong>控制转移</strong>（control transfer）。这样的控制转移序列叫做处理器的<strong>控制流</strong>（flow of control 或 control flow）。</p>
<p>系统也必须能够对系统状态的变化做出反应，这些系统状态不是被内部程序变量捕获的，而且也不一定要和程序的执行相关。比如，一个硬件定时器定期产生信号，这个事件必须得到处理。包到达网络适配器后，必须存放在内存中。程序向磁盘请求数据，然后休眠，直到被通知说数据已就绪。当子进程终止时，创造这些子进程的父进程必须得到通知。</p>
<p>现代系统通过使控制流发生突变来对这些情况做出反应。一般而言，我们把这些突变称为<strong>异常控制流</strong>（Exceptional Control Flow，ECF）。异常控制流发生在计算机系统的各个层次。比如，在硬件层，硬件检测到的事件会触发控制突然转移到异常处理程序。在操作系统层，内核通过上下文切换将控制从一个用户进程转移到另一个用户进程。在应用层，一个进程可以发送信号到另一个进程，而接收者会将控制突然转移到它的一个信号处理程序。—个程序可以通过回避通常的栈规则，并执行到其他函数中任意位置的非本地跳转来对错误做出反应。</p>
<p>作为程序员，理解 ECF 很重要，这有很多原因：</p>
<ul>
<li><strong>理解 ECF 将帮助你理解重要的系统概念。</strong>ECF 是操作系统用来实现 I/O、进程和虚拟内存的基本机制。在能够真正理解这些重要概念之前，你必须理解 ECF。</li>
<li><strong>理解 ECF 将帮助你理解应用程序是如何与操作系统交互的。</strong>应用程序通过使用一个叫做陷阱（trap）或者系统调用（system call）的 ECF 形式，向操作系统请求服务。比如，向磁盘写数据、从网络读取数据、创建一个新进程，以及终止当前进程，都是通过应用程序调用系统调用来实现的。理解基本的系统调用机制将帮助你理解这些服务是如何提供给应用的。</li>
<li><strong>理解 ECF 将帮助你编写有趣的新应用程序。</strong>操作系统为应用程序提供了强大的 ECF 机制，用来创建新进程、等待进程终止、通知其他进程系统中的异常事件，以及检测和响应这些事件。如果理解了这些 ECF 机制，那么你就能用它们来编写诸如 Unix shell 和 Web 服务器之类的有趣程序了。</li>
<li><strong>理解 ECF 将帮助你理解并发。</strong>ECF 是计算机系统中实现并发的基本机制。在运行中的并发的例子有：中断应用程序执行的异常处理程序，在时间上重叠执行的进程和线程，以及中断应用程序执行的信号处理程序。理解 ECF 是理解并发的第一步。我们会在第 12 章中更详细地研究并发。</li>
<li><strong>理解 ECF 将帮助你理解软件异常如何工作。</strong>像 C++ 和 Java 这样的语言通过 try、catch 以及 throw 语句来提供软件异常机制。软件异常允许程序进行非本地跳转（即违反通常的调用/返回栈规则的跳转）来响应错误情况。非本地跳转是一种应用层 ECF，在 C 中是通过 setjmp 和 longjmp 函数提供的。理解这些低级函数将帮助你理解高级软件异常如何得以实现。</li>
</ul>
<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><p>异常是异常控制流的一种形式，它一部分由硬件实现，一部分由操作系统实现。因为它们有一部分是由硬件实现的，所以具体细节将随系统的不同而有所不同。然而，对于每个系统而言，基本的思想都是相同的。在这一节中我们的目的是让你对异常和异常处理有一个一般性的了解，并且向你揭示现代计算机系统的一个经常令人感到迷惑的方面。</p>
<p><strong>异常</strong>（exception）就是控制流中的突变，用来响应处理器状态中的某些变化。下图展示了基本的思想。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://hoshea-1318436778.cos.ap-nanjing.myqcloud.com/image%E5%BC%82%E5%B8%B8%E7%9A%84%E5%89%96%E6%9E%90.png" alt="异常的剖析"></p>
<p>在图中，当处理器状态中发生一个重要的变化时，处理器正在执行某个当前指令 I~curr~ 。在处理器中，状态被编码为不同的位和信号。状态变化称为<strong>事件</strong>（event）. 事件可能和当前指令的执行直接相关。比如，发生虚拟内存缺页、算术溢出，或者一条指令试图除以零。另一方面，事件也可能和当前指令的执行没有关系。比如，一个系统定时器产生信号或者一个 I/O 请求完成。</p>
<p>在任何情况下，当处理器检测到有事件发生时，它就会通过一张叫做<strong>异常表</strong>（exception table）的跳转表，进行一个间接过程调用（异常），到一个专门设计用来处理这类事件的操作系统子程序（<strong>异常处理程序</strong>（exception handler））.当异常处理程序完成处理后，根据引起异常的事件的类型，会发生以下 3 种情况中的一种：</p>
<ol>
<li>处理程序将控制返回给当前指令 I~curr~，即当事件发生时正在执行的指令。</li>
<li>处理程序将控制返回给  I~next~ ，如果没有发生异常将会执行的下一条指令。</li>
<li>处理程序终止被中断的程序。</li>
</ol>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>异常可能会难以理解，因为处理异常需要硬件和软件紧密合作。很容易搞混哪个部分执行哪个任务。让我们更详细地来看看硬件和软件的分工吧。</p>
<p>系统中可能的每种类型的异常都分配了一个唯一的非负整数的<strong>异常号</strong>（exception number）。其中一些号码是由处理器的设计者分配的，其他号码是由操作系统内核（操作系统常驻内存的部分）的设计者分配的。前者的示例包括被零除、缺页、内存访问违例、断点以及算术运算溢出。后者的示例包括系统调用和来自外部 I/O 设备的信号。</p>
<p>在系统启动时（当计算机重启或者加电时），操作系统<strong>分配和初始化</strong>一张称为<strong>异常表</strong>的跳转表，使得表目 k 包含异常 k 的处理程序的地址。下图展示了异常表的格式。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://hoshea-1318436778.cos.ap-nanjing.myqcloud.com/image%E5%BC%82%E5%B8%B8%E8%A1%A8.png" alt="异常表"></p>
<p>在运行时（当系统在执行某个程序时），处理器检测到发生了一个事件，并且确定了相应的异常号 k。随后，处理器触发异常，方法是执行间接过程调用，通过异常表的表目 k，转到相应的处理程序。下图展示了处理器如何使用异常表来形成适当的异常处理程序的地址。异常号是到异常表中的索引，异常表的起始地址放在一个叫做<strong>异常表基址寄存器</strong>（exception table base register）的特殊 CPU 寄存器里。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://hoshea-1318436778.cos.ap-nanjing.myqcloud.com/image08-03%20%E7%94%9F%E6%88%90%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%9C%B0%E5%9D%80.png" alt="生成异常处理程序的地址"></p>
<p>异常类似于过程调用，但是有一些重要的不同之处：</p>
<ul>
<li>过程调用时，在跳转到处理程序之前，处理器将返回地址压入栈中。然而，根据异常的类型，返回地址要么是当前指令（当事件发生时正在执行的指令），要么是下一条指令（如果事件不发生，将会在当前指令后执行的指令）。</li>
<li>处理器也把一些额外的处理器状态压到栈里，在处理程序返回时，重新开始执行被中断的程序会需要这些状态。比如，x86-64 系统会将包含当前条件码的 EFLAGS 寄存器和其他内容压入栈中。</li>
<li>如果控制从用户程序转移到内核，所有这些项目都被压到内核栈中，而不是压到用户栈中。</li>
<li>异常处理程序运行在内核模式下（见 8.2.4 节），这意味着它们对所有的系统资源都有完全的访问权限。</li>
</ul>
<p>一旦硬件触发了异常，剩下的工作就是由异常处理程序在软件中完成。在处理程序处理完事件之后，它通过执行一条特殊的“从中断返回”指令，可选地返回到被中断的程序，该指令将适当的状态弹回到处理器的控制和数据寄存器中，如果异常中断的是一个用户程序，就将状态恢复为<strong>用户模式</strong>（见 8.2.4 节），然后将控制返回给被中断的程序。</p>
<h2 id="异常的类别"><a href="#异常的类别" class="headerlink" title="异常的类别"></a>异常的类别</h2><p>异常可以分为四类：<strong>中断</strong>（interrupt），<strong>陷阱</strong>（trap）、<strong>故障</strong>（fault）和<strong>终止</strong>（abort）。图 8-4 中的表对这些类别的属性做了小结。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类别</th>
<th>原因</th>
<th>异步/同步</th>
<th>返回行为</th>
</tr>
</thead>
<tbody>
<tr>
<td>中断</td>
<td>来自 I/O 设备的信号</td>
<td>异步</td>
<td>总是返回到下一条指令</td>
</tr>
<tr>
<td>陷阱</td>
<td>有意的异常</td>
<td>同步</td>
<td>总是返回到下一条指令</td>
</tr>
<tr>
<td>故障</td>
<td>潜在可恢复的错误</td>
<td>同步</td>
<td>可能返回到当前指令</td>
</tr>
<tr>
<td>终止</td>
<td>不可恢复的错误</td>
<td>同步</td>
<td>不会返回</td>
</tr>
</tbody>
</table>
</div>
<h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><p><strong>中断</strong>是异步发生的，是来自处理器外部的 I/O 设备的信号的结果。硬件中断不是由任何一条专门的指令造成的，从这个意义上来说它是异步的。硬件中断的异常处理程序常常称为<strong>中断处理程序</strong>（interrupt handler）。</p>
<p>下图概述了一个中断的处理。I/O 设备，例如网络适配器、磁盘控制器和定时器芯片，通过向处理器芯片上的一个引脚发信号，并将异常号放到系统总线上，来触发中断，这个异常号标识了引起中断的设备。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://hoshea-1318436778.cos.ap-nanjing.myqcloud.com/imageassets_-MHt_spaxGgCbp2POnfq_-MIO2pUWL-jQbuWXR4XG_-MIO2zwVdXyDs1DgICYV_08-05%20%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86.webp" alt="assets_-MHt_spaxGgCbp2POnfq_-MIO2pUWL-jQbuWXR4XG_-MIO2zwVdXyDs1DgICYV 中断处理"></p>
<p>在当前指令完成执行之后，处理器注意到中断引脚的电压变高了，就从系统总线读取异常号，然后调用适当的中断处理程序。当处理程序返回时，它就将控制返回给下一条指令（也即如果没有发生中断，在控制流中会在当前指令之后的那条指令）。结果是程序继续执行，就好像没有发生过中断一样。</p>
<p>剩下的异常类型（陷阱、故障和终止）是同步发生的，是执行当前指令的结果。我们把这类指令叫做<strong>故障指令</strong>（faulting instruction）。</p>
<h3 id="陷阱和系统调用"><a href="#陷阱和系统调用" class="headerlink" title="陷阱和系统调用"></a>陷阱和系统调用</h3><p>陷阱是有意的异常，是执行一条指令的结果。就像中断处理程序一样，陷阱处理程序将控制返回到下一条指令。陷阱最重要的用途是在用户程序和内核之间提供一个像过程一样的接口，叫做<strong>系统调用</strong>。</p>
<p>用户程序经常需要向内核请求服务，比如读一个文件（read）、创建一个新的进程（fork），加载一个新的程序（execve），或者终止当前进程（exit）。为了允许对这些内核服务的受控的访问，处理器提供了一条特殊的 “syscall n” 指令，当用户程序想要请求服务 n 时，可以执行这条指令。执行 syscall 指令会导致一个到异常处理程序的陷阱，这个处理程序解析参数，并调用适当的内核程序。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://hoshea-1318436778.cos.ap-nanjing.myqcloud.com/image%E9%99%B7%E9%98%B1%E5%A4%84%E7%90%86.png" alt="陷阱处理"></p>
<h3 id="故障"><a href="#故障" class="headerlink" title="故障"></a>故障</h3><p>故障由错误情况引起，它可能能够被故障处理程序修正。当故障发生时，处理器将控制转移给故障处理程序。如果处理程序能够修正这个错误情况，它就将控制返回到引起故障的指令，从而重新执行它。否则，处理程序返回到内核中的 abort 例程，abort 例程会终止引起故障的应用程序。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://hoshea-1318436778.cos.ap-nanjing.myqcloud.com/image%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86.png" alt="故障处理"></p>
<p>一个经典的故障示例是缺页异常，当指令引用一个虚拟地址，而与该地址相对应的物理页面不在内存中，因此必须从磁盘中取出时，就会发生故障。就像我们将在第 9 章中看到的那样，一个页面就是虚拟内存的一个连续的块（典型的是 4KB）。缺页处理程序从磁盘加载适当的页面，然后将控制返回给引起故障的指令。当指令再次执行时，相应的物理页面已经驻留在内存中了，指令就可以没有故障地运行完成了。</p>
<h3 id="终止"><a href="#终止" class="headerlink" title="终止"></a>终止</h3><p>终止是不可恢复的致命错误造成的结果，通常是一些硬件错误，比如 DRAM 或者 SRAM 位被损坏时发生的奇偶错误。终止处理程序从不将控制返回给应用程序。如图 8-8 所示，处理程序将控制返回给一个 abort 例程，该例程会终止这个应用程序。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://hoshea-1318436778.cos.ap-nanjing.myqcloud.com/image%E7%BB%88%E6%AD%A2%E5%A4%84%E7%90%86.png" alt="终止处理"></p>
<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><p>异常是允许操作系统内核提供<strong>进程</strong>（process）概念的基本构造块，进程是计算机科学中最深刻、最成功的概念之一。</p>
<p>在现代系统上运行一个程序时，我们会得到一个假象，就好像我们的程序是系统中当前运行的唯一的程序一样。我们的程序好像是独占地使用处理器和内存。处理器就好像是无间断地一条接一条地执行我们程序中的指令。最后，我们程序中的代码和数据好像是系统内存中唯一的对象。这些假象都是通过进程的概念提供给我们的。</p>
<p>进程的经典定义就是一个执行中程序的实例。系统中的每个程序都运行在某个进程的<strong>上下文</strong>（context）中。上下文是由程序正确运行所需的状态组成的。这个状态包括存放在内存中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。</p>
<p>每次用户通过向 shell 输入一个可执行目标文件的名字，运行程序时，shell 就会创建一个新的进程，然后在这个新进程的上下文中运行这个可执行目标文件。应用程序也能够创建新进程，并且在这个新进程的上下文中运行它们自己的代码或其他应用程序。</p>
<p>关于操作系统如何实现进程的细节的讨论超出了本书的范围。反之，我们将关注进程提供给应用程序的关键抽象：</p>
<ul>
<li>一个独立的逻辑控制流，它提供一个假象，好像我们的程序独占地使用处理器。</li>
<li>一个私有的地址空间，它提供一个假象，好像我们的程序独占地使用内存系统。让我们更深入地看看这些抽象。</li>
</ul>
<h2 id="逻辑控制流"><a href="#逻辑控制流" class="headerlink" title="逻辑控制流"></a>逻辑控制流</h2><p>即使在系统中通常有许多其他程序在运行，像它在独占地使用处理器。如果想用调试器单步执行程序，我们会看到一系列的程序计数器（PC）的值，这些值唯一地对应于包含在程序的可执行目标文件中的指令，或是包含在运行时动态链接到程序的共享对象中的指令。这个 PC 值的序列叫做<strong>逻辑控制流</strong>，或者简称<strong>逻辑流</strong>。</p>
<p>考虑一个运行着三个进程的系统，如下图所示。处理器的一个物理控制流被分成了三个逻辑流，每个进程一个。图 中每个竖直的条表示一个进程的逻辑流的一部分。在这个例子中，三个逻辑流的执行是交错的。进程 A 运行了一会儿，然后是进程 B 开始运行到完成。然后，进程 C 运行了一会儿，进程 A 接着运行直到完成。最后，进程 C 可以运行到结束了。</p>
<p>下图的关键点在于进程是轮流使用处理器的。每个进程执行它的流的一部分，然后被<strong>抢占</strong>（preempted）（暂时挂起），然后轮到其他进程。对于一个运行在这些进程之一的上下文中的程序，它看上去就像是在独占地使用处理器。唯一的反面例证是，如果我们精确地测量每条指令使用的时间，会发现在程序中一些指令的执行之间，CPU 好像会周期性地停顿。然而，每次处理器停顿，它随后会继续执行我们的程序，并不改变程序内存位置或寄存器的内容。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://hoshea-1318436778.cos.ap-nanjing.myqcloud.com/image%E9%80%BB%E8%BE%91%E6%8E%A7%E5%88%B6%E6%B5%81.png" alt="逻辑控制流"></p>
<h2 id="并发流"><a href="#并发流" class="headerlink" title="并发流"></a>并发流</h2><p>计算机系统中逻辑流有许多不同的形式。异常处理程序、进程、信号处理程序、线程和 Java 进程都是逻辑流的例子。</p>
<p>一个逻辑流的执行在时间上与另一个流重叠，称为<strong>并发流</strong>（concurrent flow），这两个流被称为<strong>并发地运行</strong>。更准确地说，流 X 和 Y 互相并发，当且仅当 X 在 Y 开始之后和 Y 结束之前开始，或者 Y 在 X 开始之后和 X 结束之前开始。例如图中，进程 A 和 B 并发地运行，A 和 C 也一样。另一方面，B 和 C 没有并发地运行，因为 B 的最后一条指令在 C 的第一条指令之前执行。</p>
<p>多个流并发地执行的一般现象被称为<strong>并发</strong>（concurrency）。一个进程和其他进程轮流运行的概念称为<strong>多任务</strong>（multitasking）。一个进程执行它的控制流的一部分的每一时间段叫做<strong>时间片</strong>（time slice）。因此，多任务也叫做<strong>时间分片</strong>（timeslicing）。例如，上图中，进程 A 的流由两个时间片组成。</p>
<p>注意，并发流的思想与流运行的处理器核数或者计算机数无关。如果两个流在时间上重叠，那么它们就是并发的，即使它们是运行在同一个处理器上。不过，有时我们会发现确认并行流是很有帮助的，它是并发流的一个真子集。如果两个流并发地运行在不同的处理器核或者计算机上，那么我们称它们为<strong>并行流</strong>（parallel flow），它们<strong>并行地运行</strong>（running in parallel），且<strong>并行地执行</strong>（parallel execution）。</p>
<h2 id="私有地址空间"><a href="#私有地址空间" class="headerlink" title="私有地址空间"></a>私有地址空间</h2><p>进程也为每个程序提供一种假象，好像它独占地使用系统地址空间。在一台 n 位地址的机器上，地址空间是2^n^个可能地址的集合，0，1，⋯，2^n^−1 。进程为每个程序提供它自己的<strong>私有地址空间</strong>。一般而言，和这个空间中某个地址相关联的那个内存字节是不能被其他进程读或者写的，从这个意义上说，这个地址空间是私有的。</p>
<p>尽管和每个私有地址空间相关联的内存的内容一般是不同的，但是每个这样的空间都有相同的通用结构。比如，图 8-13 展示了一个 x86-64 Linux 进程的地址空间的组织结构。</p>
<p>地址空间底部是保留给用户程序的，包括通常的代码、数据、堆和栈段。代码段总是从地址 0x400000 开始。地址空间顶部保留给内核（操作系统常驻内存的部分）。地址空间的这个部分包含内核在代表进程执行指令时（比如当应用程序执行系统调用时）使用的代码、数据和栈。</p>
<h2 id="用户模式和内核模式"><a href="#用户模式和内核模式" class="headerlink" title="用户模式和内核模式"></a>用户模式和内核模式</h2><p>为了使操作系统内核提供一个无懈可击的进程抽象，处理器必须提供一种机制，限制一个应用可以执行的指令以及它可以访问的地址空间范围。</p>
<p>处理器通常是用某个控制寄存器中的一个<strong>模式位</strong>（mode bit）来提供这种功能的，该寄存器描述了进程当前享有的特权。当设置了模式位时，进程就运行在<strong>内核模式</strong>中（有时叫做<strong>超级用户模式</strong>）。一个运行在内核模式的进程可以执行指令集中的任何指令，并且可以访问系统中的任何内存位置。</p>
<p>没有设置模式位时，进程就运行在用户模式中。用户模式中的进程不允许执行<strong>特权指令</strong>（privileged instruction），比如停止处理器、改变模式位，或者发起一个 I/。操作。也不允许用户模式中的进程直接引用地址空间中内核区内的代码和数据。任何这样的尝试都会导致致命的保护故障。反之，用户程序必须通过系统调用接口间接地访问内核代码和数据。</p>
<p>运行应用程序代码的进程初始时是在用户模式中的。进程从用户模式变为内核模式的唯一方法是通过诸如中断、故障或者陷入系统调用这样的异常。当异常发生时，控制传递到异常处理程序，处理器将模式从用户模式变为内核模式。处理程序运行在内核模式中，当它返回到应用程序代码时，处理器就把模式从内核模式改回到用户模式。</p>
<p>Linux 提供了一种聪明的机制，叫做 /proc 文件系统，它允许用户模式进程访问内核数据结构的内容。/proc 文件系统将许多内核数据结构的内容输出为一个用户程序可以读的文本文件的层次结构。比如，你可以使用 / proc 文件系统找出一般的系统属性，比如 CPU 类型（/proc/cpuinfo），或者某个特殊的进程使用的内存段（/proc/<process-id>/maps）。2.6 版本的 Linux 内核引入 /sys 文件系统，它输岀关于系统总线和设备的额外的低层信息。</p>
<h2 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h2><p>操作系统内核使用一种称为<strong>上下文切换</strong>（context switch）的较高层形式的异常控制流来实现多任务。上下文切换机制是建立在 8.1 节中已经讨论过的那些较低层异常机制之上的。</p>
<p>内核为每个进程维持一个<strong>上下文</strong>（context）。上下文就是内核重新启动一个被抢占的进程所需的状态。它由一些对象的值组成，这些对象包括通用目的寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构，比如描述地址空间的页表、包含有关当前进程信息的进程表，以及包含进程已打开文件的信息的文件表。</p>
<p>在进程执行的某些时刻，内核可以决定抢占当前进程，并重新开始一个先前被抢占了的进程。这种决策就叫做<strong>调度</strong>（scheduling），是由内核中称为<strong>调度器</strong>（scheduler）的代码处理的。当内核选择一个新的进程运行时，我们说内核调度了这个进程。在内核调度了一个新的进程运行后，它就抢占当前进程，并使用一种称为上下文切换的机制来将控制转移到新的进程，上下文切换 1）保存当前进程的上下文，2）恢复某个先前被抢占的进程被保存的上下文，3）将控制传递给这个新恢复的进程。</p>
<p>当内核代表用户执行系统调用时，可能会发生上下文切换。如果系统调用因为等待某个事件发生而阻塞，那么内核可以让当前进程休眠，切换到另一个进程。比如，如果一个 read 系统调用需要访问磁盘，内核可以选择执行上下文切换，运行另外一个进程，而不是等待数据从磁盘到达。另一个示例是 sleep 系统调用，它显式地请求让调用进程休眠。一般而言，即使系统调用没有阻塞，内核也可以决定执行上下文切换，而不是将控制返回给调用进程。</p>
<p>中断也可能引发上下文切换。比如，所有的系统都有某种产生周期性定时器中断的机制，通常为每 1 毫秒或每 10 毫秒。每次发生定时器中断时，内核就能判定当前进程已经运行了足够长的时间，并切换到一个新的进程。</p>
<p>下图展示了一对进程 A 和 B 之间上下文切换的示例。在这个例子中，进程 A 初始运行在用户模式中，直到它通过执行系统调用 read 陷入到内核。内核中的陷阱处理程序请求来自磁盘控制器的 DMA 传输，并且安排在磁盘控制器完成从磁盘到内存的数据传输后，磁盘中断处理器。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://hoshea-1318436778.cos.ap-nanjing.myqcloud.com/imageassets_-MHt_spaxGgCbp2POnfq_-MIO5numBy95YAm6bhKp_-MIO6ZpipSvlARdQ1rli_08-14%20%E8%BF%9B%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%E7%9A%84%E5%89%96%E6%9E%90.webp" alt="assets_-MHt_spaxGgCbp2POnfq_-MIO5numBy95YAm6bhKp_-MIO6ZpipSvlARdQ1rli_08-14 进程上下文切换的剖析"></p>
<p>磁盘取数据要用一段相对较长的时间（数量级为几十毫秒），所以内核执行从进程 A 到进程 B 的上下文切换，而不是在这个间歇时间内等待，什么都不做。注意在切换之前，内核正代表进程 A 在用户模式下执行指令（即没有单独的内核进程）。在切换的第一部分中，内核代表进程 A 在内核模式下执行指令。然后在某一时刻，它开始代表进程 B（仍然是内核模式下）执行指令。在切换之后，内核代表进程 B 在用户模式下执行指令。</p>
<p>随后，进程 B 在用户模式下运行一会儿，直到磁盘发出一个中断信号，表示数据已经从磁盘传送到了内存。内核判定进程 B 已经运行了足够长的时间，就执行一个从进程 B 到进程 A 的上下文切换，将控制返回给进程 A 中紧随在系统调用 read 之后的那条指令。进程 A 继续运行，直到下一次异常发生，依此类推。</p>
<h1 id="系统调用错误处理"><a href="#系统调用错误处理" class="headerlink" title="系统调用错误处理"></a>系统调用错误处理</h1><p>当 Unix 系统级函数遇到错误时，它们通常会返回 —1，并设置全局整数变量 errno 来表示什么出错了。程序员应该总是检査错误，但是不幸的是，许多人都忽略了错误检查，因为它使代码变得臃肿，而且难以读懂。比如，下面是我们调用 Unix fork 函数时会如何检査错误：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;fork error: %s\n&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>strerror 函数返回一个文本串，描述了和某个 errno 值相关联的错误。通过定义下面的错误报告函数，我们能够在某种程度上简化这个代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">unix_error</span><span class="params">(<span class="type">char</span> *msg)</span> <span class="comment">/* Unix-style error */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;%s: %s\n&quot;</span>, msg, <span class="built_in">strerror</span>(errno));</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>给定这个函数，我们对 fork 的调用从 4 行缩减到 2 行：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">Fork</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">unix_error</span>(<span class="string">&quot;Fork error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过使用错误处理包装函数，我们可以更进一步地简化代码，Stevens 在【110】中首先提出了这种方法。对于一个给定的基本函数 foo，我们定义一个具有相同参数的包装函数 Foo，但是第一个字母大写了。包装函数调用基本函数，检査错误，如果有任何问题就终止。比如，下面是 fork 函数的错误处理包装函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">Fork</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">unix_error</span>(<span class="string">&quot;Fork error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>给定这个包装函数，我们对 fork 的调用就缩减为 1 行：</p>
<p><code>pid = Fork();</code></p>
<h1 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h1><h2 id="获取进程id"><a href="#获取进程id" class="headerlink" title="获取进程id"></a>获取进程id</h2><p>每个进程都有一个唯一的正数（非零）进程 ID（PID）。getpid 函数返回调用进程的 PID。getppid 函数返回它的父进程的 PID（创建调用进程的进程）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">getpid</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">getppid</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回：调用者或其父进程的 PID。</span></span><br></pre></td></tr></table></figure>
<p>getpid 和 getppid 函数返回一个类型为 pid_t 的整数值，在 Linux 系统上它在 types.h 中被定义为 int。</p>
<h2 id="创建和终止进程"><a href="#创建和终止进程" class="headerlink" title="创建和终止进程"></a>创建和终止进程</h2><p>从程序员的角度，我们可以认为进程总是处于下面三种状态之一：</p>
<ul>
<li><p><strong>运行。</strong>进程要么在 CPU 上 执行，要么在等待被执行且最终会被内核调度。</p>
</li>
<li><p><strong>停止。</strong>进程的执行被挂起（suspended），且不会被调度。当收到 SIGSTOP、SIGTSTP、SIGTTIN 或者 SIGTTOU 信号时，进程就停止，并且保持停止直到它收到一个 SIGCONT 信号，在这个时刻，进程再次开始运行。（信号是一种软件中断的形式，将在 8.5 节中详细描述。）</p>
</li>
<li><p><strong>终止。</strong>进程永远地停止了。进程会因为三种原因终止：</p>
<ul>
<li><p>1）收到一个信号，该信号的默认行为是终止进程；</p>
</li>
<li><p>2）从主程序返回；</p>
</li>
<li><p>3）调用 exit 函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">exit</span><span class="params">(<span class="type">int</span> status)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该函数不返回。</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>父进程通过调用 fork 函数创建一个新的运行的子进程。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">fork</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回：子进程返回 0，父进程返回子进程的 PID，如果出错，则为 -1。</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>新创建的子进程几乎但不完全与父进程相同。子进程得到与父进程用户级虚拟地址空间相同的（但是独立的）一份副本，包括代码和数据段、堆、共享库以及用户栈。子进程还获得与父进程任何打开文件描述符相同的副本，这就意味着当父进程调用 fork 时，子进程可以读写父进程中打开的任何文件。父进程和新创建的子进程之间最大的区别在于它们有不同的 PID。</p>
</blockquote>
<p>fork 函数是有趣的（也常常令人迷惑），因为它只被调用一次，却会返回两次：一次是在调用进程（父进程）中，一次是在新创建的子进程中。在父进程中，fork 返回子进程的 PID。在子进程中，fork 返回 0。因为子进程的 PID 总是为非零，返回值就提供一个明确的方法来分辨程序是在父进程还是在子进程中执行。</p>
<p>下面的代码展示了一个使用 fork 创建子进程的父进程的示例。当 fork 调用在第 6 行返回时，在父进程和子进程中 x 的值都为 1。子进程在第 8 行加一并输出它的 x 的副本。相似地，父进程在第 13 行减一并输出它的 x 的副本。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    pid = <span class="built_in">Fork</span>();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123; <span class="comment">/* Child */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child : x=%d\n&quot;</span>, ++x);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Parent */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;parent: x=%d\n&quot;</span>, --x);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>linux&gt; ./fork<br>parent：x=0<br>child ：x=2</p>
</blockquote>
<p><strong>调用一次，返回两次。</strong>fork 函数被父进程调用一次，但是却返回两次。一次是返回到父进程，一次是返回到新创建的子进程。对于只创建一个子进程的程序来说，这还是相当简单直接的。但是具有多个 fork 实例的程序可能就会令人迷惑，需要仔细地推敲了。</p>
<p><strong>并发执行。</strong>父进程和子进程是并发运行的独立进程。内核能够以任意方式交替执行它们的逻辑控制流中的指令。在我们的系统上运行这个程序时，父进程先完成它的 printf 语句，然后是子进程。然而，在另一个系统上可能正好相反。一般而言，作为程序员，我们决不能对不同进程中指令的交替执行做任何假设。</p>
<p><strong>相同但是独立的地址空间。</strong>如果能够在 fork 函数在父进程和子进程中返回后立即暂停这两个进程，我们会看到两个进程的地址空间都是相同的。每个进程有相同的用户栈、相同的本地变量值、相同的堆、相同的全局变量值，以及相同的代码。因此，在我们的示例程序中，当 fork 函数在第 6 行返回时，本地变量 x 在父进程和子进程中都为 1。然而，因为父进程和子进程是独立的进程，它们都有自己的私有地址空间。后面，父进程和子进程对 x 所做的任何改变都是独立的，不会反映在另一个进程的内存中。这就是为什么当父进程和子进程调用它们各自的 printf 语句时，它们中的变量 x 会有不同的值。</p>
<p><strong>共享文件。</strong>当运行这个示例程序时，我们注意到父进程和子进程都把它们的输出显示在屏幕上。原因是子进程继承了父进程所有的打开文件。当父进程调用 fork 时，stdout 文件是打开的，并指向屏幕。子进程继承了这个文件，因此它的输出也是指向屏幕的。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://hoshea-1318436778.cos.ap-nanjing.myqcloud.com/image08-16%20%E5%9B%BE8-15%E4%B8%AD%E7%A4%BA%E4%BE%8B%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%9B%BE.png" alt=""></p>
<p>进程图特别有助于理解带有嵌套 fork 调用的程序。例如，下图中的程序源码中两次调用了 fork。对应的进程图可帮助我们看清这个程序运行了四个进程，每个都调用了—次 printf，这些 printf 可以以任意顺序执行。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://hoshea-1318436778.cos.ap-nanjing.myqcloud.com/image%E5%B5%8C%E5%A5%97fork%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%9B%BE.png" alt="嵌套fork的进程图"></p>
<h2 id="回收子进程"><a href="#回收子进程" class="headerlink" title="回收子进程"></a>回收子进程</h2><p>当一个进程由于某种原因终止时，内核并不是立即把它从系统中清除。相反，进程被保持在一种已终止的状态中，直到被它的父进程<strong>回收</strong>（reaped）。当父进程回收已终止的子进程时，内核将子进程的退出状态传递给父进程，然后抛弃已终止的进程，从此时开始，该进程就不存在了。一个终止了但还未被回收的进程称为<strong>僵死进程</strong>（zombie）</p>
<blockquote>
<h4 id="旁注-为什么已终止的子进程被称为僵死进程"><a href="#旁注-为什么已终止的子进程被称为僵死进程" class="headerlink" title="旁注 - 为什么已终止的子进程被称为僵死进程"></a>旁注 - 为什么已终止的子进程被称为僵死进程</h4><p>在民间传说中，僵尸是活着的尸体，一种半生半死的实体。僵死进程已经终止了，而内核仍保留着它的某些状态直到父进程回收它为止，从这个意义上说它们是类似的。</p>
</blockquote>
<p>如果一个父进程终止了，内核会安排 init 进程成为它的孤儿进程的养父。init 进程的 PID 为 1，是在系统启动时由内核创建的，它不会终止，是所有进程的祖先。如果父进程没有回收它的僵死子进程就终止了，那么内核会安排 init 进程去回收它们。不过，长时间运行的程序，比如 shell 或者服务器，总是应该回收它们的僵死子进程。即使僵死子进程没有运行，它们仍然消耗系统的内存资源。</p>
<p>一个进程可以通过调用 waitpid 函数来等待它的子进程终止或者停止。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> *statusp, <span class="type">int</span> options)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回：如果成功，则为子进程的 PID，如果 WNOHANG，则为 0，如果其他错误，则为 -1。</span></span><br></pre></td></tr></table></figure>
<p>waitpid 函数有点复杂。默认情况下（当 options=0 时），waitpid 挂起调用进程的执行，直到它的<strong>等待集合</strong>（wait set）中的一个子进程终止。如果等待集合中的一个进程在刚调用的时刻就已经终止了，那么 waitpid 就立即返回。在这两种情况中，waitpid 返回导致 waitpid 返回的已终止子进程的 PID。此时，已终止的子进程已经被回收，内核会从系统中删除掉它的所有痕迹。</p>
<h3 id="判定等待集合的成员"><a href="#判定等待集合的成员" class="headerlink" title="判定等待集合的成员"></a>判定等待集合的成员</h3><p>等待集合的成员是由参数 pid 来确定的：</p>
<ul>
<li>如果 Pid&gt;0，那么等待集合就是一个单独的子进程，它的进程 ID 等于 pid。</li>
<li>如果 Pid=-1，那么等待集合就是由父进程所有的子进程组成的。</li>
</ul>
<p>waitpid 函数还支持其他类型的等待集合，包括 Unix 进程组，对此我们将不做讨论。</p>
<h3 id="修改默认行为"><a href="#修改默认行为" class="headerlink" title="修改默认行为"></a>修改默认行为</h3><p>可以通过将 options 设置为常量 WNOHANG，WUNTRACED 和 WCONTINUED 的各种组合来修改默认行为：</p>
<ul>
<li><strong>WNOHANG：</strong>如果等待集合中的任何子进程都还没有终止，那么就立即返回（返回值为 0）。默认的行为是挂起调用进程，直到有子进程终止。在等待子进程终止的同时，如果还想做些有用的工作，这个选项会有用。</li>
<li><strong>WUNTRACED：</strong>挂起调用进程的执行，直到等待集合中的一个进程变成已终止或者被停止，返回的 PID 为导致返回的已终止或被停止子进程的 PID。默认的行为是只返回已终止的子进程。当你想要检査已终止和被停止的子进程时，这个选项会有用。</li>
<li><strong>WCONTINUED：</strong>挂起调用进程的执行，直到等待集合中一个正在运行的进程终止或等待集合中一个被停止的进程收到 SIGCONT 信号重新开始执行。（8.5 节会解释这些信号。）</li>
</ul>
<p>可以用或运算把这些选项组合起来。例如：</p>
<ul>
<li><strong>WNOHANG | WUNTRACED：</strong>立即返回，如果等待集合中的子进程都没有被停止或终止，则返回值为 0；如果有一个停止或终止，则返回值为该子进程的 PID。</li>
</ul>
<h3 id="检查已回收子进程的退出状态"><a href="#检查已回收子进程的退出状态" class="headerlink" title="检查已回收子进程的退出状态"></a>检查已回收子进程的退出状态</h3><p>如果 statusp 参数是非空的，那么 waitpid 就会在 status 中放上关于导致返回的子进程的状态信息，status 是 statusp 指向的值。wait.h 头文件定义了解释 status 参数的几个宏：</p>
<ul>
<li><strong>WIFEXITED</strong>(status)：如果于进程通过调用 exit 或者一个返回（return）正常终止，就返回真。</li>
<li><strong>WEXITSTATUS</strong>(status)：返回一令正常终止的子进程的退出状态。只有在 WIFEXITED() 返回为真时，才会定义这个状态。</li>
<li><strong>WIFSIGNALED</strong>(status)：如果子进程是因为一个未被捕获的信号终止的，. 那么就返回真。</li>
<li><strong>WTERMSIG</strong>(status)：返回导致子进程终止的信号的编号。只有在 WIFSIGNALED() 返回为真时，才定义这个状态。</li>
<li><strong>WIFSTOPPED</strong>(status)：如果引起返回的子进程当前是停止的，那么就返回真。</li>
<li><strong>WSTOPSIG</strong>(status)：返回引起子进程停止的信号的编号。只有在 WIFSTOPPED() 返回为真时，才定义这个状态。</li>
<li><strong>WIFCONTINUED</strong>(status)：如果子进程收到 SIGCONT 信号重新启动，则返回真。</li>
</ul>
<h3 id="错误条件"><a href="#错误条件" class="headerlink" title="错误条件"></a>错误条件</h3><p>如果调用进程没有子进程，那么 waitpid 返回 -1，并且设置 errno 为 ECHILD。如果 waitpid 函数被一个信号中断，那么它返回 -1，并设置 errno 为 EINTR。</p>
<h2 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">wait</span><span class="params">(<span class="type">int</span> *statusp)</span></span>;</span><br><span class="line"><span class="comment">// 返回：如果成功，则为子进程的 PID，如果出错，则为 -1。</span></span><br></pre></td></tr></table></figure>
<h2 id="进程休眠"><a href="#进程休眠" class="headerlink" title="进程休眠"></a>进程休眠</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">sleep</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> secs)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回：还要休眠的秒数。</span></span><br></pre></td></tr></table></figure>
<p>如果请求的时间量已经到了，sleep 返回 0，否则返回还剩下的要休眠的秒数。后一种情况是可能的，如果因为 sleep 函数被一个信号中断而过早地返回。我们将在 8.5 节中详细讨论信号。</p>
<p>我们会发现另一个很有用的函数是 pause 函数，该函数让调用函数休眠，直到该进程收到一个信号。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pause</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 总是返回 -1。</span></span><br></pre></td></tr></table></figure>
<h2 id="加载并运行程序"><a href="#加载并运行程序" class="headerlink" title="加载并运行程序"></a>加载并运行程序</h2><p>execve 函数在当前进程的上下文中加载并运行一个新程序。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *argv[],</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="type">const</span> <span class="type">char</span> *envp[])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果成功，则不返回，如果错误，则返回 -1。</span></span><br></pre></td></tr></table></figure>
<p>execve 函数加载并运行可执行目标文件 filename，且带参数列表 argv 和环境变量列表 envp。只有当出现错误时，例如找不到 filename，execve 才会返回到调用程序。所以，与 fork—次调用返回两次不同，execve 调用一次并从不返回。</p>
<p>参数列表是用下图中的数据结构表示的。argv 变量指向一个以 null 结尾的指针数组，其中每个指针都指向一个参数字符串。按照惯例，argv[0] 是可执行目标文件的名字。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://hoshea-1318436778.cos.ap-nanjing.myqcloud.com/image%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8%E7%9A%84%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84.png" alt="参数列表的组织结构"></p>
<p>环境变量的列表是由一个类似的数据结构表示的，如图 8-21 所示。envp 变量指向一个以 null 结尾的指针数组，其中每个指针指向一个环境变量字符串，每个串都是形如 “name=value” 的名字—值对。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://hoshea-1318436778.cos.ap-nanjing.myqcloud.com/image%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%88%97%E8%A1%A8%E7%9A%84%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84.png" alt="环境变量列表的组织结构"></p>
<p>在 execve 加载了 filename 之后，它调用 7.9 节中描述的启动代码。启动代码设置栈，并将控制传递给新程序的主函数，该主函数有如下形式的原型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="type">char</span> **envp)</span></span>;</span><br></pre></td></tr></table></figure>
<p>或者等价的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[], <span class="type">char</span> *envp[])</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>确认一下你理解了程序和进程之间的区别。程序是一堆代码和数据；程序可以作为目标文件存在于磁盘上，或者作为段存在于地址空间中。进程是执行中程序的一个具体的实例；程序总是运行在某个进程的上下文中。如果你想要理解 fork 和 execve 函数，理解这个差异是很重要的。fork 函数在新的子进程中运行相同的程序，新的子进程是父进程的一个复制品。execve 函数在当前进程的上下文中加载并运行一个新的程序。它会覆盖当前进程的地址空间，但并没有创建一个新进程。新的程序仍然有相同的 PID，并且继承了调用 execve 函数时已打开的所有文件描述符。</p>
</blockquote>
<h2 id="利用fork或者execve运行程序"><a href="#利用fork或者execve运行程序" class="headerlink" title="利用fork或者execve运行程序"></a>利用fork或者execve运行程序</h2><p>像 Unix shell 和 Web 服务器这样的程序大量使用了 fork 和 execve 函数。shell 是一个交互型的应用级程序，它代表用户运行其他程序。最早的 shell 是 sh 程序，后面出现了—些变种，比如 csh、tcsh、ksh 和 bash。shell 执行一系列的读/求值（read/evaluate）步骤，然后终止。读步骤读取来自用户的一个命令行。求值步骤解析命令行，并代表用户运行程序。</p>
<p>下面展示了一个简单 shell 的 main 例程。shell 打印一个命令行提示符，等待用户在 stdin 上 输入命令行，然后对这个命令行求值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;csapp.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXARGS 128</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Function prototypes */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eval</span><span class="params">(<span class="type">char</span> *cmdline)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">parseline</span><span class="params">(<span class="type">char</span> *buf, <span class="type">char</span> **argv)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">builtin_command</span><span class="params">(<span class="type">char</span> **argv)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> cmdline[MAXLINE]; <span class="comment">/* Command line */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">/* Read */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&gt; &quot;</span>);</span><br><span class="line">        <span class="built_in">Fgets</span>(cmdline, MAXLINE, stdin);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">feof</span>(stdin))</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Evaluate */</span></span><br><span class="line">        <span class="built_in">eval</span>(cmdline);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* eval - Evaluate a command line */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eval</span><span class="params">(<span class="type">char</span> *cmdline)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> *argv[MAXARGS]; <span class="comment">/* Argument list execve() */</span></span><br><span class="line">    <span class="type">char</span> buf[MAXLINE];   <span class="comment">/* Holds modified command line */</span></span><br><span class="line">    <span class="type">int</span> bg;              <span class="comment">/* Should the job run in bg or fg? */</span></span><br><span class="line">    <span class="type">pid_t</span> pid;           <span class="comment">/* Process id */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(buf, cmdline);</span><br><span class="line">    bg = <span class="built_in">parseline</span>(buf, argv);</span><br><span class="line">    <span class="keyword">if</span> (argv[<span class="number">0</span>] == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;   <span class="comment">/* Ignore empty lines */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">builtin_command</span>(argv)) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((pid = <span class="built_in">Fork</span>()) == <span class="number">0</span>) &#123;   <span class="comment">/* Child runs user job */</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">execve</span>(argv[<span class="number">0</span>], argv, environ) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s: Command not found.\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Parent waits for foreground job to terminate */</span></span><br><span class="line">        <span class="keyword">if</span> (!bg) &#123;</span><br><span class="line">            <span class="type">int</span> status;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">waitpid</span>(pid, &amp;status, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="built_in">unix_error</span>(<span class="string">&quot;waitfg: waitpid error&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d %s&quot;</span>, pid, cmdline);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* If first arg is a builtin command, run it and return true */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">builtin_command</span><span class="params">(<span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;quit&quot;</span>)) <span class="comment">/* quit command */</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;&amp;&quot;</span>))    <span class="comment">/* Ignore singleton &amp; */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;                     <span class="comment">/* Not a builtin command */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* parseline - Parse the command line and build the argv array */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">parseline</span><span class="params">(<span class="type">char</span> *buf, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> *delim;         <span class="comment">/* Points to first space delimiter */</span></span><br><span class="line">    <span class="type">int</span> argc;            <span class="comment">/* Number of args */</span></span><br><span class="line">    <span class="type">int</span> bg;              <span class="comment">/* Background job? */</span></span><br><span class="line"></span><br><span class="line">    buf[<span class="built_in">strlen</span>(buf)<span class="number">-1</span>] = <span class="string">&#x27; &#x27;</span>;  <span class="comment">/* Replace trailing &#x27;\n&#x27; with space */</span></span><br><span class="line">    <span class="keyword">while</span> (*buf &amp;&amp; (*buf == <span class="string">&#x27; &#x27;</span>)) <span class="comment">/* Ignore leading spaces */</span></span><br><span class="line">        buf++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Build the argv list */</span></span><br><span class="line">    argc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((delim = <span class="built_in">strchr</span>(buf, <span class="string">&#x27; &#x27;</span>))) &#123;</span><br><span class="line">        argv[argc++] = buf;</span><br><span class="line">        *delim = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        buf = delim + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (*buf &amp;&amp; (*buf == <span class="string">&#x27; &#x27;</span>)) <span class="comment">/* Ignore spaces */</span></span><br><span class="line">            buf++;</span><br><span class="line">    &#125;</span><br><span class="line">    argv[argc] = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">0</span>) <span class="comment">/* Ignore blank line */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Should the job run in the background? */</span></span><br><span class="line">    <span class="keyword">if</span> ((bg = (*argv[argc<span class="number">-1</span>] == <span class="string">&#x27;&amp;&#x27;</span>)) != <span class="number">0</span>)</span><br><span class="line">        argv[--argc] = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，这个简单的 shell 是有缺陷的，因为它并不回收它的后台子进程。修改这个缺陷就要求使用信号，我们将在下一节中讲述信号。</p>
<h1 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h1><p>到目前为止对异常控制流的学习中，我们已经看到了硬件和软件是如何合作以提供基本的低层异常机制的。我们也看到了操作系统如何利用异常来支持进程上下文切换的异常控制流形式。在本节中，我们将研究一种更高层的软件形式的异常，称为 <strong>Linux 信号</strong>，它允许进程和内核中断其他进程。</p>
<p>一个<strong>信号</strong>就是一条小消息，它通知进程系统中发生了一个某种类型的事件。比如，下图展示了 Linux 系统上支持的 30 种不同类型的信号。</p>
<p>每种信号类型都对应于某种系统事件。低层的硬件异常是由内核异常处理程序处理的，正常情况下，对用户进程而言是不可见的。信号提供了一种机制，通知用户进程发生了这些异常。比如，如果一个进程试图除以 0，那么内核就发送给它一个 SIGFPE 信号（号码 8）。如果一个进程执行一条非法指令，那么内核就发送给它一个 SIGILL 信号（号码 4）。如果进程进行非法内存引用，内核就发送给它一个 SIGSEGV 信号（号码 11）。其他信号对应于内核或者其他用户进程中较高层的软件事件。比如，如果当进程在前台运行时，你键入 Ctrl+C（也就是同时按下 Ctrl 键和 C 键），那么内核就会发送一个 SIGINT 信号（号码 2）给这个前台进程组中的每个进程。一个进程可以通过向另一个进程发送一个 SIGKILL 信号（号码 9）强制终止它。当一个子进程终止或者停止时，内核会发送一个 SIGCHLD 信号（号码 17）给父进程。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>名称</th>
<th>默认行为</th>
<th>相应事件</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>SIGHUP</td>
<td>终止</td>
<td>终端线挂断</td>
</tr>
<tr>
<td>2</td>
<td>SIGINT</td>
<td>终止</td>
<td>来自键盘的中断</td>
</tr>
<tr>
<td>3</td>
<td>SIGQUIT</td>
<td>终止</td>
<td>来自键盘的退出</td>
</tr>
<tr>
<td>4</td>
<td>SIGILL</td>
<td>终止</td>
<td>非法指令</td>
</tr>
<tr>
<td>5</td>
<td>SIGTRAP</td>
<td>终止并转储内存①^①①</td>
<td>跟踪陷阱</td>
</tr>
<tr>
<td>6</td>
<td>SIGABRT</td>
<td>终止并转储内存①^①①</td>
<td>来自 abort 函数的终止信号</td>
</tr>
<tr>
<td>7</td>
<td>SIGBUS</td>
<td>终止</td>
<td>总线错误</td>
</tr>
<tr>
<td>8</td>
<td>SIGFPE</td>
<td>终止并转储内存①^①①</td>
<td>浮点异常</td>
</tr>
<tr>
<td>9</td>
<td>SIGKILL</td>
<td>终止②^②②</td>
<td>杀死程序</td>
</tr>
<tr>
<td>10</td>
<td>SIGUSR1</td>
<td>终止</td>
<td>用户定义的信号 1</td>
</tr>
<tr>
<td>11</td>
<td>SIGSEGV</td>
<td>终止并转储内存①^①①</td>
<td>无效的内存引用（段故障）</td>
</tr>
<tr>
<td>12</td>
<td>SIGUSR2</td>
<td>终止</td>
<td>用户定义的信号 2</td>
</tr>
<tr>
<td>13</td>
<td>SIGPIPE</td>
<td>终止</td>
<td>向一个没有读用户的管道做写操作</td>
</tr>
<tr>
<td>14</td>
<td>SIGALRM</td>
<td>终止</td>
<td>来自 alarm 函数的定时器信号</td>
</tr>
<tr>
<td>15</td>
<td>SIGTERM</td>
<td>终止</td>
<td>软件终止信号</td>
</tr>
<tr>
<td>16</td>
<td>SIGSTKFLT</td>
<td>终止</td>
<td>协处理器上的栈故障</td>
</tr>
<tr>
<td>17</td>
<td>SIGCHLD</td>
<td>忽略</td>
<td>一个子进程停止或者终止</td>
</tr>
<tr>
<td>18</td>
<td>SIGCONT</td>
<td>忽略</td>
<td>继续进程如果该进程停止</td>
</tr>
<tr>
<td>19</td>
<td>SIGSTOP</td>
<td>停止直到下一个SIGCONT②^②②</td>
<td>不是来自终端的停止信号</td>
</tr>
<tr>
<td>20</td>
<td>SIGTSTP</td>
<td>停止直到下一个SIGCONT</td>
<td>来自终端的停止信号</td>
</tr>
<tr>
<td>21</td>
<td>SIGTTIN</td>
<td>停止直到下一个SIGCONT</td>
<td>后台进程从终端读</td>
</tr>
<tr>
<td>22</td>
<td>SIGTTOU</td>
<td>停止直到下一个SIGCONT</td>
<td>后台进程向终端写</td>
</tr>
<tr>
<td>23</td>
<td>SIGURG</td>
<td>忽略</td>
<td>套接字上的紧急情况</td>
</tr>
<tr>
<td>24</td>
<td>SIGXCPU</td>
<td>终止</td>
<td>CPU 时间限制超出</td>
</tr>
<tr>
<td>25</td>
<td>SIGXFSZ</td>
<td>终止</td>
<td>文件大小限制超出</td>
</tr>
<tr>
<td>26</td>
<td>SIGVTALRM</td>
<td>终止</td>
<td>虚拟定时器期满</td>
</tr>
<tr>
<td>27</td>
<td>SIGPROF</td>
<td>终止</td>
<td>剖析定时器期满</td>
</tr>
<tr>
<td>28</td>
<td>SIGWINCH</td>
<td>忽略</td>
<td>窗口大小变化</td>
</tr>
<tr>
<td>29</td>
<td>SIGIO</td>
<td>终止</td>
<td>在某个描述符上可执行 I/O 操作</td>
</tr>
<tr>
<td>30</td>
<td>SIGPWR</td>
<td>终止</td>
<td>电源故障</td>
</tr>
</tbody>
</table>
</div>
<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><p>传送一个信号到目的进程是由两个不同步骤组成的：</p>
<ul>
<li><p><strong>发送信号。</strong>内核通过更新目的进程上下文中的某个状态，发送（递送）一个信号给目的进程。发送信号可以有如下两种原因：</p>
<ul>
<li>内核检测到一个系统事件，比如除零错误或者子进程终止。</li>
<li>一个进程调用了 kill 函数（在下一节中讨论），显式地要求内核发送一个信号给目的进程。</li>
</ul>
<p>一个进程可以发送信号给它自己。</p>
</li>
<li><p><strong>接收信号。当目的进程被内核强迫以某种方式对信号的发送做出反应时，它就接收了信号。进程可以忽略这个信号，终止或者通过执行一个称为信号处理程序</strong>（signal handler）的用户层函数捕获这个信号。给出了信号处理程序捕获信号的基本思想。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://hoshea-1318436778.cos.ap-nanjing.myqcloud.com/imageassets_-MHt_spaxGgCbp2POnfq_-MIO8n7Rxfdny0W9yZK__-MIO91UBkLEG6iqFp72r_%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86.webp" alt="assets_-MHt_spaxGgCbp2POnfq_-MIO8n7Rxfdny0W9yZK__-MIO91UBkLEG6iqFp72r_信号处理"></p>
</li>
</ul>
<h2 id="发送信号"><a href="#发送信号" class="headerlink" title="发送信号"></a>发送信号</h2><p>Unix 系统提供了大量向进程发送信号的机制。所有这些机制都是基于进程组（process group）这个概念的。</p>
<h3 id="进程组"><a href="#进程组" class="headerlink" title="进程组"></a>进程组</h3><p>每个进程都只属于一个进程组，进程组是由一个正整数进程组 ID 来标识的。getpgrp 函数返回当前进程的进程组 ID：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">getpgrp</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="comment">// 返回：调用进程的进程组 ID。</span></span><br></pre></td></tr></table></figure>
<p>默认地，一个子进程和它的父进程同属于一个进程组。一个进程可以通过使用 setpgid 函数来改变自己或者其他进程的进程组：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setpgid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">pid_t</span> pgid)</span></span>;</span><br><span class="line"><span class="comment">// 返回：若成功则为o，若错误则为 -1。</span></span><br></pre></td></tr></table></figure>
<p>setpgid 函数将进程 pid 的进程组改为 pgid。如果 pid 是 0，那么就使用当前进程的 PID。如果 pgid 是 0，那么就用 pid 指定的进程的 PID 作为进程组 ID。例如，如果进程 15213 是调用进程，那么</p>
<p><code>setpgid(0, 0);</code></p>
<p>会创建一个新的进程组，其进程组 ID 是 15213，并且把进程 15213 加入到这个新的进程组中。</p>
<h3 id="用-bin-kill发送信号"><a href="#用-bin-kill发送信号" class="headerlink" title="用/bin/kill发送信号"></a>用/bin/kill发送信号</h3><p>/bin/kill 程序可以向另外的进程发送任意的信号。比如，命令</p>
<p><code>linux&gt; /bin/kill -9 15213</code></p>
<p>发送信号 9（SIGKILL）给进程 15213。一个为负的 PID 会导致信号被发送到进程组 PID 中的每个进程。比如，命令</p>
<p><code>linux&gt; /bin/kill -9 -15213</code></p>
<p>发送一个 SIGKILL 信号给进程组 15213 中的每个进程。注意，在此我们使用完整路径 /bin/kill，因为有些 Unix shell 有自己内置的 kill 命令。</p>
<h3 id="从键盘发送信号"><a href="#从键盘发送信号" class="headerlink" title="从键盘发送信号"></a>从键盘发送信号</h3><p>Unix shell 使用<strong>作业</strong>（job）这个抽象概念来表示为对一条命令行求值而创建的进程。在任何时刻，至多只有一个前台作业和 0 个或多个后台作业。比如，键入</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">linux&gt; ls | sort</span><br></pre></td></tr></table></figure>
<p>会创建一个由两个进程组成的前台作业，这两个进程是通过 Unix 管道连接起来的：一个进程运行 ls 程序，另一个运行 sort 程序。shell 为每个作业创建一个独立的进程组。进程组 ID 通常取自作业中父进程中的一个。比如，图 8-28 展示了有一个前台作业和两个后台作业的 shell。前台作业中的父进程 PID 为 20，进程组 ID 也为 20。父进程创建两个子进程，每个也都是进程组 20 的成员。</p>
<h3 id="用-kill-函数发送信号"><a href="#用-kill-函数发送信号" class="headerlink" title="用 kill 函数发送信号"></a>用 kill 函数发送信号</h3><p>进程通过调用 kill 函数发送信号给其他进程（包括它们自己）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kill</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sig)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回：若成功则为 0，若错误则为 -1。</span></span><br></pre></td></tr></table></figure>
<p>如果 pid 大于零，那么 kill 函数发送信号号码 sig 给进程 pid。如果 pid 等于零，那么 kill 发送信号 sig 给调用进程所在进程组中的每个进程，包括调用进程自己。如果 pid 小于零，kill 发送信号 sig 给进程组 |pid|（pid 的绝对值）中的每个进程。下图展示了一个示例，父进程用 kill 函数发送 SIGKILL 信号给它的子进程。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;csapp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Child sleeps until SIGKILL signal received, then dies */</span></span><br><span class="line">    <span class="keyword">if</span> ((pid = <span class="built_in">Fork</span>()) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">Pause</span>(); <span class="comment">/* Wait for a signal to arrive */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;control should never reach here!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Parent sends a SIGKILL signal to a child */</span></span><br><span class="line">    <span class="built_in">Kill</span>(pid, SIGKILL);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="用alarm函数发送信号"><a href="#用alarm函数发送信号" class="headerlink" title="用alarm函数发送信号"></a>用alarm函数发送信号</h3><p>进程可以通过调用 alarm 函数向它自己发送 SIGALRM 信号</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">alarm</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> secs)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回：前一次闹钟剩余的秒数，若以前没有设定闹钟，则为0。</span></span><br></pre></td></tr></table></figure>
<p>alarm 函数安排内核在 secs 秒后发送一个 SIGALRM 信号给调用进程。如果 secs 是零，那么不会调度安排新的闹钟（alarm）。在任何情况下，对 alarm 的调用都将取消任何待处理的（pending）闹钟，并且返回任何待处理的闹钟在被发送前还剩下的秒数（如果这次对 alarm 的调用没有取消它的话）；如果没有任何待处理的闹钟，就返回零。</p>
<h3 id="接收信号"><a href="#接收信号" class="headerlink" title="接收信号"></a>接收信号</h3><p>当内核把进程 p 从内核模式切换到用户模式时（例如，从系统调用返回或是完成了一次上下文切换），它会检查进程 p 的未被阻塞的待处理信号的集合（pending &amp;~blocked）。如果这个集合为空（通常情况下），那么内核将控制传递到 p 的逻辑控制流中的下一条指令（I~next~）。然而，如果集合是非空的，那么内核选择集合中的某个信号 k （通常是最小的 k），并且强制 p 接收信号 k。收到这个信号会触发进程采取某种行为。一旦进程完成了这个行为，那么控制就传递回 p 的逻辑控制流中的下一条指令（I~next~）。每个信号类型都有一个预定义的<strong>默认行为</strong>，是下面中的一种：</p>
<ul>
<li>进程终止。</li>
<li>进程终止并转储内存。</li>
<li>进程停止（挂起）直到被 SIGCONT 信号重启。</li>
<li>进程忽略该信号。</li>
</ul>
<p>进程可以通过使用 signal 函数修改和信号相关联的默认行为。唯一的例外是 SIGSTOP 和 SIGKILL，它们的默认行为是不能修改的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="type">sighandler_t</span>)</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">sighandler_t</span> <span class="title">signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">sighandler_t</span> handler)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回：若成功则为指向前次处理程序的指针，若出错则为 SIG_ERR（不设置 errno）。</span></span><br></pre></td></tr></table></figure>
<p>signal 函数可以通过下列三种方法之一来改变和信号 signum 相关联的行为：</p>
<ul>
<li><p>如果 handler 是 SIG_IGN，那么忽略类型为 signum 的信号。</p>
</li>
<li><p>如果 handler 是 SIG_DFL，那么类型为 signum 的信号行为恢复为默认行为。</p>
</li>
<li><p>否则，handler 就是用户定义的函数的地址，这个函数被称为<strong>信号处理程序</strong>，只要进程接收到一个类型为 signum 的信号，就会调用这个程序。通过把处理程序的地址传递到 signal 函数从而改变默认行为，这叫做<strong>设置信号处理程序</strong>（installing the handler）。调用信号处理程序被称为<strong>捕获信号</strong>。执行信号处理程序被称为<strong>处理信号</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;csapp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sigint_handler</span><span class="params">(<span class="type">int</span> sig)</span> <span class="comment">/* SIGINT handler */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Caught SIGINT!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* Install the SIGINT handler */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">signal</span>(SIGINT, sigint_handler) == SIG_ERR)</span><br><span class="line">    <span class="built_in">unix_error</span>(<span class="string">&quot;signal error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pause</span>(); <span class="comment">/* Wait for the receipt of a signal */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="非本地跳转"><a href="#非本地跳转" class="headerlink" title="非本地跳转"></a>非本地跳转</h1><p>C 语言提供了一种用户级异常控制流形式，称为非本地跳转（non local jump），它将控制直接从一个函数转移到另一个当前正在执行的函数，而不需要经过正常的调用—返回序列。非本地跳转是通过 setjmp 和 longjmp 函数来提供的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setjmp</span><span class="params">(jmp_buf env)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigsetjmp</span><span class="params">(sigjmp_buf env, <span class="type">int</span> savesigs)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回：setjmp 返回 0，longjmp 返回非零。</span></span><br></pre></td></tr></table></figure>
<p>setjmp 函数在 env 缓冲区中保存当前调用环境，以供后面的 longjmp 使用，并返回0。调用环境包括程序计数器、栈指针和通用目的寄存器。岀于某种超出本书描述范围的原因，setjmp 返回的值不能被赋值给变量：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">longjmp</span><span class="params">(jmp_buf env, <span class="type">int</span> retval)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">siglongjmp</span><span class="params">(sigjmp_buf env, <span class="type">int</span> retval)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从不返回。</span></span><br></pre></td></tr></table></figure>
<p>longjmp 函数从 env 缓冲区中恢复调用环境，然后触发一个从最近一次初始化 env 的 setjmp 调用的返回。然后 setjmp 返回，并带有非零的返回值 retval。</p>
<p>第一眼看过去，setjmp 和 longjmp 之间的相互关系令人迷惑。setjmp 函数只被调用一次，但返回多次：一次是当第一次调用 setjmp，而调用环境保存在缓冲区 env 中时，一次是为每个相应的 longjmp 调用。另一方面，longjmp 函数被调用一次，但从不返回。</p>
<p>非本地跳转的一个重要应用就是允许从一个深层嵌套的函数调用中立即返回，通常是由检测到某个错误情况引起的。如果在一个深层嵌套的函数调用中发现了一个错误情况，我们可以使用非本地跳转直接返回到一个普通的本地化的错误处理程序，而不是费力地解开调用栈。</p>
<p>图 8-43 展示了一个示例，说明这可能是如何工作的。main 函数首先调用 setjmp 以保存当前的调用环境，然后调用函数 foo，foo 依次调用函数 bar。如果 foo 或者 bar 遇到一个错误，它们立即通过一次 longjmp 调用从 setjmp 返回。setjmp 的非零返回值指明了错误类型，随后可以被解码，且在代码中的某个位置进行处理。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;csapp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">jmp_buf buf;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> error1 = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> error2 = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">void</span>)</span>, <span class="title">bar</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (<span class="built_in">setjmp</span>(buf)) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">foo</span>();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Detected an error1 condition in foo\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Detected an error2 condition in foo\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Unknown error condition in foo\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Deeply nested function foo */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (error1)</span><br><span class="line">        <span class="built_in">longjmp</span>(buf, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">bar</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (error2)</span><br><span class="line">        <span class="built_in">longjmp</span>(buf, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="操作进程的工具"><a href="#操作进程的工具" class="headerlink" title="操作进程的工具"></a>操作进程的工具</h1><p>Linux 系统提供了大量的监控和操作进程的有用工具。</p>
<ul>
<li><strong>STRACE：</strong>打印一个正在运行的程序和它的子进程调用的每个系统调用的轨迹。对于好奇的学生而言，这是一个令人着迷的工具。用 -static 编译你的程序，能得到一个更干净的、不带有大量与共享库相关的输出的轨迹。</li>
<li><strong>PS：</strong>列出当前系统中的进程（包括僵死进程）。</li>
<li><strong>TOP：</strong>打印出关于当前进程资源使用的信息。</li>
<li><strong>PMAP：</strong>显示进程的内存映射。</li>
<li><strong>/proc：</strong>一个虚拟文件系统，以 ASCII 文本格式输出大量内核数据结构的内容，用户程序可以读取这些内容。比如，输入 “cat/proc/loadavg”，可以看到你的 Linux 系统上当前的平均负载。</li>
</ul>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">Hoshea Zhang</div><div class="post-copyright__author_desc">平安喜乐</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://example.com/2023/10/24/CSAPP%E7%AC%AC%E5%85%AB%E7%AB%A0%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://example.com/2023/10/24/CSAPP%E7%AC%AC%E5%85%AB%E7%AB%A0%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/')">CSAPP第八章异常控制流</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://example.com/2023/10/24/CSAPP%E7%AC%AC%E5%85%AB%E7%AB%A0%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=CSAPP第八章异常控制流&amp;url=http://example.com/2023/10/24/CSAPP%E7%AC%AC%E5%85%AB%E7%AB%A0%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/&amp;pic=https://hoshea-1318436778.cos.ap-nanjing.myqcloud.com/imagebg_CSAPP.webp" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="rm.copyPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/CSAPP/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>CSAPP<span class="tagsPageCount">9</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://hoshea-1318436778.cos.ap-nanjing.myqcloud.com/image360.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/10/24/CPP-Primer%E7%AC%AC%E4%B8%89-%E4%B8%83%E7%AB%A0/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://hoshea-1318436778.cos.ap-nanjing.myqcloud.com/imagebg_c%2B%2Bprimer.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">CPP_Primer第三-七章</div></div></a></div><div class="next-post pull-right"><a href="/2023/10/25/%E6%B1%82%E4%B8%80%E4%B8%AA%E6%95%B4%E6%95%B0%E7%9A%84%E6%83%A9%E7%BD%9A%E6%95%B0/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://hoshea-1318436778.cos.ap-nanjing.myqcloud.com/imagebg_leetcode.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">求一个整数的惩罚数</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2023/10/16/CSAPP%E7%AC%AC%E4%B8%80%E7%AB%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/" title="CSAPP第一章:计算机系统漫游"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://hoshea-1318436778.cos.ap-nanjing.myqcloud.com/imagebg_CSAPP.webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-10-16</div><div class="title">CSAPP第一章:计算机系统漫游</div></div></a></div><div><a href="/2023/10/17/CSAPP%E7%AC%AC%E4%BA%8C%E7%AB%A0%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/" title="CSAPP第二章信息的表示和处理"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://hoshea-1318436778.cos.ap-nanjing.myqcloud.com/imagebg_CSAPP.webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-10-17</div><div class="title">CSAPP第二章信息的表示和处理</div></div></a></div><div><a href="/2023/10/17/CSAPP-Lab1-DataLab/" title="CSAPP_Lab1_DataLab"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://hoshea-1318436778.cos.ap-nanjing.myqcloud.com/imagebg_CSAPP.webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-10-17</div><div class="title">CSAPP_Lab1_DataLab</div></div></a></div><div><a href="/2023/10/18/CSAPP%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/" title="CSAPP第三章程序的机器级表示"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://hoshea-1318436778.cos.ap-nanjing.myqcloud.com/imagebg_CSAPP.webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-10-18</div><div class="title">CSAPP第三章程序的机器级表示</div></div></a></div><div><a href="/2023/10/19/CSAPP-Lab2-BombLab/" title="CSAPP-Lab2-BombLab"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://hoshea-1318436778.cos.ap-nanjing.myqcloud.com/imagebg_CSAPP.webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-10-19</div><div class="title">CSAPP-Lab2-BombLab</div></div></a></div><div><a href="/2023/10/21/CSAPP%E7%AC%AC%E5%9B%9B%E7%AB%A0%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/" title="CSAPP第四章处理器体系结构"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://hoshea-1318436778.cos.ap-nanjing.myqcloud.com/imagebg_CSAPP.webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-10-21</div><div class="title">CSAPP第四章处理器体系结构</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/24/64e6ce9c507bb.png" ait="status"/></div></div><div class="author-info__description"></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">Hoshea Zhang</h1><div class="author-info__desc">平安喜乐</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/HosheaZhang" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a></div></div></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bullhorn anzhiyu-shake"></i><span>Announcement</span></div><div class="announcement_content">e-mail:542978210@qq.com</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8"><span class="toc-number">1.</span> <span class="toc-text">异常</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">1.1.</span> <span class="toc-text">异常处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E7%B1%BB%E5%88%AB"><span class="toc-number">1.2.</span> <span class="toc-text">异常的类别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD"><span class="toc-number">1.2.1.</span> <span class="toc-text">中断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%B7%E9%98%B1%E5%92%8C%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">1.2.2.</span> <span class="toc-text">陷阱和系统调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%85%E9%9A%9C"><span class="toc-number">1.2.3.</span> <span class="toc-text">故障</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%88%E6%AD%A2"><span class="toc-number">1.2.4.</span> <span class="toc-text">终止</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">进程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E6%8E%A7%E5%88%B6%E6%B5%81"><span class="toc-number">2.1.</span> <span class="toc-text">逻辑控制流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E6%B5%81"><span class="toc-number">2.2.</span> <span class="toc-text">并发流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%81%E6%9C%89%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="toc-number">2.3.</span> <span class="toc-text">私有地址空间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%86%85%E6%A0%B8%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.4.</span> <span class="toc-text">用户模式和内核模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="toc-number">2.5.</span> <span class="toc-text">上下文切换</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-number">3.</span> <span class="toc-text">系统调用错误处理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">4.</span> <span class="toc-text">进程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E8%BF%9B%E7%A8%8Bid"><span class="toc-number">4.1.</span> <span class="toc-text">获取进程id</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%92%8C%E7%BB%88%E6%AD%A2%E8%BF%9B%E7%A8%8B"><span class="toc-number">4.2.</span> <span class="toc-text">创建和终止进程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%94%B6%E5%AD%90%E8%BF%9B%E7%A8%8B"><span class="toc-number">4.3.</span> <span class="toc-text">回收子进程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%81%E6%B3%A8-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%B7%B2%E7%BB%88%E6%AD%A2%E7%9A%84%E5%AD%90%E8%BF%9B%E7%A8%8B%E8%A2%AB%E7%A7%B0%E4%B8%BA%E5%83%B5%E6%AD%BB%E8%BF%9B%E7%A8%8B"><span class="toc-number">4.3.0.1.</span> <span class="toc-text">旁注 - 为什么已终止的子进程被称为僵死进程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E5%AE%9A%E7%AD%89%E5%BE%85%E9%9B%86%E5%90%88%E7%9A%84%E6%88%90%E5%91%98"><span class="toc-number">4.3.1.</span> <span class="toc-text">判定等待集合的成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E9%BB%98%E8%AE%A4%E8%A1%8C%E4%B8%BA"><span class="toc-number">4.3.2.</span> <span class="toc-text">修改默认行为</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E5%B7%B2%E5%9B%9E%E6%94%B6%E5%AD%90%E8%BF%9B%E7%A8%8B%E7%9A%84%E9%80%80%E5%87%BA%E7%8A%B6%E6%80%81"><span class="toc-number">4.3.3.</span> <span class="toc-text">检查已回收子进程的退出状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E6%9D%A1%E4%BB%B6"><span class="toc-number">4.3.4.</span> <span class="toc-text">错误条件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#wait"><span class="toc-number">4.4.</span> <span class="toc-text">wait</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%BC%91%E7%9C%A0"><span class="toc-number">4.5.</span> <span class="toc-text">进程休眠</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E5%B9%B6%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F"><span class="toc-number">4.6.</span> <span class="toc-text">加载并运行程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8fork%E6%88%96%E8%80%85execve%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F"><span class="toc-number">4.7.</span> <span class="toc-text">利用fork或者execve运行程序</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7"><span class="toc-number">5.</span> <span class="toc-text">信号</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AF%E8%AF%AD"><span class="toc-number">5.1.</span> <span class="toc-text">术语</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E4%BF%A1%E5%8F%B7"><span class="toc-number">5.2.</span> <span class="toc-text">发送信号</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%BB%84"><span class="toc-number">5.2.1.</span> <span class="toc-text">进程组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8-bin-kill%E5%8F%91%E9%80%81%E4%BF%A1%E5%8F%B7"><span class="toc-number">5.2.2.</span> <span class="toc-text">用&#x2F;bin&#x2F;kill发送信号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E9%94%AE%E7%9B%98%E5%8F%91%E9%80%81%E4%BF%A1%E5%8F%B7"><span class="toc-number">5.2.3.</span> <span class="toc-text">从键盘发送信号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8-kill-%E5%87%BD%E6%95%B0%E5%8F%91%E9%80%81%E4%BF%A1%E5%8F%B7"><span class="toc-number">5.2.4.</span> <span class="toc-text">用 kill 函数发送信号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8alarm%E5%87%BD%E6%95%B0%E5%8F%91%E9%80%81%E4%BF%A1%E5%8F%B7"><span class="toc-number">5.2.5.</span> <span class="toc-text">用alarm函数发送信号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E6%94%B6%E4%BF%A1%E5%8F%B7"><span class="toc-number">5.2.6.</span> <span class="toc-text">接收信号</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%9E%E6%9C%AC%E5%9C%B0%E8%B7%B3%E8%BD%AC"><span class="toc-number">6.</span> <span class="toc-text">非本地跳转</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B7%A5%E5%85%B7"><span class="toc-number">7.</span> <span class="toc-text">操作进程的工具</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/10/26/360%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E4%BA%8C%EF%BC%9Aresource/" title="360代码规范二：resource"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://hoshea-1318436778.cos.ap-nanjing.myqcloud.com/image360.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="360代码规范二：resource"/></a><div class="content"><a class="title" href="/2023/10/26/360%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E4%BA%8C%EF%BC%9Aresource/" title="360代码规范二：resource">360代码规范二：resource</a><time datetime="2023-10-26T00:09:03.000Z" title="Created 2023-10-26 08:09:03">2023-10-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/10/26/%E7%BB%9F%E8%AE%A1%E8%83%BD%E6%95%B4%E9%99%A4%E6%95%B0%E5%AD%97%E7%9A%84%E4%BD%8D%E6%95%B0/" title="统计能整除数字的位数"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://hoshea-1318436778.cos.ap-nanjing.myqcloud.com/imagebg_leetcode.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="统计能整除数字的位数"/></a><div class="content"><a class="title" href="/2023/10/26/%E7%BB%9F%E8%AE%A1%E8%83%BD%E6%95%B4%E9%99%A4%E6%95%B0%E5%AD%97%E7%9A%84%E4%BD%8D%E6%95%B0/" title="统计能整除数字的位数">统计能整除数字的位数</a><time datetime="2023-10-25T23:54:29.000Z" title="Created 2023-10-26 07:54:29">2023-10-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/10/25/360%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E4%B8%80%EF%BC%9Asecurity/" title="360代码规范一：security"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://hoshea-1318436778.cos.ap-nanjing.myqcloud.com/image360.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="360代码规范一：security"/></a><div class="content"><a class="title" href="/2023/10/25/360%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E4%B8%80%EF%BC%9Asecurity/" title="360代码规范一：security">360代码规范一：security</a><time datetime="2023-10-25T14:53:17.000Z" title="Created 2023-10-25 22:53:17">2023-10-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/10/25/workflow%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9A%E7%BA%BF%E7%A8%8B%E6%B1%A0/" title="workflow源码分析：线程池"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://hoshea-1318436778.cos.ap-nanjing.myqcloud.com/imagebg_sougou.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="workflow源码分析：线程池"/></a><div class="content"><a class="title" href="/2023/10/25/workflow%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9A%E7%BA%BF%E7%A8%8B%E6%B1%A0/" title="workflow源码分析：线程池">workflow源码分析：线程池</a><time datetime="2023-10-25T07:10:55.000Z" title="Created 2023-10-25 15:10:55">2023-10-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/10/25/%E6%B1%82%E4%B8%80%E4%B8%AA%E6%95%B4%E6%95%B0%E7%9A%84%E6%83%A9%E7%BD%9A%E6%95%B0/" title="求一个整数的惩罚数"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://hoshea-1318436778.cos.ap-nanjing.myqcloud.com/imagebg_leetcode.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="求一个整数的惩罚数"/></a><div class="content"><a class="title" href="/2023/10/25/%E6%B1%82%E4%B8%80%E4%B8%AA%E6%95%B4%E6%95%B0%E7%9A%84%E6%83%A9%E7%BD%9A%E6%95%B0/" title="求一个整数的惩罚数">求一个整数的惩罚数</a><time datetime="2023-10-24T23:59:48.000Z" title="Created 2023-10-25 07:59:48">2023-10-25</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2021 - 2023 By <a class="footer-bar-link" href="/" title="Hoshea Zhang" target="_blank">Hoshea Zhang</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">Articles</div><div class="length-num">56</div></a><a href="/tags/" title="tag"><div class="headline">Tags</div><div class="length-num">30</div></a><a href="/categories/" title="category"><div class="headline">Categories</div><div class="length-num">8</div></a></div><span class="sidebar-menu-item-title">Function</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="Display Mode"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>Display Mode</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://hosheazhang.github.io/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://github.com/HosheaZhang/cmu15445" title="cmu15445"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="cmu15445"/><span class="back-menu-item-text">cmu15445</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/360/" style="font-size: 0.88rem;">360<sup>2</sup></a><a href="/tags/C/" style="font-size: 0.88rem;">C++<sup>6</sup></a><a href="/tags/CMU15445/" style="font-size: 0.88rem;">CMU15445<sup>2</sup></a><a href="/tags/CMake/" style="font-size: 0.88rem;">CMake<sup>1</sup></a><a href="/tags/CSAPP/" style="font-size: 0.88rem;">CSAPP<sup>9</sup></a><a href="/tags/MYSQL/" style="font-size: 0.88rem;">MYSQL<sup>6</sup></a><a href="/tags/VSCODE/" style="font-size: 0.88rem;">VSCODE<sup>1</sup></a><a href="/tags/dfs/" style="font-size: 0.88rem;">dfs<sup>1</sup></a><a href="/tags/gdb/" style="font-size: 0.88rem;">gdb<sup>1</sup></a><a href="/tags/git/" style="font-size: 0.88rem;">git<sup>1</sup></a><a href="/tags/github/" style="font-size: 0.88rem;">github<sup>1</sup></a><a href="/tags/linux/" style="font-size: 0.88rem;">linux<sup>6</sup></a><a href="/tags/markdown/" style="font-size: 0.88rem;">markdown<sup>1</sup></a><a href="/tags/ssh/" style="font-size: 0.88rem;">ssh<sup>1</sup></a><a href="/tags/workflow/" style="font-size: 0.88rem;">workflow<sup>3</sup></a><a href="/tags/%E4%B8%AD%E7%AD%89/" style="font-size: 0.88rem;">中等<sup>9</sup></a><a href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" style="font-size: 0.88rem;">动态规划<sup>2</sup></a><a href="/tags/%E5%91%A8%E8%B5%9B/" style="font-size: 0.88rem;">周赛<sup>9</sup></a><a href="/tags/%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/" style="font-size: 0.88rem;">学习计划<sup>1</sup></a><a href="/tags/%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3/" style="font-size: 0.88rem;">报错解决<sup>4</sup></a><a href="/tags/%E6%A0%A1%E6%8B%9B/" style="font-size: 0.88rem;">校招<sup>1</sup></a><a href="/tags/%E6%A8%A1%E6%8B%9F/" style="font-size: 0.88rem;">模拟<sup>7</sup></a><a href="/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/" style="font-size: 0.88rem;">每日一题<sup>4</sup></a><a href="/tags/%E6%B1%87%E7%BC%96/" style="font-size: 0.88rem;">汇编<sup>1</sup></a><a href="/tags/%E6%BA%90%E7%A0%81/" style="font-size: 0.88rem;">源码<sup>2</sup></a><a href="/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/" style="font-size: 0.88rem;">滑动窗口<sup>1</sup></a><a href="/tags/%E7%AE%80%E5%8D%95/" style="font-size: 0.88rem;">简单<sup>4</sup></a><a href="/tags/%E7%BC%96%E8%AF%91/" style="font-size: 0.88rem;">编译<sup>1</sup></a><a href="/tags/%E8%84%91%E7%AD%8B%E6%80%A5%E8%BD%AC%E5%BC%AF/" style="font-size: 0.88rem;">脑筋急转弯<sup>1</sup></a><a href="/tags/%E8%B4%AA%E5%BF%83/" style="font-size: 0.88rem;">贪心<sup>2</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="Switch Between Traditional Chinese And Simplified Chinese">繁</button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Setting"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="7372688489" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;undefined&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div id="he-plugin-simple"></div><script>var WIDGET = {
  "CONFIG": {
    "modules": "0124",
    "background": "2",
    "tmpColor": "FFFFFF",
    "tmpSize": "16",
    "cityColor": "FFFFFF",
    "citySize": "16",
    "aqiColor": "E8D87B",
    "aqiSize": "16",
    "weatherIconSize": "24",
    "alertIconSize": "18",
    "padding": "10px 10px 10px 10px",
    "shadow": "0",
    "language": "auto",
    "borderRadius": "20",
    "fixed": "true",
    "vertical": "top",
    "horizontal": "left",
    "left": "20",
    "top": "7.1",
    "key": "df245676fb434a0691ead1c63341cd94"
  }
}
</script><link rel="stylesheet" href="https://widget.qweather.net/simple/static/css/he-simple.css?v=1.4.0"/><script src="https://widget.qweather.net/simple/static/js/he-simple.js?v=1.4.0"></script><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.4/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2021 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2021 By 安知鱼 V1.6.8",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 Hoshea Zhang 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.1/bubble/bubble.js"></script><script>var visitorMail = "visitor@anheyu.com";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script src="/js/anzhiyu/right_click_menu.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>